{"version":3,"sources":["webpack:///js/main.js","webpack:///webpack/bootstrap eec0046e26096bafff5b?e50b*","webpack:///./src/js/main.js","webpack:///./src/js/util.js","webpack:///./~/lodash/lodash.js","webpack:///(webpack)/buildin/module.js","webpack:///./src/js/regexper.js","webpack:///./src/js/parser/javascript.js","webpack:///./~/snapsvg/dist/snap.svg.js","webpack:///./src/js/parser/javascript/parser.js","webpack:///./src/js/parser/javascript/grammar.peg","webpack:///./src/js/parser/javascript/node.js","webpack:///./src/js/parser/javascript/root.js","webpack:///./src/js/parser/javascript/regexp.js","webpack:///./src/js/parser/javascript/match.js","webpack:///./src/js/parser/javascript/match_fragment.js","webpack:///./src/js/parser/javascript/anchor.js","webpack:///./src/js/parser/javascript/subexp.js","webpack:///./src/js/parser/javascript/charset.js","webpack:///./src/js/parser/javascript/charset_escape.js","webpack:///./src/js/parser/javascript/escape.js","webpack:///./src/js/parser/javascript/charset_range.js","webpack:///./src/js/parser/javascript/literal.js","webpack:///./src/js/parser/javascript/any_character.js","webpack:///./src/js/parser/javascript/repeat.js","webpack:///./src/js/parser/javascript/repeat_any.js","webpack:///./src/js/parser/javascript/repeat_optional.js","webpack:///./src/js/parser/javascript/repeat_required.js","webpack:///./src/js/parser/javascript/repeat_spec.js","webpack:///./src/js/parser/javascript/parser_state.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_util","_util2","_regexper","_regexper2","_javascript","_javascript2","_lodash","_lodash2","window","addEventListener","error","lineno","track","filename","colno","message","stack","document","body","querySelector","regexper","detectBuggyHash","bindListeners","tick","then","dispatchEvent","customEvent","each","querySelectorAll","element","keepContent","parse","getAttribute","parser","render","catch","exposeError","name","detail","evt","createEvent","initEvent","normalizeBBox","box","defaults","ax","x","ax2","x2","ay","cy","spaceHorizontally","items","options","verticalCenter","values","padding","map","item","getBBox","reduce","center","_ref","Math","max","offset","_ref2","transform","Snap","matrix","translate","width","spaceVertically","horizontalCenter","_ref3","cx","_ref4","height","wait","delay","Promise","resolve","reject","setTimeout","icon","selector","ga","apply","arguments","console","debug","Object","defineProperty","value","__WEBPACK_AMD_DEFINE_RESULT__","global","addMapEntry","pair","set","addSetEntry","add","func","thisArg","args","length","arrayAggregator","array","setter","iteratee","accumulator","index","arrayEach","arrayEachRight","arrayEvery","predicate","arrayFilter","resIndex","result","arrayIncludes","baseIndexOf","arrayIncludesWith","comparator","arrayMap","Array","arrayPush","arrayReduce","initAccum","arrayReduceRight","arraySome","asciiToArray","string","split","asciiWords","match","reAsciiWord","baseFindKey","collection","eachFunc","key","baseFindIndex","fromIndex","fromRight","strictIndexOf","baseIsNaN","baseIndexOfWith","baseMean","baseSum","NAN","baseProperty","object","undefined","basePropertyOf","baseReduce","baseSortBy","comparer","sort","current","baseTimes","n","baseToPairs","props","baseUnary","baseValues","cacheHas","cache","has","charsStartIndex","strSymbols","chrSymbols","charsEndIndex","countHolders","placeholder","escapeStringChar","chr","stringEscapes","getValue","hasUnicode","reHasUnicode","test","hasUnicodeWord","reHasUnicodeWord","iteratorToArray","iterator","data","next","done","push","mapToArray","size","forEach","overArg","arg","replaceHolders","PLACEHOLDER","setToArray","setToPairs","strictLastIndexOf","stringSize","unicodeSize","asciiSize","stringToArray","unicodeToArray","reUnicode","lastIndex","unicodeWords","reUnicodeWord","VERSION","LARGE_ARRAY_SIZE","CORE_ERROR_TEXT","FUNC_ERROR_TEXT","HASH_UNDEFINED","MAX_MEMOIZE_SIZE","CLONE_DEEP_FLAG","CLONE_FLAT_FLAG","CLONE_SYMBOLS_FLAG","COMPARE_PARTIAL_FLAG","COMPARE_UNORDERED_FLAG","WRAP_BIND_FLAG","WRAP_BIND_KEY_FLAG","WRAP_CURRY_BOUND_FLAG","WRAP_CURRY_FLAG","WRAP_CURRY_RIGHT_FLAG","WRAP_PARTIAL_FLAG","WRAP_PARTIAL_RIGHT_FLAG","WRAP_ARY_FLAG","WRAP_REARG_FLAG","WRAP_FLIP_FLAG","DEFAULT_TRUNC_LENGTH","DEFAULT_TRUNC_OMISSION","HOT_COUNT","HOT_SPAN","LAZY_FILTER_FLAG","LAZY_MAP_FLAG","LAZY_WHILE_FLAG","INFINITY","MAX_SAFE_INTEGER","MAX_INTEGER","MAX_ARRAY_LENGTH","MAX_ARRAY_INDEX","HALF_MAX_ARRAY_LENGTH","wrapFlags","argsTag","arrayTag","asyncTag","boolTag","dateTag","domExcTag","errorTag","funcTag","genTag","mapTag","numberTag","nullTag","objectTag","promiseTag","proxyTag","regexpTag","setTag","stringTag","symbolTag","undefinedTag","weakMapTag","weakSetTag","arrayBufferTag","dataViewTag","float32Tag","float64Tag","int8Tag","int16Tag","int32Tag","uint8Tag","uint8ClampedTag","uint16Tag","uint32Tag","reEmptyStringLeading","reEmptyStringMiddle","reEmptyStringTrailing","reEscapedHtml","reUnescapedHtml","reHasEscapedHtml","RegExp","source","reHasUnescapedHtml","reEscape","reEvaluate","reInterpolate","reIsDeepProp","reIsPlainProp","reLeadingDot","rePropName","reRegExpChar","reHasRegExpChar","reTrim","reTrimStart","reTrimEnd","reWrapComment","reWrapDetails","reSplitDetails","reEscapeChar","reEsTemplate","reFlags","reIsBadHex","reIsBinary","reIsHostCtor","reIsOctal","reIsUint","reLatin","reNoMatch","reUnescapedString","rsAstralRange","rsComboMarksRange","reComboHalfMarksRange","rsComboSymbolsRange","rsComboRange","rsDingbatRange","rsLowerRange","rsMathOpRange","rsNonCharRange","rsPunctuationRange","rsSpaceRange","rsUpperRange","rsVarRange","rsBreakRange","rsApos","rsAstral","rsBreak","rsCombo","rsDigits","rsDingbat","rsLower","rsMisc","rsFitz","rsModifier","rsNonAstral","rsRegional","rsSurrPair","rsUpper","rsZWJ","rsMiscLower","rsMiscUpper","rsOptContrLower","rsOptContrUpper","reOptMod","rsOptVar","rsOptJoin","join","rsOrdLower","rsOrdUpper","rsSeq","rsEmoji","rsSymbol","reApos","reComboMark","contextProps","templateCounter","typedArrayTags","cloneableTags","deburredLetters","À","Á","Â","Ã","Ä","Å","à","á","â","ã","ä","å","Ç","ç","Ð","ð","È","É","Ê","Ë","è","é","ê","ë","Ì","Í","Î","Ï","ì","í","î","ï","Ñ","ñ","Ò","Ó","Ô","Õ","Ö","Ø","ò","ó","ô","õ","ö","ø","Ù","Ú","Û","Ü","ù","ú","û","ü","Ý","ý","ÿ","Æ","æ","Þ","þ","ß","Ā","Ă","Ą","ā","ă","ą","Ć","Ĉ","Ċ","Č","ć","ĉ","ċ","č","Ď","Đ","ď","đ","Ē","Ĕ","Ė","Ę","Ě","ē","ĕ","ė","ę","ě","Ĝ","Ğ","Ġ","Ģ","ĝ","ğ","ġ","ģ","Ĥ","Ħ","ĥ","ħ","Ĩ","Ī","Ĭ","Į","İ","ĩ","ī","ĭ","į","ı","Ĵ","ĵ","Ķ","ķ","ĸ","Ĺ","Ļ","Ľ","Ŀ","Ł","ĺ","ļ","ľ","ŀ","ł","Ń","Ņ","Ň","Ŋ","ń","ņ","ň","ŋ","Ō","Ŏ","Ő","ō","ŏ","ő","Ŕ","Ŗ","Ř","ŕ","ŗ","ř","Ś","Ŝ","Ş","Š","ś","ŝ","ş","š","Ţ","Ť","Ŧ","ţ","ť","ŧ","Ũ","Ū","Ŭ","Ů","Ű","Ų","ũ","ū","ŭ","ů","ű","ų","Ŵ","ŵ","Ŷ","ŷ","Ÿ","Ź","Ż","Ž","ź","ż","ž","Ĳ","ĳ","Œ","œ","ŉ","ſ","htmlEscapes","&","<",">","\"","'","htmlUnescapes","&amp;","&lt;","&gt;","&quot;","&#39;","\\","\n","\r"," "," ","freeParseFloat","parseFloat","freeParseInt","parseInt","freeGlobal","freeSelf","self","root","Function","freeExports","nodeType","freeModule","moduleExports","freeProcess","process","nodeUtil","binding","e","nodeIsArrayBuffer","isArrayBuffer","nodeIsDate","isDate","nodeIsMap","isMap","nodeIsRegExp","isRegExp","nodeIsSet","isSet","nodeIsTypedArray","isTypedArray","deburrLetter","escapeHtmlChar","unescapeHtmlChar","runInContext","context","lodash","isObjectLike","isArray","LazyWrapper","LodashWrapper","hasOwnProperty","wrapperClone","baseLodash","chainAll","this","__wrapped__","__actions__","__chain__","__index__","__values__","__dir__","__filtered__","__iteratees__","__takeCount__","__views__","lazyClone","copyArray","lazyReverse","clone","lazyValue","dir","isArr","isRight","arrLength","view","getView","start","end","iteratees","iterLength","takeCount","nativeMin","baseWrapperValue","outer","iterIndex","type","computed","Hash","entries","clear","entry","hashClear","__data__","nativeCreate","hashDelete","hashGet","hashHas","hashSet","ListCache","listCacheClear","listCacheDelete","assocIndexOf","pop","splice","listCacheGet","listCacheHas","listCacheSet","MapCache","mapCacheClear","hash","Map","mapCacheDelete","getMapData","mapCacheGet","get","mapCacheHas","mapCacheSet","SetCache","setCacheAdd","setCacheHas","Stack","stackClear","stackDelete","stackGet","stackHas","stackSet","pairs","arrayLikeKeys","inherited","isArg","isArguments","isBuff","isBuffer","isType","skipIndexes","String","isIndex","arraySample","baseRandom","arraySampleSize","shuffleSelf","baseClamp","arrayShuffle","assignInDefaults","objValue","srcValue","eq","objectProto","assignMergeValue","baseAssignValue","assignValue","baseAggregator","baseEach","baseAssign","copyObject","keys","baseAssignIn","keysIn","configurable","enumerable","writable","baseAt","paths","skip","number","lower","upper","baseClone","bitmask","customizer","isDeep","isFlat","isFull","isObject","initCloneArray","tag","getTag","isFunc","cloneBuffer","initCloneObject","copySymbolsIn","copySymbols","initCloneByTag","stacked","keysFunc","getAllKeysIn","getAllKeys","subValue","baseConforms","baseConformsTo","baseDelay","TypeError","baseDifference","includes","isCommon","valuesLength","valuesIndex","baseEvery","baseExtremum","isSymbol","baseFill","toInteger","toLength","baseFilter","baseFlatten","depth","isStrict","isFlattenable","baseForOwn","baseFor","baseForOwnRight","baseForRight","baseFunctions","isFunction","baseGet","path","castPath","toKey","baseGetAllKeys","symbolsFunc","baseGetTag","symToStringTag","getRawTag","objectToString","baseGt","other","baseHas","baseHasIn","baseInRange","nativeMax","baseIntersection","arrays","othLength","othIndex","caches","maxLength","Infinity","seen","baseInverter","baseInvoke","parent","last","baseIsArguments","baseIsArrayBuffer","baseIsDate","baseIsEqual","baseIsEqualDeep","equalFunc","objIsArr","othIsArr","objTag","othTag","objIsObj","othIsObj","isSameTag","equalArrays","equalByTag","objIsWrapped","othIsWrapped","objUnwrapped","othUnwrapped","equalObjects","baseIsMap","baseIsMatch","matchData","noCustomizer","baseIsNative","isMasked","pattern","reIsNative","toSource","baseIsRegExp","baseIsSet","baseIsTypedArray","isLength","baseIteratee","identity","baseMatchesProperty","baseMatches","property","baseKeys","isPrototype","nativeKeys","baseKeysIn","nativeKeysIn","isProto","baseLt","baseMap","isArrayLike","getMatchData","matchesStrictComparable","isKey","isStrictComparable","hasIn","baseMerge","srcIndex","baseMergeDeep","newValue","mergeFunc","isTyped","isArrayLikeObject","cloneTypedArray","isPlainObject","toPlainObject","baseNth","baseOrderBy","orders","getIteratee","criteria","compareMultiple","basePick","basePickBy","baseSet","basePropertyDeep","basePullAll","indexOf","basePullAt","indexes","previous","baseUnset","nativeFloor","nativeRandom","baseRange","step","nativeCeil","baseRepeat","baseRest","setToString","overRest","baseSample","baseSampleSize","nested","baseShuffle","baseSlice","baseSome","baseSortedIndex","retHighest","low","high","mid","baseSortedIndexBy","valIsNaN","valIsNull","valIsSymbol","valIsUndefined","othIsDefined","othIsNull","othIsReflexive","othIsSymbol","setLow","baseSortedUniq","baseToNumber","baseToString","symbolToString","baseUniq","createSet","seenIndex","baseUpdate","updater","baseWhile","isDrop","actions","action","baseXor","baseZipObject","assignFunc","valsLength","castArrayLikeObject","castFunction","stringToPath","toString","castSlice","buffer","slice","allocUnsafe","constructor","copy","cloneArrayBuffer","arrayBuffer","byteLength","Uint8Array","cloneDataView","dataView","byteOffset","cloneMap","cloneFunc","cloneRegExp","regexp","exec","cloneSet","cloneSymbol","symbol","symbolValueOf","typedArray","compareAscending","valIsDefined","valIsReflexive","objCriteria","othCriteria","ordersLength","order","composeArgs","partials","holders","isCurried","argsIndex","argsLength","holdersLength","leftIndex","leftLength","rangeLength","isUncurried","composeArgsRight","holdersIndex","rightIndex","rightLength","isNew","getSymbols","getSymbolsIn","createAggregator","initializer","createAssigner","assigner","sources","guard","isIterateeCall","createBaseEach","iterable","createBaseFor","createBind","wrapper","fn","Ctor","isBind","createCtor","createCaseFirst","methodName","charAt","trailing","createCompounder","callback","words","deburr","replace","thisBinding","baseCreate","prototype","createCurry","arity","getHolder","createRecurry","createHybrid","createFind","findIndexFunc","createFlow","flatRest","funcs","prereq","thru","reverse","getFuncName","funcName","getData","isLaziable","plant","partialsRight","holdersRight","argPos","ary","holdersCount","newHolders","isBindKey","reorder","isFlip","isAry","createInverter","toIteratee","createMathOperation","operator","defaultValue","createOver","arrayFunc","createPadding","chars","charsLength","createPartial","createRange","toFinite","createRelationalOperation","toNumber","wrapFunc","isCurry","newHoldersRight","newPartials","newPartialsRight","newData","setData","setWrapToString","createRound","precision","createToPairs","createWrap","mergeData","baseSetData","isPartial","arrValue","othValue","compared","convert","objProps","objLength","othProps","skipCtor","objCtor","othCtor","flatten","realNames","otherFunc","isKeyable","getNative","isOwn","unmasked","nativeObjectToString","transforms","getWrapDetails","hasPath","hasFunc","input","getPrototype","insertWrapDetails","details","spreadableSymbol","maskSrcKey","proto","memoizeCapped","memoize","srcBitmask","newBitmask","isCombo","mergeDefaults","otherArgs","oldArray","reference","updateWrapDetails","shortOut","count","lastCalled","stamp","nativeNow","remaining","rand","funcToString","chunk","compact","concat","drop","dropRight","dropRightWhile","dropWhile","fill","findIndex","findLastIndex","flattenDeep","flattenDepth","fromPairs","head","initial","separator","nativeJoin","lastIndexOf","nth","pullAll","pullAllBy","pullAllWith","remove","nativeReverse","sortedIndex","sortedIndexBy","sortedIndexOf","sortedLastIndex","sortedLastIndexBy","sortedLastIndexOf","sortedUniq","sortedUniqBy","tail","take","takeRight","takeRightWhile","takeWhile","uniq","uniqBy","uniqWith","unzip","group","unzipWith","zipObject","zipObjectDeep","chain","tap","interceptor","wrapperChain","wrapperCommit","wrapperNext","toArray","wrapperToIterator","wrapperPlant","wrapperReverse","wrapped","wrapperValue","every","filter","flatMap","flatMapDeep","flatMapDepth","forEachRight","baseEachRight","isString","orderBy","reduceRight","negate","sample","sampleSize","shuffle","some","after","before","curry","curryRight","debounce","invokeFunc","time","lastArgs","lastThis","lastInvokeTime","leadingEdge","timerId","timerExpired","leading","remainingWait","timeSinceLastCall","lastCallTime","timeSinceLastInvoke","maxing","maxWait","shouldInvoke","now","trailingEdge","cancel","clearTimeout","flush","debounced","isInvoking","flip","resolver","memoized","Cache","once","rest","spread","throttle","unary","wrap","partial","castArray","cloneWith","cloneDeep","cloneDeepWith","conformsTo","isBoolean","isElement","isEmpty","isEqual","isEqualWith","isError","isFinite","nativeIsFinite","isInteger","isMatch","isMatchWith","isNaN","isNumber","isNative","isMaskable","Error","isNull","isNil","objectCtorString","isSafeInteger","isUndefined","isWeakMap","isWeakSet","symIterator","sign","remainder","valueOf","isBinary","toSafeInteger","create","properties","findKey","findLastKey","forIn","forInRight","forOwn","forOwnRight","functions","functionsIn","mapKeys","mapValues","omitBy","pickBy","prop","setWith","isArrLike","unset","update","updateWith","valuesIn","clamp","inRange","random","floating","temp","capitalize","upperFirst","toLowerCase","endsWith","target","position","escape","escapeRegExp","pad","strLength","padEnd","padStart","radix","nativeParseInt","repeat","limit","startsWith","template","settings","templateSettings","assignInWith","isEscaping","isEvaluating","imports","importsKeys","importsValues","interpolate","reDelimiters","evaluate","sourceURL","escapeValue","interpolateValue","esTemplateValue","evaluateValue","variable","attempt","toLower","toUpper","toUpperCase","trim","trimEnd","trimStart","truncate","omission","search","substring","newEnd","unescape","cond","conforms","constant","defaultTo","matches","matchesProperty","mixin","methodNames","noConflict","_","oldDash","noop","nthArg","propertyOf","stubArray","stubFalse","stubObject","stubString","stubTrue","times","toPath","uniqueId","prefix","idCounter","maxBy","mean","meanBy","min","minBy","sum","sumBy","pick","Date","arrayProto","funcProto","coreJsData","uid","IE_PROTO","Buffer","Symbol","getPrototypeOf","objectCreate","propertyIsEnumerable","isConcatSpreadable","toStringTag","ctxClearTimeout","ctxNow","ctxSetTimeout","ceil","floor","nativeGetSymbols","getOwnPropertySymbols","nativeIsBuffer","DataView","Set","WeakMap","metaMap","dataViewCtorString","mapCtorString","promiseCtorString","setCtorString","weakMapCtorString","symbolProto","baseSetToString","castRest","ArrayBuffer","ctorString","quote","difference","differenceBy","differenceWith","intersection","mapped","intersectionBy","intersectionWith","pull","pullAt","union","unionBy","unionWith","without","xor","xorBy","xorWith","zip","zipWith","wrapperAt","countBy","find","findLast","groupBy","invokeMap","keyBy","partition","sortBy","bind","bindKey","defer","overArgs","funcsLength","partialRight","rearg","gt","gte","lt","lte","assign","assignIn","assignWith","at","defaultsDeep","mergeWith","invert","invertBy","invoke","merge","omit","toPairs","toPairsIn","camelCase","word","kebabCase","lowerCase","lowerFirst","snakeCase","startCase","upperCase","bindAll","flow","flowRight","method","methodOf","over","overEvery","overSome","range","rangeRight","augend","addend","divide","dividend","divisor","multiply","multiplier","multiplicand","round","subtract","minuend","subtrahend","entriesIn","extend","extendWith","eachRight","first","filtered","isFilter","takeName","dropName","checkIteratee","isTaker","lodashFunc","retUnwrapped","isLazy","useLazy","isHybrid","isUnwrapped","onlyLazy","chainName","names","commit","toJSON","webpackPolyfill","deprecate","children","_classCallCheck","instance","Constructor","_createClass","defineProperties","i","descriptor","protoProps","staticProps","Regexper","buggyHash","form","field","warnings","links","permalink","download","svgContainer","event","shiftKey","keyCode","returnValue","preventDefault","running","_setHash","permalinkEnabled","showExpression","expr","_getHash","state","innerHTML","keypressListener","submitListener","documentKeypressListener","hashchangeListener","URL","url","location","encodeURIComponent","decodeURIComponent","expression","renderRegexp","content","blob","Blob","createObjectURL","classes","className","parentNode","style","display","href","buildBlobURL","warning","_this","parseError","startTime","endTime","getTime","appendChild","createTextNode","updateLinks","displayWarnings","_snapsvg","_snapsvg2","_parser","_parser2","_parser_state","_parser_state2","Parser","container","_addClass","SyntaxNode","parsed","_this2","svg","y","attr","_removeClass","removeChild","cancelRender","cont","_container","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_LOCAL_MODULE_0__","glob","current_event","stop","version","comaseparator","wildcard","numsort","a","b","events","firstDefined","ii","lastDefined","eve","scope","l","oldstop","listeners","z","indexed","queue","out","ce","zIndex","_events","k","j","jj","nes","es","f","on","exist","attrs","nt","subname","nts","off","unbind","cur","f2","factory","mina","animations","requestAnimFrame","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","idgen","idprefix","ID","timer","sta","val","s","ds","dur","B","speed","spd","duration","stopit","pause","pdif","resume","res","easing","frame","len","A","anim","linear","status","getById","easeout","pow","easein","easeinout","q","Q","sqrt","X","abs","Y","t","backin","backout","elastic","sin","PI","bounce","w","h","is","Element","doc","Paper","$","el","text","createComment","getAttributeNS","xlink","xmlns","nodeValue","Str","setAttributeNS","setAttribute","removeAttribute","createElementNS","o","repush","cacher","postprocessor","newf","shift","angle","x1","y1","y2","x3","y3","math","atan2","rad","deg","svgTransform2string","tstr","all","params","tan","transform2matrix","bbox","tdata","parseTransformString","Matrix","bb","tlen","command","absolute","inver","rotate","scale","getSomeDefs","node","ownerSVGElement","select","pdefs","defs","make","getSomeSVG","unit2px","getW","E","mgr","getH","nam","class","add2group","list","childNodes","snap","hub","paper","tagName","nodeName","anims","g","mask","Fragment","frag","desc","ownerDocument","getElementsByTagName","dom","contentDocument","jsonFiller","win","toFloat","toInt","mmax","mmin","colourRegExp","commaSpaces","hsrg","hs","rg","pathCommand","tCommand","pathValues","format","tokenRegex","objNotationRegex","replacer","quotedName","str","cos","asin","num","acos","atan","len2","closestPoint","distance2","dx","dy","best","bestLength","scan","scanDistance","pathNode","pathLength","getTotalLength","pathSegList","numberOfItems","bestDistance","scanLength","getPointAtLength","beforeLength","afterLength","beforeDistance","afterDistance","distance","snapTo","tolerance","rem","getRGB","colour","r","hex","rgbtoString","toHex","red","green","blue","opacity","rgb","hsb2rgb","hsl2rgb","hsb","hsl","toFixed","color","defaultView","getComputedStyle","getPropertyValue","hsbtoString","hsltoString","prepareRGB","clr","packageRGB","rgb2hsl","rgb2hsb","v","R","G","C","H","S","V","L","M","parsePathString","pathString","pth","arr","paramCounts","u","TString","rgTransform","_unit2px","contains","compareDocumentPosition","adown","documentElement","bup","query","selectAll","nodelist","setInterval","attributes","json","att","createDocumentFragment","full","div","createElement","firstChild","fragment","ch","css","letter","cssAttr","alignment-baseline","baseline-shift","clip","clip-path","clip-rule","color-interpolation","color-interpolation-filters","color-profile","color-rendering","cursor","direction","dominant-baseline","enable-background","fill-opacity","fill-rule","flood-color","flood-opacity","font","font-family","font-size","font-size-adjust","font-stretch","font-style","font-variant","font-weight","glyph-orientation-horizontal","glyph-orientation-vertical","image-rendering","kerning","letter-spacing","lighting-color","marker","marker-end","marker-mid","marker-start","overflow","pointer-events","shape-rendering","stop-color","stop-opacity","stroke","stroke-dasharray","stroke-dashoffset","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke-width","text-anchor","text-decoration","text-rendering","unicode-bidi","visibility","word-spacing","writing-mode","ajax","postData","req","XMLHttpRequest","pd","open","setRequestHeader","onreadystatechange","readyState","send","load","responseText","getOffset","elem","getBoundingClientRect","docElem","clientTop","clientLeft","top","pageYOffset","scrollTop","left","pageXOffset","scrollLeft","getElementByPoint","canvas","elementFromPoint","opera","so","sr","createSVGRect","hits","getIntersectionList","plugin","extractTransform","doReturn","fixids","urltest","it","uses","linktest","els","ids","oldid","old","fs","from","to","chld","elproto","isWithoutTransform","removed","localMatrix","original","getElementById","pathfinder","deflt","bboxwt","realPath","propString","papa","getCTM","local","ms","localString","toTransformString","globalMatrix","totalMatrix","diffMatrix","total","gradientTransform","patternTransform","append","appendTo","prepend","insertBefore","prependTo","nextSibling","insertAfter","asPX","use","xlink:href","cloneNode","toDefs","toPattern","patternUnits","viewBox","refX","refY","markerWidth","markerHeight","orient","Animation","animation","inAnim","_attrs","_callback","curStatus","animate","fkeys","tkeys","equal","eldata","removeData","outerSVG","innerSVG","toDataURL","btoa","contents","d","matrixproto","norm","normalize","mag","me","fromCharCode","determinant","row","scalex","shear","scaley","isSimple","isSuperSimple","noRotation","shorter","fillStroke","grad","gradient","setFontSize","fontSize","textExtract","chi","getFontSize","reURLValue","clipIt","gradrg","tokens","stops","toAbsolute","txt","baseVal","vb","rx","ry","tp","textPath","tuner","tuned","getter","textContent","rgNotSpace","addClass","pos","clazz","finalValue","curClasses","removeClass","hasClass","toggleClass","flag","getNumber","getUnit","unit","operators","+","-","/","*","reUnit","reAddon","plus","evnt","atr","aUnit","op","bplus","rect","circle","preload","onerror","src","img","cssText","onload","image","preserveAspectRatio","offsetWidth","offsetHeight","ellipse","vbx","vby","vbw","vbh","ptrn","vx","vy","vw","vh","line","polyline","points","polygon","Gstops","GaddStop","GgetBBox","seed","unshift","gradientLinear","gradientRadial","gradientUnits","addStop","fx","fy","ps","sleep","r1","r2","r0","rectPath","p2s","pathClone","pathArray","getPointAtSegmentLength","p1x","p1y","c1x","c1y","c2x","c2y","p2x","p2y","bezlen","findDotsAtSegment","getTotLen","getLengthFactory","istotal","subpath","O","onlystart","path2curve","point","sp","subpaths","t1","t13","t12","t2","t3","mx","my","nx","ny","alpha","bezierBBox","curveDim","isPointInsideBBox","isBBoxIntersect","bbox1","bbox2","base3","p1","p2","p3","p4","x4","y4","z2","Tvalues","Cvalues","ct","xbase","ybase","comb","ll","intersect","denominator","px","py","px2","py2","interHelper","bez1","bez2","justCount","l1","l2","n1","n2","dots1","dots2","xy","di","di1","dj","dj1","ci","cj","pathIntersection","path1","path2","interPathHelper","pathIntersectionNumber","x1m","y1m","x2m","y2m","pi","pj","intr","kk","segment1","segment2","isPointInsidePath","pathBBox","dim","xmin","ymin","xmax","ymax","ellipsePath","pathToRelative","rel","pa","pathToAbsolute","pa0","crz","dots","catmullRom2bezier","l2c","q2c","_13","_23","a2c","large_arc_flag","sweep_flag","recursive","_120","f1","rx2","ry2","df","f2old","x2old","y2old","c1","s1","c2","s2","hx","hy","m1","m2","m3","m4","newres","x0","y0","b2ac","sqrtb2ac","tvalues","bounds","mt","jlen","curve","bx","by","qx","qy","attrs2","processPath","pcom","T","fixArc","pp","pcoms1","pcoms2","fixM","a1","a2","pfirst","seg","seg2","seglen","seg2len","mapPath","pathi","crp","iLen","getSubpathsAtLength","getPath","getSubpath","closest","inside","found","intersectionNumber","isPointInside","toRelative","toCubic","bindings","setproto","begin","handler","cb","callbacker","aname","unbound","insertion","todel","arglen","exclude","getEmpty","equaliseTransform","tt1","tt2","maxlength","path2array","getViewBox","getColour","isNumeric","arrayEqual","arr1","arr2","Number","bUnit","supportsTouch","touchMap","mousedown","mousemove","mouseup","getScroll","preventTouch","originalEvent","stopTouch","stopPropagation","addEvent","realName","scrollY","scrollX","targetTouches","olde","clientX","clientY","removeEventListener","drag","dragMove","dragi","touch","touches","identifier","_drag","move_scope","dragUp","unmousemove","unmouseup","end_scope","start_scope","eventName","hover","f_in","f_out","scope_in","scope_out","mouseover","mouseout","unhover","unmouseover","unmouseout","draggable","onmove","onstart","onend","init","origTransform","undrag","unmousedown","pproto","rgurl","filstr","filterUnits","blur","def","shadow","grayscale","amount","sepia","saturate","hueRotate","amount2","brightness","contrast","firstLetter","getAlign","way","align","_grammar","_grammar2","_node","_node2","_root","_root2","_regexp","_regexp2","_match","_match2","_match_fragment","_match_fragment2","_anchor","_anchor2","_subexp","_subexp2","_charset","_charset2","_charset_escape","_charset_escape2","_charset_range","_charset_range2","_literal","_literal2","_escape","_escape2","_any_character","_any_character2","_repeat","_repeat2","_repeat_any","_repeat_any2","_repeat_optional","_repeat_optional2","_repeat_required","_repeat_required2","_repeat_spec","_repeat_spec2","Root","Regexp","Match","MatchFragment","Anchor","Subexp","Charset","CharsetEscape","CharsetRange","Literal","Escape","AnyCharacter","Repeat","RepeatAny","RepeatOptional","RepeatRequired","RepeatSpec","destination","objectName","part","parts","formatError","lines","lineNo","expected","Grammar","__consume__root","address0","index0","_offset","_nodeCache","cached","textValue","index1","index2","elements0","labelled0","text0","address1","slice0","_input","klass0","type0","slice1","lastError","address2","__consume__regexp","address3","slice2","klass1","type1","slice3","address4","remaining0","index3","elements1","text1","address5","slice4","klass2","type2","slice5","klass3","type3","flags","klass4","type4","type5","index4","elements2","labelled1","text2","address6","address7","index5","slice6","klass5","type6","slice7","klass6","type7","klass7","type8","type9","__consume__match","alternates","__consume__repeat","__consume__match_fragment","__consume__anchor","__consume__subexp","__consume__charset","__consume__terminal","__consume__repeat_any","__consume__repeat_required","__consume__repeat_optional","__consume__repeat_spec","spec","greedy","remaining1","slice8","slice9","elements3","text3","address8","slice10","klass8","slice11","address9","remaining2","index6","elements4","text4","address10","slice12","klass9","type10","slice13","klass10","type11","address11","slice14","klass11","type12","slice15","klass12","type13","type14","index7","elements5","labelled2","text5","address12","slice16","klass13","type15","slice17","address13","remaining3","index8","elements6","text6","address14","slice18","klass14","type16","slice19","klass15","type17","exact","address15","slice20","klass16","type18","slice21","klass17","type19","type20","capture","__consume__charset_range","__consume__charset_terminal","__consume__charset_range_terminal","__consume__charset_escape","__consume__charset_literal","__consume__charset_range_escape","code","__consume__control_escape","__consume__octal_escape","__consume__hex_escape","__consume__unicode_escape","__consume__null_escape","esc","literal","__consume__escape","__consume__literal","temp0","elements","block","Node","anchor","proxy","renderCounter","_render","label","deferredStep","margin","labelBox","contentBox","mod","_this3","setup","definedProperties","methods","flagLabels","flagText","matchContainer","containerBox","makeCurve","makeSide","makeConnector","edge","partPromises","connectorPaths","prev","canMerge","contentPosition","skipPath","loopPath","loopLabel","labelStr","tooltipStr","tooltip","hasSkip","hasLoop","renderLabel","labelMap","?:","?=","?!","renderLabeledBox","groupCounter","partContainer","_slicedToArray","sliceIterator","_arr","_n","_d","_e","_s","_i","err","addHex","_$result","_$result2","ordinal","D","W","1","2","3","4","5","6","7","8","9","0","charCodeAt","spans","formatTimes","minimum","maximum","repeatCount","vert","horiz","ParserState","progress","_renderCounter","_maxCounter","_progress"],"mappings":"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AAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,KAAAC,IAAA,KACAC,IAAA,KAAAC,IAAA,KACAC,IAAA,KAEAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IA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","file":"js/main.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _util = __webpack_require__(1);\n\t\n\tvar _util2 = _interopRequireDefault(_util);\n\t\n\tvar _regexper = __webpack_require__(4);\n\t\n\tvar _regexper2 = _interopRequireDefault(_regexper);\n\t\n\tvar _javascript = __webpack_require__(5);\n\t\n\tvar _javascript2 = _interopRequireDefault(_javascript);\n\t\n\tvar _lodash = __webpack_require__(2);\n\t\n\tvar _lodash2 = _interopRequireDefault(_lodash);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// This file contains code to start up pages on the site, and other code that\n\t// is not directly related to parsing and display of regular expressions.\n\t//\n\t// Since the code in this is executed immediately, it is all but impossible to\n\t// test. Therefore, this code is kept as simple as possible to reduce the need\n\t// to run it through automated tests.\n\t\n\t(function () {\n\t  // Global error handler that will send unhandled JavaScript exceptions and\n\t  // stack-traces to Google Analytics. This data can be used to find errors in\n\t  // code that were not found during testing.\n\t  window.addEventListener('error', function (error) {\n\t    if (error.lineno !== 0) {\n\t      _util2.default.track('send', 'event', 'global', 'exception', error.filename + '(' + error.lineno + ',' + error.colno + '): ' + error.message);\n\t\n\t      if (typeof error.error !== 'undefined' && typeof error.error.stack !== 'undefined') {\n\t        _util2.default.track('send', 'event', 'global', 'stack trace', error.error.stack);\n\t      }\n\t    }\n\t  });\n\t\n\t  // Initialize the main page of the site. Functionality is kept in the\n\t  // [Regexper class](./regexper.html).\n\t  if (document.body.querySelector('#content .application')) {\n\t    var regexper = new _regexper2.default(document.body);\n\t\n\t    regexper.detectBuggyHash();\n\t    regexper.bindListeners();\n\t\n\t    _util2.default.tick().then(function () {\n\t      window.dispatchEvent(_util2.default.customEvent('hashchange'));\n\t    });\n\t  }\n\t\n\t  // Initialize other pages on the site (specifically the documentation page).\n\t  // Any element with a `data-expr` attribute will contain a rendering of the\n\t  // provided regular expression.\n\t  _lodash2.default.each(document.querySelectorAll('[data-expr]'), function (element) {\n\t    new _javascript2.default(element, { keepContent: true }).parse(element.getAttribute('data-expr')).then(function (parser) {\n\t      parser.render();\n\t    }).catch(_util2.default.exposeError);\n\t  });\n\t})();\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _lodash = __webpack_require__(2);\n\t\n\tvar _lodash2 = _interopRequireDefault(_lodash);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// Generate an `Event` object for triggering a custom event.\n\t//\n\t// - __name__ - Name of the custom event. This should be a String.\n\t// - __detail__ - Event details. The event details are provided to the event\n\t//    handler.\n\tfunction customEvent(name, detail) {\n\t  var evt = document.createEvent('Event');\n\t  evt.initEvent(name, true, true);\n\t  evt.detail = detail;\n\t  return evt;\n\t}\n\t\n\t// Add extra fields to a bounding box returned by `getBBox`. Specifically adds\n\t// details about the box's axis points (used when positioning elements for\n\t// display).\n\t//\n\t// - __box__ - Bounding box object to update. Attributes `ax`, `ax2`, and `ay`\n\t//    will be added if they are not already defined.\n\t// Utility functions used elsewhere in the codebase. Most JavaScript files on\n\t// the site use some functions defined in this file.\n\t\n\tfunction normalizeBBox(box) {\n\t  return _lodash2.default.defaults(box, {\n\t    ax: box.x,\n\t    ax2: box.x2,\n\t    ay: box.cy\n\t  });\n\t}\n\t\n\t// Positions a collection of items with their axis points aligned along a\n\t// horizontal line. This leads to the items being spaced horizontally and\n\t// effectively centered vertically.\n\t//\n\t// - __items__ - Array of items to be positioned\n\t// - __options.padding__ - Number of pixels to leave between items\n\tfunction spaceHorizontally(items, options) {\n\t  var verticalCenter, values;\n\t\n\t  options = _lodash2.default.defaults(options || {}, {\n\t    padding: 0\n\t  });\n\t\n\t  values = _lodash2.default.map(items, function (item) {\n\t    return {\n\t      box: normalizeBBox(item.getBBox()),\n\t      item: item\n\t    };\n\t  });\n\t\n\t  // Calculate where the axis points should be positioned vertically.\n\t  verticalCenter = _lodash2.default.reduce(values, function (center, _ref) {\n\t    var box = _ref.box;\n\t    return Math.max(center, box.ay);\n\t  }, 0);\n\t\n\t  // Position items with padding between them and aligned their axis points.\n\t  _lodash2.default.reduce(values, function (offset, _ref2) {\n\t    var item = _ref2.item,\n\t        box = _ref2.box;\n\t\n\t    item.transform(Snap.matrix().translate(offset, verticalCenter - box.ay));\n\t\n\t    return offset + options.padding + box.width;\n\t  }, 0);\n\t}\n\t\n\t// Positions a collection of items centered horizontally in a vertical stack.\n\t//\n\t// - __items__ - Array of items to be positioned\n\t// - __options.padding__ - Number of pixels to leave between items\n\tfunction spaceVertically(items, options) {\n\t  var horizontalCenter, values;\n\t\n\t  options = _lodash2.default.defaults(options || {}, {\n\t    padding: 0\n\t  });\n\t\n\t  values = _lodash2.default.map(items, function (item) {\n\t    return {\n\t      box: item.getBBox(),\n\t      item: item\n\t    };\n\t  });\n\t\n\t  // Calculate where the center of each item should be positioned horizontally.\n\t  horizontalCenter = _lodash2.default.reduce(values, function (center, _ref3) {\n\t    var box = _ref3.box;\n\t    return Math.max(center, box.cx);\n\t  }, 0);\n\t\n\t  // Position items with padding between them and align their centers.\n\t  _lodash2.default.reduce(values, function (offset, _ref4) {\n\t    var item = _ref4.item,\n\t        box = _ref4.box;\n\t\n\t    item.transform(Snap.matrix().translate(horizontalCenter - box.cx, offset));\n\t\n\t    return offset + options.padding + box.height;\n\t  }, 0);\n\t}\n\t\n\t// Creates a Promise that will be resolved after a specified delay.\n\t//\n\t// - __delay__ - Time in milliseconds to wait before resolving promise.\n\tfunction wait(delay) {\n\t  return new Promise(function (resolve, reject) {\n\t    setTimeout(resolve, delay);\n\t  });\n\t}\n\t\n\t// Creates a Promise that will be resolved after 0 milliseconds. This is used\n\t// to create a short delay that allows the browser to address any pending tasks\n\t// while the JavaScript VM is not active.\n\tfunction tick() {\n\t  return wait(0);\n\t}\n\t\n\t// Re-throws an exception asynchronously. This is used to expose an exception\n\t// that was created during a Promise operation to be handled by global error\n\t// handlers (and to be displayed in the browser's debug console).\n\t//\n\t// - __error__ - Error/exception object to be re-thrown to the browser.\n\tfunction exposeError(error) {\n\t  setTimeout(function () {\n\t    throw error;\n\t  }, 0);\n\t}\n\t\n\t// Renders an SVG icon.\n\t//\n\t// - __selector__ - Selector to the SVG icon to render.\n\tfunction icon(selector) {\n\t  return '<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 8 8\"><use xlink:href=\"' + selector + '\" /></svg>';\n\t}\n\t\n\t// Send tracking data.\n\tfunction track() {\n\t  if (window.ga) {\n\t    ga.apply(ga, arguments);\n\t  } else {\n\t    console.debug.apply(console, arguments);\n\t  }\n\t}\n\t\n\texports.default = {\n\t  customEvent: customEvent,\n\t  normalizeBBox: normalizeBBox,\n\t  spaceHorizontally: spaceHorizontally,\n\t  spaceVertically: spaceVertically,\n\t  wait: wait,\n\t  tick: tick,\n\t  exposeError: exposeError,\n\t  icon: icon,\n\t  track: track\n\t};\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global, module) {/**\n\t * @license\n\t * Lodash <https://lodash.com/>\n\t * Copyright JS Foundation and other contributors <https://js.foundation/>\n\t * Released under MIT license <https://lodash.com/license>\n\t * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n\t * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t */\n\t;(function() {\n\t\n\t  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n\t  var undefined;\n\t\n\t  /** Used as the semantic version number. */\n\t  var VERSION = '4.17.2';\n\t\n\t  /** Used as the size to enable large array optimizations. */\n\t  var LARGE_ARRAY_SIZE = 200;\n\t\n\t  /** Error message constants. */\n\t  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',\n\t      FUNC_ERROR_TEXT = 'Expected a function';\n\t\n\t  /** Used to stand-in for `undefined` hash values. */\n\t  var HASH_UNDEFINED = '__lodash_hash_undefined__';\n\t\n\t  /** Used as the maximum memoize cache size. */\n\t  var MAX_MEMOIZE_SIZE = 500;\n\t\n\t  /** Used as the internal argument placeholder. */\n\t  var PLACEHOLDER = '__lodash_placeholder__';\n\t\n\t  /** Used to compose bitmasks for cloning. */\n\t  var CLONE_DEEP_FLAG = 1,\n\t      CLONE_FLAT_FLAG = 2,\n\t      CLONE_SYMBOLS_FLAG = 4;\n\t\n\t  /** Used to compose bitmasks for value comparisons. */\n\t  var COMPARE_PARTIAL_FLAG = 1,\n\t      COMPARE_UNORDERED_FLAG = 2;\n\t\n\t  /** Used to compose bitmasks for function metadata. */\n\t  var WRAP_BIND_FLAG = 1,\n\t      WRAP_BIND_KEY_FLAG = 2,\n\t      WRAP_CURRY_BOUND_FLAG = 4,\n\t      WRAP_CURRY_FLAG = 8,\n\t      WRAP_CURRY_RIGHT_FLAG = 16,\n\t      WRAP_PARTIAL_FLAG = 32,\n\t      WRAP_PARTIAL_RIGHT_FLAG = 64,\n\t      WRAP_ARY_FLAG = 128,\n\t      WRAP_REARG_FLAG = 256,\n\t      WRAP_FLIP_FLAG = 512;\n\t\n\t  /** Used as default options for `_.truncate`. */\n\t  var DEFAULT_TRUNC_LENGTH = 30,\n\t      DEFAULT_TRUNC_OMISSION = '...';\n\t\n\t  /** Used to detect hot functions by number of calls within a span of milliseconds. */\n\t  var HOT_COUNT = 800,\n\t      HOT_SPAN = 16;\n\t\n\t  /** Used to indicate the type of lazy iteratees. */\n\t  var LAZY_FILTER_FLAG = 1,\n\t      LAZY_MAP_FLAG = 2,\n\t      LAZY_WHILE_FLAG = 3;\n\t\n\t  /** Used as references for various `Number` constants. */\n\t  var INFINITY = 1 / 0,\n\t      MAX_SAFE_INTEGER = 9007199254740991,\n\t      MAX_INTEGER = 1.7976931348623157e+308,\n\t      NAN = 0 / 0;\n\t\n\t  /** Used as references for the maximum length and index of an array. */\n\t  var MAX_ARRAY_LENGTH = 4294967295,\n\t      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,\n\t      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\n\t\n\t  /** Used to associate wrap methods with their bit flags. */\n\t  var wrapFlags = [\n\t    ['ary', WRAP_ARY_FLAG],\n\t    ['bind', WRAP_BIND_FLAG],\n\t    ['bindKey', WRAP_BIND_KEY_FLAG],\n\t    ['curry', WRAP_CURRY_FLAG],\n\t    ['curryRight', WRAP_CURRY_RIGHT_FLAG],\n\t    ['flip', WRAP_FLIP_FLAG],\n\t    ['partial', WRAP_PARTIAL_FLAG],\n\t    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],\n\t    ['rearg', WRAP_REARG_FLAG]\n\t  ];\n\t\n\t  /** `Object#toString` result references. */\n\t  var argsTag = '[object Arguments]',\n\t      arrayTag = '[object Array]',\n\t      asyncTag = '[object AsyncFunction]',\n\t      boolTag = '[object Boolean]',\n\t      dateTag = '[object Date]',\n\t      domExcTag = '[object DOMException]',\n\t      errorTag = '[object Error]',\n\t      funcTag = '[object Function]',\n\t      genTag = '[object GeneratorFunction]',\n\t      mapTag = '[object Map]',\n\t      numberTag = '[object Number]',\n\t      nullTag = '[object Null]',\n\t      objectTag = '[object Object]',\n\t      promiseTag = '[object Promise]',\n\t      proxyTag = '[object Proxy]',\n\t      regexpTag = '[object RegExp]',\n\t      setTag = '[object Set]',\n\t      stringTag = '[object String]',\n\t      symbolTag = '[object Symbol]',\n\t      undefinedTag = '[object Undefined]',\n\t      weakMapTag = '[object WeakMap]',\n\t      weakSetTag = '[object WeakSet]';\n\t\n\t  var arrayBufferTag = '[object ArrayBuffer]',\n\t      dataViewTag = '[object DataView]',\n\t      float32Tag = '[object Float32Array]',\n\t      float64Tag = '[object Float64Array]',\n\t      int8Tag = '[object Int8Array]',\n\t      int16Tag = '[object Int16Array]',\n\t      int32Tag = '[object Int32Array]',\n\t      uint8Tag = '[object Uint8Array]',\n\t      uint8ClampedTag = '[object Uint8ClampedArray]',\n\t      uint16Tag = '[object Uint16Array]',\n\t      uint32Tag = '[object Uint32Array]';\n\t\n\t  /** Used to match empty string literals in compiled template source. */\n\t  var reEmptyStringLeading = /\\b__p \\+= '';/g,\n\t      reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g,\n\t      reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n\t\n\t  /** Used to match HTML entities and HTML characters. */\n\t  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,\n\t      reUnescapedHtml = /[&<>\"']/g,\n\t      reHasEscapedHtml = RegExp(reEscapedHtml.source),\n\t      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n\t\n\t  /** Used to match template delimiters. */\n\t  var reEscape = /<%-([\\s\\S]+?)%>/g,\n\t      reEvaluate = /<%([\\s\\S]+?)%>/g,\n\t      reInterpolate = /<%=([\\s\\S]+?)%>/g;\n\t\n\t  /** Used to match property names within property paths. */\n\t  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n\t      reIsPlainProp = /^\\w*$/,\n\t      reLeadingDot = /^\\./,\n\t      rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\t\n\t  /**\n\t   * Used to match `RegExp`\n\t   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n\t   */\n\t  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g,\n\t      reHasRegExpChar = RegExp(reRegExpChar.source);\n\t\n\t  /** Used to match leading and trailing whitespace. */\n\t  var reTrim = /^\\s+|\\s+$/g,\n\t      reTrimStart = /^\\s+/,\n\t      reTrimEnd = /\\s+$/;\n\t\n\t  /** Used to match wrap detail comments. */\n\t  var reWrapComment = /\\{(?:\\n\\/\\* \\[wrapped with .+\\] \\*\\/)?\\n?/,\n\t      reWrapDetails = /\\{\\n\\/\\* \\[wrapped with (.+)\\] \\*/,\n\t      reSplitDetails = /,? & /;\n\t\n\t  /** Used to match words composed of alphanumeric characters. */\n\t  var reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n\t\n\t  /** Used to match backslashes in property paths. */\n\t  var reEscapeChar = /\\\\(\\\\)?/g;\n\t\n\t  /**\n\t   * Used to match\n\t   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).\n\t   */\n\t  var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n\t\n\t  /** Used to match `RegExp` flags from their coerced string values. */\n\t  var reFlags = /\\w*$/;\n\t\n\t  /** Used to detect bad signed hexadecimal string values. */\n\t  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\t\n\t  /** Used to detect binary string values. */\n\t  var reIsBinary = /^0b[01]+$/i;\n\t\n\t  /** Used to detect host constructors (Safari). */\n\t  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\t\n\t  /** Used to detect octal string values. */\n\t  var reIsOctal = /^0o[0-7]+$/i;\n\t\n\t  /** Used to detect unsigned integer values. */\n\t  var reIsUint = /^(?:0|[1-9]\\d*)$/;\n\t\n\t  /** Used to match Latin Unicode letters (excluding mathematical operators). */\n\t  var reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;\n\t\n\t  /** Used to ensure capturing order of template delimiters. */\n\t  var reNoMatch = /($^)/;\n\t\n\t  /** Used to match unescaped characters in compiled string literals. */\n\t  var reUnescapedString = /['\\n\\r\\u2028\\u2029\\\\]/g;\n\t\n\t  /** Used to compose unicode character classes. */\n\t  var rsAstralRange = '\\\\ud800-\\\\udfff',\n\t      rsComboMarksRange = '\\\\u0300-\\\\u036f',\n\t      reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n\t      rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n\t      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n\t      rsDingbatRange = '\\\\u2700-\\\\u27bf',\n\t      rsLowerRange = 'a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff',\n\t      rsMathOpRange = '\\\\xac\\\\xb1\\\\xd7\\\\xf7',\n\t      rsNonCharRange = '\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf',\n\t      rsPunctuationRange = '\\\\u2000-\\\\u206f',\n\t      rsSpaceRange = ' \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000',\n\t      rsUpperRange = 'A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde',\n\t      rsVarRange = '\\\\ufe0e\\\\ufe0f',\n\t      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\n\t\n\t  /** Used to compose unicode capture groups. */\n\t  var rsApos = \"['\\u2019]\",\n\t      rsAstral = '[' + rsAstralRange + ']',\n\t      rsBreak = '[' + rsBreakRange + ']',\n\t      rsCombo = '[' + rsComboRange + ']',\n\t      rsDigits = '\\\\d+',\n\t      rsDingbat = '[' + rsDingbatRange + ']',\n\t      rsLower = '[' + rsLowerRange + ']',\n\t      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',\n\t      rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\n\t      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\n\t      rsNonAstral = '[^' + rsAstralRange + ']',\n\t      rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n\t      rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n\t      rsUpper = '[' + rsUpperRange + ']',\n\t      rsZWJ = '\\\\u200d';\n\t\n\t  /** Used to compose unicode regexes. */\n\t  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',\n\t      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',\n\t      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',\n\t      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',\n\t      reOptMod = rsModifier + '?',\n\t      rsOptVar = '[' + rsVarRange + ']?',\n\t      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n\t      rsOrdLower = '\\\\d*(?:(?:1st|2nd|3rd|(?![123])\\\\dth)\\\\b)',\n\t      rsOrdUpper = '\\\\d*(?:(?:1ST|2ND|3RD|(?![123])\\\\dTH)\\\\b)',\n\t      rsSeq = rsOptVar + reOptMod + rsOptJoin,\n\t      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,\n\t      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\t\n\t  /** Used to match apostrophes. */\n\t  var reApos = RegExp(rsApos, 'g');\n\t\n\t  /**\n\t   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and\n\t   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).\n\t   */\n\t  var reComboMark = RegExp(rsCombo, 'g');\n\t\n\t  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\n\t  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\t\n\t  /** Used to match complex or compound words. */\n\t  var reUnicodeWord = RegExp([\n\t    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',\n\t    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',\n\t    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,\n\t    rsUpper + '+' + rsOptContrUpper,\n\t    rsOrdUpper,\n\t    rsOrdLower,\n\t    rsDigits,\n\t    rsEmoji\n\t  ].join('|'), 'g');\n\t\n\t  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\n\t  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');\n\t\n\t  /** Used to detect strings that need a more robust regexp to match words. */\n\t  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;\n\t\n\t  /** Used to assign default `context` object properties. */\n\t  var contextProps = [\n\t    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',\n\t    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',\n\t    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',\n\t    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',\n\t    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'\n\t  ];\n\t\n\t  /** Used to make template sourceURLs easier to identify. */\n\t  var templateCounter = -1;\n\t\n\t  /** Used to identify `toStringTag` values of typed arrays. */\n\t  var typedArrayTags = {};\n\t  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\n\t  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\n\t  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\n\t  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\n\t  typedArrayTags[uint32Tag] = true;\n\t  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =\n\t  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\n\t  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\n\t  typedArrayTags[errorTag] = typedArrayTags[funcTag] =\n\t  typedArrayTags[mapTag] = typedArrayTags[numberTag] =\n\t  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =\n\t  typedArrayTags[setTag] = typedArrayTags[stringTag] =\n\t  typedArrayTags[weakMapTag] = false;\n\t\n\t  /** Used to identify `toStringTag` values supported by `_.clone`. */\n\t  var cloneableTags = {};\n\t  cloneableTags[argsTag] = cloneableTags[arrayTag] =\n\t  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\n\t  cloneableTags[boolTag] = cloneableTags[dateTag] =\n\t  cloneableTags[float32Tag] = cloneableTags[float64Tag] =\n\t  cloneableTags[int8Tag] = cloneableTags[int16Tag] =\n\t  cloneableTags[int32Tag] = cloneableTags[mapTag] =\n\t  cloneableTags[numberTag] = cloneableTags[objectTag] =\n\t  cloneableTags[regexpTag] = cloneableTags[setTag] =\n\t  cloneableTags[stringTag] = cloneableTags[symbolTag] =\n\t  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\n\t  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n\t  cloneableTags[errorTag] = cloneableTags[funcTag] =\n\t  cloneableTags[weakMapTag] = false;\n\t\n\t  /** Used to map Latin Unicode letters to basic Latin letters. */\n\t  var deburredLetters = {\n\t    // Latin-1 Supplement block.\n\t    '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\n\t    '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\n\t    '\\xc7': 'C',  '\\xe7': 'c',\n\t    '\\xd0': 'D',  '\\xf0': 'd',\n\t    '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\n\t    '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\n\t    '\\xcc': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\n\t    '\\xec': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\n\t    '\\xd1': 'N',  '\\xf1': 'n',\n\t    '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\n\t    '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\n\t    '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\n\t    '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\n\t    '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\n\t    '\\xc6': 'Ae', '\\xe6': 'ae',\n\t    '\\xde': 'Th', '\\xfe': 'th',\n\t    '\\xdf': 'ss',\n\t    // Latin Extended-A block.\n\t    '\\u0100': 'A',  '\\u0102': 'A', '\\u0104': 'A',\n\t    '\\u0101': 'a',  '\\u0103': 'a', '\\u0105': 'a',\n\t    '\\u0106': 'C',  '\\u0108': 'C', '\\u010a': 'C', '\\u010c': 'C',\n\t    '\\u0107': 'c',  '\\u0109': 'c', '\\u010b': 'c', '\\u010d': 'c',\n\t    '\\u010e': 'D',  '\\u0110': 'D', '\\u010f': 'd', '\\u0111': 'd',\n\t    '\\u0112': 'E',  '\\u0114': 'E', '\\u0116': 'E', '\\u0118': 'E', '\\u011a': 'E',\n\t    '\\u0113': 'e',  '\\u0115': 'e', '\\u0117': 'e', '\\u0119': 'e', '\\u011b': 'e',\n\t    '\\u011c': 'G',  '\\u011e': 'G', '\\u0120': 'G', '\\u0122': 'G',\n\t    '\\u011d': 'g',  '\\u011f': 'g', '\\u0121': 'g', '\\u0123': 'g',\n\t    '\\u0124': 'H',  '\\u0126': 'H', '\\u0125': 'h', '\\u0127': 'h',\n\t    '\\u0128': 'I',  '\\u012a': 'I', '\\u012c': 'I', '\\u012e': 'I', '\\u0130': 'I',\n\t    '\\u0129': 'i',  '\\u012b': 'i', '\\u012d': 'i', '\\u012f': 'i', '\\u0131': 'i',\n\t    '\\u0134': 'J',  '\\u0135': 'j',\n\t    '\\u0136': 'K',  '\\u0137': 'k', '\\u0138': 'k',\n\t    '\\u0139': 'L',  '\\u013b': 'L', '\\u013d': 'L', '\\u013f': 'L', '\\u0141': 'L',\n\t    '\\u013a': 'l',  '\\u013c': 'l', '\\u013e': 'l', '\\u0140': 'l', '\\u0142': 'l',\n\t    '\\u0143': 'N',  '\\u0145': 'N', '\\u0147': 'N', '\\u014a': 'N',\n\t    '\\u0144': 'n',  '\\u0146': 'n', '\\u0148': 'n', '\\u014b': 'n',\n\t    '\\u014c': 'O',  '\\u014e': 'O', '\\u0150': 'O',\n\t    '\\u014d': 'o',  '\\u014f': 'o', '\\u0151': 'o',\n\t    '\\u0154': 'R',  '\\u0156': 'R', '\\u0158': 'R',\n\t    '\\u0155': 'r',  '\\u0157': 'r', '\\u0159': 'r',\n\t    '\\u015a': 'S',  '\\u015c': 'S', '\\u015e': 'S', '\\u0160': 'S',\n\t    '\\u015b': 's',  '\\u015d': 's', '\\u015f': 's', '\\u0161': 's',\n\t    '\\u0162': 'T',  '\\u0164': 'T', '\\u0166': 'T',\n\t    '\\u0163': 't',  '\\u0165': 't', '\\u0167': 't',\n\t    '\\u0168': 'U',  '\\u016a': 'U', '\\u016c': 'U', '\\u016e': 'U', '\\u0170': 'U', '\\u0172': 'U',\n\t    '\\u0169': 'u',  '\\u016b': 'u', '\\u016d': 'u', '\\u016f': 'u', '\\u0171': 'u', '\\u0173': 'u',\n\t    '\\u0174': 'W',  '\\u0175': 'w',\n\t    '\\u0176': 'Y',  '\\u0177': 'y', '\\u0178': 'Y',\n\t    '\\u0179': 'Z',  '\\u017b': 'Z', '\\u017d': 'Z',\n\t    '\\u017a': 'z',  '\\u017c': 'z', '\\u017e': 'z',\n\t    '\\u0132': 'IJ', '\\u0133': 'ij',\n\t    '\\u0152': 'Oe', '\\u0153': 'oe',\n\t    '\\u0149': \"'n\", '\\u017f': 's'\n\t  };\n\t\n\t  /** Used to map characters to HTML entities. */\n\t  var htmlEscapes = {\n\t    '&': '&amp;',\n\t    '<': '&lt;',\n\t    '>': '&gt;',\n\t    '\"': '&quot;',\n\t    \"'\": '&#39;'\n\t  };\n\t\n\t  /** Used to map HTML entities to characters. */\n\t  var htmlUnescapes = {\n\t    '&amp;': '&',\n\t    '&lt;': '<',\n\t    '&gt;': '>',\n\t    '&quot;': '\"',\n\t    '&#39;': \"'\"\n\t  };\n\t\n\t  /** Used to escape characters for inclusion in compiled string literals. */\n\t  var stringEscapes = {\n\t    '\\\\': '\\\\',\n\t    \"'\": \"'\",\n\t    '\\n': 'n',\n\t    '\\r': 'r',\n\t    '\\u2028': 'u2028',\n\t    '\\u2029': 'u2029'\n\t  };\n\t\n\t  /** Built-in method references without a dependency on `root`. */\n\t  var freeParseFloat = parseFloat,\n\t      freeParseInt = parseInt;\n\t\n\t  /** Detect free variable `global` from Node.js. */\n\t  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\t\n\t  /** Detect free variable `self`. */\n\t  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\t\n\t  /** Used as a reference to the global object. */\n\t  var root = freeGlobal || freeSelf || Function('return this')();\n\t\n\t  /** Detect free variable `exports`. */\n\t  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\t\n\t  /** Detect free variable `module`. */\n\t  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\t\n\t  /** Detect the popular CommonJS extension `module.exports`. */\n\t  var moduleExports = freeModule && freeModule.exports === freeExports;\n\t\n\t  /** Detect free variable `process` from Node.js. */\n\t  var freeProcess = moduleExports && freeGlobal.process;\n\t\n\t  /** Used to access faster Node.js helpers. */\n\t  var nodeUtil = (function() {\n\t    try {\n\t      return freeProcess && freeProcess.binding && freeProcess.binding('util');\n\t    } catch (e) {}\n\t  }());\n\t\n\t  /* Node.js helper references. */\n\t  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,\n\t      nodeIsDate = nodeUtil && nodeUtil.isDate,\n\t      nodeIsMap = nodeUtil && nodeUtil.isMap,\n\t      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,\n\t      nodeIsSet = nodeUtil && nodeUtil.isSet,\n\t      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\t\n\t  /*--------------------------------------------------------------------------*/\n\t\n\t  /**\n\t   * Adds the key-value `pair` to `map`.\n\t   *\n\t   * @private\n\t   * @param {Object} map The map to modify.\n\t   * @param {Array} pair The key-value pair to add.\n\t   * @returns {Object} Returns `map`.\n\t   */\n\t  function addMapEntry(map, pair) {\n\t    // Don't return `map.set` because it's not chainable in IE 11.\n\t    map.set(pair[0], pair[1]);\n\t    return map;\n\t  }\n\t\n\t  /**\n\t   * Adds `value` to `set`.\n\t   *\n\t   * @private\n\t   * @param {Object} set The set to modify.\n\t   * @param {*} value The value to add.\n\t   * @returns {Object} Returns `set`.\n\t   */\n\t  function addSetEntry(set, value) {\n\t    // Don't return `set.add` because it's not chainable in IE 11.\n\t    set.add(value);\n\t    return set;\n\t  }\n\t\n\t  /**\n\t   * A faster alternative to `Function#apply`, this function invokes `func`\n\t   * with the `this` binding of `thisArg` and the arguments of `args`.\n\t   *\n\t   * @private\n\t   * @param {Function} func The function to invoke.\n\t   * @param {*} thisArg The `this` binding of `func`.\n\t   * @param {Array} args The arguments to invoke `func` with.\n\t   * @returns {*} Returns the result of `func`.\n\t   */\n\t  function apply(func, thisArg, args) {\n\t    switch (args.length) {\n\t      case 0: return func.call(thisArg);\n\t      case 1: return func.call(thisArg, args[0]);\n\t      case 2: return func.call(thisArg, args[0], args[1]);\n\t      case 3: return func.call(thisArg, args[0], args[1], args[2]);\n\t    }\n\t    return func.apply(thisArg, args);\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `baseAggregator` for arrays.\n\t   *\n\t   * @private\n\t   * @param {Array} [array] The array to iterate over.\n\t   * @param {Function} setter The function to set `accumulator` values.\n\t   * @param {Function} iteratee The iteratee to transform keys.\n\t   * @param {Object} accumulator The initial aggregated object.\n\t   * @returns {Function} Returns `accumulator`.\n\t   */\n\t  function arrayAggregator(array, setter, iteratee, accumulator) {\n\t    var index = -1,\n\t        length = array == null ? 0 : array.length;\n\t\n\t    while (++index < length) {\n\t      var value = array[index];\n\t      setter(accumulator, value, iteratee(value), array);\n\t    }\n\t    return accumulator;\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `_.forEach` for arrays without support for\n\t   * iteratee shorthands.\n\t   *\n\t   * @private\n\t   * @param {Array} [array] The array to iterate over.\n\t   * @param {Function} iteratee The function invoked per iteration.\n\t   * @returns {Array} Returns `array`.\n\t   */\n\t  function arrayEach(array, iteratee) {\n\t    var index = -1,\n\t        length = array == null ? 0 : array.length;\n\t\n\t    while (++index < length) {\n\t      if (iteratee(array[index], index, array) === false) {\n\t        break;\n\t      }\n\t    }\n\t    return array;\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `_.forEachRight` for arrays without support for\n\t   * iteratee shorthands.\n\t   *\n\t   * @private\n\t   * @param {Array} [array] The array to iterate over.\n\t   * @param {Function} iteratee The function invoked per iteration.\n\t   * @returns {Array} Returns `array`.\n\t   */\n\t  function arrayEachRight(array, iteratee) {\n\t    var length = array == null ? 0 : array.length;\n\t\n\t    while (length--) {\n\t      if (iteratee(array[length], length, array) === false) {\n\t        break;\n\t      }\n\t    }\n\t    return array;\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `_.every` for arrays without support for\n\t   * iteratee shorthands.\n\t   *\n\t   * @private\n\t   * @param {Array} [array] The array to iterate over.\n\t   * @param {Function} predicate The function invoked per iteration.\n\t   * @returns {boolean} Returns `true` if all elements pass the predicate check,\n\t   *  else `false`.\n\t   */\n\t  function arrayEvery(array, predicate) {\n\t    var index = -1,\n\t        length = array == null ? 0 : array.length;\n\t\n\t    while (++index < length) {\n\t      if (!predicate(array[index], index, array)) {\n\t        return false;\n\t      }\n\t    }\n\t    return true;\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `_.filter` for arrays without support for\n\t   * iteratee shorthands.\n\t   *\n\t   * @private\n\t   * @param {Array} [array] The array to iterate over.\n\t   * @param {Function} predicate The function invoked per iteration.\n\t   * @returns {Array} Returns the new filtered array.\n\t   */\n\t  function arrayFilter(array, predicate) {\n\t    var index = -1,\n\t        length = array == null ? 0 : array.length,\n\t        resIndex = 0,\n\t        result = [];\n\t\n\t    while (++index < length) {\n\t      var value = array[index];\n\t      if (predicate(value, index, array)) {\n\t        result[resIndex++] = value;\n\t      }\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `_.includes` for arrays without support for\n\t   * specifying an index to search from.\n\t   *\n\t   * @private\n\t   * @param {Array} [array] The array to inspect.\n\t   * @param {*} target The value to search for.\n\t   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n\t   */\n\t  function arrayIncludes(array, value) {\n\t    var length = array == null ? 0 : array.length;\n\t    return !!length && baseIndexOf(array, value, 0) > -1;\n\t  }\n\t\n\t  /**\n\t   * This function is like `arrayIncludes` except that it accepts a comparator.\n\t   *\n\t   * @private\n\t   * @param {Array} [array] The array to inspect.\n\t   * @param {*} target The value to search for.\n\t   * @param {Function} comparator The comparator invoked per element.\n\t   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n\t   */\n\t  function arrayIncludesWith(array, value, comparator) {\n\t    var index = -1,\n\t        length = array == null ? 0 : array.length;\n\t\n\t    while (++index < length) {\n\t      if (comparator(value, array[index])) {\n\t        return true;\n\t      }\n\t    }\n\t    return false;\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `_.map` for arrays without support for iteratee\n\t   * shorthands.\n\t   *\n\t   * @private\n\t   * @param {Array} [array] The array to iterate over.\n\t   * @param {Function} iteratee The function invoked per iteration.\n\t   * @returns {Array} Returns the new mapped array.\n\t   */\n\t  function arrayMap(array, iteratee) {\n\t    var index = -1,\n\t        length = array == null ? 0 : array.length,\n\t        result = Array(length);\n\t\n\t    while (++index < length) {\n\t      result[index] = iteratee(array[index], index, array);\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * Appends the elements of `values` to `array`.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to modify.\n\t   * @param {Array} values The values to append.\n\t   * @returns {Array} Returns `array`.\n\t   */\n\t  function arrayPush(array, values) {\n\t    var index = -1,\n\t        length = values.length,\n\t        offset = array.length;\n\t\n\t    while (++index < length) {\n\t      array[offset + index] = values[index];\n\t    }\n\t    return array;\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `_.reduce` for arrays without support for\n\t   * iteratee shorthands.\n\t   *\n\t   * @private\n\t   * @param {Array} [array] The array to iterate over.\n\t   * @param {Function} iteratee The function invoked per iteration.\n\t   * @param {*} [accumulator] The initial value.\n\t   * @param {boolean} [initAccum] Specify using the first element of `array` as\n\t   *  the initial value.\n\t   * @returns {*} Returns the accumulated value.\n\t   */\n\t  function arrayReduce(array, iteratee, accumulator, initAccum) {\n\t    var index = -1,\n\t        length = array == null ? 0 : array.length;\n\t\n\t    if (initAccum && length) {\n\t      accumulator = array[++index];\n\t    }\n\t    while (++index < length) {\n\t      accumulator = iteratee(accumulator, array[index], index, array);\n\t    }\n\t    return accumulator;\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `_.reduceRight` for arrays without support for\n\t   * iteratee shorthands.\n\t   *\n\t   * @private\n\t   * @param {Array} [array] The array to iterate over.\n\t   * @param {Function} iteratee The function invoked per iteration.\n\t   * @param {*} [accumulator] The initial value.\n\t   * @param {boolean} [initAccum] Specify using the last element of `array` as\n\t   *  the initial value.\n\t   * @returns {*} Returns the accumulated value.\n\t   */\n\t  function arrayReduceRight(array, iteratee, accumulator, initAccum) {\n\t    var length = array == null ? 0 : array.length;\n\t    if (initAccum && length) {\n\t      accumulator = array[--length];\n\t    }\n\t    while (length--) {\n\t      accumulator = iteratee(accumulator, array[length], length, array);\n\t    }\n\t    return accumulator;\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `_.some` for arrays without support for iteratee\n\t   * shorthands.\n\t   *\n\t   * @private\n\t   * @param {Array} [array] The array to iterate over.\n\t   * @param {Function} predicate The function invoked per iteration.\n\t   * @returns {boolean} Returns `true` if any element passes the predicate check,\n\t   *  else `false`.\n\t   */\n\t  function arraySome(array, predicate) {\n\t    var index = -1,\n\t        length = array == null ? 0 : array.length;\n\t\n\t    while (++index < length) {\n\t      if (predicate(array[index], index, array)) {\n\t        return true;\n\t      }\n\t    }\n\t    return false;\n\t  }\n\t\n\t  /**\n\t   * Gets the size of an ASCII `string`.\n\t   *\n\t   * @private\n\t   * @param {string} string The string inspect.\n\t   * @returns {number} Returns the string size.\n\t   */\n\t  var asciiSize = baseProperty('length');\n\t\n\t  /**\n\t   * Converts an ASCII `string` to an array.\n\t   *\n\t   * @private\n\t   * @param {string} string The string to convert.\n\t   * @returns {Array} Returns the converted array.\n\t   */\n\t  function asciiToArray(string) {\n\t    return string.split('');\n\t  }\n\t\n\t  /**\n\t   * Splits an ASCII `string` into an array of its words.\n\t   *\n\t   * @private\n\t   * @param {string} The string to inspect.\n\t   * @returns {Array} Returns the words of `string`.\n\t   */\n\t  function asciiWords(string) {\n\t    return string.match(reAsciiWord) || [];\n\t  }\n\t\n\t  /**\n\t   * The base implementation of methods like `_.findKey` and `_.findLastKey`,\n\t   * without support for iteratee shorthands, which iterates over `collection`\n\t   * using `eachFunc`.\n\t   *\n\t   * @private\n\t   * @param {Array|Object} collection The collection to inspect.\n\t   * @param {Function} predicate The function invoked per iteration.\n\t   * @param {Function} eachFunc The function to iterate over `collection`.\n\t   * @returns {*} Returns the found element or its key, else `undefined`.\n\t   */\n\t  function baseFindKey(collection, predicate, eachFunc) {\n\t    var result;\n\t    eachFunc(collection, function(value, key, collection) {\n\t      if (predicate(value, key, collection)) {\n\t        result = key;\n\t        return false;\n\t      }\n\t    });\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.findIndex` and `_.findLastIndex` without\n\t   * support for iteratee shorthands.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to inspect.\n\t   * @param {Function} predicate The function invoked per iteration.\n\t   * @param {number} fromIndex The index to search from.\n\t   * @param {boolean} [fromRight] Specify iterating from right to left.\n\t   * @returns {number} Returns the index of the matched value, else `-1`.\n\t   */\n\t  function baseFindIndex(array, predicate, fromIndex, fromRight) {\n\t    var length = array.length,\n\t        index = fromIndex + (fromRight ? 1 : -1);\n\t\n\t    while ((fromRight ? index-- : ++index < length)) {\n\t      if (predicate(array[index], index, array)) {\n\t        return index;\n\t      }\n\t    }\n\t    return -1;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to inspect.\n\t   * @param {*} value The value to search for.\n\t   * @param {number} fromIndex The index to search from.\n\t   * @returns {number} Returns the index of the matched value, else `-1`.\n\t   */\n\t  function baseIndexOf(array, value, fromIndex) {\n\t    return value === value\n\t      ? strictIndexOf(array, value, fromIndex)\n\t      : baseFindIndex(array, baseIsNaN, fromIndex);\n\t  }\n\t\n\t  /**\n\t   * This function is like `baseIndexOf` except that it accepts a comparator.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to inspect.\n\t   * @param {*} value The value to search for.\n\t   * @param {number} fromIndex The index to search from.\n\t   * @param {Function} comparator The comparator invoked per element.\n\t   * @returns {number} Returns the index of the matched value, else `-1`.\n\t   */\n\t  function baseIndexOfWith(array, value, fromIndex, comparator) {\n\t    var index = fromIndex - 1,\n\t        length = array.length;\n\t\n\t    while (++index < length) {\n\t      if (comparator(array[index], value)) {\n\t        return index;\n\t      }\n\t    }\n\t    return -1;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.isNaN` without support for number objects.\n\t   *\n\t   * @private\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n\t   */\n\t  function baseIsNaN(value) {\n\t    return value !== value;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.mean` and `_.meanBy` without support for\n\t   * iteratee shorthands.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to iterate over.\n\t   * @param {Function} iteratee The function invoked per iteration.\n\t   * @returns {number} Returns the mean.\n\t   */\n\t  function baseMean(array, iteratee) {\n\t    var length = array == null ? 0 : array.length;\n\t    return length ? (baseSum(array, iteratee) / length) : NAN;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.property` without support for deep paths.\n\t   *\n\t   * @private\n\t   * @param {string} key The key of the property to get.\n\t   * @returns {Function} Returns the new accessor function.\n\t   */\n\t  function baseProperty(key) {\n\t    return function(object) {\n\t      return object == null ? undefined : object[key];\n\t    };\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.propertyOf` without support for deep paths.\n\t   *\n\t   * @private\n\t   * @param {Object} object The object to query.\n\t   * @returns {Function} Returns the new accessor function.\n\t   */\n\t  function basePropertyOf(object) {\n\t    return function(key) {\n\t      return object == null ? undefined : object[key];\n\t    };\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.reduce` and `_.reduceRight`, without support\n\t   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n\t   *\n\t   * @private\n\t   * @param {Array|Object} collection The collection to iterate over.\n\t   * @param {Function} iteratee The function invoked per iteration.\n\t   * @param {*} accumulator The initial value.\n\t   * @param {boolean} initAccum Specify using the first or last element of\n\t   *  `collection` as the initial value.\n\t   * @param {Function} eachFunc The function to iterate over `collection`.\n\t   * @returns {*} Returns the accumulated value.\n\t   */\n\t  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n\t    eachFunc(collection, function(value, index, collection) {\n\t      accumulator = initAccum\n\t        ? (initAccum = false, value)\n\t        : iteratee(accumulator, value, index, collection);\n\t    });\n\t    return accumulator;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.sortBy` which uses `comparer` to define the\n\t   * sort order of `array` and replaces criteria objects with their corresponding\n\t   * values.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to sort.\n\t   * @param {Function} comparer The function to define sort order.\n\t   * @returns {Array} Returns `array`.\n\t   */\n\t  function baseSortBy(array, comparer) {\n\t    var length = array.length;\n\t\n\t    array.sort(comparer);\n\t    while (length--) {\n\t      array[length] = array[length].value;\n\t    }\n\t    return array;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.sum` and `_.sumBy` without support for\n\t   * iteratee shorthands.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to iterate over.\n\t   * @param {Function} iteratee The function invoked per iteration.\n\t   * @returns {number} Returns the sum.\n\t   */\n\t  function baseSum(array, iteratee) {\n\t    var result,\n\t        index = -1,\n\t        length = array.length;\n\t\n\t    while (++index < length) {\n\t      var current = iteratee(array[index]);\n\t      if (current !== undefined) {\n\t        result = result === undefined ? current : (result + current);\n\t      }\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.times` without support for iteratee shorthands\n\t   * or max array length checks.\n\t   *\n\t   * @private\n\t   * @param {number} n The number of times to invoke `iteratee`.\n\t   * @param {Function} iteratee The function invoked per iteration.\n\t   * @returns {Array} Returns the array of results.\n\t   */\n\t  function baseTimes(n, iteratee) {\n\t    var index = -1,\n\t        result = Array(n);\n\t\n\t    while (++index < n) {\n\t      result[index] = iteratee(index);\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array\n\t   * of key-value pairs for `object` corresponding to the property names of `props`.\n\t   *\n\t   * @private\n\t   * @param {Object} object The object to query.\n\t   * @param {Array} props The property names to get values for.\n\t   * @returns {Object} Returns the key-value pairs.\n\t   */\n\t  function baseToPairs(object, props) {\n\t    return arrayMap(props, function(key) {\n\t      return [key, object[key]];\n\t    });\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.unary` without support for storing metadata.\n\t   *\n\t   * @private\n\t   * @param {Function} func The function to cap arguments for.\n\t   * @returns {Function} Returns the new capped function.\n\t   */\n\t  function baseUnary(func) {\n\t    return function(value) {\n\t      return func(value);\n\t    };\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.values` and `_.valuesIn` which creates an\n\t   * array of `object` property values corresponding to the property names\n\t   * of `props`.\n\t   *\n\t   * @private\n\t   * @param {Object} object The object to query.\n\t   * @param {Array} props The property names to get values for.\n\t   * @returns {Object} Returns the array of property values.\n\t   */\n\t  function baseValues(object, props) {\n\t    return arrayMap(props, function(key) {\n\t      return object[key];\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Checks if a `cache` value for `key` exists.\n\t   *\n\t   * @private\n\t   * @param {Object} cache The cache to query.\n\t   * @param {string} key The key of the entry to check.\n\t   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t   */\n\t  function cacheHas(cache, key) {\n\t    return cache.has(key);\n\t  }\n\t\n\t  /**\n\t   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol\n\t   * that is not found in the character symbols.\n\t   *\n\t   * @private\n\t   * @param {Array} strSymbols The string symbols to inspect.\n\t   * @param {Array} chrSymbols The character symbols to find.\n\t   * @returns {number} Returns the index of the first unmatched string symbol.\n\t   */\n\t  function charsStartIndex(strSymbols, chrSymbols) {\n\t    var index = -1,\n\t        length = strSymbols.length;\n\t\n\t    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n\t    return index;\n\t  }\n\t\n\t  /**\n\t   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol\n\t   * that is not found in the character symbols.\n\t   *\n\t   * @private\n\t   * @param {Array} strSymbols The string symbols to inspect.\n\t   * @param {Array} chrSymbols The character symbols to find.\n\t   * @returns {number} Returns the index of the last unmatched string symbol.\n\t   */\n\t  function charsEndIndex(strSymbols, chrSymbols) {\n\t    var index = strSymbols.length;\n\t\n\t    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n\t    return index;\n\t  }\n\t\n\t  /**\n\t   * Gets the number of `placeholder` occurrences in `array`.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to inspect.\n\t   * @param {*} placeholder The placeholder to search for.\n\t   * @returns {number} Returns the placeholder count.\n\t   */\n\t  function countHolders(array, placeholder) {\n\t    var length = array.length,\n\t        result = 0;\n\t\n\t    while (length--) {\n\t      if (array[length] === placeholder) {\n\t        ++result;\n\t      }\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A\n\t   * letters to basic Latin letters.\n\t   *\n\t   * @private\n\t   * @param {string} letter The matched letter to deburr.\n\t   * @returns {string} Returns the deburred letter.\n\t   */\n\t  var deburrLetter = basePropertyOf(deburredLetters);\n\t\n\t  /**\n\t   * Used by `_.escape` to convert characters to HTML entities.\n\t   *\n\t   * @private\n\t   * @param {string} chr The matched character to escape.\n\t   * @returns {string} Returns the escaped character.\n\t   */\n\t  var escapeHtmlChar = basePropertyOf(htmlEscapes);\n\t\n\t  /**\n\t   * Used by `_.template` to escape characters for inclusion in compiled string literals.\n\t   *\n\t   * @private\n\t   * @param {string} chr The matched character to escape.\n\t   * @returns {string} Returns the escaped character.\n\t   */\n\t  function escapeStringChar(chr) {\n\t    return '\\\\' + stringEscapes[chr];\n\t  }\n\t\n\t  /**\n\t   * Gets the value at `key` of `object`.\n\t   *\n\t   * @private\n\t   * @param {Object} [object] The object to query.\n\t   * @param {string} key The key of the property to get.\n\t   * @returns {*} Returns the property value.\n\t   */\n\t  function getValue(object, key) {\n\t    return object == null ? undefined : object[key];\n\t  }\n\t\n\t  /**\n\t   * Checks if `string` contains Unicode symbols.\n\t   *\n\t   * @private\n\t   * @param {string} string The string to inspect.\n\t   * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n\t   */\n\t  function hasUnicode(string) {\n\t    return reHasUnicode.test(string);\n\t  }\n\t\n\t  /**\n\t   * Checks if `string` contains a word composed of Unicode symbols.\n\t   *\n\t   * @private\n\t   * @param {string} string The string to inspect.\n\t   * @returns {boolean} Returns `true` if a word is found, else `false`.\n\t   */\n\t  function hasUnicodeWord(string) {\n\t    return reHasUnicodeWord.test(string);\n\t  }\n\t\n\t  /**\n\t   * Converts `iterator` to an array.\n\t   *\n\t   * @private\n\t   * @param {Object} iterator The iterator to convert.\n\t   * @returns {Array} Returns the converted array.\n\t   */\n\t  function iteratorToArray(iterator) {\n\t    var data,\n\t        result = [];\n\t\n\t    while (!(data = iterator.next()).done) {\n\t      result.push(data.value);\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * Converts `map` to its key-value pairs.\n\t   *\n\t   * @private\n\t   * @param {Object} map The map to convert.\n\t   * @returns {Array} Returns the key-value pairs.\n\t   */\n\t  function mapToArray(map) {\n\t    var index = -1,\n\t        result = Array(map.size);\n\t\n\t    map.forEach(function(value, key) {\n\t      result[++index] = [key, value];\n\t    });\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * Creates a unary function that invokes `func` with its argument transformed.\n\t   *\n\t   * @private\n\t   * @param {Function} func The function to wrap.\n\t   * @param {Function} transform The argument transform.\n\t   * @returns {Function} Returns the new function.\n\t   */\n\t  function overArg(func, transform) {\n\t    return function(arg) {\n\t      return func(transform(arg));\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Replaces all `placeholder` elements in `array` with an internal placeholder\n\t   * and returns an array of their indexes.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to modify.\n\t   * @param {*} placeholder The placeholder to replace.\n\t   * @returns {Array} Returns the new array of placeholder indexes.\n\t   */\n\t  function replaceHolders(array, placeholder) {\n\t    var index = -1,\n\t        length = array.length,\n\t        resIndex = 0,\n\t        result = [];\n\t\n\t    while (++index < length) {\n\t      var value = array[index];\n\t      if (value === placeholder || value === PLACEHOLDER) {\n\t        array[index] = PLACEHOLDER;\n\t        result[resIndex++] = index;\n\t      }\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * Converts `set` to an array of its values.\n\t   *\n\t   * @private\n\t   * @param {Object} set The set to convert.\n\t   * @returns {Array} Returns the values.\n\t   */\n\t  function setToArray(set) {\n\t    var index = -1,\n\t        result = Array(set.size);\n\t\n\t    set.forEach(function(value) {\n\t      result[++index] = value;\n\t    });\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * Converts `set` to its value-value pairs.\n\t   *\n\t   * @private\n\t   * @param {Object} set The set to convert.\n\t   * @returns {Array} Returns the value-value pairs.\n\t   */\n\t  function setToPairs(set) {\n\t    var index = -1,\n\t        result = Array(set.size);\n\t\n\t    set.forEach(function(value) {\n\t      result[++index] = [value, value];\n\t    });\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `_.indexOf` which performs strict equality\n\t   * comparisons of values, i.e. `===`.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to inspect.\n\t   * @param {*} value The value to search for.\n\t   * @param {number} fromIndex The index to search from.\n\t   * @returns {number} Returns the index of the matched value, else `-1`.\n\t   */\n\t  function strictIndexOf(array, value, fromIndex) {\n\t    var index = fromIndex - 1,\n\t        length = array.length;\n\t\n\t    while (++index < length) {\n\t      if (array[index] === value) {\n\t        return index;\n\t      }\n\t    }\n\t    return -1;\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `_.lastIndexOf` which performs strict equality\n\t   * comparisons of values, i.e. `===`.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to inspect.\n\t   * @param {*} value The value to search for.\n\t   * @param {number} fromIndex The index to search from.\n\t   * @returns {number} Returns the index of the matched value, else `-1`.\n\t   */\n\t  function strictLastIndexOf(array, value, fromIndex) {\n\t    var index = fromIndex + 1;\n\t    while (index--) {\n\t      if (array[index] === value) {\n\t        return index;\n\t      }\n\t    }\n\t    return index;\n\t  }\n\t\n\t  /**\n\t   * Gets the number of symbols in `string`.\n\t   *\n\t   * @private\n\t   * @param {string} string The string to inspect.\n\t   * @returns {number} Returns the string size.\n\t   */\n\t  function stringSize(string) {\n\t    return hasUnicode(string)\n\t      ? unicodeSize(string)\n\t      : asciiSize(string);\n\t  }\n\t\n\t  /**\n\t   * Converts `string` to an array.\n\t   *\n\t   * @private\n\t   * @param {string} string The string to convert.\n\t   * @returns {Array} Returns the converted array.\n\t   */\n\t  function stringToArray(string) {\n\t    return hasUnicode(string)\n\t      ? unicodeToArray(string)\n\t      : asciiToArray(string);\n\t  }\n\t\n\t  /**\n\t   * Used by `_.unescape` to convert HTML entities to characters.\n\t   *\n\t   * @private\n\t   * @param {string} chr The matched character to unescape.\n\t   * @returns {string} Returns the unescaped character.\n\t   */\n\t  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);\n\t\n\t  /**\n\t   * Gets the size of a Unicode `string`.\n\t   *\n\t   * @private\n\t   * @param {string} string The string inspect.\n\t   * @returns {number} Returns the string size.\n\t   */\n\t  function unicodeSize(string) {\n\t    var result = reUnicode.lastIndex = 0;\n\t    while (reUnicode.test(string)) {\n\t      ++result;\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * Converts a Unicode `string` to an array.\n\t   *\n\t   * @private\n\t   * @param {string} string The string to convert.\n\t   * @returns {Array} Returns the converted array.\n\t   */\n\t  function unicodeToArray(string) {\n\t    return string.match(reUnicode) || [];\n\t  }\n\t\n\t  /**\n\t   * Splits a Unicode `string` into an array of its words.\n\t   *\n\t   * @private\n\t   * @param {string} The string to inspect.\n\t   * @returns {Array} Returns the words of `string`.\n\t   */\n\t  function unicodeWords(string) {\n\t    return string.match(reUnicodeWord) || [];\n\t  }\n\t\n\t  /*--------------------------------------------------------------------------*/\n\t\n\t  /**\n\t   * Create a new pristine `lodash` function using the `context` object.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @since 1.1.0\n\t   * @category Util\n\t   * @param {Object} [context=root] The context object.\n\t   * @returns {Function} Returns a new `lodash` function.\n\t   * @example\n\t   *\n\t   * _.mixin({ 'foo': _.constant('foo') });\n\t   *\n\t   * var lodash = _.runInContext();\n\t   * lodash.mixin({ 'bar': lodash.constant('bar') });\n\t   *\n\t   * _.isFunction(_.foo);\n\t   * // => true\n\t   * _.isFunction(_.bar);\n\t   * // => false\n\t   *\n\t   * lodash.isFunction(lodash.foo);\n\t   * // => false\n\t   * lodash.isFunction(lodash.bar);\n\t   * // => true\n\t   *\n\t   * // Create a suped-up `defer` in Node.js.\n\t   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;\n\t   */\n\t  var runInContext = (function runInContext(context) {\n\t    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));\n\t\n\t    /** Built-in constructor references. */\n\t    var Array = context.Array,\n\t        Date = context.Date,\n\t        Error = context.Error,\n\t        Function = context.Function,\n\t        Math = context.Math,\n\t        Object = context.Object,\n\t        RegExp = context.RegExp,\n\t        String = context.String,\n\t        TypeError = context.TypeError;\n\t\n\t    /** Used for built-in method references. */\n\t    var arrayProto = Array.prototype,\n\t        funcProto = Function.prototype,\n\t        objectProto = Object.prototype;\n\t\n\t    /** Used to detect overreaching core-js shims. */\n\t    var coreJsData = context['__core-js_shared__'];\n\t\n\t    /** Used to resolve the decompiled source of functions. */\n\t    var funcToString = funcProto.toString;\n\t\n\t    /** Used to check objects for own properties. */\n\t    var hasOwnProperty = objectProto.hasOwnProperty;\n\t\n\t    /** Used to generate unique IDs. */\n\t    var idCounter = 0;\n\t\n\t    /** Used to detect methods masquerading as native. */\n\t    var maskSrcKey = (function() {\n\t      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n\t      return uid ? ('Symbol(src)_1.' + uid) : '';\n\t    }());\n\t\n\t    /**\n\t     * Used to resolve the\n\t     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n\t     * of values.\n\t     */\n\t    var nativeObjectToString = objectProto.toString;\n\t\n\t    /** Used to infer the `Object` constructor. */\n\t    var objectCtorString = funcToString.call(Object);\n\t\n\t    /** Used to restore the original `_` reference in `_.noConflict`. */\n\t    var oldDash = root._;\n\t\n\t    /** Used to detect if a method is native. */\n\t    var reIsNative = RegExp('^' +\n\t      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n\t      .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n\t    );\n\t\n\t    /** Built-in value references. */\n\t    var Buffer = moduleExports ? context.Buffer : undefined,\n\t        Symbol = context.Symbol,\n\t        Uint8Array = context.Uint8Array,\n\t        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,\n\t        getPrototype = overArg(Object.getPrototypeOf, Object),\n\t        objectCreate = Object.create,\n\t        propertyIsEnumerable = objectProto.propertyIsEnumerable,\n\t        splice = arrayProto.splice,\n\t        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,\n\t        symIterator = Symbol ? Symbol.iterator : undefined,\n\t        symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\t\n\t    var defineProperty = (function() {\n\t      try {\n\t        var func = getNative(Object, 'defineProperty');\n\t        func({}, '', {});\n\t        return func;\n\t      } catch (e) {}\n\t    }());\n\t\n\t    /** Mocked built-ins. */\n\t    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,\n\t        ctxNow = Date && Date.now !== root.Date.now && Date.now,\n\t        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;\n\t\n\t    /* Built-in method references for those with the same name as other `lodash` methods. */\n\t    var nativeCeil = Math.ceil,\n\t        nativeFloor = Math.floor,\n\t        nativeGetSymbols = Object.getOwnPropertySymbols,\n\t        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n\t        nativeIsFinite = context.isFinite,\n\t        nativeJoin = arrayProto.join,\n\t        nativeKeys = overArg(Object.keys, Object),\n\t        nativeMax = Math.max,\n\t        nativeMin = Math.min,\n\t        nativeNow = Date.now,\n\t        nativeParseInt = context.parseInt,\n\t        nativeRandom = Math.random,\n\t        nativeReverse = arrayProto.reverse;\n\t\n\t    /* Built-in method references that are verified to be native. */\n\t    var DataView = getNative(context, 'DataView'),\n\t        Map = getNative(context, 'Map'),\n\t        Promise = getNative(context, 'Promise'),\n\t        Set = getNative(context, 'Set'),\n\t        WeakMap = getNative(context, 'WeakMap'),\n\t        nativeCreate = getNative(Object, 'create');\n\t\n\t    /** Used to store function metadata. */\n\t    var metaMap = WeakMap && new WeakMap;\n\t\n\t    /** Used to lookup unminified function names. */\n\t    var realNames = {};\n\t\n\t    /** Used to detect maps, sets, and weakmaps. */\n\t    var dataViewCtorString = toSource(DataView),\n\t        mapCtorString = toSource(Map),\n\t        promiseCtorString = toSource(Promise),\n\t        setCtorString = toSource(Set),\n\t        weakMapCtorString = toSource(WeakMap);\n\t\n\t    /** Used to convert symbols to primitives and strings. */\n\t    var symbolProto = Symbol ? Symbol.prototype : undefined,\n\t        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n\t        symbolToString = symbolProto ? symbolProto.toString : undefined;\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Creates a `lodash` object which wraps `value` to enable implicit method\n\t     * chain sequences. Methods that operate on and return arrays, collections,\n\t     * and functions can be chained together. Methods that retrieve a single value\n\t     * or may return a primitive value will automatically end the chain sequence\n\t     * and return the unwrapped value. Otherwise, the value must be unwrapped\n\t     * with `_#value`.\n\t     *\n\t     * Explicit chain sequences, which must be unwrapped with `_#value`, may be\n\t     * enabled using `_.chain`.\n\t     *\n\t     * The execution of chained methods is lazy, that is, it's deferred until\n\t     * `_#value` is implicitly or explicitly called.\n\t     *\n\t     * Lazy evaluation allows several methods to support shortcut fusion.\n\t     * Shortcut fusion is an optimization to merge iteratee calls; this avoids\n\t     * the creation of intermediate arrays and can greatly reduce the number of\n\t     * iteratee executions. Sections of a chain sequence qualify for shortcut\n\t     * fusion if the section is applied to an array of at least `200` elements\n\t     * and any iteratees accept only one argument. The heuristic for whether a\n\t     * section qualifies for shortcut fusion is subject to change.\n\t     *\n\t     * Chaining is supported in custom builds as long as the `_#value` method is\n\t     * directly or indirectly included in the build.\n\t     *\n\t     * In addition to lodash methods, wrappers have `Array` and `String` methods.\n\t     *\n\t     * The wrapper `Array` methods are:\n\t     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`\n\t     *\n\t     * The wrapper `String` methods are:\n\t     * `replace` and `split`\n\t     *\n\t     * The wrapper methods that support shortcut fusion are:\n\t     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,\n\t     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,\n\t     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`\n\t     *\n\t     * The chainable wrapper methods are:\n\t     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,\n\t     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,\n\t     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,\n\t     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,\n\t     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,\n\t     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,\n\t     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,\n\t     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,\n\t     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,\n\t     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,\n\t     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,\n\t     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,\n\t     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,\n\t     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,\n\t     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,\n\t     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,\n\t     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,\n\t     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,\n\t     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,\n\t     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,\n\t     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,\n\t     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,\n\t     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,\n\t     * `zipObject`, `zipObjectDeep`, and `zipWith`\n\t     *\n\t     * The wrapper methods that are **not** chainable by default are:\n\t     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,\n\t     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,\n\t     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,\n\t     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,\n\t     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,\n\t     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,\n\t     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,\n\t     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,\n\t     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,\n\t     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,\n\t     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,\n\t     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,\n\t     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,\n\t     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,\n\t     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,\n\t     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,\n\t     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,\n\t     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,\n\t     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,\n\t     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,\n\t     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,\n\t     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,\n\t     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,\n\t     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,\n\t     * `upperFirst`, `value`, and `words`\n\t     *\n\t     * @name _\n\t     * @constructor\n\t     * @category Seq\n\t     * @param {*} value The value to wrap in a `lodash` instance.\n\t     * @returns {Object} Returns the new `lodash` wrapper instance.\n\t     * @example\n\t     *\n\t     * function square(n) {\n\t     *   return n * n;\n\t     * }\n\t     *\n\t     * var wrapped = _([1, 2, 3]);\n\t     *\n\t     * // Returns an unwrapped value.\n\t     * wrapped.reduce(_.add);\n\t     * // => 6\n\t     *\n\t     * // Returns a wrapped value.\n\t     * var squares = wrapped.map(square);\n\t     *\n\t     * _.isArray(squares);\n\t     * // => false\n\t     *\n\t     * _.isArray(squares.value());\n\t     * // => true\n\t     */\n\t    function lodash(value) {\n\t      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {\n\t        if (value instanceof LodashWrapper) {\n\t          return value;\n\t        }\n\t        if (hasOwnProperty.call(value, '__wrapped__')) {\n\t          return wrapperClone(value);\n\t        }\n\t      }\n\t      return new LodashWrapper(value);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.create` without support for assigning\n\t     * properties to the created object.\n\t     *\n\t     * @private\n\t     * @param {Object} proto The object to inherit from.\n\t     * @returns {Object} Returns the new object.\n\t     */\n\t    var baseCreate = (function() {\n\t      function object() {}\n\t      return function(proto) {\n\t        if (!isObject(proto)) {\n\t          return {};\n\t        }\n\t        if (objectCreate) {\n\t          return objectCreate(proto);\n\t        }\n\t        object.prototype = proto;\n\t        var result = new object;\n\t        object.prototype = undefined;\n\t        return result;\n\t      };\n\t    }());\n\t\n\t    /**\n\t     * The function whose prototype chain sequence wrappers inherit from.\n\t     *\n\t     * @private\n\t     */\n\t    function baseLodash() {\n\t      // No operation performed.\n\t    }\n\t\n\t    /**\n\t     * The base constructor for creating `lodash` wrapper objects.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to wrap.\n\t     * @param {boolean} [chainAll] Enable explicit method chain sequences.\n\t     */\n\t    function LodashWrapper(value, chainAll) {\n\t      this.__wrapped__ = value;\n\t      this.__actions__ = [];\n\t      this.__chain__ = !!chainAll;\n\t      this.__index__ = 0;\n\t      this.__values__ = undefined;\n\t    }\n\t\n\t    /**\n\t     * By default, the template delimiters used by lodash are like those in\n\t     * embedded Ruby (ERB). Change the following template settings to use\n\t     * alternative delimiters.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @type {Object}\n\t     */\n\t    lodash.templateSettings = {\n\t\n\t      /**\n\t       * Used to detect `data` property values to be HTML-escaped.\n\t       *\n\t       * @memberOf _.templateSettings\n\t       * @type {RegExp}\n\t       */\n\t      'escape': reEscape,\n\t\n\t      /**\n\t       * Used to detect code to be evaluated.\n\t       *\n\t       * @memberOf _.templateSettings\n\t       * @type {RegExp}\n\t       */\n\t      'evaluate': reEvaluate,\n\t\n\t      /**\n\t       * Used to detect `data` property values to inject.\n\t       *\n\t       * @memberOf _.templateSettings\n\t       * @type {RegExp}\n\t       */\n\t      'interpolate': reInterpolate,\n\t\n\t      /**\n\t       * Used to reference the data object in the template text.\n\t       *\n\t       * @memberOf _.templateSettings\n\t       * @type {string}\n\t       */\n\t      'variable': '',\n\t\n\t      /**\n\t       * Used to import variables into the compiled template.\n\t       *\n\t       * @memberOf _.templateSettings\n\t       * @type {Object}\n\t       */\n\t      'imports': {\n\t\n\t        /**\n\t         * A reference to the `lodash` function.\n\t         *\n\t         * @memberOf _.templateSettings.imports\n\t         * @type {Function}\n\t         */\n\t        '_': lodash\n\t      }\n\t    };\n\t\n\t    // Ensure wrappers are instances of `baseLodash`.\n\t    lodash.prototype = baseLodash.prototype;\n\t    lodash.prototype.constructor = lodash;\n\t\n\t    LodashWrapper.prototype = baseCreate(baseLodash.prototype);\n\t    LodashWrapper.prototype.constructor = LodashWrapper;\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.\n\t     *\n\t     * @private\n\t     * @constructor\n\t     * @param {*} value The value to wrap.\n\t     */\n\t    function LazyWrapper(value) {\n\t      this.__wrapped__ = value;\n\t      this.__actions__ = [];\n\t      this.__dir__ = 1;\n\t      this.__filtered__ = false;\n\t      this.__iteratees__ = [];\n\t      this.__takeCount__ = MAX_ARRAY_LENGTH;\n\t      this.__views__ = [];\n\t    }\n\t\n\t    /**\n\t     * Creates a clone of the lazy wrapper object.\n\t     *\n\t     * @private\n\t     * @name clone\n\t     * @memberOf LazyWrapper\n\t     * @returns {Object} Returns the cloned `LazyWrapper` object.\n\t     */\n\t    function lazyClone() {\n\t      var result = new LazyWrapper(this.__wrapped__);\n\t      result.__actions__ = copyArray(this.__actions__);\n\t      result.__dir__ = this.__dir__;\n\t      result.__filtered__ = this.__filtered__;\n\t      result.__iteratees__ = copyArray(this.__iteratees__);\n\t      result.__takeCount__ = this.__takeCount__;\n\t      result.__views__ = copyArray(this.__views__);\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Reverses the direction of lazy iteration.\n\t     *\n\t     * @private\n\t     * @name reverse\n\t     * @memberOf LazyWrapper\n\t     * @returns {Object} Returns the new reversed `LazyWrapper` object.\n\t     */\n\t    function lazyReverse() {\n\t      if (this.__filtered__) {\n\t        var result = new LazyWrapper(this);\n\t        result.__dir__ = -1;\n\t        result.__filtered__ = true;\n\t      } else {\n\t        result = this.clone();\n\t        result.__dir__ *= -1;\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Extracts the unwrapped value from its lazy wrapper.\n\t     *\n\t     * @private\n\t     * @name value\n\t     * @memberOf LazyWrapper\n\t     * @returns {*} Returns the unwrapped value.\n\t     */\n\t    function lazyValue() {\n\t      var array = this.__wrapped__.value(),\n\t          dir = this.__dir__,\n\t          isArr = isArray(array),\n\t          isRight = dir < 0,\n\t          arrLength = isArr ? array.length : 0,\n\t          view = getView(0, arrLength, this.__views__),\n\t          start = view.start,\n\t          end = view.end,\n\t          length = end - start,\n\t          index = isRight ? end : (start - 1),\n\t          iteratees = this.__iteratees__,\n\t          iterLength = iteratees.length,\n\t          resIndex = 0,\n\t          takeCount = nativeMin(length, this.__takeCount__);\n\t\n\t      if (!isArr || arrLength < LARGE_ARRAY_SIZE ||\n\t          (arrLength == length && takeCount == length)) {\n\t        return baseWrapperValue(array, this.__actions__);\n\t      }\n\t      var result = [];\n\t\n\t      outer:\n\t      while (length-- && resIndex < takeCount) {\n\t        index += dir;\n\t\n\t        var iterIndex = -1,\n\t            value = array[index];\n\t\n\t        while (++iterIndex < iterLength) {\n\t          var data = iteratees[iterIndex],\n\t              iteratee = data.iteratee,\n\t              type = data.type,\n\t              computed = iteratee(value);\n\t\n\t          if (type == LAZY_MAP_FLAG) {\n\t            value = computed;\n\t          } else if (!computed) {\n\t            if (type == LAZY_FILTER_FLAG) {\n\t              continue outer;\n\t            } else {\n\t              break outer;\n\t            }\n\t          }\n\t        }\n\t        result[resIndex++] = value;\n\t      }\n\t      return result;\n\t    }\n\t\n\t    // Ensure `LazyWrapper` is an instance of `baseLodash`.\n\t    LazyWrapper.prototype = baseCreate(baseLodash.prototype);\n\t    LazyWrapper.prototype.constructor = LazyWrapper;\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Creates a hash object.\n\t     *\n\t     * @private\n\t     * @constructor\n\t     * @param {Array} [entries] The key-value pairs to cache.\n\t     */\n\t    function Hash(entries) {\n\t      var index = -1,\n\t          length = entries == null ? 0 : entries.length;\n\t\n\t      this.clear();\n\t      while (++index < length) {\n\t        var entry = entries[index];\n\t        this.set(entry[0], entry[1]);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Removes all key-value entries from the hash.\n\t     *\n\t     * @private\n\t     * @name clear\n\t     * @memberOf Hash\n\t     */\n\t    function hashClear() {\n\t      this.__data__ = nativeCreate ? nativeCreate(null) : {};\n\t      this.size = 0;\n\t    }\n\t\n\t    /**\n\t     * Removes `key` and its value from the hash.\n\t     *\n\t     * @private\n\t     * @name delete\n\t     * @memberOf Hash\n\t     * @param {Object} hash The hash to modify.\n\t     * @param {string} key The key of the value to remove.\n\t     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n\t     */\n\t    function hashDelete(key) {\n\t      var result = this.has(key) && delete this.__data__[key];\n\t      this.size -= result ? 1 : 0;\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Gets the hash value for `key`.\n\t     *\n\t     * @private\n\t     * @name get\n\t     * @memberOf Hash\n\t     * @param {string} key The key of the value to get.\n\t     * @returns {*} Returns the entry value.\n\t     */\n\t    function hashGet(key) {\n\t      var data = this.__data__;\n\t      if (nativeCreate) {\n\t        var result = data[key];\n\t        return result === HASH_UNDEFINED ? undefined : result;\n\t      }\n\t      return hasOwnProperty.call(data, key) ? data[key] : undefined;\n\t    }\n\t\n\t    /**\n\t     * Checks if a hash value for `key` exists.\n\t     *\n\t     * @private\n\t     * @name has\n\t     * @memberOf Hash\n\t     * @param {string} key The key of the entry to check.\n\t     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t     */\n\t    function hashHas(key) {\n\t      var data = this.__data__;\n\t      return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n\t    }\n\t\n\t    /**\n\t     * Sets the hash `key` to `value`.\n\t     *\n\t     * @private\n\t     * @name set\n\t     * @memberOf Hash\n\t     * @param {string} key The key of the value to set.\n\t     * @param {*} value The value to set.\n\t     * @returns {Object} Returns the hash instance.\n\t     */\n\t    function hashSet(key, value) {\n\t      var data = this.__data__;\n\t      this.size += this.has(key) ? 0 : 1;\n\t      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n\t      return this;\n\t    }\n\t\n\t    // Add methods to `Hash`.\n\t    Hash.prototype.clear = hashClear;\n\t    Hash.prototype['delete'] = hashDelete;\n\t    Hash.prototype.get = hashGet;\n\t    Hash.prototype.has = hashHas;\n\t    Hash.prototype.set = hashSet;\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Creates an list cache object.\n\t     *\n\t     * @private\n\t     * @constructor\n\t     * @param {Array} [entries] The key-value pairs to cache.\n\t     */\n\t    function ListCache(entries) {\n\t      var index = -1,\n\t          length = entries == null ? 0 : entries.length;\n\t\n\t      this.clear();\n\t      while (++index < length) {\n\t        var entry = entries[index];\n\t        this.set(entry[0], entry[1]);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Removes all key-value entries from the list cache.\n\t     *\n\t     * @private\n\t     * @name clear\n\t     * @memberOf ListCache\n\t     */\n\t    function listCacheClear() {\n\t      this.__data__ = [];\n\t      this.size = 0;\n\t    }\n\t\n\t    /**\n\t     * Removes `key` and its value from the list cache.\n\t     *\n\t     * @private\n\t     * @name delete\n\t     * @memberOf ListCache\n\t     * @param {string} key The key of the value to remove.\n\t     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n\t     */\n\t    function listCacheDelete(key) {\n\t      var data = this.__data__,\n\t          index = assocIndexOf(data, key);\n\t\n\t      if (index < 0) {\n\t        return false;\n\t      }\n\t      var lastIndex = data.length - 1;\n\t      if (index == lastIndex) {\n\t        data.pop();\n\t      } else {\n\t        splice.call(data, index, 1);\n\t      }\n\t      --this.size;\n\t      return true;\n\t    }\n\t\n\t    /**\n\t     * Gets the list cache value for `key`.\n\t     *\n\t     * @private\n\t     * @name get\n\t     * @memberOf ListCache\n\t     * @param {string} key The key of the value to get.\n\t     * @returns {*} Returns the entry value.\n\t     */\n\t    function listCacheGet(key) {\n\t      var data = this.__data__,\n\t          index = assocIndexOf(data, key);\n\t\n\t      return index < 0 ? undefined : data[index][1];\n\t    }\n\t\n\t    /**\n\t     * Checks if a list cache value for `key` exists.\n\t     *\n\t     * @private\n\t     * @name has\n\t     * @memberOf ListCache\n\t     * @param {string} key The key of the entry to check.\n\t     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t     */\n\t    function listCacheHas(key) {\n\t      return assocIndexOf(this.__data__, key) > -1;\n\t    }\n\t\n\t    /**\n\t     * Sets the list cache `key` to `value`.\n\t     *\n\t     * @private\n\t     * @name set\n\t     * @memberOf ListCache\n\t     * @param {string} key The key of the value to set.\n\t     * @param {*} value The value to set.\n\t     * @returns {Object} Returns the list cache instance.\n\t     */\n\t    function listCacheSet(key, value) {\n\t      var data = this.__data__,\n\t          index = assocIndexOf(data, key);\n\t\n\t      if (index < 0) {\n\t        ++this.size;\n\t        data.push([key, value]);\n\t      } else {\n\t        data[index][1] = value;\n\t      }\n\t      return this;\n\t    }\n\t\n\t    // Add methods to `ListCache`.\n\t    ListCache.prototype.clear = listCacheClear;\n\t    ListCache.prototype['delete'] = listCacheDelete;\n\t    ListCache.prototype.get = listCacheGet;\n\t    ListCache.prototype.has = listCacheHas;\n\t    ListCache.prototype.set = listCacheSet;\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Creates a map cache object to store key-value pairs.\n\t     *\n\t     * @private\n\t     * @constructor\n\t     * @param {Array} [entries] The key-value pairs to cache.\n\t     */\n\t    function MapCache(entries) {\n\t      var index = -1,\n\t          length = entries == null ? 0 : entries.length;\n\t\n\t      this.clear();\n\t      while (++index < length) {\n\t        var entry = entries[index];\n\t        this.set(entry[0], entry[1]);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Removes all key-value entries from the map.\n\t     *\n\t     * @private\n\t     * @name clear\n\t     * @memberOf MapCache\n\t     */\n\t    function mapCacheClear() {\n\t      this.size = 0;\n\t      this.__data__ = {\n\t        'hash': new Hash,\n\t        'map': new (Map || ListCache),\n\t        'string': new Hash\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Removes `key` and its value from the map.\n\t     *\n\t     * @private\n\t     * @name delete\n\t     * @memberOf MapCache\n\t     * @param {string} key The key of the value to remove.\n\t     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n\t     */\n\t    function mapCacheDelete(key) {\n\t      var result = getMapData(this, key)['delete'](key);\n\t      this.size -= result ? 1 : 0;\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Gets the map value for `key`.\n\t     *\n\t     * @private\n\t     * @name get\n\t     * @memberOf MapCache\n\t     * @param {string} key The key of the value to get.\n\t     * @returns {*} Returns the entry value.\n\t     */\n\t    function mapCacheGet(key) {\n\t      return getMapData(this, key).get(key);\n\t    }\n\t\n\t    /**\n\t     * Checks if a map value for `key` exists.\n\t     *\n\t     * @private\n\t     * @name has\n\t     * @memberOf MapCache\n\t     * @param {string} key The key of the entry to check.\n\t     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t     */\n\t    function mapCacheHas(key) {\n\t      return getMapData(this, key).has(key);\n\t    }\n\t\n\t    /**\n\t     * Sets the map `key` to `value`.\n\t     *\n\t     * @private\n\t     * @name set\n\t     * @memberOf MapCache\n\t     * @param {string} key The key of the value to set.\n\t     * @param {*} value The value to set.\n\t     * @returns {Object} Returns the map cache instance.\n\t     */\n\t    function mapCacheSet(key, value) {\n\t      var data = getMapData(this, key),\n\t          size = data.size;\n\t\n\t      data.set(key, value);\n\t      this.size += data.size == size ? 0 : 1;\n\t      return this;\n\t    }\n\t\n\t    // Add methods to `MapCache`.\n\t    MapCache.prototype.clear = mapCacheClear;\n\t    MapCache.prototype['delete'] = mapCacheDelete;\n\t    MapCache.prototype.get = mapCacheGet;\n\t    MapCache.prototype.has = mapCacheHas;\n\t    MapCache.prototype.set = mapCacheSet;\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     *\n\t     * Creates an array cache object to store unique values.\n\t     *\n\t     * @private\n\t     * @constructor\n\t     * @param {Array} [values] The values to cache.\n\t     */\n\t    function SetCache(values) {\n\t      var index = -1,\n\t          length = values == null ? 0 : values.length;\n\t\n\t      this.__data__ = new MapCache;\n\t      while (++index < length) {\n\t        this.add(values[index]);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Adds `value` to the array cache.\n\t     *\n\t     * @private\n\t     * @name add\n\t     * @memberOf SetCache\n\t     * @alias push\n\t     * @param {*} value The value to cache.\n\t     * @returns {Object} Returns the cache instance.\n\t     */\n\t    function setCacheAdd(value) {\n\t      this.__data__.set(value, HASH_UNDEFINED);\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is in the array cache.\n\t     *\n\t     * @private\n\t     * @name has\n\t     * @memberOf SetCache\n\t     * @param {*} value The value to search for.\n\t     * @returns {number} Returns `true` if `value` is found, else `false`.\n\t     */\n\t    function setCacheHas(value) {\n\t      return this.__data__.has(value);\n\t    }\n\t\n\t    // Add methods to `SetCache`.\n\t    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\n\t    SetCache.prototype.has = setCacheHas;\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Creates a stack cache object to store key-value pairs.\n\t     *\n\t     * @private\n\t     * @constructor\n\t     * @param {Array} [entries] The key-value pairs to cache.\n\t     */\n\t    function Stack(entries) {\n\t      var data = this.__data__ = new ListCache(entries);\n\t      this.size = data.size;\n\t    }\n\t\n\t    /**\n\t     * Removes all key-value entries from the stack.\n\t     *\n\t     * @private\n\t     * @name clear\n\t     * @memberOf Stack\n\t     */\n\t    function stackClear() {\n\t      this.__data__ = new ListCache;\n\t      this.size = 0;\n\t    }\n\t\n\t    /**\n\t     * Removes `key` and its value from the stack.\n\t     *\n\t     * @private\n\t     * @name delete\n\t     * @memberOf Stack\n\t     * @param {string} key The key of the value to remove.\n\t     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n\t     */\n\t    function stackDelete(key) {\n\t      var data = this.__data__,\n\t          result = data['delete'](key);\n\t\n\t      this.size = data.size;\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Gets the stack value for `key`.\n\t     *\n\t     * @private\n\t     * @name get\n\t     * @memberOf Stack\n\t     * @param {string} key The key of the value to get.\n\t     * @returns {*} Returns the entry value.\n\t     */\n\t    function stackGet(key) {\n\t      return this.__data__.get(key);\n\t    }\n\t\n\t    /**\n\t     * Checks if a stack value for `key` exists.\n\t     *\n\t     * @private\n\t     * @name has\n\t     * @memberOf Stack\n\t     * @param {string} key The key of the entry to check.\n\t     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t     */\n\t    function stackHas(key) {\n\t      return this.__data__.has(key);\n\t    }\n\t\n\t    /**\n\t     * Sets the stack `key` to `value`.\n\t     *\n\t     * @private\n\t     * @name set\n\t     * @memberOf Stack\n\t     * @param {string} key The key of the value to set.\n\t     * @param {*} value The value to set.\n\t     * @returns {Object} Returns the stack cache instance.\n\t     */\n\t    function stackSet(key, value) {\n\t      var data = this.__data__;\n\t      if (data instanceof ListCache) {\n\t        var pairs = data.__data__;\n\t        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n\t          pairs.push([key, value]);\n\t          this.size = ++data.size;\n\t          return this;\n\t        }\n\t        data = this.__data__ = new MapCache(pairs);\n\t      }\n\t      data.set(key, value);\n\t      this.size = data.size;\n\t      return this;\n\t    }\n\t\n\t    // Add methods to `Stack`.\n\t    Stack.prototype.clear = stackClear;\n\t    Stack.prototype['delete'] = stackDelete;\n\t    Stack.prototype.get = stackGet;\n\t    Stack.prototype.has = stackHas;\n\t    Stack.prototype.set = stackSet;\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Creates an array of the enumerable property names of the array-like `value`.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to query.\n\t     * @param {boolean} inherited Specify returning inherited property names.\n\t     * @returns {Array} Returns the array of property names.\n\t     */\n\t    function arrayLikeKeys(value, inherited) {\n\t      var isArr = isArray(value),\n\t          isArg = !isArr && isArguments(value),\n\t          isBuff = !isArr && !isArg && isBuffer(value),\n\t          isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n\t          skipIndexes = isArr || isArg || isBuff || isType,\n\t          result = skipIndexes ? baseTimes(value.length, String) : [],\n\t          length = result.length;\n\t\n\t      for (var key in value) {\n\t        if ((inherited || hasOwnProperty.call(value, key)) &&\n\t            !(skipIndexes && (\n\t               // Safari 9 has enumerable `arguments.length` in strict mode.\n\t               key == 'length' ||\n\t               // Node.js 0.10 has enumerable non-index properties on buffers.\n\t               (isBuff && (key == 'offset' || key == 'parent')) ||\n\t               // PhantomJS 2 has enumerable non-index properties on typed arrays.\n\t               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n\t               // Skip index properties.\n\t               isIndex(key, length)\n\t            ))) {\n\t          result.push(key);\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `_.sample` for arrays.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to sample.\n\t     * @returns {*} Returns the random element.\n\t     */\n\t    function arraySample(array) {\n\t      var length = array.length;\n\t      return length ? array[baseRandom(0, length - 1)] : undefined;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `_.sampleSize` for arrays.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to sample.\n\t     * @param {number} n The number of elements to sample.\n\t     * @returns {Array} Returns the random elements.\n\t     */\n\t    function arraySampleSize(array, n) {\n\t      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `_.shuffle` for arrays.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to shuffle.\n\t     * @returns {Array} Returns the new shuffled array.\n\t     */\n\t    function arrayShuffle(array) {\n\t      return shuffleSelf(copyArray(array));\n\t    }\n\t\n\t    /**\n\t     * Used by `_.defaults` to customize its `_.assignIn` use.\n\t     *\n\t     * @private\n\t     * @param {*} objValue The destination value.\n\t     * @param {*} srcValue The source value.\n\t     * @param {string} key The key of the property to assign.\n\t     * @param {Object} object The parent object of `objValue`.\n\t     * @returns {*} Returns the value to assign.\n\t     */\n\t    function assignInDefaults(objValue, srcValue, key, object) {\n\t      if (objValue === undefined ||\n\t          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n\t        return srcValue;\n\t      }\n\t      return objValue;\n\t    }\n\t\n\t    /**\n\t     * This function is like `assignValue` except that it doesn't assign\n\t     * `undefined` values.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to modify.\n\t     * @param {string} key The key of the property to assign.\n\t     * @param {*} value The value to assign.\n\t     */\n\t    function assignMergeValue(object, key, value) {\n\t      if ((value !== undefined && !eq(object[key], value)) ||\n\t          (value === undefined && !(key in object))) {\n\t        baseAssignValue(object, key, value);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Assigns `value` to `key` of `object` if the existing value is not equivalent\n\t     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n\t     * for equality comparisons.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to modify.\n\t     * @param {string} key The key of the property to assign.\n\t     * @param {*} value The value to assign.\n\t     */\n\t    function assignValue(object, key, value) {\n\t      var objValue = object[key];\n\t      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n\t          (value === undefined && !(key in object))) {\n\t        baseAssignValue(object, key, value);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Gets the index at which the `key` is found in `array` of key-value pairs.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to inspect.\n\t     * @param {*} key The key to search for.\n\t     * @returns {number} Returns the index of the matched value, else `-1`.\n\t     */\n\t    function assocIndexOf(array, key) {\n\t      var length = array.length;\n\t      while (length--) {\n\t        if (eq(array[length][0], key)) {\n\t          return length;\n\t        }\n\t      }\n\t      return -1;\n\t    }\n\t\n\t    /**\n\t     * Aggregates elements of `collection` on `accumulator` with keys transformed\n\t     * by `iteratee` and values set by `setter`.\n\t     *\n\t     * @private\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function} setter The function to set `accumulator` values.\n\t     * @param {Function} iteratee The iteratee to transform keys.\n\t     * @param {Object} accumulator The initial aggregated object.\n\t     * @returns {Function} Returns `accumulator`.\n\t     */\n\t    function baseAggregator(collection, setter, iteratee, accumulator) {\n\t      baseEach(collection, function(value, key, collection) {\n\t        setter(accumulator, value, iteratee(value), collection);\n\t      });\n\t      return accumulator;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.assign` without support for multiple sources\n\t     * or `customizer` functions.\n\t     *\n\t     * @private\n\t     * @param {Object} object The destination object.\n\t     * @param {Object} source The source object.\n\t     * @returns {Object} Returns `object`.\n\t     */\n\t    function baseAssign(object, source) {\n\t      return object && copyObject(source, keys(source), object);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.assignIn` without support for multiple sources\n\t     * or `customizer` functions.\n\t     *\n\t     * @private\n\t     * @param {Object} object The destination object.\n\t     * @param {Object} source The source object.\n\t     * @returns {Object} Returns `object`.\n\t     */\n\t    function baseAssignIn(object, source) {\n\t      return object && copyObject(source, keysIn(source), object);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `assignValue` and `assignMergeValue` without\n\t     * value checks.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to modify.\n\t     * @param {string} key The key of the property to assign.\n\t     * @param {*} value The value to assign.\n\t     */\n\t    function baseAssignValue(object, key, value) {\n\t      if (key == '__proto__' && defineProperty) {\n\t        defineProperty(object, key, {\n\t          'configurable': true,\n\t          'enumerable': true,\n\t          'value': value,\n\t          'writable': true\n\t        });\n\t      } else {\n\t        object[key] = value;\n\t      }\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.at` without support for individual paths.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {string[]} paths The property paths to pick.\n\t     * @returns {Array} Returns the picked elements.\n\t     */\n\t    function baseAt(object, paths) {\n\t      var index = -1,\n\t          length = paths.length,\n\t          result = Array(length),\n\t          skip = object == null;\n\t\n\t      while (++index < length) {\n\t        result[index] = skip ? undefined : get(object, paths[index]);\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.clamp` which doesn't coerce arguments.\n\t     *\n\t     * @private\n\t     * @param {number} number The number to clamp.\n\t     * @param {number} [lower] The lower bound.\n\t     * @param {number} upper The upper bound.\n\t     * @returns {number} Returns the clamped number.\n\t     */\n\t    function baseClamp(number, lower, upper) {\n\t      if (number === number) {\n\t        if (upper !== undefined) {\n\t          number = number <= upper ? number : upper;\n\t        }\n\t        if (lower !== undefined) {\n\t          number = number >= lower ? number : lower;\n\t        }\n\t      }\n\t      return number;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n\t     * traversed objects.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to clone.\n\t     * @param {boolean} bitmask The bitmask flags.\n\t     *  1 - Deep clone\n\t     *  2 - Flatten inherited properties\n\t     *  4 - Clone symbols\n\t     * @param {Function} [customizer] The function to customize cloning.\n\t     * @param {string} [key] The key of `value`.\n\t     * @param {Object} [object] The parent object of `value`.\n\t     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n\t     * @returns {*} Returns the cloned value.\n\t     */\n\t    function baseClone(value, bitmask, customizer, key, object, stack) {\n\t      var result,\n\t          isDeep = bitmask & CLONE_DEEP_FLAG,\n\t          isFlat = bitmask & CLONE_FLAT_FLAG,\n\t          isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\t\n\t      if (customizer) {\n\t        result = object ? customizer(value, key, object, stack) : customizer(value);\n\t      }\n\t      if (result !== undefined) {\n\t        return result;\n\t      }\n\t      if (!isObject(value)) {\n\t        return value;\n\t      }\n\t      var isArr = isArray(value);\n\t      if (isArr) {\n\t        result = initCloneArray(value);\n\t        if (!isDeep) {\n\t          return copyArray(value, result);\n\t        }\n\t      } else {\n\t        var tag = getTag(value),\n\t            isFunc = tag == funcTag || tag == genTag;\n\t\n\t        if (isBuffer(value)) {\n\t          return cloneBuffer(value, isDeep);\n\t        }\n\t        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n\t          result = (isFlat || isFunc) ? {} : initCloneObject(value);\n\t          if (!isDeep) {\n\t            return isFlat\n\t              ? copySymbolsIn(value, baseAssignIn(result, value))\n\t              : copySymbols(value, baseAssign(result, value));\n\t          }\n\t        } else {\n\t          if (!cloneableTags[tag]) {\n\t            return object ? value : {};\n\t          }\n\t          result = initCloneByTag(value, tag, baseClone, isDeep);\n\t        }\n\t      }\n\t      // Check for circular references and return its corresponding clone.\n\t      stack || (stack = new Stack);\n\t      var stacked = stack.get(value);\n\t      if (stacked) {\n\t        return stacked;\n\t      }\n\t      stack.set(value, result);\n\t\n\t      var keysFunc = isFull\n\t        ? (isFlat ? getAllKeysIn : getAllKeys)\n\t        : (isFlat ? keysIn : keys);\n\t\n\t      var props = isArr ? undefined : keysFunc(value);\n\t      arrayEach(props || value, function(subValue, key) {\n\t        if (props) {\n\t          key = subValue;\n\t          subValue = value[key];\n\t        }\n\t        // Recursively populate clone (susceptible to call stack limits).\n\t        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n\t      });\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.conforms` which doesn't clone `source`.\n\t     *\n\t     * @private\n\t     * @param {Object} source The object of property predicates to conform to.\n\t     * @returns {Function} Returns the new spec function.\n\t     */\n\t    function baseConforms(source) {\n\t      var props = keys(source);\n\t      return function(object) {\n\t        return baseConformsTo(object, source, props);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.conformsTo` which accepts `props` to check.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to inspect.\n\t     * @param {Object} source The object of property predicates to conform to.\n\t     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n\t     */\n\t    function baseConformsTo(object, source, props) {\n\t      var length = props.length;\n\t      if (object == null) {\n\t        return !length;\n\t      }\n\t      object = Object(object);\n\t      while (length--) {\n\t        var key = props[length],\n\t            predicate = source[key],\n\t            value = object[key];\n\t\n\t        if ((value === undefined && !(key in object)) || !predicate(value)) {\n\t          return false;\n\t        }\n\t      }\n\t      return true;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.delay` and `_.defer` which accepts `args`\n\t     * to provide to `func`.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to delay.\n\t     * @param {number} wait The number of milliseconds to delay invocation.\n\t     * @param {Array} args The arguments to provide to `func`.\n\t     * @returns {number|Object} Returns the timer id or timeout object.\n\t     */\n\t    function baseDelay(func, wait, args) {\n\t      if (typeof func != 'function') {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      return setTimeout(function() { func.apply(undefined, args); }, wait);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of methods like `_.difference` without support\n\t     * for excluding multiple arrays or iteratee shorthands.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to inspect.\n\t     * @param {Array} values The values to exclude.\n\t     * @param {Function} [iteratee] The iteratee invoked per element.\n\t     * @param {Function} [comparator] The comparator invoked per element.\n\t     * @returns {Array} Returns the new array of filtered values.\n\t     */\n\t    function baseDifference(array, values, iteratee, comparator) {\n\t      var index = -1,\n\t          includes = arrayIncludes,\n\t          isCommon = true,\n\t          length = array.length,\n\t          result = [],\n\t          valuesLength = values.length;\n\t\n\t      if (!length) {\n\t        return result;\n\t      }\n\t      if (iteratee) {\n\t        values = arrayMap(values, baseUnary(iteratee));\n\t      }\n\t      if (comparator) {\n\t        includes = arrayIncludesWith;\n\t        isCommon = false;\n\t      }\n\t      else if (values.length >= LARGE_ARRAY_SIZE) {\n\t        includes = cacheHas;\n\t        isCommon = false;\n\t        values = new SetCache(values);\n\t      }\n\t      outer:\n\t      while (++index < length) {\n\t        var value = array[index],\n\t            computed = iteratee == null ? value : iteratee(value);\n\t\n\t        value = (comparator || value !== 0) ? value : 0;\n\t        if (isCommon && computed === computed) {\n\t          var valuesIndex = valuesLength;\n\t          while (valuesIndex--) {\n\t            if (values[valuesIndex] === computed) {\n\t              continue outer;\n\t            }\n\t          }\n\t          result.push(value);\n\t        }\n\t        else if (!includes(values, computed, comparator)) {\n\t          result.push(value);\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.forEach` without support for iteratee shorthands.\n\t     *\n\t     * @private\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @returns {Array|Object} Returns `collection`.\n\t     */\n\t    var baseEach = createBaseEach(baseForOwn);\n\t\n\t    /**\n\t     * The base implementation of `_.forEachRight` without support for iteratee shorthands.\n\t     *\n\t     * @private\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @returns {Array|Object} Returns `collection`.\n\t     */\n\t    var baseEachRight = createBaseEach(baseForOwnRight, true);\n\t\n\t    /**\n\t     * The base implementation of `_.every` without support for iteratee shorthands.\n\t     *\n\t     * @private\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function} predicate The function invoked per iteration.\n\t     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n\t     *  else `false`\n\t     */\n\t    function baseEvery(collection, predicate) {\n\t      var result = true;\n\t      baseEach(collection, function(value, index, collection) {\n\t        result = !!predicate(value, index, collection);\n\t        return result;\n\t      });\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of methods like `_.max` and `_.min` which accepts a\n\t     * `comparator` to determine the extremum value.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to iterate over.\n\t     * @param {Function} iteratee The iteratee invoked per iteration.\n\t     * @param {Function} comparator The comparator used to compare values.\n\t     * @returns {*} Returns the extremum value.\n\t     */\n\t    function baseExtremum(array, iteratee, comparator) {\n\t      var index = -1,\n\t          length = array.length;\n\t\n\t      while (++index < length) {\n\t        var value = array[index],\n\t            current = iteratee(value);\n\t\n\t        if (current != null && (computed === undefined\n\t              ? (current === current && !isSymbol(current))\n\t              : comparator(current, computed)\n\t            )) {\n\t          var computed = current,\n\t              result = value;\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.fill` without an iteratee call guard.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to fill.\n\t     * @param {*} value The value to fill `array` with.\n\t     * @param {number} [start=0] The start position.\n\t     * @param {number} [end=array.length] The end position.\n\t     * @returns {Array} Returns `array`.\n\t     */\n\t    function baseFill(array, value, start, end) {\n\t      var length = array.length;\n\t\n\t      start = toInteger(start);\n\t      if (start < 0) {\n\t        start = -start > length ? 0 : (length + start);\n\t      }\n\t      end = (end === undefined || end > length) ? length : toInteger(end);\n\t      if (end < 0) {\n\t        end += length;\n\t      }\n\t      end = start > end ? 0 : toLength(end);\n\t      while (start < end) {\n\t        array[start++] = value;\n\t      }\n\t      return array;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.filter` without support for iteratee shorthands.\n\t     *\n\t     * @private\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function} predicate The function invoked per iteration.\n\t     * @returns {Array} Returns the new filtered array.\n\t     */\n\t    function baseFilter(collection, predicate) {\n\t      var result = [];\n\t      baseEach(collection, function(value, index, collection) {\n\t        if (predicate(value, index, collection)) {\n\t          result.push(value);\n\t        }\n\t      });\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.flatten` with support for restricting flattening.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to flatten.\n\t     * @param {number} depth The maximum recursion depth.\n\t     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n\t     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n\t     * @param {Array} [result=[]] The initial result value.\n\t     * @returns {Array} Returns the new flattened array.\n\t     */\n\t    function baseFlatten(array, depth, predicate, isStrict, result) {\n\t      var index = -1,\n\t          length = array.length;\n\t\n\t      predicate || (predicate = isFlattenable);\n\t      result || (result = []);\n\t\n\t      while (++index < length) {\n\t        var value = array[index];\n\t        if (depth > 0 && predicate(value)) {\n\t          if (depth > 1) {\n\t            // Recursively flatten arrays (susceptible to call stack limits).\n\t            baseFlatten(value, depth - 1, predicate, isStrict, result);\n\t          } else {\n\t            arrayPush(result, value);\n\t          }\n\t        } else if (!isStrict) {\n\t          result[result.length] = value;\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `baseForOwn` which iterates over `object`\n\t     * properties returned by `keysFunc` and invokes `iteratee` for each property.\n\t     * Iteratee functions may exit iteration early by explicitly returning `false`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @param {Function} keysFunc The function to get the keys of `object`.\n\t     * @returns {Object} Returns `object`.\n\t     */\n\t    var baseFor = createBaseFor();\n\t\n\t    /**\n\t     * This function is like `baseFor` except that it iterates over properties\n\t     * in the opposite order.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @param {Function} keysFunc The function to get the keys of `object`.\n\t     * @returns {Object} Returns `object`.\n\t     */\n\t    var baseForRight = createBaseFor(true);\n\t\n\t    /**\n\t     * The base implementation of `_.forOwn` without support for iteratee shorthands.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @returns {Object} Returns `object`.\n\t     */\n\t    function baseForOwn(object, iteratee) {\n\t      return object && baseFor(object, iteratee, keys);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @returns {Object} Returns `object`.\n\t     */\n\t    function baseForOwnRight(object, iteratee) {\n\t      return object && baseForRight(object, iteratee, keys);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.functions` which creates an array of\n\t     * `object` function property names filtered from `props`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to inspect.\n\t     * @param {Array} props The property names to filter.\n\t     * @returns {Array} Returns the function names.\n\t     */\n\t    function baseFunctions(object, props) {\n\t      return arrayFilter(props, function(key) {\n\t        return isFunction(object[key]);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.get` without support for default values.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to query.\n\t     * @param {Array|string} path The path of the property to get.\n\t     * @returns {*} Returns the resolved value.\n\t     */\n\t    function baseGet(object, path) {\n\t      path = castPath(path, object);\n\t\n\t      var index = 0,\n\t          length = path.length;\n\t\n\t      while (object != null && index < length) {\n\t        object = object[toKey(path[index++])];\n\t      }\n\t      return (index && index == length) ? object : undefined;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n\t     * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n\t     * symbols of `object`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to query.\n\t     * @param {Function} keysFunc The function to get the keys of `object`.\n\t     * @param {Function} symbolsFunc The function to get the symbols of `object`.\n\t     * @returns {Array} Returns the array of property names and symbols.\n\t     */\n\t    function baseGetAllKeys(object, keysFunc, symbolsFunc) {\n\t      var result = keysFunc(object);\n\t      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `getTag` without fallbacks for buggy environments.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to query.\n\t     * @returns {string} Returns the `toStringTag`.\n\t     */\n\t    function baseGetTag(value) {\n\t      if (value == null) {\n\t        return value === undefined ? undefinedTag : nullTag;\n\t      }\n\t      value = Object(value);\n\t      return (symToStringTag && symToStringTag in value)\n\t        ? getRawTag(value)\n\t        : objectToString(value);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.gt` which doesn't coerce arguments.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to compare.\n\t     * @param {*} other The other value to compare.\n\t     * @returns {boolean} Returns `true` if `value` is greater than `other`,\n\t     *  else `false`.\n\t     */\n\t    function baseGt(value, other) {\n\t      return value > other;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.has` without support for deep paths.\n\t     *\n\t     * @private\n\t     * @param {Object} [object] The object to query.\n\t     * @param {Array|string} key The key to check.\n\t     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n\t     */\n\t    function baseHas(object, key) {\n\t      return object != null && hasOwnProperty.call(object, key);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.hasIn` without support for deep paths.\n\t     *\n\t     * @private\n\t     * @param {Object} [object] The object to query.\n\t     * @param {Array|string} key The key to check.\n\t     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n\t     */\n\t    function baseHasIn(object, key) {\n\t      return object != null && key in Object(object);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.inRange` which doesn't coerce arguments.\n\t     *\n\t     * @private\n\t     * @param {number} number The number to check.\n\t     * @param {number} start The start of the range.\n\t     * @param {number} end The end of the range.\n\t     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n\t     */\n\t    function baseInRange(number, start, end) {\n\t      return number >= nativeMin(start, end) && number < nativeMax(start, end);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of methods like `_.intersection`, without support\n\t     * for iteratee shorthands, that accepts an array of arrays to inspect.\n\t     *\n\t     * @private\n\t     * @param {Array} arrays The arrays to inspect.\n\t     * @param {Function} [iteratee] The iteratee invoked per element.\n\t     * @param {Function} [comparator] The comparator invoked per element.\n\t     * @returns {Array} Returns the new array of shared values.\n\t     */\n\t    function baseIntersection(arrays, iteratee, comparator) {\n\t      var includes = comparator ? arrayIncludesWith : arrayIncludes,\n\t          length = arrays[0].length,\n\t          othLength = arrays.length,\n\t          othIndex = othLength,\n\t          caches = Array(othLength),\n\t          maxLength = Infinity,\n\t          result = [];\n\t\n\t      while (othIndex--) {\n\t        var array = arrays[othIndex];\n\t        if (othIndex && iteratee) {\n\t          array = arrayMap(array, baseUnary(iteratee));\n\t        }\n\t        maxLength = nativeMin(array.length, maxLength);\n\t        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))\n\t          ? new SetCache(othIndex && array)\n\t          : undefined;\n\t      }\n\t      array = arrays[0];\n\t\n\t      var index = -1,\n\t          seen = caches[0];\n\t\n\t      outer:\n\t      while (++index < length && result.length < maxLength) {\n\t        var value = array[index],\n\t            computed = iteratee ? iteratee(value) : value;\n\t\n\t        value = (comparator || value !== 0) ? value : 0;\n\t        if (!(seen\n\t              ? cacheHas(seen, computed)\n\t              : includes(result, computed, comparator)\n\t            )) {\n\t          othIndex = othLength;\n\t          while (--othIndex) {\n\t            var cache = caches[othIndex];\n\t            if (!(cache\n\t                  ? cacheHas(cache, computed)\n\t                  : includes(arrays[othIndex], computed, comparator))\n\t                ) {\n\t              continue outer;\n\t            }\n\t          }\n\t          if (seen) {\n\t            seen.push(computed);\n\t          }\n\t          result.push(value);\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.invert` and `_.invertBy` which inverts\n\t     * `object` with values transformed by `iteratee` and set by `setter`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} setter The function to set `accumulator` values.\n\t     * @param {Function} iteratee The iteratee to transform values.\n\t     * @param {Object} accumulator The initial inverted object.\n\t     * @returns {Function} Returns `accumulator`.\n\t     */\n\t    function baseInverter(object, setter, iteratee, accumulator) {\n\t      baseForOwn(object, function(value, key, object) {\n\t        setter(accumulator, iteratee(value), key, object);\n\t      });\n\t      return accumulator;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.invoke` without support for individual\n\t     * method arguments.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to query.\n\t     * @param {Array|string} path The path of the method to invoke.\n\t     * @param {Array} args The arguments to invoke the method with.\n\t     * @returns {*} Returns the result of the invoked method.\n\t     */\n\t    function baseInvoke(object, path, args) {\n\t      path = castPath(path, object);\n\t      object = parent(object, path);\n\t      var func = object == null ? object : object[toKey(last(path))];\n\t      return func == null ? undefined : apply(func, object, args);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.isArguments`.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n\t     */\n\t    function baseIsArguments(value) {\n\t      return isObjectLike(value) && baseGetTag(value) == argsTag;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n\t     */\n\t    function baseIsArrayBuffer(value) {\n\t      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.isDate` without Node.js optimizations.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n\t     */\n\t    function baseIsDate(value) {\n\t      return isObjectLike(value) && baseGetTag(value) == dateTag;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.isEqual` which supports partial comparisons\n\t     * and tracks traversed objects.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to compare.\n\t     * @param {*} other The other value to compare.\n\t     * @param {boolean} bitmask The bitmask flags.\n\t     *  1 - Unordered comparison\n\t     *  2 - Partial comparison\n\t     * @param {Function} [customizer] The function to customize comparisons.\n\t     * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n\t     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n\t     */\n\t    function baseIsEqual(value, other, bitmask, customizer, stack) {\n\t      if (value === other) {\n\t        return true;\n\t      }\n\t      if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {\n\t        return value !== value && other !== other;\n\t      }\n\t      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `baseIsEqual` for arrays and objects which performs\n\t     * deep comparisons and tracks traversed objects enabling objects with circular\n\t     * references to be compared.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to compare.\n\t     * @param {Object} other The other object to compare.\n\t     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n\t     * @param {Function} customizer The function to customize comparisons.\n\t     * @param {Function} equalFunc The function to determine equivalents of values.\n\t     * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n\t     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n\t     */\n\t    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n\t      var objIsArr = isArray(object),\n\t          othIsArr = isArray(other),\n\t          objTag = arrayTag,\n\t          othTag = arrayTag;\n\t\n\t      if (!objIsArr) {\n\t        objTag = getTag(object);\n\t        objTag = objTag == argsTag ? objectTag : objTag;\n\t      }\n\t      if (!othIsArr) {\n\t        othTag = getTag(other);\n\t        othTag = othTag == argsTag ? objectTag : othTag;\n\t      }\n\t      var objIsObj = objTag == objectTag,\n\t          othIsObj = othTag == objectTag,\n\t          isSameTag = objTag == othTag;\n\t\n\t      if (isSameTag && isBuffer(object)) {\n\t        if (!isBuffer(other)) {\n\t          return false;\n\t        }\n\t        objIsArr = true;\n\t        objIsObj = false;\n\t      }\n\t      if (isSameTag && !objIsObj) {\n\t        stack || (stack = new Stack);\n\t        return (objIsArr || isTypedArray(object))\n\t          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n\t          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n\t      }\n\t      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n\t        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n\t            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\t\n\t        if (objIsWrapped || othIsWrapped) {\n\t          var objUnwrapped = objIsWrapped ? object.value() : object,\n\t              othUnwrapped = othIsWrapped ? other.value() : other;\n\t\n\t          stack || (stack = new Stack);\n\t          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n\t        }\n\t      }\n\t      if (!isSameTag) {\n\t        return false;\n\t      }\n\t      stack || (stack = new Stack);\n\t      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.isMap` without Node.js optimizations.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n\t     */\n\t    function baseIsMap(value) {\n\t      return isObjectLike(value) && getTag(value) == mapTag;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.isMatch` without support for iteratee shorthands.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to inspect.\n\t     * @param {Object} source The object of property values to match.\n\t     * @param {Array} matchData The property names, values, and compare flags to match.\n\t     * @param {Function} [customizer] The function to customize comparisons.\n\t     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n\t     */\n\t    function baseIsMatch(object, source, matchData, customizer) {\n\t      var index = matchData.length,\n\t          length = index,\n\t          noCustomizer = !customizer;\n\t\n\t      if (object == null) {\n\t        return !length;\n\t      }\n\t      object = Object(object);\n\t      while (index--) {\n\t        var data = matchData[index];\n\t        if ((noCustomizer && data[2])\n\t              ? data[1] !== object[data[0]]\n\t              : !(data[0] in object)\n\t            ) {\n\t          return false;\n\t        }\n\t      }\n\t      while (++index < length) {\n\t        data = matchData[index];\n\t        var key = data[0],\n\t            objValue = object[key],\n\t            srcValue = data[1];\n\t\n\t        if (noCustomizer && data[2]) {\n\t          if (objValue === undefined && !(key in object)) {\n\t            return false;\n\t          }\n\t        } else {\n\t          var stack = new Stack;\n\t          if (customizer) {\n\t            var result = customizer(objValue, srcValue, key, object, source, stack);\n\t          }\n\t          if (!(result === undefined\n\t                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n\t                : result\n\t              )) {\n\t            return false;\n\t          }\n\t        }\n\t      }\n\t      return true;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.isNative` without bad shim checks.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a native function,\n\t     *  else `false`.\n\t     */\n\t    function baseIsNative(value) {\n\t      if (!isObject(value) || isMasked(value)) {\n\t        return false;\n\t      }\n\t      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n\t      return pattern.test(toSource(value));\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.isRegExp` without Node.js optimizations.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n\t     */\n\t    function baseIsRegExp(value) {\n\t      return isObjectLike(value) && baseGetTag(value) == regexpTag;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.isSet` without Node.js optimizations.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n\t     */\n\t    function baseIsSet(value) {\n\t      return isObjectLike(value) && getTag(value) == setTag;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.isTypedArray` without Node.js optimizations.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n\t     */\n\t    function baseIsTypedArray(value) {\n\t      return isObjectLike(value) &&\n\t        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.iteratee`.\n\t     *\n\t     * @private\n\t     * @param {*} [value=_.identity] The value to convert to an iteratee.\n\t     * @returns {Function} Returns the iteratee.\n\t     */\n\t    function baseIteratee(value) {\n\t      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n\t      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n\t      if (typeof value == 'function') {\n\t        return value;\n\t      }\n\t      if (value == null) {\n\t        return identity;\n\t      }\n\t      if (typeof value == 'object') {\n\t        return isArray(value)\n\t          ? baseMatchesProperty(value[0], value[1])\n\t          : baseMatches(value);\n\t      }\n\t      return property(value);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to query.\n\t     * @returns {Array} Returns the array of property names.\n\t     */\n\t    function baseKeys(object) {\n\t      if (!isPrototype(object)) {\n\t        return nativeKeys(object);\n\t      }\n\t      var result = [];\n\t      for (var key in Object(object)) {\n\t        if (hasOwnProperty.call(object, key) && key != 'constructor') {\n\t          result.push(key);\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to query.\n\t     * @returns {Array} Returns the array of property names.\n\t     */\n\t    function baseKeysIn(object) {\n\t      if (!isObject(object)) {\n\t        return nativeKeysIn(object);\n\t      }\n\t      var isProto = isPrototype(object),\n\t          result = [];\n\t\n\t      for (var key in object) {\n\t        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n\t          result.push(key);\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.lt` which doesn't coerce arguments.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to compare.\n\t     * @param {*} other The other value to compare.\n\t     * @returns {boolean} Returns `true` if `value` is less than `other`,\n\t     *  else `false`.\n\t     */\n\t    function baseLt(value, other) {\n\t      return value < other;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.map` without support for iteratee shorthands.\n\t     *\n\t     * @private\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @returns {Array} Returns the new mapped array.\n\t     */\n\t    function baseMap(collection, iteratee) {\n\t      var index = -1,\n\t          result = isArrayLike(collection) ? Array(collection.length) : [];\n\t\n\t      baseEach(collection, function(value, key, collection) {\n\t        result[++index] = iteratee(value, key, collection);\n\t      });\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.matches` which doesn't clone `source`.\n\t     *\n\t     * @private\n\t     * @param {Object} source The object of property values to match.\n\t     * @returns {Function} Returns the new spec function.\n\t     */\n\t    function baseMatches(source) {\n\t      var matchData = getMatchData(source);\n\t      if (matchData.length == 1 && matchData[0][2]) {\n\t        return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n\t      }\n\t      return function(object) {\n\t        return object === source || baseIsMatch(object, source, matchData);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n\t     *\n\t     * @private\n\t     * @param {string} path The path of the property to get.\n\t     * @param {*} srcValue The value to match.\n\t     * @returns {Function} Returns the new spec function.\n\t     */\n\t    function baseMatchesProperty(path, srcValue) {\n\t      if (isKey(path) && isStrictComparable(srcValue)) {\n\t        return matchesStrictComparable(toKey(path), srcValue);\n\t      }\n\t      return function(object) {\n\t        var objValue = get(object, path);\n\t        return (objValue === undefined && objValue === srcValue)\n\t          ? hasIn(object, path)\n\t          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.merge` without support for multiple sources.\n\t     *\n\t     * @private\n\t     * @param {Object} object The destination object.\n\t     * @param {Object} source The source object.\n\t     * @param {number} srcIndex The index of `source`.\n\t     * @param {Function} [customizer] The function to customize merged values.\n\t     * @param {Object} [stack] Tracks traversed source values and their merged\n\t     *  counterparts.\n\t     */\n\t    function baseMerge(object, source, srcIndex, customizer, stack) {\n\t      if (object === source) {\n\t        return;\n\t      }\n\t      baseFor(source, function(srcValue, key) {\n\t        if (isObject(srcValue)) {\n\t          stack || (stack = new Stack);\n\t          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n\t        }\n\t        else {\n\t          var newValue = customizer\n\t            ? customizer(object[key], srcValue, (key + ''), object, source, stack)\n\t            : undefined;\n\t\n\t          if (newValue === undefined) {\n\t            newValue = srcValue;\n\t          }\n\t          assignMergeValue(object, key, newValue);\n\t        }\n\t      }, keysIn);\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `baseMerge` for arrays and objects which performs\n\t     * deep merges and tracks traversed objects enabling objects with circular\n\t     * references to be merged.\n\t     *\n\t     * @private\n\t     * @param {Object} object The destination object.\n\t     * @param {Object} source The source object.\n\t     * @param {string} key The key of the value to merge.\n\t     * @param {number} srcIndex The index of `source`.\n\t     * @param {Function} mergeFunc The function to merge values.\n\t     * @param {Function} [customizer] The function to customize assigned values.\n\t     * @param {Object} [stack] Tracks traversed source values and their merged\n\t     *  counterparts.\n\t     */\n\t    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n\t      var objValue = object[key],\n\t          srcValue = source[key],\n\t          stacked = stack.get(srcValue);\n\t\n\t      if (stacked) {\n\t        assignMergeValue(object, key, stacked);\n\t        return;\n\t      }\n\t      var newValue = customizer\n\t        ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n\t        : undefined;\n\t\n\t      var isCommon = newValue === undefined;\n\t\n\t      if (isCommon) {\n\t        var isArr = isArray(srcValue),\n\t            isBuff = !isArr && isBuffer(srcValue),\n\t            isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n\t\n\t        newValue = srcValue;\n\t        if (isArr || isBuff || isTyped) {\n\t          if (isArray(objValue)) {\n\t            newValue = objValue;\n\t          }\n\t          else if (isArrayLikeObject(objValue)) {\n\t            newValue = copyArray(objValue);\n\t          }\n\t          else if (isBuff) {\n\t            isCommon = false;\n\t            newValue = cloneBuffer(srcValue, true);\n\t          }\n\t          else if (isTyped) {\n\t            isCommon = false;\n\t            newValue = cloneTypedArray(srcValue, true);\n\t          }\n\t          else {\n\t            newValue = [];\n\t          }\n\t        }\n\t        else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n\t          newValue = objValue;\n\t          if (isArguments(objValue)) {\n\t            newValue = toPlainObject(objValue);\n\t          }\n\t          else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {\n\t            newValue = initCloneObject(srcValue);\n\t          }\n\t        }\n\t        else {\n\t          isCommon = false;\n\t        }\n\t      }\n\t      if (isCommon) {\n\t        // Recursively merge objects and arrays (susceptible to call stack limits).\n\t        stack.set(srcValue, newValue);\n\t        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n\t        stack['delete'](srcValue);\n\t      }\n\t      assignMergeValue(object, key, newValue);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.nth` which doesn't coerce arguments.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to query.\n\t     * @param {number} n The index of the element to return.\n\t     * @returns {*} Returns the nth element of `array`.\n\t     */\n\t    function baseNth(array, n) {\n\t      var length = array.length;\n\t      if (!length) {\n\t        return;\n\t      }\n\t      n += n < 0 ? length : 0;\n\t      return isIndex(n, length) ? array[n] : undefined;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.orderBy` without param guards.\n\t     *\n\t     * @private\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n\t     * @param {string[]} orders The sort orders of `iteratees`.\n\t     * @returns {Array} Returns the new sorted array.\n\t     */\n\t    function baseOrderBy(collection, iteratees, orders) {\n\t      var index = -1;\n\t      iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));\n\t\n\t      var result = baseMap(collection, function(value, key, collection) {\n\t        var criteria = arrayMap(iteratees, function(iteratee) {\n\t          return iteratee(value);\n\t        });\n\t        return { 'criteria': criteria, 'index': ++index, 'value': value };\n\t      });\n\t\n\t      return baseSortBy(result, function(object, other) {\n\t        return compareMultiple(object, other, orders);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.pick` without support for individual\n\t     * property identifiers.\n\t     *\n\t     * @private\n\t     * @param {Object} object The source object.\n\t     * @param {string[]} paths The property paths to pick.\n\t     * @returns {Object} Returns the new object.\n\t     */\n\t    function basePick(object, paths) {\n\t      object = Object(object);\n\t      return basePickBy(object, paths, function(value, path) {\n\t        return hasIn(object, path);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * The base implementation of  `_.pickBy` without support for iteratee shorthands.\n\t     *\n\t     * @private\n\t     * @param {Object} object The source object.\n\t     * @param {string[]} paths The property paths to pick.\n\t     * @param {Function} predicate The function invoked per property.\n\t     * @returns {Object} Returns the new object.\n\t     */\n\t    function basePickBy(object, paths, predicate) {\n\t      var index = -1,\n\t          length = paths.length,\n\t          result = {};\n\t\n\t      while (++index < length) {\n\t        var path = paths[index],\n\t            value = baseGet(object, path);\n\t\n\t        if (predicate(value, path)) {\n\t          baseSet(result, castPath(path, object), value);\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `baseProperty` which supports deep paths.\n\t     *\n\t     * @private\n\t     * @param {Array|string} path The path of the property to get.\n\t     * @returns {Function} Returns the new accessor function.\n\t     */\n\t    function basePropertyDeep(path) {\n\t      return function(object) {\n\t        return baseGet(object, path);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.pullAllBy` without support for iteratee\n\t     * shorthands.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to modify.\n\t     * @param {Array} values The values to remove.\n\t     * @param {Function} [iteratee] The iteratee invoked per element.\n\t     * @param {Function} [comparator] The comparator invoked per element.\n\t     * @returns {Array} Returns `array`.\n\t     */\n\t    function basePullAll(array, values, iteratee, comparator) {\n\t      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,\n\t          index = -1,\n\t          length = values.length,\n\t          seen = array;\n\t\n\t      if (array === values) {\n\t        values = copyArray(values);\n\t      }\n\t      if (iteratee) {\n\t        seen = arrayMap(array, baseUnary(iteratee));\n\t      }\n\t      while (++index < length) {\n\t        var fromIndex = 0,\n\t            value = values[index],\n\t            computed = iteratee ? iteratee(value) : value;\n\t\n\t        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {\n\t          if (seen !== array) {\n\t            splice.call(seen, fromIndex, 1);\n\t          }\n\t          splice.call(array, fromIndex, 1);\n\t        }\n\t      }\n\t      return array;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.pullAt` without support for individual\n\t     * indexes or capturing the removed elements.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to modify.\n\t     * @param {number[]} indexes The indexes of elements to remove.\n\t     * @returns {Array} Returns `array`.\n\t     */\n\t    function basePullAt(array, indexes) {\n\t      var length = array ? indexes.length : 0,\n\t          lastIndex = length - 1;\n\t\n\t      while (length--) {\n\t        var index = indexes[length];\n\t        if (length == lastIndex || index !== previous) {\n\t          var previous = index;\n\t          if (isIndex(index)) {\n\t            splice.call(array, index, 1);\n\t          } else {\n\t            baseUnset(array, index);\n\t          }\n\t        }\n\t      }\n\t      return array;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.random` without support for returning\n\t     * floating-point numbers.\n\t     *\n\t     * @private\n\t     * @param {number} lower The lower bound.\n\t     * @param {number} upper The upper bound.\n\t     * @returns {number} Returns the random number.\n\t     */\n\t    function baseRandom(lower, upper) {\n\t      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.range` and `_.rangeRight` which doesn't\n\t     * coerce arguments.\n\t     *\n\t     * @private\n\t     * @param {number} start The start of the range.\n\t     * @param {number} end The end of the range.\n\t     * @param {number} step The value to increment or decrement by.\n\t     * @param {boolean} [fromRight] Specify iterating from right to left.\n\t     * @returns {Array} Returns the range of numbers.\n\t     */\n\t    function baseRange(start, end, step, fromRight) {\n\t      var index = -1,\n\t          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n\t          result = Array(length);\n\t\n\t      while (length--) {\n\t        result[fromRight ? length : ++index] = start;\n\t        start += step;\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.repeat` which doesn't coerce arguments.\n\t     *\n\t     * @private\n\t     * @param {string} string The string to repeat.\n\t     * @param {number} n The number of times to repeat the string.\n\t     * @returns {string} Returns the repeated string.\n\t     */\n\t    function baseRepeat(string, n) {\n\t      var result = '';\n\t      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {\n\t        return result;\n\t      }\n\t      // Leverage the exponentiation by squaring algorithm for a faster repeat.\n\t      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.\n\t      do {\n\t        if (n % 2) {\n\t          result += string;\n\t        }\n\t        n = nativeFloor(n / 2);\n\t        if (n) {\n\t          string += string;\n\t        }\n\t      } while (n);\n\t\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to apply a rest parameter to.\n\t     * @param {number} [start=func.length-1] The start position of the rest parameter.\n\t     * @returns {Function} Returns the new function.\n\t     */\n\t    function baseRest(func, start) {\n\t      return setToString(overRest(func, start, identity), func + '');\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.sample`.\n\t     *\n\t     * @private\n\t     * @param {Array|Object} collection The collection to sample.\n\t     * @returns {*} Returns the random element.\n\t     */\n\t    function baseSample(collection) {\n\t      return arraySample(values(collection));\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.sampleSize` without param guards.\n\t     *\n\t     * @private\n\t     * @param {Array|Object} collection The collection to sample.\n\t     * @param {number} n The number of elements to sample.\n\t     * @returns {Array} Returns the random elements.\n\t     */\n\t    function baseSampleSize(collection, n) {\n\t      var array = values(collection);\n\t      return shuffleSelf(array, baseClamp(n, 0, array.length));\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.set`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to modify.\n\t     * @param {Array|string} path The path of the property to set.\n\t     * @param {*} value The value to set.\n\t     * @param {Function} [customizer] The function to customize path creation.\n\t     * @returns {Object} Returns `object`.\n\t     */\n\t    function baseSet(object, path, value, customizer) {\n\t      if (!isObject(object)) {\n\t        return object;\n\t      }\n\t      path = castPath(path, object);\n\t\n\t      var index = -1,\n\t          length = path.length,\n\t          lastIndex = length - 1,\n\t          nested = object;\n\t\n\t      while (nested != null && ++index < length) {\n\t        var key = toKey(path[index]),\n\t            newValue = value;\n\t\n\t        if (index != lastIndex) {\n\t          var objValue = nested[key];\n\t          newValue = customizer ? customizer(objValue, key, nested) : undefined;\n\t          if (newValue === undefined) {\n\t            newValue = isObject(objValue)\n\t              ? objValue\n\t              : (isIndex(path[index + 1]) ? [] : {});\n\t          }\n\t        }\n\t        assignValue(nested, key, newValue);\n\t        nested = nested[key];\n\t      }\n\t      return object;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `setData` without support for hot loop shorting.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to associate metadata with.\n\t     * @param {*} data The metadata.\n\t     * @returns {Function} Returns `func`.\n\t     */\n\t    var baseSetData = !metaMap ? identity : function(func, data) {\n\t      metaMap.set(func, data);\n\t      return func;\n\t    };\n\t\n\t    /**\n\t     * The base implementation of `setToString` without support for hot loop shorting.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to modify.\n\t     * @param {Function} string The `toString` result.\n\t     * @returns {Function} Returns `func`.\n\t     */\n\t    var baseSetToString = !defineProperty ? identity : function(func, string) {\n\t      return defineProperty(func, 'toString', {\n\t        'configurable': true,\n\t        'enumerable': false,\n\t        'value': constant(string),\n\t        'writable': true\n\t      });\n\t    };\n\t\n\t    /**\n\t     * The base implementation of `_.shuffle`.\n\t     *\n\t     * @private\n\t     * @param {Array|Object} collection The collection to shuffle.\n\t     * @returns {Array} Returns the new shuffled array.\n\t     */\n\t    function baseShuffle(collection) {\n\t      return shuffleSelf(values(collection));\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.slice` without an iteratee call guard.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to slice.\n\t     * @param {number} [start=0] The start position.\n\t     * @param {number} [end=array.length] The end position.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     */\n\t    function baseSlice(array, start, end) {\n\t      var index = -1,\n\t          length = array.length;\n\t\n\t      if (start < 0) {\n\t        start = -start > length ? 0 : (length + start);\n\t      }\n\t      end = end > length ? length : end;\n\t      if (end < 0) {\n\t        end += length;\n\t      }\n\t      length = start > end ? 0 : ((end - start) >>> 0);\n\t      start >>>= 0;\n\t\n\t      var result = Array(length);\n\t      while (++index < length) {\n\t        result[index] = array[index + start];\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.some` without support for iteratee shorthands.\n\t     *\n\t     * @private\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function} predicate The function invoked per iteration.\n\t     * @returns {boolean} Returns `true` if any element passes the predicate check,\n\t     *  else `false`.\n\t     */\n\t    function baseSome(collection, predicate) {\n\t      var result;\n\t\n\t      baseEach(collection, function(value, index, collection) {\n\t        result = predicate(value, index, collection);\n\t        return !result;\n\t      });\n\t      return !!result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which\n\t     * performs a binary search of `array` to determine the index at which `value`\n\t     * should be inserted into `array` in order to maintain its sort order.\n\t     *\n\t     * @private\n\t     * @param {Array} array The sorted array to inspect.\n\t     * @param {*} value The value to evaluate.\n\t     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n\t     * @returns {number} Returns the index at which `value` should be inserted\n\t     *  into `array`.\n\t     */\n\t    function baseSortedIndex(array, value, retHighest) {\n\t      var low = 0,\n\t          high = array == null ? low : array.length;\n\t\n\t      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\n\t        while (low < high) {\n\t          var mid = (low + high) >>> 1,\n\t              computed = array[mid];\n\t\n\t          if (computed !== null && !isSymbol(computed) &&\n\t              (retHighest ? (computed <= value) : (computed < value))) {\n\t            low = mid + 1;\n\t          } else {\n\t            high = mid;\n\t          }\n\t        }\n\t        return high;\n\t      }\n\t      return baseSortedIndexBy(array, value, identity, retHighest);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`\n\t     * which invokes `iteratee` for `value` and each element of `array` to compute\n\t     * their sort ranking. The iteratee is invoked with one argument; (value).\n\t     *\n\t     * @private\n\t     * @param {Array} array The sorted array to inspect.\n\t     * @param {*} value The value to evaluate.\n\t     * @param {Function} iteratee The iteratee invoked per element.\n\t     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n\t     * @returns {number} Returns the index at which `value` should be inserted\n\t     *  into `array`.\n\t     */\n\t    function baseSortedIndexBy(array, value, iteratee, retHighest) {\n\t      value = iteratee(value);\n\t\n\t      var low = 0,\n\t          high = array == null ? 0 : array.length,\n\t          valIsNaN = value !== value,\n\t          valIsNull = value === null,\n\t          valIsSymbol = isSymbol(value),\n\t          valIsUndefined = value === undefined;\n\t\n\t      while (low < high) {\n\t        var mid = nativeFloor((low + high) / 2),\n\t            computed = iteratee(array[mid]),\n\t            othIsDefined = computed !== undefined,\n\t            othIsNull = computed === null,\n\t            othIsReflexive = computed === computed,\n\t            othIsSymbol = isSymbol(computed);\n\t\n\t        if (valIsNaN) {\n\t          var setLow = retHighest || othIsReflexive;\n\t        } else if (valIsUndefined) {\n\t          setLow = othIsReflexive && (retHighest || othIsDefined);\n\t        } else if (valIsNull) {\n\t          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);\n\t        } else if (valIsSymbol) {\n\t          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);\n\t        } else if (othIsNull || othIsSymbol) {\n\t          setLow = false;\n\t        } else {\n\t          setLow = retHighest ? (computed <= value) : (computed < value);\n\t        }\n\t        if (setLow) {\n\t          low = mid + 1;\n\t        } else {\n\t          high = mid;\n\t        }\n\t      }\n\t      return nativeMin(high, MAX_ARRAY_INDEX);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without\n\t     * support for iteratee shorthands.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to inspect.\n\t     * @param {Function} [iteratee] The iteratee invoked per element.\n\t     * @returns {Array} Returns the new duplicate free array.\n\t     */\n\t    function baseSortedUniq(array, iteratee) {\n\t      var index = -1,\n\t          length = array.length,\n\t          resIndex = 0,\n\t          result = [];\n\t\n\t      while (++index < length) {\n\t        var value = array[index],\n\t            computed = iteratee ? iteratee(value) : value;\n\t\n\t        if (!index || !eq(computed, seen)) {\n\t          var seen = computed;\n\t          result[resIndex++] = value === 0 ? 0 : value;\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.toNumber` which doesn't ensure correct\n\t     * conversions of binary, hexadecimal, or octal string values.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to process.\n\t     * @returns {number} Returns the number.\n\t     */\n\t    function baseToNumber(value) {\n\t      if (typeof value == 'number') {\n\t        return value;\n\t      }\n\t      if (isSymbol(value)) {\n\t        return NAN;\n\t      }\n\t      return +value;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.toString` which doesn't convert nullish\n\t     * values to empty strings.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to process.\n\t     * @returns {string} Returns the string.\n\t     */\n\t    function baseToString(value) {\n\t      // Exit early for strings to avoid a performance hit in some environments.\n\t      if (typeof value == 'string') {\n\t        return value;\n\t      }\n\t      if (isArray(value)) {\n\t        // Recursively convert values (susceptible to call stack limits).\n\t        return arrayMap(value, baseToString) + '';\n\t      }\n\t      if (isSymbol(value)) {\n\t        return symbolToString ? symbolToString.call(value) : '';\n\t      }\n\t      var result = (value + '');\n\t      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to inspect.\n\t     * @param {Function} [iteratee] The iteratee invoked per element.\n\t     * @param {Function} [comparator] The comparator invoked per element.\n\t     * @returns {Array} Returns the new duplicate free array.\n\t     */\n\t    function baseUniq(array, iteratee, comparator) {\n\t      var index = -1,\n\t          includes = arrayIncludes,\n\t          length = array.length,\n\t          isCommon = true,\n\t          result = [],\n\t          seen = result;\n\t\n\t      if (comparator) {\n\t        isCommon = false;\n\t        includes = arrayIncludesWith;\n\t      }\n\t      else if (length >= LARGE_ARRAY_SIZE) {\n\t        var set = iteratee ? null : createSet(array);\n\t        if (set) {\n\t          return setToArray(set);\n\t        }\n\t        isCommon = false;\n\t        includes = cacheHas;\n\t        seen = new SetCache;\n\t      }\n\t      else {\n\t        seen = iteratee ? [] : result;\n\t      }\n\t      outer:\n\t      while (++index < length) {\n\t        var value = array[index],\n\t            computed = iteratee ? iteratee(value) : value;\n\t\n\t        value = (comparator || value !== 0) ? value : 0;\n\t        if (isCommon && computed === computed) {\n\t          var seenIndex = seen.length;\n\t          while (seenIndex--) {\n\t            if (seen[seenIndex] === computed) {\n\t              continue outer;\n\t            }\n\t          }\n\t          if (iteratee) {\n\t            seen.push(computed);\n\t          }\n\t          result.push(value);\n\t        }\n\t        else if (!includes(seen, computed, comparator)) {\n\t          if (seen !== result) {\n\t            seen.push(computed);\n\t          }\n\t          result.push(value);\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.unset`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to modify.\n\t     * @param {Array|string} path The property path to unset.\n\t     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n\t     */\n\t    function baseUnset(object, path) {\n\t      path = castPath(path, object);\n\t      object = parent(object, path);\n\t      return object == null || delete object[toKey(last(path))];\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.update`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to modify.\n\t     * @param {Array|string} path The path of the property to update.\n\t     * @param {Function} updater The function to produce the updated value.\n\t     * @param {Function} [customizer] The function to customize path creation.\n\t     * @returns {Object} Returns `object`.\n\t     */\n\t    function baseUpdate(object, path, updater, customizer) {\n\t      return baseSet(object, path, updater(baseGet(object, path)), customizer);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`\n\t     * without support for iteratee shorthands.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to query.\n\t     * @param {Function} predicate The function invoked per iteration.\n\t     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.\n\t     * @param {boolean} [fromRight] Specify iterating from right to left.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     */\n\t    function baseWhile(array, predicate, isDrop, fromRight) {\n\t      var length = array.length,\n\t          index = fromRight ? length : -1;\n\t\n\t      while ((fromRight ? index-- : ++index < length) &&\n\t        predicate(array[index], index, array)) {}\n\t\n\t      return isDrop\n\t        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))\n\t        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `wrapperValue` which returns the result of\n\t     * performing a sequence of actions on the unwrapped `value`, where each\n\t     * successive action is supplied the return value of the previous.\n\t     *\n\t     * @private\n\t     * @param {*} value The unwrapped value.\n\t     * @param {Array} actions Actions to perform to resolve the unwrapped value.\n\t     * @returns {*} Returns the resolved value.\n\t     */\n\t    function baseWrapperValue(value, actions) {\n\t      var result = value;\n\t      if (result instanceof LazyWrapper) {\n\t        result = result.value();\n\t      }\n\t      return arrayReduce(actions, function(result, action) {\n\t        return action.func.apply(action.thisArg, arrayPush([result], action.args));\n\t      }, result);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of methods like `_.xor`, without support for\n\t     * iteratee shorthands, that accepts an array of arrays to inspect.\n\t     *\n\t     * @private\n\t     * @param {Array} arrays The arrays to inspect.\n\t     * @param {Function} [iteratee] The iteratee invoked per element.\n\t     * @param {Function} [comparator] The comparator invoked per element.\n\t     * @returns {Array} Returns the new array of values.\n\t     */\n\t    function baseXor(arrays, iteratee, comparator) {\n\t      var length = arrays.length;\n\t      if (length < 2) {\n\t        return length ? baseUniq(arrays[0]) : [];\n\t      }\n\t      var index = -1,\n\t          result = Array(length);\n\t\n\t      while (++index < length) {\n\t        var array = arrays[index],\n\t            othIndex = -1;\n\t\n\t        while (++othIndex < length) {\n\t          if (othIndex != index) {\n\t            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);\n\t          }\n\t        }\n\t      }\n\t      return baseUniq(baseFlatten(result, 1), iteratee, comparator);\n\t    }\n\t\n\t    /**\n\t     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.\n\t     *\n\t     * @private\n\t     * @param {Array} props The property identifiers.\n\t     * @param {Array} values The property values.\n\t     * @param {Function} assignFunc The function to assign values.\n\t     * @returns {Object} Returns the new object.\n\t     */\n\t    function baseZipObject(props, values, assignFunc) {\n\t      var index = -1,\n\t          length = props.length,\n\t          valsLength = values.length,\n\t          result = {};\n\t\n\t      while (++index < length) {\n\t        var value = index < valsLength ? values[index] : undefined;\n\t        assignFunc(result, props[index], value);\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Casts `value` to an empty array if it's not an array like object.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to inspect.\n\t     * @returns {Array|Object} Returns the cast array-like object.\n\t     */\n\t    function castArrayLikeObject(value) {\n\t      return isArrayLikeObject(value) ? value : [];\n\t    }\n\t\n\t    /**\n\t     * Casts `value` to `identity` if it's not a function.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to inspect.\n\t     * @returns {Function} Returns cast function.\n\t     */\n\t    function castFunction(value) {\n\t      return typeof value == 'function' ? value : identity;\n\t    }\n\t\n\t    /**\n\t     * Casts `value` to a path array if it's not one.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to inspect.\n\t     * @param {Object} [object] The object to query keys on.\n\t     * @returns {Array} Returns the cast property path array.\n\t     */\n\t    function castPath(value, object) {\n\t      if (isArray(value)) {\n\t        return value;\n\t      }\n\t      return isKey(value, object) ? [value] : stringToPath(toString(value));\n\t    }\n\t\n\t    /**\n\t     * A `baseRest` alias which can be replaced with `identity` by module\n\t     * replacement plugins.\n\t     *\n\t     * @private\n\t     * @type {Function}\n\t     * @param {Function} func The function to apply a rest parameter to.\n\t     * @returns {Function} Returns the new function.\n\t     */\n\t    var castRest = baseRest;\n\t\n\t    /**\n\t     * Casts `array` to a slice if it's needed.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to inspect.\n\t     * @param {number} start The start position.\n\t     * @param {number} [end=array.length] The end position.\n\t     * @returns {Array} Returns the cast slice.\n\t     */\n\t    function castSlice(array, start, end) {\n\t      var length = array.length;\n\t      end = end === undefined ? length : end;\n\t      return (!start && end >= length) ? array : baseSlice(array, start, end);\n\t    }\n\t\n\t    /**\n\t     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).\n\t     *\n\t     * @private\n\t     * @param {number|Object} id The timer id or timeout object of the timer to clear.\n\t     */\n\t    var clearTimeout = ctxClearTimeout || function(id) {\n\t      return root.clearTimeout(id);\n\t    };\n\t\n\t    /**\n\t     * Creates a clone of  `buffer`.\n\t     *\n\t     * @private\n\t     * @param {Buffer} buffer The buffer to clone.\n\t     * @param {boolean} [isDeep] Specify a deep clone.\n\t     * @returns {Buffer} Returns the cloned buffer.\n\t     */\n\t    function cloneBuffer(buffer, isDeep) {\n\t      if (isDeep) {\n\t        return buffer.slice();\n\t      }\n\t      var length = buffer.length,\n\t          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\t\n\t      buffer.copy(result);\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Creates a clone of `arrayBuffer`.\n\t     *\n\t     * @private\n\t     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n\t     * @returns {ArrayBuffer} Returns the cloned array buffer.\n\t     */\n\t    function cloneArrayBuffer(arrayBuffer) {\n\t      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n\t      new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Creates a clone of `dataView`.\n\t     *\n\t     * @private\n\t     * @param {Object} dataView The data view to clone.\n\t     * @param {boolean} [isDeep] Specify a deep clone.\n\t     * @returns {Object} Returns the cloned data view.\n\t     */\n\t    function cloneDataView(dataView, isDeep) {\n\t      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n\t      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n\t    }\n\t\n\t    /**\n\t     * Creates a clone of `map`.\n\t     *\n\t     * @private\n\t     * @param {Object} map The map to clone.\n\t     * @param {Function} cloneFunc The function to clone values.\n\t     * @param {boolean} [isDeep] Specify a deep clone.\n\t     * @returns {Object} Returns the cloned map.\n\t     */\n\t    function cloneMap(map, isDeep, cloneFunc) {\n\t      var array = isDeep ? cloneFunc(mapToArray(map), CLONE_DEEP_FLAG) : mapToArray(map);\n\t      return arrayReduce(array, addMapEntry, new map.constructor);\n\t    }\n\t\n\t    /**\n\t     * Creates a clone of `regexp`.\n\t     *\n\t     * @private\n\t     * @param {Object} regexp The regexp to clone.\n\t     * @returns {Object} Returns the cloned regexp.\n\t     */\n\t    function cloneRegExp(regexp) {\n\t      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n\t      result.lastIndex = regexp.lastIndex;\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Creates a clone of `set`.\n\t     *\n\t     * @private\n\t     * @param {Object} set The set to clone.\n\t     * @param {Function} cloneFunc The function to clone values.\n\t     * @param {boolean} [isDeep] Specify a deep clone.\n\t     * @returns {Object} Returns the cloned set.\n\t     */\n\t    function cloneSet(set, isDeep, cloneFunc) {\n\t      var array = isDeep ? cloneFunc(setToArray(set), CLONE_DEEP_FLAG) : setToArray(set);\n\t      return arrayReduce(array, addSetEntry, new set.constructor);\n\t    }\n\t\n\t    /**\n\t     * Creates a clone of the `symbol` object.\n\t     *\n\t     * @private\n\t     * @param {Object} symbol The symbol object to clone.\n\t     * @returns {Object} Returns the cloned symbol object.\n\t     */\n\t    function cloneSymbol(symbol) {\n\t      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n\t    }\n\t\n\t    /**\n\t     * Creates a clone of `typedArray`.\n\t     *\n\t     * @private\n\t     * @param {Object} typedArray The typed array to clone.\n\t     * @param {boolean} [isDeep] Specify a deep clone.\n\t     * @returns {Object} Returns the cloned typed array.\n\t     */\n\t    function cloneTypedArray(typedArray, isDeep) {\n\t      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n\t      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n\t    }\n\t\n\t    /**\n\t     * Compares values to sort them in ascending order.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to compare.\n\t     * @param {*} other The other value to compare.\n\t     * @returns {number} Returns the sort order indicator for `value`.\n\t     */\n\t    function compareAscending(value, other) {\n\t      if (value !== other) {\n\t        var valIsDefined = value !== undefined,\n\t            valIsNull = value === null,\n\t            valIsReflexive = value === value,\n\t            valIsSymbol = isSymbol(value);\n\t\n\t        var othIsDefined = other !== undefined,\n\t            othIsNull = other === null,\n\t            othIsReflexive = other === other,\n\t            othIsSymbol = isSymbol(other);\n\t\n\t        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n\t            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n\t            (valIsNull && othIsDefined && othIsReflexive) ||\n\t            (!valIsDefined && othIsReflexive) ||\n\t            !valIsReflexive) {\n\t          return 1;\n\t        }\n\t        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n\t            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n\t            (othIsNull && valIsDefined && valIsReflexive) ||\n\t            (!othIsDefined && valIsReflexive) ||\n\t            !othIsReflexive) {\n\t          return -1;\n\t        }\n\t      }\n\t      return 0;\n\t    }\n\t\n\t    /**\n\t     * Used by `_.orderBy` to compare multiple properties of a value to another\n\t     * and stable sort them.\n\t     *\n\t     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n\t     * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n\t     * of corresponding values.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to compare.\n\t     * @param {Object} other The other object to compare.\n\t     * @param {boolean[]|string[]} orders The order to sort by for each property.\n\t     * @returns {number} Returns the sort order indicator for `object`.\n\t     */\n\t    function compareMultiple(object, other, orders) {\n\t      var index = -1,\n\t          objCriteria = object.criteria,\n\t          othCriteria = other.criteria,\n\t          length = objCriteria.length,\n\t          ordersLength = orders.length;\n\t\n\t      while (++index < length) {\n\t        var result = compareAscending(objCriteria[index], othCriteria[index]);\n\t        if (result) {\n\t          if (index >= ordersLength) {\n\t            return result;\n\t          }\n\t          var order = orders[index];\n\t          return result * (order == 'desc' ? -1 : 1);\n\t        }\n\t      }\n\t      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n\t      // that causes it, under certain circumstances, to provide the same value for\n\t      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n\t      // for more details.\n\t      //\n\t      // This also ensures a stable sort in V8 and other engines.\n\t      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n\t      return object.index - other.index;\n\t    }\n\t\n\t    /**\n\t     * Creates an array that is the composition of partially applied arguments,\n\t     * placeholders, and provided arguments into a single array of arguments.\n\t     *\n\t     * @private\n\t     * @param {Array} args The provided arguments.\n\t     * @param {Array} partials The arguments to prepend to those provided.\n\t     * @param {Array} holders The `partials` placeholder indexes.\n\t     * @params {boolean} [isCurried] Specify composing for a curried function.\n\t     * @returns {Array} Returns the new array of composed arguments.\n\t     */\n\t    function composeArgs(args, partials, holders, isCurried) {\n\t      var argsIndex = -1,\n\t          argsLength = args.length,\n\t          holdersLength = holders.length,\n\t          leftIndex = -1,\n\t          leftLength = partials.length,\n\t          rangeLength = nativeMax(argsLength - holdersLength, 0),\n\t          result = Array(leftLength + rangeLength),\n\t          isUncurried = !isCurried;\n\t\n\t      while (++leftIndex < leftLength) {\n\t        result[leftIndex] = partials[leftIndex];\n\t      }\n\t      while (++argsIndex < holdersLength) {\n\t        if (isUncurried || argsIndex < argsLength) {\n\t          result[holders[argsIndex]] = args[argsIndex];\n\t        }\n\t      }\n\t      while (rangeLength--) {\n\t        result[leftIndex++] = args[argsIndex++];\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * This function is like `composeArgs` except that the arguments composition\n\t     * is tailored for `_.partialRight`.\n\t     *\n\t     * @private\n\t     * @param {Array} args The provided arguments.\n\t     * @param {Array} partials The arguments to append to those provided.\n\t     * @param {Array} holders The `partials` placeholder indexes.\n\t     * @params {boolean} [isCurried] Specify composing for a curried function.\n\t     * @returns {Array} Returns the new array of composed arguments.\n\t     */\n\t    function composeArgsRight(args, partials, holders, isCurried) {\n\t      var argsIndex = -1,\n\t          argsLength = args.length,\n\t          holdersIndex = -1,\n\t          holdersLength = holders.length,\n\t          rightIndex = -1,\n\t          rightLength = partials.length,\n\t          rangeLength = nativeMax(argsLength - holdersLength, 0),\n\t          result = Array(rangeLength + rightLength),\n\t          isUncurried = !isCurried;\n\t\n\t      while (++argsIndex < rangeLength) {\n\t        result[argsIndex] = args[argsIndex];\n\t      }\n\t      var offset = argsIndex;\n\t      while (++rightIndex < rightLength) {\n\t        result[offset + rightIndex] = partials[rightIndex];\n\t      }\n\t      while (++holdersIndex < holdersLength) {\n\t        if (isUncurried || argsIndex < argsLength) {\n\t          result[offset + holders[holdersIndex]] = args[argsIndex++];\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Copies the values of `source` to `array`.\n\t     *\n\t     * @private\n\t     * @param {Array} source The array to copy values from.\n\t     * @param {Array} [array=[]] The array to copy values to.\n\t     * @returns {Array} Returns `array`.\n\t     */\n\t    function copyArray(source, array) {\n\t      var index = -1,\n\t          length = source.length;\n\t\n\t      array || (array = Array(length));\n\t      while (++index < length) {\n\t        array[index] = source[index];\n\t      }\n\t      return array;\n\t    }\n\t\n\t    /**\n\t     * Copies properties of `source` to `object`.\n\t     *\n\t     * @private\n\t     * @param {Object} source The object to copy properties from.\n\t     * @param {Array} props The property identifiers to copy.\n\t     * @param {Object} [object={}] The object to copy properties to.\n\t     * @param {Function} [customizer] The function to customize copied values.\n\t     * @returns {Object} Returns `object`.\n\t     */\n\t    function copyObject(source, props, object, customizer) {\n\t      var isNew = !object;\n\t      object || (object = {});\n\t\n\t      var index = -1,\n\t          length = props.length;\n\t\n\t      while (++index < length) {\n\t        var key = props[index];\n\t\n\t        var newValue = customizer\n\t          ? customizer(object[key], source[key], key, object, source)\n\t          : undefined;\n\t\n\t        if (newValue === undefined) {\n\t          newValue = source[key];\n\t        }\n\t        if (isNew) {\n\t          baseAssignValue(object, key, newValue);\n\t        } else {\n\t          assignValue(object, key, newValue);\n\t        }\n\t      }\n\t      return object;\n\t    }\n\t\n\t    /**\n\t     * Copies own symbols of `source` to `object`.\n\t     *\n\t     * @private\n\t     * @param {Object} source The object to copy symbols from.\n\t     * @param {Object} [object={}] The object to copy symbols to.\n\t     * @returns {Object} Returns `object`.\n\t     */\n\t    function copySymbols(source, object) {\n\t      return copyObject(source, getSymbols(source), object);\n\t    }\n\t\n\t    /**\n\t     * Copies own and inherited symbols of `source` to `object`.\n\t     *\n\t     * @private\n\t     * @param {Object} source The object to copy symbols from.\n\t     * @param {Object} [object={}] The object to copy symbols to.\n\t     * @returns {Object} Returns `object`.\n\t     */\n\t    function copySymbolsIn(source, object) {\n\t      return copyObject(source, getSymbolsIn(source), object);\n\t    }\n\t\n\t    /**\n\t     * Creates a function like `_.groupBy`.\n\t     *\n\t     * @private\n\t     * @param {Function} setter The function to set accumulator values.\n\t     * @param {Function} [initializer] The accumulator object initializer.\n\t     * @returns {Function} Returns the new aggregator function.\n\t     */\n\t    function createAggregator(setter, initializer) {\n\t      return function(collection, iteratee) {\n\t        var func = isArray(collection) ? arrayAggregator : baseAggregator,\n\t            accumulator = initializer ? initializer() : {};\n\t\n\t        return func(collection, setter, getIteratee(iteratee, 2), accumulator);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function like `_.assign`.\n\t     *\n\t     * @private\n\t     * @param {Function} assigner The function to assign values.\n\t     * @returns {Function} Returns the new assigner function.\n\t     */\n\t    function createAssigner(assigner) {\n\t      return baseRest(function(object, sources) {\n\t        var index = -1,\n\t            length = sources.length,\n\t            customizer = length > 1 ? sources[length - 1] : undefined,\n\t            guard = length > 2 ? sources[2] : undefined;\n\t\n\t        customizer = (assigner.length > 3 && typeof customizer == 'function')\n\t          ? (length--, customizer)\n\t          : undefined;\n\t\n\t        if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n\t          customizer = length < 3 ? undefined : customizer;\n\t          length = 1;\n\t        }\n\t        object = Object(object);\n\t        while (++index < length) {\n\t          var source = sources[index];\n\t          if (source) {\n\t            assigner(object, source, index, customizer);\n\t          }\n\t        }\n\t        return object;\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Creates a `baseEach` or `baseEachRight` function.\n\t     *\n\t     * @private\n\t     * @param {Function} eachFunc The function to iterate over a collection.\n\t     * @param {boolean} [fromRight] Specify iterating from right to left.\n\t     * @returns {Function} Returns the new base function.\n\t     */\n\t    function createBaseEach(eachFunc, fromRight) {\n\t      return function(collection, iteratee) {\n\t        if (collection == null) {\n\t          return collection;\n\t        }\n\t        if (!isArrayLike(collection)) {\n\t          return eachFunc(collection, iteratee);\n\t        }\n\t        var length = collection.length,\n\t            index = fromRight ? length : -1,\n\t            iterable = Object(collection);\n\t\n\t        while ((fromRight ? index-- : ++index < length)) {\n\t          if (iteratee(iterable[index], index, iterable) === false) {\n\t            break;\n\t          }\n\t        }\n\t        return collection;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n\t     *\n\t     * @private\n\t     * @param {boolean} [fromRight] Specify iterating from right to left.\n\t     * @returns {Function} Returns the new base function.\n\t     */\n\t    function createBaseFor(fromRight) {\n\t      return function(object, iteratee, keysFunc) {\n\t        var index = -1,\n\t            iterable = Object(object),\n\t            props = keysFunc(object),\n\t            length = props.length;\n\t\n\t        while (length--) {\n\t          var key = props[fromRight ? length : ++index];\n\t          if (iteratee(iterable[key], key, iterable) === false) {\n\t            break;\n\t          }\n\t        }\n\t        return object;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that wraps `func` to invoke it with the optional `this`\n\t     * binding of `thisArg`.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to wrap.\n\t     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n\t     * @param {*} [thisArg] The `this` binding of `func`.\n\t     * @returns {Function} Returns the new wrapped function.\n\t     */\n\t    function createBind(func, bitmask, thisArg) {\n\t      var isBind = bitmask & WRAP_BIND_FLAG,\n\t          Ctor = createCtor(func);\n\t\n\t      function wrapper() {\n\t        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n\t        return fn.apply(isBind ? thisArg : this, arguments);\n\t      }\n\t      return wrapper;\n\t    }\n\t\n\t    /**\n\t     * Creates a function like `_.lowerFirst`.\n\t     *\n\t     * @private\n\t     * @param {string} methodName The name of the `String` case method to use.\n\t     * @returns {Function} Returns the new case function.\n\t     */\n\t    function createCaseFirst(methodName) {\n\t      return function(string) {\n\t        string = toString(string);\n\t\n\t        var strSymbols = hasUnicode(string)\n\t          ? stringToArray(string)\n\t          : undefined;\n\t\n\t        var chr = strSymbols\n\t          ? strSymbols[0]\n\t          : string.charAt(0);\n\t\n\t        var trailing = strSymbols\n\t          ? castSlice(strSymbols, 1).join('')\n\t          : string.slice(1);\n\t\n\t        return chr[methodName]() + trailing;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function like `_.camelCase`.\n\t     *\n\t     * @private\n\t     * @param {Function} callback The function to combine each word.\n\t     * @returns {Function} Returns the new compounder function.\n\t     */\n\t    function createCompounder(callback) {\n\t      return function(string) {\n\t        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that produces an instance of `Ctor` regardless of\n\t     * whether it was invoked as part of a `new` expression or by `call` or `apply`.\n\t     *\n\t     * @private\n\t     * @param {Function} Ctor The constructor to wrap.\n\t     * @returns {Function} Returns the new wrapped function.\n\t     */\n\t    function createCtor(Ctor) {\n\t      return function() {\n\t        // Use a `switch` statement to work with class constructors. See\n\t        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist\n\t        // for more details.\n\t        var args = arguments;\n\t        switch (args.length) {\n\t          case 0: return new Ctor;\n\t          case 1: return new Ctor(args[0]);\n\t          case 2: return new Ctor(args[0], args[1]);\n\t          case 3: return new Ctor(args[0], args[1], args[2]);\n\t          case 4: return new Ctor(args[0], args[1], args[2], args[3]);\n\t          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);\n\t          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);\n\t          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n\t        }\n\t        var thisBinding = baseCreate(Ctor.prototype),\n\t            result = Ctor.apply(thisBinding, args);\n\t\n\t        // Mimic the constructor's `return` behavior.\n\t        // See https://es5.github.io/#x13.2.2 for more details.\n\t        return isObject(result) ? result : thisBinding;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that wraps `func` to enable currying.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to wrap.\n\t     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n\t     * @param {number} arity The arity of `func`.\n\t     * @returns {Function} Returns the new wrapped function.\n\t     */\n\t    function createCurry(func, bitmask, arity) {\n\t      var Ctor = createCtor(func);\n\t\n\t      function wrapper() {\n\t        var length = arguments.length,\n\t            args = Array(length),\n\t            index = length,\n\t            placeholder = getHolder(wrapper);\n\t\n\t        while (index--) {\n\t          args[index] = arguments[index];\n\t        }\n\t        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)\n\t          ? []\n\t          : replaceHolders(args, placeholder);\n\t\n\t        length -= holders.length;\n\t        if (length < arity) {\n\t          return createRecurry(\n\t            func, bitmask, createHybrid, wrapper.placeholder, undefined,\n\t            args, holders, undefined, undefined, arity - length);\n\t        }\n\t        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n\t        return apply(fn, this, args);\n\t      }\n\t      return wrapper;\n\t    }\n\t\n\t    /**\n\t     * Creates a `_.find` or `_.findLast` function.\n\t     *\n\t     * @private\n\t     * @param {Function} findIndexFunc The function to find the collection index.\n\t     * @returns {Function} Returns the new find function.\n\t     */\n\t    function createFind(findIndexFunc) {\n\t      return function(collection, predicate, fromIndex) {\n\t        var iterable = Object(collection);\n\t        if (!isArrayLike(collection)) {\n\t          var iteratee = getIteratee(predicate, 3);\n\t          collection = keys(collection);\n\t          predicate = function(key) { return iteratee(iterable[key], key, iterable); };\n\t        }\n\t        var index = findIndexFunc(collection, predicate, fromIndex);\n\t        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a `_.flow` or `_.flowRight` function.\n\t     *\n\t     * @private\n\t     * @param {boolean} [fromRight] Specify iterating from right to left.\n\t     * @returns {Function} Returns the new flow function.\n\t     */\n\t    function createFlow(fromRight) {\n\t      return flatRest(function(funcs) {\n\t        var length = funcs.length,\n\t            index = length,\n\t            prereq = LodashWrapper.prototype.thru;\n\t\n\t        if (fromRight) {\n\t          funcs.reverse();\n\t        }\n\t        while (index--) {\n\t          var func = funcs[index];\n\t          if (typeof func != 'function') {\n\t            throw new TypeError(FUNC_ERROR_TEXT);\n\t          }\n\t          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {\n\t            var wrapper = new LodashWrapper([], true);\n\t          }\n\t        }\n\t        index = wrapper ? index : length;\n\t        while (++index < length) {\n\t          func = funcs[index];\n\t\n\t          var funcName = getFuncName(func),\n\t              data = funcName == 'wrapper' ? getData(func) : undefined;\n\t\n\t          if (data && isLaziable(data[0]) &&\n\t                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&\n\t                !data[4].length && data[9] == 1\n\t              ) {\n\t            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);\n\t          } else {\n\t            wrapper = (func.length == 1 && isLaziable(func))\n\t              ? wrapper[funcName]()\n\t              : wrapper.thru(func);\n\t          }\n\t        }\n\t        return function() {\n\t          var args = arguments,\n\t              value = args[0];\n\t\n\t          if (wrapper && args.length == 1 &&\n\t              isArray(value) && value.length >= LARGE_ARRAY_SIZE) {\n\t            return wrapper.plant(value).value();\n\t          }\n\t          var index = 0,\n\t              result = length ? funcs[index].apply(this, args) : value;\n\t\n\t          while (++index < length) {\n\t            result = funcs[index].call(this, result);\n\t          }\n\t          return result;\n\t        };\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Creates a function that wraps `func` to invoke it with optional `this`\n\t     * binding of `thisArg`, partial application, and currying.\n\t     *\n\t     * @private\n\t     * @param {Function|string} func The function or method name to wrap.\n\t     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n\t     * @param {*} [thisArg] The `this` binding of `func`.\n\t     * @param {Array} [partials] The arguments to prepend to those provided to\n\t     *  the new function.\n\t     * @param {Array} [holders] The `partials` placeholder indexes.\n\t     * @param {Array} [partialsRight] The arguments to append to those provided\n\t     *  to the new function.\n\t     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.\n\t     * @param {Array} [argPos] The argument positions of the new function.\n\t     * @param {number} [ary] The arity cap of `func`.\n\t     * @param {number} [arity] The arity of `func`.\n\t     * @returns {Function} Returns the new wrapped function.\n\t     */\n\t    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {\n\t      var isAry = bitmask & WRAP_ARY_FLAG,\n\t          isBind = bitmask & WRAP_BIND_FLAG,\n\t          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,\n\t          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),\n\t          isFlip = bitmask & WRAP_FLIP_FLAG,\n\t          Ctor = isBindKey ? undefined : createCtor(func);\n\t\n\t      function wrapper() {\n\t        var length = arguments.length,\n\t            args = Array(length),\n\t            index = length;\n\t\n\t        while (index--) {\n\t          args[index] = arguments[index];\n\t        }\n\t        if (isCurried) {\n\t          var placeholder = getHolder(wrapper),\n\t              holdersCount = countHolders(args, placeholder);\n\t        }\n\t        if (partials) {\n\t          args = composeArgs(args, partials, holders, isCurried);\n\t        }\n\t        if (partialsRight) {\n\t          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);\n\t        }\n\t        length -= holdersCount;\n\t        if (isCurried && length < arity) {\n\t          var newHolders = replaceHolders(args, placeholder);\n\t          return createRecurry(\n\t            func, bitmask, createHybrid, wrapper.placeholder, thisArg,\n\t            args, newHolders, argPos, ary, arity - length\n\t          );\n\t        }\n\t        var thisBinding = isBind ? thisArg : this,\n\t            fn = isBindKey ? thisBinding[func] : func;\n\t\n\t        length = args.length;\n\t        if (argPos) {\n\t          args = reorder(args, argPos);\n\t        } else if (isFlip && length > 1) {\n\t          args.reverse();\n\t        }\n\t        if (isAry && ary < length) {\n\t          args.length = ary;\n\t        }\n\t        if (this && this !== root && this instanceof wrapper) {\n\t          fn = Ctor || createCtor(fn);\n\t        }\n\t        return fn.apply(thisBinding, args);\n\t      }\n\t      return wrapper;\n\t    }\n\t\n\t    /**\n\t     * Creates a function like `_.invertBy`.\n\t     *\n\t     * @private\n\t     * @param {Function} setter The function to set accumulator values.\n\t     * @param {Function} toIteratee The function to resolve iteratees.\n\t     * @returns {Function} Returns the new inverter function.\n\t     */\n\t    function createInverter(setter, toIteratee) {\n\t      return function(object, iteratee) {\n\t        return baseInverter(object, setter, toIteratee(iteratee), {});\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that performs a mathematical operation on two values.\n\t     *\n\t     * @private\n\t     * @param {Function} operator The function to perform the operation.\n\t     * @param {number} [defaultValue] The value used for `undefined` arguments.\n\t     * @returns {Function} Returns the new mathematical operation function.\n\t     */\n\t    function createMathOperation(operator, defaultValue) {\n\t      return function(value, other) {\n\t        var result;\n\t        if (value === undefined && other === undefined) {\n\t          return defaultValue;\n\t        }\n\t        if (value !== undefined) {\n\t          result = value;\n\t        }\n\t        if (other !== undefined) {\n\t          if (result === undefined) {\n\t            return other;\n\t          }\n\t          if (typeof value == 'string' || typeof other == 'string') {\n\t            value = baseToString(value);\n\t            other = baseToString(other);\n\t          } else {\n\t            value = baseToNumber(value);\n\t            other = baseToNumber(other);\n\t          }\n\t          result = operator(value, other);\n\t        }\n\t        return result;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function like `_.over`.\n\t     *\n\t     * @private\n\t     * @param {Function} arrayFunc The function to iterate over iteratees.\n\t     * @returns {Function} Returns the new over function.\n\t     */\n\t    function createOver(arrayFunc) {\n\t      return flatRest(function(iteratees) {\n\t        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));\n\t        return baseRest(function(args) {\n\t          var thisArg = this;\n\t          return arrayFunc(iteratees, function(iteratee) {\n\t            return apply(iteratee, thisArg, args);\n\t          });\n\t        });\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Creates the padding for `string` based on `length`. The `chars` string\n\t     * is truncated if the number of characters exceeds `length`.\n\t     *\n\t     * @private\n\t     * @param {number} length The padding length.\n\t     * @param {string} [chars=' '] The string used as padding.\n\t     * @returns {string} Returns the padding for `string`.\n\t     */\n\t    function createPadding(length, chars) {\n\t      chars = chars === undefined ? ' ' : baseToString(chars);\n\t\n\t      var charsLength = chars.length;\n\t      if (charsLength < 2) {\n\t        return charsLength ? baseRepeat(chars, length) : chars;\n\t      }\n\t      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));\n\t      return hasUnicode(chars)\n\t        ? castSlice(stringToArray(result), 0, length).join('')\n\t        : result.slice(0, length);\n\t    }\n\t\n\t    /**\n\t     * Creates a function that wraps `func` to invoke it with the `this` binding\n\t     * of `thisArg` and `partials` prepended to the arguments it receives.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to wrap.\n\t     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n\t     * @param {*} thisArg The `this` binding of `func`.\n\t     * @param {Array} partials The arguments to prepend to those provided to\n\t     *  the new function.\n\t     * @returns {Function} Returns the new wrapped function.\n\t     */\n\t    function createPartial(func, bitmask, thisArg, partials) {\n\t      var isBind = bitmask & WRAP_BIND_FLAG,\n\t          Ctor = createCtor(func);\n\t\n\t      function wrapper() {\n\t        var argsIndex = -1,\n\t            argsLength = arguments.length,\n\t            leftIndex = -1,\n\t            leftLength = partials.length,\n\t            args = Array(leftLength + argsLength),\n\t            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n\t\n\t        while (++leftIndex < leftLength) {\n\t          args[leftIndex] = partials[leftIndex];\n\t        }\n\t        while (argsLength--) {\n\t          args[leftIndex++] = arguments[++argsIndex];\n\t        }\n\t        return apply(fn, isBind ? thisArg : this, args);\n\t      }\n\t      return wrapper;\n\t    }\n\t\n\t    /**\n\t     * Creates a `_.range` or `_.rangeRight` function.\n\t     *\n\t     * @private\n\t     * @param {boolean} [fromRight] Specify iterating from right to left.\n\t     * @returns {Function} Returns the new range function.\n\t     */\n\t    function createRange(fromRight) {\n\t      return function(start, end, step) {\n\t        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {\n\t          end = step = undefined;\n\t        }\n\t        // Ensure the sign of `-0` is preserved.\n\t        start = toFinite(start);\n\t        if (end === undefined) {\n\t          end = start;\n\t          start = 0;\n\t        } else {\n\t          end = toFinite(end);\n\t        }\n\t        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);\n\t        return baseRange(start, end, step, fromRight);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that performs a relational operation on two values.\n\t     *\n\t     * @private\n\t     * @param {Function} operator The function to perform the operation.\n\t     * @returns {Function} Returns the new relational operation function.\n\t     */\n\t    function createRelationalOperation(operator) {\n\t      return function(value, other) {\n\t        if (!(typeof value == 'string' && typeof other == 'string')) {\n\t          value = toNumber(value);\n\t          other = toNumber(other);\n\t        }\n\t        return operator(value, other);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that wraps `func` to continue currying.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to wrap.\n\t     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n\t     * @param {Function} wrapFunc The function to create the `func` wrapper.\n\t     * @param {*} placeholder The placeholder value.\n\t     * @param {*} [thisArg] The `this` binding of `func`.\n\t     * @param {Array} [partials] The arguments to prepend to those provided to\n\t     *  the new function.\n\t     * @param {Array} [holders] The `partials` placeholder indexes.\n\t     * @param {Array} [argPos] The argument positions of the new function.\n\t     * @param {number} [ary] The arity cap of `func`.\n\t     * @param {number} [arity] The arity of `func`.\n\t     * @returns {Function} Returns the new wrapped function.\n\t     */\n\t    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {\n\t      var isCurry = bitmask & WRAP_CURRY_FLAG,\n\t          newHolders = isCurry ? holders : undefined,\n\t          newHoldersRight = isCurry ? undefined : holders,\n\t          newPartials = isCurry ? partials : undefined,\n\t          newPartialsRight = isCurry ? undefined : partials;\n\t\n\t      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);\n\t      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);\n\t\n\t      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {\n\t        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);\n\t      }\n\t      var newData = [\n\t        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,\n\t        newHoldersRight, argPos, ary, arity\n\t      ];\n\t\n\t      var result = wrapFunc.apply(undefined, newData);\n\t      if (isLaziable(func)) {\n\t        setData(result, newData);\n\t      }\n\t      result.placeholder = placeholder;\n\t      return setWrapToString(result, func, bitmask);\n\t    }\n\t\n\t    /**\n\t     * Creates a function like `_.round`.\n\t     *\n\t     * @private\n\t     * @param {string} methodName The name of the `Math` method to use when rounding.\n\t     * @returns {Function} Returns the new round function.\n\t     */\n\t    function createRound(methodName) {\n\t      var func = Math[methodName];\n\t      return function(number, precision) {\n\t        number = toNumber(number);\n\t        precision = nativeMin(toInteger(precision), 292);\n\t        if (precision) {\n\t          // Shift with exponential notation to avoid floating-point issues.\n\t          // See [MDN](https://mdn.io/round#Examples) for more details.\n\t          var pair = (toString(number) + 'e').split('e'),\n\t              value = func(pair[0] + 'e' + (+pair[1] + precision));\n\t\n\t          pair = (toString(value) + 'e').split('e');\n\t          return +(pair[0] + 'e' + (+pair[1] - precision));\n\t        }\n\t        return func(number);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a set object of `values`.\n\t     *\n\t     * @private\n\t     * @param {Array} values The values to add to the set.\n\t     * @returns {Object} Returns the new set.\n\t     */\n\t    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n\t      return new Set(values);\n\t    };\n\t\n\t    /**\n\t     * Creates a `_.toPairs` or `_.toPairsIn` function.\n\t     *\n\t     * @private\n\t     * @param {Function} keysFunc The function to get the keys of a given object.\n\t     * @returns {Function} Returns the new pairs function.\n\t     */\n\t    function createToPairs(keysFunc) {\n\t      return function(object) {\n\t        var tag = getTag(object);\n\t        if (tag == mapTag) {\n\t          return mapToArray(object);\n\t        }\n\t        if (tag == setTag) {\n\t          return setToPairs(object);\n\t        }\n\t        return baseToPairs(object, keysFunc(object));\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that either curries or invokes `func` with optional\n\t     * `this` binding and partially applied arguments.\n\t     *\n\t     * @private\n\t     * @param {Function|string} func The function or method name to wrap.\n\t     * @param {number} bitmask The bitmask flags.\n\t     *    1 - `_.bind`\n\t     *    2 - `_.bindKey`\n\t     *    4 - `_.curry` or `_.curryRight` of a bound function\n\t     *    8 - `_.curry`\n\t     *   16 - `_.curryRight`\n\t     *   32 - `_.partial`\n\t     *   64 - `_.partialRight`\n\t     *  128 - `_.rearg`\n\t     *  256 - `_.ary`\n\t     *  512 - `_.flip`\n\t     * @param {*} [thisArg] The `this` binding of `func`.\n\t     * @param {Array} [partials] The arguments to be partially applied.\n\t     * @param {Array} [holders] The `partials` placeholder indexes.\n\t     * @param {Array} [argPos] The argument positions of the new function.\n\t     * @param {number} [ary] The arity cap of `func`.\n\t     * @param {number} [arity] The arity of `func`.\n\t     * @returns {Function} Returns the new wrapped function.\n\t     */\n\t    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {\n\t      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;\n\t      if (!isBindKey && typeof func != 'function') {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      var length = partials ? partials.length : 0;\n\t      if (!length) {\n\t        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);\n\t        partials = holders = undefined;\n\t      }\n\t      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);\n\t      arity = arity === undefined ? arity : toInteger(arity);\n\t      length -= holders ? holders.length : 0;\n\t\n\t      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {\n\t        var partialsRight = partials,\n\t            holdersRight = holders;\n\t\n\t        partials = holders = undefined;\n\t      }\n\t      var data = isBindKey ? undefined : getData(func);\n\t\n\t      var newData = [\n\t        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,\n\t        argPos, ary, arity\n\t      ];\n\t\n\t      if (data) {\n\t        mergeData(newData, data);\n\t      }\n\t      func = newData[0];\n\t      bitmask = newData[1];\n\t      thisArg = newData[2];\n\t      partials = newData[3];\n\t      holders = newData[4];\n\t      arity = newData[9] = newData[9] == null\n\t        ? (isBindKey ? 0 : func.length)\n\t        : nativeMax(newData[9] - length, 0);\n\t\n\t      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {\n\t        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);\n\t      }\n\t      if (!bitmask || bitmask == WRAP_BIND_FLAG) {\n\t        var result = createBind(func, bitmask, thisArg);\n\t      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {\n\t        result = createCurry(func, bitmask, arity);\n\t      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {\n\t        result = createPartial(func, bitmask, thisArg, partials);\n\t      } else {\n\t        result = createHybrid.apply(undefined, newData);\n\t      }\n\t      var setter = data ? baseSetData : setData;\n\t      return setWrapToString(setter(result, newData), func, bitmask);\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `baseIsEqualDeep` for arrays with support for\n\t     * partial deep comparisons.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to compare.\n\t     * @param {Array} other The other array to compare.\n\t     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n\t     * @param {Function} customizer The function to customize comparisons.\n\t     * @param {Function} equalFunc The function to determine equivalents of values.\n\t     * @param {Object} stack Tracks traversed `array` and `other` objects.\n\t     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n\t     */\n\t    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n\t      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n\t          arrLength = array.length,\n\t          othLength = other.length;\n\t\n\t      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n\t        return false;\n\t      }\n\t      // Assume cyclic values are equal.\n\t      var stacked = stack.get(array);\n\t      if (stacked && stack.get(other)) {\n\t        return stacked == other;\n\t      }\n\t      var index = -1,\n\t          result = true,\n\t          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\t\n\t      stack.set(array, other);\n\t      stack.set(other, array);\n\t\n\t      // Ignore non-index properties.\n\t      while (++index < arrLength) {\n\t        var arrValue = array[index],\n\t            othValue = other[index];\n\t\n\t        if (customizer) {\n\t          var compared = isPartial\n\t            ? customizer(othValue, arrValue, index, other, array, stack)\n\t            : customizer(arrValue, othValue, index, array, other, stack);\n\t        }\n\t        if (compared !== undefined) {\n\t          if (compared) {\n\t            continue;\n\t          }\n\t          result = false;\n\t          break;\n\t        }\n\t        // Recursively compare arrays (susceptible to call stack limits).\n\t        if (seen) {\n\t          if (!arraySome(other, function(othValue, othIndex) {\n\t                if (!cacheHas(seen, othIndex) &&\n\t                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n\t                  return seen.push(othIndex);\n\t                }\n\t              })) {\n\t            result = false;\n\t            break;\n\t          }\n\t        } else if (!(\n\t              arrValue === othValue ||\n\t                equalFunc(arrValue, othValue, bitmask, customizer, stack)\n\t            )) {\n\t          result = false;\n\t          break;\n\t        }\n\t      }\n\t      stack['delete'](array);\n\t      stack['delete'](other);\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `baseIsEqualDeep` for comparing objects of\n\t     * the same `toStringTag`.\n\t     *\n\t     * **Note:** This function only supports comparing values with tags of\n\t     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to compare.\n\t     * @param {Object} other The other object to compare.\n\t     * @param {string} tag The `toStringTag` of the objects to compare.\n\t     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n\t     * @param {Function} customizer The function to customize comparisons.\n\t     * @param {Function} equalFunc The function to determine equivalents of values.\n\t     * @param {Object} stack Tracks traversed `object` and `other` objects.\n\t     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n\t     */\n\t    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n\t      switch (tag) {\n\t        case dataViewTag:\n\t          if ((object.byteLength != other.byteLength) ||\n\t              (object.byteOffset != other.byteOffset)) {\n\t            return false;\n\t          }\n\t          object = object.buffer;\n\t          other = other.buffer;\n\t\n\t        case arrayBufferTag:\n\t          if ((object.byteLength != other.byteLength) ||\n\t              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n\t            return false;\n\t          }\n\t          return true;\n\t\n\t        case boolTag:\n\t        case dateTag:\n\t        case numberTag:\n\t          // Coerce booleans to `1` or `0` and dates to milliseconds.\n\t          // Invalid dates are coerced to `NaN`.\n\t          return eq(+object, +other);\n\t\n\t        case errorTag:\n\t          return object.name == other.name && object.message == other.message;\n\t\n\t        case regexpTag:\n\t        case stringTag:\n\t          // Coerce regexes to strings and treat strings, primitives and objects,\n\t          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n\t          // for more details.\n\t          return object == (other + '');\n\t\n\t        case mapTag:\n\t          var convert = mapToArray;\n\t\n\t        case setTag:\n\t          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n\t          convert || (convert = setToArray);\n\t\n\t          if (object.size != other.size && !isPartial) {\n\t            return false;\n\t          }\n\t          // Assume cyclic values are equal.\n\t          var stacked = stack.get(object);\n\t          if (stacked) {\n\t            return stacked == other;\n\t          }\n\t          bitmask |= COMPARE_UNORDERED_FLAG;\n\t\n\t          // Recursively compare objects (susceptible to call stack limits).\n\t          stack.set(object, other);\n\t          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n\t          stack['delete'](object);\n\t          return result;\n\t\n\t        case symbolTag:\n\t          if (symbolValueOf) {\n\t            return symbolValueOf.call(object) == symbolValueOf.call(other);\n\t          }\n\t      }\n\t      return false;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `baseIsEqualDeep` for objects with support for\n\t     * partial deep comparisons.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to compare.\n\t     * @param {Object} other The other object to compare.\n\t     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n\t     * @param {Function} customizer The function to customize comparisons.\n\t     * @param {Function} equalFunc The function to determine equivalents of values.\n\t     * @param {Object} stack Tracks traversed `object` and `other` objects.\n\t     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n\t     */\n\t    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n\t      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n\t          objProps = keys(object),\n\t          objLength = objProps.length,\n\t          othProps = keys(other),\n\t          othLength = othProps.length;\n\t\n\t      if (objLength != othLength && !isPartial) {\n\t        return false;\n\t      }\n\t      var index = objLength;\n\t      while (index--) {\n\t        var key = objProps[index];\n\t        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n\t          return false;\n\t        }\n\t      }\n\t      // Assume cyclic values are equal.\n\t      var stacked = stack.get(object);\n\t      if (stacked && stack.get(other)) {\n\t        return stacked == other;\n\t      }\n\t      var result = true;\n\t      stack.set(object, other);\n\t      stack.set(other, object);\n\t\n\t      var skipCtor = isPartial;\n\t      while (++index < objLength) {\n\t        key = objProps[index];\n\t        var objValue = object[key],\n\t            othValue = other[key];\n\t\n\t        if (customizer) {\n\t          var compared = isPartial\n\t            ? customizer(othValue, objValue, key, other, object, stack)\n\t            : customizer(objValue, othValue, key, object, other, stack);\n\t        }\n\t        // Recursively compare objects (susceptible to call stack limits).\n\t        if (!(compared === undefined\n\t              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n\t              : compared\n\t            )) {\n\t          result = false;\n\t          break;\n\t        }\n\t        skipCtor || (skipCtor = key == 'constructor');\n\t      }\n\t      if (result && !skipCtor) {\n\t        var objCtor = object.constructor,\n\t            othCtor = other.constructor;\n\t\n\t        // Non `Object` object instances with different constructors are not equal.\n\t        if (objCtor != othCtor &&\n\t            ('constructor' in object && 'constructor' in other) &&\n\t            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n\t              typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n\t          result = false;\n\t        }\n\t      }\n\t      stack['delete'](object);\n\t      stack['delete'](other);\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `baseRest` which flattens the rest array.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to apply a rest parameter to.\n\t     * @returns {Function} Returns the new function.\n\t     */\n\t    function flatRest(func) {\n\t      return setToString(overRest(func, undefined, flatten), func + '');\n\t    }\n\t\n\t    /**\n\t     * Creates an array of own enumerable property names and symbols of `object`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to query.\n\t     * @returns {Array} Returns the array of property names and symbols.\n\t     */\n\t    function getAllKeys(object) {\n\t      return baseGetAllKeys(object, keys, getSymbols);\n\t    }\n\t\n\t    /**\n\t     * Creates an array of own and inherited enumerable property names and\n\t     * symbols of `object`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to query.\n\t     * @returns {Array} Returns the array of property names and symbols.\n\t     */\n\t    function getAllKeysIn(object) {\n\t      return baseGetAllKeys(object, keysIn, getSymbolsIn);\n\t    }\n\t\n\t    /**\n\t     * Gets metadata for `func`.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to query.\n\t     * @returns {*} Returns the metadata for `func`.\n\t     */\n\t    var getData = !metaMap ? noop : function(func) {\n\t      return metaMap.get(func);\n\t    };\n\t\n\t    /**\n\t     * Gets the name of `func`.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to query.\n\t     * @returns {string} Returns the function name.\n\t     */\n\t    function getFuncName(func) {\n\t      var result = (func.name + ''),\n\t          array = realNames[result],\n\t          length = hasOwnProperty.call(realNames, result) ? array.length : 0;\n\t\n\t      while (length--) {\n\t        var data = array[length],\n\t            otherFunc = data.func;\n\t        if (otherFunc == null || otherFunc == func) {\n\t          return data.name;\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Gets the argument placeholder value for `func`.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to inspect.\n\t     * @returns {*} Returns the placeholder value.\n\t     */\n\t    function getHolder(func) {\n\t      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;\n\t      return object.placeholder;\n\t    }\n\t\n\t    /**\n\t     * Gets the appropriate \"iteratee\" function. If `_.iteratee` is customized,\n\t     * this function returns the custom method, otherwise it returns `baseIteratee`.\n\t     * If arguments are provided, the chosen function is invoked with them and\n\t     * its result is returned.\n\t     *\n\t     * @private\n\t     * @param {*} [value] The value to convert to an iteratee.\n\t     * @param {number} [arity] The arity of the created iteratee.\n\t     * @returns {Function} Returns the chosen function or its result.\n\t     */\n\t    function getIteratee() {\n\t      var result = lodash.iteratee || iteratee;\n\t      result = result === iteratee ? baseIteratee : result;\n\t      return arguments.length ? result(arguments[0], arguments[1]) : result;\n\t    }\n\t\n\t    /**\n\t     * Gets the data for `map`.\n\t     *\n\t     * @private\n\t     * @param {Object} map The map to query.\n\t     * @param {string} key The reference key.\n\t     * @returns {*} Returns the map data.\n\t     */\n\t    function getMapData(map, key) {\n\t      var data = map.__data__;\n\t      return isKeyable(key)\n\t        ? data[typeof key == 'string' ? 'string' : 'hash']\n\t        : data.map;\n\t    }\n\t\n\t    /**\n\t     * Gets the property names, values, and compare flags of `object`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to query.\n\t     * @returns {Array} Returns the match data of `object`.\n\t     */\n\t    function getMatchData(object) {\n\t      var result = keys(object),\n\t          length = result.length;\n\t\n\t      while (length--) {\n\t        var key = result[length],\n\t            value = object[key];\n\t\n\t        result[length] = [key, value, isStrictComparable(value)];\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Gets the native function at `key` of `object`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to query.\n\t     * @param {string} key The key of the method to get.\n\t     * @returns {*} Returns the function if it's native, else `undefined`.\n\t     */\n\t    function getNative(object, key) {\n\t      var value = getValue(object, key);\n\t      return baseIsNative(value) ? value : undefined;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to query.\n\t     * @returns {string} Returns the raw `toStringTag`.\n\t     */\n\t    function getRawTag(value) {\n\t      var isOwn = hasOwnProperty.call(value, symToStringTag),\n\t          tag = value[symToStringTag];\n\t\n\t      try {\n\t        value[symToStringTag] = undefined;\n\t        var unmasked = true;\n\t      } catch (e) {}\n\t\n\t      var result = nativeObjectToString.call(value);\n\t      if (unmasked) {\n\t        if (isOwn) {\n\t          value[symToStringTag] = tag;\n\t        } else {\n\t          delete value[symToStringTag];\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Creates an array of the own enumerable symbols of `object`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to query.\n\t     * @returns {Array} Returns the array of symbols.\n\t     */\n\t    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;\n\t\n\t    /**\n\t     * Creates an array of the own and inherited enumerable symbols of `object`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to query.\n\t     * @returns {Array} Returns the array of symbols.\n\t     */\n\t    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n\t      var result = [];\n\t      while (object) {\n\t        arrayPush(result, getSymbols(object));\n\t        object = getPrototype(object);\n\t      }\n\t      return result;\n\t    };\n\t\n\t    /**\n\t     * Gets the `toStringTag` of `value`.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to query.\n\t     * @returns {string} Returns the `toStringTag`.\n\t     */\n\t    var getTag = baseGetTag;\n\t\n\t    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\n\t    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n\t        (Map && getTag(new Map) != mapTag) ||\n\t        (Promise && getTag(Promise.resolve()) != promiseTag) ||\n\t        (Set && getTag(new Set) != setTag) ||\n\t        (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n\t      getTag = function(value) {\n\t        var result = baseGetTag(value),\n\t            Ctor = result == objectTag ? value.constructor : undefined,\n\t            ctorString = Ctor ? toSource(Ctor) : '';\n\t\n\t        if (ctorString) {\n\t          switch (ctorString) {\n\t            case dataViewCtorString: return dataViewTag;\n\t            case mapCtorString: return mapTag;\n\t            case promiseCtorString: return promiseTag;\n\t            case setCtorString: return setTag;\n\t            case weakMapCtorString: return weakMapTag;\n\t          }\n\t        }\n\t        return result;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Gets the view, applying any `transforms` to the `start` and `end` positions.\n\t     *\n\t     * @private\n\t     * @param {number} start The start of the view.\n\t     * @param {number} end The end of the view.\n\t     * @param {Array} transforms The transformations to apply to the view.\n\t     * @returns {Object} Returns an object containing the `start` and `end`\n\t     *  positions of the view.\n\t     */\n\t    function getView(start, end, transforms) {\n\t      var index = -1,\n\t          length = transforms.length;\n\t\n\t      while (++index < length) {\n\t        var data = transforms[index],\n\t            size = data.size;\n\t\n\t        switch (data.type) {\n\t          case 'drop':      start += size; break;\n\t          case 'dropRight': end -= size; break;\n\t          case 'take':      end = nativeMin(end, start + size); break;\n\t          case 'takeRight': start = nativeMax(start, end - size); break;\n\t        }\n\t      }\n\t      return { 'start': start, 'end': end };\n\t    }\n\t\n\t    /**\n\t     * Extracts wrapper details from the `source` body comment.\n\t     *\n\t     * @private\n\t     * @param {string} source The source to inspect.\n\t     * @returns {Array} Returns the wrapper details.\n\t     */\n\t    function getWrapDetails(source) {\n\t      var match = source.match(reWrapDetails);\n\t      return match ? match[1].split(reSplitDetails) : [];\n\t    }\n\t\n\t    /**\n\t     * Checks if `path` exists on `object`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to query.\n\t     * @param {Array|string} path The path to check.\n\t     * @param {Function} hasFunc The function to check properties.\n\t     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n\t     */\n\t    function hasPath(object, path, hasFunc) {\n\t      path = castPath(path, object);\n\t\n\t      var index = -1,\n\t          length = path.length,\n\t          result = false;\n\t\n\t      while (++index < length) {\n\t        var key = toKey(path[index]);\n\t        if (!(result = object != null && hasFunc(object, key))) {\n\t          break;\n\t        }\n\t        object = object[key];\n\t      }\n\t      if (result || ++index != length) {\n\t        return result;\n\t      }\n\t      length = object == null ? 0 : object.length;\n\t      return !!length && isLength(length) && isIndex(key, length) &&\n\t        (isArray(object) || isArguments(object));\n\t    }\n\t\n\t    /**\n\t     * Initializes an array clone.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to clone.\n\t     * @returns {Array} Returns the initialized clone.\n\t     */\n\t    function initCloneArray(array) {\n\t      var length = array.length,\n\t          result = array.constructor(length);\n\t\n\t      // Add properties assigned by `RegExp#exec`.\n\t      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n\t        result.index = array.index;\n\t        result.input = array.input;\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Initializes an object clone.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to clone.\n\t     * @returns {Object} Returns the initialized clone.\n\t     */\n\t    function initCloneObject(object) {\n\t      return (typeof object.constructor == 'function' && !isPrototype(object))\n\t        ? baseCreate(getPrototype(object))\n\t        : {};\n\t    }\n\t\n\t    /**\n\t     * Initializes an object clone based on its `toStringTag`.\n\t     *\n\t     * **Note:** This function only supports cloning values with tags of\n\t     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to clone.\n\t     * @param {string} tag The `toStringTag` of the object to clone.\n\t     * @param {Function} cloneFunc The function to clone values.\n\t     * @param {boolean} [isDeep] Specify a deep clone.\n\t     * @returns {Object} Returns the initialized clone.\n\t     */\n\t    function initCloneByTag(object, tag, cloneFunc, isDeep) {\n\t      var Ctor = object.constructor;\n\t      switch (tag) {\n\t        case arrayBufferTag:\n\t          return cloneArrayBuffer(object);\n\t\n\t        case boolTag:\n\t        case dateTag:\n\t          return new Ctor(+object);\n\t\n\t        case dataViewTag:\n\t          return cloneDataView(object, isDeep);\n\t\n\t        case float32Tag: case float64Tag:\n\t        case int8Tag: case int16Tag: case int32Tag:\n\t        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n\t          return cloneTypedArray(object, isDeep);\n\t\n\t        case mapTag:\n\t          return cloneMap(object, isDeep, cloneFunc);\n\t\n\t        case numberTag:\n\t        case stringTag:\n\t          return new Ctor(object);\n\t\n\t        case regexpTag:\n\t          return cloneRegExp(object);\n\t\n\t        case setTag:\n\t          return cloneSet(object, isDeep, cloneFunc);\n\t\n\t        case symbolTag:\n\t          return cloneSymbol(object);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Inserts wrapper `details` in a comment at the top of the `source` body.\n\t     *\n\t     * @private\n\t     * @param {string} source The source to modify.\n\t     * @returns {Array} details The details to insert.\n\t     * @returns {string} Returns the modified source.\n\t     */\n\t    function insertWrapDetails(source, details) {\n\t      var length = details.length;\n\t      if (!length) {\n\t        return source;\n\t      }\n\t      var lastIndex = length - 1;\n\t      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];\n\t      details = details.join(length > 2 ? ', ' : ' ');\n\t      return source.replace(reWrapComment, '{\\n/* [wrapped with ' + details + '] */\\n');\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is a flattenable `arguments` object or array.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n\t     */\n\t    function isFlattenable(value) {\n\t      return isArray(value) || isArguments(value) ||\n\t        !!(spreadableSymbol && value && value[spreadableSymbol]);\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is a valid array-like index.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to check.\n\t     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n\t     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n\t     */\n\t    function isIndex(value, length) {\n\t      length = length == null ? MAX_SAFE_INTEGER : length;\n\t      return !!length &&\n\t        (typeof value == 'number' || reIsUint.test(value)) &&\n\t        (value > -1 && value % 1 == 0 && value < length);\n\t    }\n\t\n\t    /**\n\t     * Checks if the given arguments are from an iteratee call.\n\t     *\n\t     * @private\n\t     * @param {*} value The potential iteratee value argument.\n\t     * @param {*} index The potential iteratee index or key argument.\n\t     * @param {*} object The potential iteratee object argument.\n\t     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n\t     *  else `false`.\n\t     */\n\t    function isIterateeCall(value, index, object) {\n\t      if (!isObject(object)) {\n\t        return false;\n\t      }\n\t      var type = typeof index;\n\t      if (type == 'number'\n\t            ? (isArrayLike(object) && isIndex(index, object.length))\n\t            : (type == 'string' && index in object)\n\t          ) {\n\t        return eq(object[index], value);\n\t      }\n\t      return false;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is a property name and not a property path.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to check.\n\t     * @param {Object} [object] The object to query keys on.\n\t     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n\t     */\n\t    function isKey(value, object) {\n\t      if (isArray(value)) {\n\t        return false;\n\t      }\n\t      var type = typeof value;\n\t      if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n\t          value == null || isSymbol(value)) {\n\t        return true;\n\t      }\n\t      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n\t        (object != null && value in Object(object));\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is suitable for use as unique object key.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n\t     */\n\t    function isKeyable(value) {\n\t      var type = typeof value;\n\t      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n\t        ? (value !== '__proto__')\n\t        : (value === null);\n\t    }\n\t\n\t    /**\n\t     * Checks if `func` has a lazy counterpart.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to check.\n\t     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,\n\t     *  else `false`.\n\t     */\n\t    function isLaziable(func) {\n\t      var funcName = getFuncName(func),\n\t          other = lodash[funcName];\n\t\n\t      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {\n\t        return false;\n\t      }\n\t      if (func === other) {\n\t        return true;\n\t      }\n\t      var data = getData(other);\n\t      return !!data && func === data[0];\n\t    }\n\t\n\t    /**\n\t     * Checks if `func` has its source masked.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to check.\n\t     * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n\t     */\n\t    function isMasked(func) {\n\t      return !!maskSrcKey && (maskSrcKey in func);\n\t    }\n\t\n\t    /**\n\t     * Checks if `func` is capable of being masked.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.\n\t     */\n\t    var isMaskable = coreJsData ? isFunction : stubFalse;\n\t\n\t    /**\n\t     * Checks if `value` is likely a prototype object.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n\t     */\n\t    function isPrototype(value) {\n\t      var Ctor = value && value.constructor,\n\t          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\t\n\t      return value === proto;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` if suitable for strict\n\t     *  equality comparisons, else `false`.\n\t     */\n\t    function isStrictComparable(value) {\n\t      return value === value && !isObject(value);\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `matchesProperty` for source values suitable\n\t     * for strict equality comparisons, i.e. `===`.\n\t     *\n\t     * @private\n\t     * @param {string} key The key of the property to get.\n\t     * @param {*} srcValue The value to match.\n\t     * @returns {Function} Returns the new spec function.\n\t     */\n\t    function matchesStrictComparable(key, srcValue) {\n\t      return function(object) {\n\t        if (object == null) {\n\t          return false;\n\t        }\n\t        return object[key] === srcValue &&\n\t          (srcValue !== undefined || (key in Object(object)));\n\t      };\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `_.memoize` which clears the memoized function's\n\t     * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to have its output memoized.\n\t     * @returns {Function} Returns the new memoized function.\n\t     */\n\t    function memoizeCapped(func) {\n\t      var result = memoize(func, function(key) {\n\t        if (cache.size === MAX_MEMOIZE_SIZE) {\n\t          cache.clear();\n\t        }\n\t        return key;\n\t      });\n\t\n\t      var cache = result.cache;\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Merges the function metadata of `source` into `data`.\n\t     *\n\t     * Merging metadata reduces the number of wrappers used to invoke a function.\n\t     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`\n\t     * may be applied regardless of execution order. Methods like `_.ary` and\n\t     * `_.rearg` modify function arguments, making the order in which they are\n\t     * executed important, preventing the merging of metadata. However, we make\n\t     * an exception for a safe combined case where curried functions have `_.ary`\n\t     * and or `_.rearg` applied.\n\t     *\n\t     * @private\n\t     * @param {Array} data The destination metadata.\n\t     * @param {Array} source The source metadata.\n\t     * @returns {Array} Returns `data`.\n\t     */\n\t    function mergeData(data, source) {\n\t      var bitmask = data[1],\n\t          srcBitmask = source[1],\n\t          newBitmask = bitmask | srcBitmask,\n\t          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);\n\t\n\t      var isCombo =\n\t        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||\n\t        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||\n\t        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));\n\t\n\t      // Exit early if metadata can't be merged.\n\t      if (!(isCommon || isCombo)) {\n\t        return data;\n\t      }\n\t      // Use source `thisArg` if available.\n\t      if (srcBitmask & WRAP_BIND_FLAG) {\n\t        data[2] = source[2];\n\t        // Set when currying a bound function.\n\t        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;\n\t      }\n\t      // Compose partial arguments.\n\t      var value = source[3];\n\t      if (value) {\n\t        var partials = data[3];\n\t        data[3] = partials ? composeArgs(partials, value, source[4]) : value;\n\t        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];\n\t      }\n\t      // Compose partial right arguments.\n\t      value = source[5];\n\t      if (value) {\n\t        partials = data[5];\n\t        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;\n\t        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];\n\t      }\n\t      // Use source `argPos` if available.\n\t      value = source[7];\n\t      if (value) {\n\t        data[7] = value;\n\t      }\n\t      // Use source `ary` if it's smaller.\n\t      if (srcBitmask & WRAP_ARY_FLAG) {\n\t        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);\n\t      }\n\t      // Use source `arity` if one is not provided.\n\t      if (data[9] == null) {\n\t        data[9] = source[9];\n\t      }\n\t      // Use source `func` and merge bitmasks.\n\t      data[0] = source[0];\n\t      data[1] = newBitmask;\n\t\n\t      return data;\n\t    }\n\t\n\t    /**\n\t     * Used by `_.defaultsDeep` to customize its `_.merge` use.\n\t     *\n\t     * @private\n\t     * @param {*} objValue The destination value.\n\t     * @param {*} srcValue The source value.\n\t     * @param {string} key The key of the property to merge.\n\t     * @param {Object} object The parent object of `objValue`.\n\t     * @param {Object} source The parent object of `srcValue`.\n\t     * @param {Object} [stack] Tracks traversed source values and their merged\n\t     *  counterparts.\n\t     * @returns {*} Returns the value to assign.\n\t     */\n\t    function mergeDefaults(objValue, srcValue, key, object, source, stack) {\n\t      if (isObject(objValue) && isObject(srcValue)) {\n\t        // Recursively merge objects and arrays (susceptible to call stack limits).\n\t        stack.set(srcValue, objValue);\n\t        baseMerge(objValue, srcValue, undefined, mergeDefaults, stack);\n\t        stack['delete'](srcValue);\n\t      }\n\t      return objValue;\n\t    }\n\t\n\t    /**\n\t     * This function is like\n\t     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n\t     * except that it includes inherited enumerable properties.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to query.\n\t     * @returns {Array} Returns the array of property names.\n\t     */\n\t    function nativeKeysIn(object) {\n\t      var result = [];\n\t      if (object != null) {\n\t        for (var key in Object(object)) {\n\t          result.push(key);\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Converts `value` to a string using `Object.prototype.toString`.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to convert.\n\t     * @returns {string} Returns the converted string.\n\t     */\n\t    function objectToString(value) {\n\t      return nativeObjectToString.call(value);\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `baseRest` which transforms the rest array.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to apply a rest parameter to.\n\t     * @param {number} [start=func.length-1] The start position of the rest parameter.\n\t     * @param {Function} transform The rest array transform.\n\t     * @returns {Function} Returns the new function.\n\t     */\n\t    function overRest(func, start, transform) {\n\t      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n\t      return function() {\n\t        var args = arguments,\n\t            index = -1,\n\t            length = nativeMax(args.length - start, 0),\n\t            array = Array(length);\n\t\n\t        while (++index < length) {\n\t          array[index] = args[start + index];\n\t        }\n\t        index = -1;\n\t        var otherArgs = Array(start + 1);\n\t        while (++index < start) {\n\t          otherArgs[index] = args[index];\n\t        }\n\t        otherArgs[start] = transform(array);\n\t        return apply(func, this, otherArgs);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Gets the parent value at `path` of `object`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to query.\n\t     * @param {Array} path The path to get the parent value of.\n\t     * @returns {*} Returns the parent value.\n\t     */\n\t    function parent(object, path) {\n\t      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));\n\t    }\n\t\n\t    /**\n\t     * Reorder `array` according to the specified indexes where the element at\n\t     * the first index is assigned as the first element, the element at\n\t     * the second index is assigned as the second element, and so on.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to reorder.\n\t     * @param {Array} indexes The arranged array indexes.\n\t     * @returns {Array} Returns `array`.\n\t     */\n\t    function reorder(array, indexes) {\n\t      var arrLength = array.length,\n\t          length = nativeMin(indexes.length, arrLength),\n\t          oldArray = copyArray(array);\n\t\n\t      while (length--) {\n\t        var index = indexes[length];\n\t        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;\n\t      }\n\t      return array;\n\t    }\n\t\n\t    /**\n\t     * Sets metadata for `func`.\n\t     *\n\t     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short\n\t     * period of time, it will trip its breaker and transition to an identity\n\t     * function to avoid garbage collection pauses in V8. See\n\t     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)\n\t     * for more details.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to associate metadata with.\n\t     * @param {*} data The metadata.\n\t     * @returns {Function} Returns `func`.\n\t     */\n\t    var setData = shortOut(baseSetData);\n\t\n\t    /**\n\t     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to delay.\n\t     * @param {number} wait The number of milliseconds to delay invocation.\n\t     * @returns {number|Object} Returns the timer id or timeout object.\n\t     */\n\t    var setTimeout = ctxSetTimeout || function(func, wait) {\n\t      return root.setTimeout(func, wait);\n\t    };\n\t\n\t    /**\n\t     * Sets the `toString` method of `func` to return `string`.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to modify.\n\t     * @param {Function} string The `toString` result.\n\t     * @returns {Function} Returns `func`.\n\t     */\n\t    var setToString = shortOut(baseSetToString);\n\t\n\t    /**\n\t     * Sets the `toString` method of `wrapper` to mimic the source of `reference`\n\t     * with wrapper details in a comment at the top of the source body.\n\t     *\n\t     * @private\n\t     * @param {Function} wrapper The function to modify.\n\t     * @param {Function} reference The reference function.\n\t     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n\t     * @returns {Function} Returns `wrapper`.\n\t     */\n\t    function setWrapToString(wrapper, reference, bitmask) {\n\t      var source = (reference + '');\n\t      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));\n\t    }\n\t\n\t    /**\n\t     * Creates a function that'll short out and invoke `identity` instead\n\t     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n\t     * milliseconds.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to restrict.\n\t     * @returns {Function} Returns the new shortable function.\n\t     */\n\t    function shortOut(func) {\n\t      var count = 0,\n\t          lastCalled = 0;\n\t\n\t      return function() {\n\t        var stamp = nativeNow(),\n\t            remaining = HOT_SPAN - (stamp - lastCalled);\n\t\n\t        lastCalled = stamp;\n\t        if (remaining > 0) {\n\t          if (++count >= HOT_COUNT) {\n\t            return arguments[0];\n\t          }\n\t        } else {\n\t          count = 0;\n\t        }\n\t        return func.apply(undefined, arguments);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to shuffle.\n\t     * @param {number} [size=array.length] The size of `array`.\n\t     * @returns {Array} Returns `array`.\n\t     */\n\t    function shuffleSelf(array, size) {\n\t      var index = -1,\n\t          length = array.length,\n\t          lastIndex = length - 1;\n\t\n\t      size = size === undefined ? length : size;\n\t      while (++index < size) {\n\t        var rand = baseRandom(index, lastIndex),\n\t            value = array[rand];\n\t\n\t        array[rand] = array[index];\n\t        array[index] = value;\n\t      }\n\t      array.length = size;\n\t      return array;\n\t    }\n\t\n\t    /**\n\t     * Converts `string` to a property path array.\n\t     *\n\t     * @private\n\t     * @param {string} string The string to convert.\n\t     * @returns {Array} Returns the property path array.\n\t     */\n\t    var stringToPath = memoizeCapped(function(string) {\n\t      var result = [];\n\t      if (reLeadingDot.test(string)) {\n\t        result.push('');\n\t      }\n\t      string.replace(rePropName, function(match, number, quote, string) {\n\t        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n\t      });\n\t      return result;\n\t    });\n\t\n\t    /**\n\t     * Converts `value` to a string key if it's not a string or symbol.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to inspect.\n\t     * @returns {string|symbol} Returns the key.\n\t     */\n\t    function toKey(value) {\n\t      if (typeof value == 'string' || isSymbol(value)) {\n\t        return value;\n\t      }\n\t      var result = (value + '');\n\t      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n\t    }\n\t\n\t    /**\n\t     * Converts `func` to its source code.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to convert.\n\t     * @returns {string} Returns the source code.\n\t     */\n\t    function toSource(func) {\n\t      if (func != null) {\n\t        try {\n\t          return funcToString.call(func);\n\t        } catch (e) {}\n\t        try {\n\t          return (func + '');\n\t        } catch (e) {}\n\t      }\n\t      return '';\n\t    }\n\t\n\t    /**\n\t     * Updates wrapper `details` based on `bitmask` flags.\n\t     *\n\t     * @private\n\t     * @returns {Array} details The details to modify.\n\t     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n\t     * @returns {Array} Returns `details`.\n\t     */\n\t    function updateWrapDetails(details, bitmask) {\n\t      arrayEach(wrapFlags, function(pair) {\n\t        var value = '_.' + pair[0];\n\t        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {\n\t          details.push(value);\n\t        }\n\t      });\n\t      return details.sort();\n\t    }\n\t\n\t    /**\n\t     * Creates a clone of `wrapper`.\n\t     *\n\t     * @private\n\t     * @param {Object} wrapper The wrapper to clone.\n\t     * @returns {Object} Returns the cloned wrapper.\n\t     */\n\t    function wrapperClone(wrapper) {\n\t      if (wrapper instanceof LazyWrapper) {\n\t        return wrapper.clone();\n\t      }\n\t      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);\n\t      result.__actions__ = copyArray(wrapper.__actions__);\n\t      result.__index__  = wrapper.__index__;\n\t      result.__values__ = wrapper.__values__;\n\t      return result;\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Creates an array of elements split into groups the length of `size`.\n\t     * If `array` can't be split evenly, the final chunk will be the remaining\n\t     * elements.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category Array\n\t     * @param {Array} array The array to process.\n\t     * @param {number} [size=1] The length of each chunk\n\t     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n\t     * @returns {Array} Returns the new array of chunks.\n\t     * @example\n\t     *\n\t     * _.chunk(['a', 'b', 'c', 'd'], 2);\n\t     * // => [['a', 'b'], ['c', 'd']]\n\t     *\n\t     * _.chunk(['a', 'b', 'c', 'd'], 3);\n\t     * // => [['a', 'b', 'c'], ['d']]\n\t     */\n\t    function chunk(array, size, guard) {\n\t      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {\n\t        size = 1;\n\t      } else {\n\t        size = nativeMax(toInteger(size), 0);\n\t      }\n\t      var length = array == null ? 0 : array.length;\n\t      if (!length || size < 1) {\n\t        return [];\n\t      }\n\t      var index = 0,\n\t          resIndex = 0,\n\t          result = Array(nativeCeil(length / size));\n\t\n\t      while (index < length) {\n\t        result[resIndex++] = baseSlice(array, index, (index += size));\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Creates an array with all falsey values removed. The values `false`, `null`,\n\t     * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Array\n\t     * @param {Array} array The array to compact.\n\t     * @returns {Array} Returns the new array of filtered values.\n\t     * @example\n\t     *\n\t     * _.compact([0, 1, false, 2, '', 3]);\n\t     * // => [1, 2, 3]\n\t     */\n\t    function compact(array) {\n\t      var index = -1,\n\t          length = array == null ? 0 : array.length,\n\t          resIndex = 0,\n\t          result = [];\n\t\n\t      while (++index < length) {\n\t        var value = array[index];\n\t        if (value) {\n\t          result[resIndex++] = value;\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Creates a new array concatenating `array` with any additional arrays\n\t     * and/or values.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Array\n\t     * @param {Array} array The array to concatenate.\n\t     * @param {...*} [values] The values to concatenate.\n\t     * @returns {Array} Returns the new concatenated array.\n\t     * @example\n\t     *\n\t     * var array = [1];\n\t     * var other = _.concat(array, 2, [3], [[4]]);\n\t     *\n\t     * console.log(other);\n\t     * // => [1, 2, 3, [4]]\n\t     *\n\t     * console.log(array);\n\t     * // => [1]\n\t     */\n\t    function concat() {\n\t      var length = arguments.length;\n\t      if (!length) {\n\t        return [];\n\t      }\n\t      var args = Array(length - 1),\n\t          array = arguments[0],\n\t          index = length;\n\t\n\t      while (index--) {\n\t        args[index - 1] = arguments[index];\n\t      }\n\t      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));\n\t    }\n\t\n\t    /**\n\t     * Creates an array of `array` values not included in the other given arrays\n\t     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n\t     * for equality comparisons. The order and references of result values are\n\t     * determined by the first array.\n\t     *\n\t     * **Note:** Unlike `_.pullAll`, this method returns a new array.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Array\n\t     * @param {Array} array The array to inspect.\n\t     * @param {...Array} [values] The values to exclude.\n\t     * @returns {Array} Returns the new array of filtered values.\n\t     * @see _.without, _.xor\n\t     * @example\n\t     *\n\t     * _.difference([2, 1], [2, 3]);\n\t     * // => [1]\n\t     */\n\t    var difference = baseRest(function(array, values) {\n\t      return isArrayLikeObject(array)\n\t        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))\n\t        : [];\n\t    });\n\t\n\t    /**\n\t     * This method is like `_.difference` except that it accepts `iteratee` which\n\t     * is invoked for each element of `array` and `values` to generate the criterion\n\t     * by which they're compared. The order and references of result values are\n\t     * determined by the first array. The iteratee is invoked with one argument:\n\t     * (value).\n\t     *\n\t     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Array\n\t     * @param {Array} array The array to inspect.\n\t     * @param {...Array} [values] The values to exclude.\n\t     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n\t     * @returns {Array} Returns the new array of filtered values.\n\t     * @example\n\t     *\n\t     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n\t     * // => [1.2]\n\t     *\n\t     * // The `_.property` iteratee shorthand.\n\t     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');\n\t     * // => [{ 'x': 2 }]\n\t     */\n\t    var differenceBy = baseRest(function(array, values) {\n\t      var iteratee = last(values);\n\t      if (isArrayLikeObject(iteratee)) {\n\t        iteratee = undefined;\n\t      }\n\t      return isArrayLikeObject(array)\n\t        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))\n\t        : [];\n\t    });\n\t\n\t    /**\n\t     * This method is like `_.difference` except that it accepts `comparator`\n\t     * which is invoked to compare elements of `array` to `values`. The order and\n\t     * references of result values are determined by the first array. The comparator\n\t     * is invoked with two arguments: (arrVal, othVal).\n\t     *\n\t     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Array\n\t     * @param {Array} array The array to inspect.\n\t     * @param {...Array} [values] The values to exclude.\n\t     * @param {Function} [comparator] The comparator invoked per element.\n\t     * @returns {Array} Returns the new array of filtered values.\n\t     * @example\n\t     *\n\t     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n\t     *\n\t     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);\n\t     * // => [{ 'x': 2, 'y': 1 }]\n\t     */\n\t    var differenceWith = baseRest(function(array, values) {\n\t      var comparator = last(values);\n\t      if (isArrayLikeObject(comparator)) {\n\t        comparator = undefined;\n\t      }\n\t      return isArrayLikeObject(array)\n\t        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)\n\t        : [];\n\t    });\n\t\n\t    /**\n\t     * Creates a slice of `array` with `n` elements dropped from the beginning.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.5.0\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @param {number} [n=1] The number of elements to drop.\n\t     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * _.drop([1, 2, 3]);\n\t     * // => [2, 3]\n\t     *\n\t     * _.drop([1, 2, 3], 2);\n\t     * // => [3]\n\t     *\n\t     * _.drop([1, 2, 3], 5);\n\t     * // => []\n\t     *\n\t     * _.drop([1, 2, 3], 0);\n\t     * // => [1, 2, 3]\n\t     */\n\t    function drop(array, n, guard) {\n\t      var length = array == null ? 0 : array.length;\n\t      if (!length) {\n\t        return [];\n\t      }\n\t      n = (guard || n === undefined) ? 1 : toInteger(n);\n\t      return baseSlice(array, n < 0 ? 0 : n, length);\n\t    }\n\t\n\t    /**\n\t     * Creates a slice of `array` with `n` elements dropped from the end.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @param {number} [n=1] The number of elements to drop.\n\t     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * _.dropRight([1, 2, 3]);\n\t     * // => [1, 2]\n\t     *\n\t     * _.dropRight([1, 2, 3], 2);\n\t     * // => [1]\n\t     *\n\t     * _.dropRight([1, 2, 3], 5);\n\t     * // => []\n\t     *\n\t     * _.dropRight([1, 2, 3], 0);\n\t     * // => [1, 2, 3]\n\t     */\n\t    function dropRight(array, n, guard) {\n\t      var length = array == null ? 0 : array.length;\n\t      if (!length) {\n\t        return [];\n\t      }\n\t      n = (guard || n === undefined) ? 1 : toInteger(n);\n\t      n = length - n;\n\t      return baseSlice(array, 0, n < 0 ? 0 : n);\n\t    }\n\t\n\t    /**\n\t     * Creates a slice of `array` excluding elements dropped from the end.\n\t     * Elements are dropped until `predicate` returns falsey. The predicate is\n\t     * invoked with three arguments: (value, index, array).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney',  'active': true },\n\t     *   { 'user': 'fred',    'active': false },\n\t     *   { 'user': 'pebbles', 'active': false }\n\t     * ];\n\t     *\n\t     * _.dropRightWhile(users, function(o) { return !o.active; });\n\t     * // => objects for ['barney']\n\t     *\n\t     * // The `_.matches` iteratee shorthand.\n\t     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });\n\t     * // => objects for ['barney', 'fred']\n\t     *\n\t     * // The `_.matchesProperty` iteratee shorthand.\n\t     * _.dropRightWhile(users, ['active', false]);\n\t     * // => objects for ['barney']\n\t     *\n\t     * // The `_.property` iteratee shorthand.\n\t     * _.dropRightWhile(users, 'active');\n\t     * // => objects for ['barney', 'fred', 'pebbles']\n\t     */\n\t    function dropRightWhile(array, predicate) {\n\t      return (array && array.length)\n\t        ? baseWhile(array, getIteratee(predicate, 3), true, true)\n\t        : [];\n\t    }\n\t\n\t    /**\n\t     * Creates a slice of `array` excluding elements dropped from the beginning.\n\t     * Elements are dropped until `predicate` returns falsey. The predicate is\n\t     * invoked with three arguments: (value, index, array).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney',  'active': false },\n\t     *   { 'user': 'fred',    'active': false },\n\t     *   { 'user': 'pebbles', 'active': true }\n\t     * ];\n\t     *\n\t     * _.dropWhile(users, function(o) { return !o.active; });\n\t     * // => objects for ['pebbles']\n\t     *\n\t     * // The `_.matches` iteratee shorthand.\n\t     * _.dropWhile(users, { 'user': 'barney', 'active': false });\n\t     * // => objects for ['fred', 'pebbles']\n\t     *\n\t     * // The `_.matchesProperty` iteratee shorthand.\n\t     * _.dropWhile(users, ['active', false]);\n\t     * // => objects for ['pebbles']\n\t     *\n\t     * // The `_.property` iteratee shorthand.\n\t     * _.dropWhile(users, 'active');\n\t     * // => objects for ['barney', 'fred', 'pebbles']\n\t     */\n\t    function dropWhile(array, predicate) {\n\t      return (array && array.length)\n\t        ? baseWhile(array, getIteratee(predicate, 3), true)\n\t        : [];\n\t    }\n\t\n\t    /**\n\t     * Fills elements of `array` with `value` from `start` up to, but not\n\t     * including, `end`.\n\t     *\n\t     * **Note:** This method mutates `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.2.0\n\t     * @category Array\n\t     * @param {Array} array The array to fill.\n\t     * @param {*} value The value to fill `array` with.\n\t     * @param {number} [start=0] The start position.\n\t     * @param {number} [end=array.length] The end position.\n\t     * @returns {Array} Returns `array`.\n\t     * @example\n\t     *\n\t     * var array = [1, 2, 3];\n\t     *\n\t     * _.fill(array, 'a');\n\t     * console.log(array);\n\t     * // => ['a', 'a', 'a']\n\t     *\n\t     * _.fill(Array(3), 2);\n\t     * // => [2, 2, 2]\n\t     *\n\t     * _.fill([4, 6, 8, 10], '*', 1, 3);\n\t     * // => [4, '*', '*', 10]\n\t     */\n\t    function fill(array, value, start, end) {\n\t      var length = array == null ? 0 : array.length;\n\t      if (!length) {\n\t        return [];\n\t      }\n\t      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {\n\t        start = 0;\n\t        end = length;\n\t      }\n\t      return baseFill(array, value, start, end);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.find` except that it returns the index of the first\n\t     * element `predicate` returns truthy for instead of the element itself.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 1.1.0\n\t     * @category Array\n\t     * @param {Array} array The array to inspect.\n\t     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n\t     * @param {number} [fromIndex=0] The index to search from.\n\t     * @returns {number} Returns the index of the found element, else `-1`.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney',  'active': false },\n\t     *   { 'user': 'fred',    'active': false },\n\t     *   { 'user': 'pebbles', 'active': true }\n\t     * ];\n\t     *\n\t     * _.findIndex(users, function(o) { return o.user == 'barney'; });\n\t     * // => 0\n\t     *\n\t     * // The `_.matches` iteratee shorthand.\n\t     * _.findIndex(users, { 'user': 'fred', 'active': false });\n\t     * // => 1\n\t     *\n\t     * // The `_.matchesProperty` iteratee shorthand.\n\t     * _.findIndex(users, ['active', false]);\n\t     * // => 0\n\t     *\n\t     * // The `_.property` iteratee shorthand.\n\t     * _.findIndex(users, 'active');\n\t     * // => 2\n\t     */\n\t    function findIndex(array, predicate, fromIndex) {\n\t      var length = array == null ? 0 : array.length;\n\t      if (!length) {\n\t        return -1;\n\t      }\n\t      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n\t      if (index < 0) {\n\t        index = nativeMax(length + index, 0);\n\t      }\n\t      return baseFindIndex(array, getIteratee(predicate, 3), index);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.findIndex` except that it iterates over elements\n\t     * of `collection` from right to left.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 2.0.0\n\t     * @category Array\n\t     * @param {Array} array The array to inspect.\n\t     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n\t     * @param {number} [fromIndex=array.length-1] The index to search from.\n\t     * @returns {number} Returns the index of the found element, else `-1`.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney',  'active': true },\n\t     *   { 'user': 'fred',    'active': false },\n\t     *   { 'user': 'pebbles', 'active': false }\n\t     * ];\n\t     *\n\t     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });\n\t     * // => 2\n\t     *\n\t     * // The `_.matches` iteratee shorthand.\n\t     * _.findLastIndex(users, { 'user': 'barney', 'active': true });\n\t     * // => 0\n\t     *\n\t     * // The `_.matchesProperty` iteratee shorthand.\n\t     * _.findLastIndex(users, ['active', false]);\n\t     * // => 2\n\t     *\n\t     * // The `_.property` iteratee shorthand.\n\t     * _.findLastIndex(users, 'active');\n\t     * // => 0\n\t     */\n\t    function findLastIndex(array, predicate, fromIndex) {\n\t      var length = array == null ? 0 : array.length;\n\t      if (!length) {\n\t        return -1;\n\t      }\n\t      var index = length - 1;\n\t      if (fromIndex !== undefined) {\n\t        index = toInteger(fromIndex);\n\t        index = fromIndex < 0\n\t          ? nativeMax(length + index, 0)\n\t          : nativeMin(index, length - 1);\n\t      }\n\t      return baseFindIndex(array, getIteratee(predicate, 3), index, true);\n\t    }\n\t\n\t    /**\n\t     * Flattens `array` a single level deep.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Array\n\t     * @param {Array} array The array to flatten.\n\t     * @returns {Array} Returns the new flattened array.\n\t     * @example\n\t     *\n\t     * _.flatten([1, [2, [3, [4]], 5]]);\n\t     * // => [1, 2, [3, [4]], 5]\n\t     */\n\t    function flatten(array) {\n\t      var length = array == null ? 0 : array.length;\n\t      return length ? baseFlatten(array, 1) : [];\n\t    }\n\t\n\t    /**\n\t     * Recursively flattens `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category Array\n\t     * @param {Array} array The array to flatten.\n\t     * @returns {Array} Returns the new flattened array.\n\t     * @example\n\t     *\n\t     * _.flattenDeep([1, [2, [3, [4]], 5]]);\n\t     * // => [1, 2, 3, 4, 5]\n\t     */\n\t    function flattenDeep(array) {\n\t      var length = array == null ? 0 : array.length;\n\t      return length ? baseFlatten(array, INFINITY) : [];\n\t    }\n\t\n\t    /**\n\t     * Recursively flatten `array` up to `depth` times.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.4.0\n\t     * @category Array\n\t     * @param {Array} array The array to flatten.\n\t     * @param {number} [depth=1] The maximum recursion depth.\n\t     * @returns {Array} Returns the new flattened array.\n\t     * @example\n\t     *\n\t     * var array = [1, [2, [3, [4]], 5]];\n\t     *\n\t     * _.flattenDepth(array, 1);\n\t     * // => [1, 2, [3, [4]], 5]\n\t     *\n\t     * _.flattenDepth(array, 2);\n\t     * // => [1, 2, 3, [4], 5]\n\t     */\n\t    function flattenDepth(array, depth) {\n\t      var length = array == null ? 0 : array.length;\n\t      if (!length) {\n\t        return [];\n\t      }\n\t      depth = depth === undefined ? 1 : toInteger(depth);\n\t      return baseFlatten(array, depth);\n\t    }\n\t\n\t    /**\n\t     * The inverse of `_.toPairs`; this method returns an object composed\n\t     * from key-value `pairs`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Array\n\t     * @param {Array} pairs The key-value pairs.\n\t     * @returns {Object} Returns the new object.\n\t     * @example\n\t     *\n\t     * _.fromPairs([['a', 1], ['b', 2]]);\n\t     * // => { 'a': 1, 'b': 2 }\n\t     */\n\t    function fromPairs(pairs) {\n\t      var index = -1,\n\t          length = pairs == null ? 0 : pairs.length,\n\t          result = {};\n\t\n\t      while (++index < length) {\n\t        var pair = pairs[index];\n\t        result[pair[0]] = pair[1];\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Gets the first element of `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @alias first\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @returns {*} Returns the first element of `array`.\n\t     * @example\n\t     *\n\t     * _.head([1, 2, 3]);\n\t     * // => 1\n\t     *\n\t     * _.head([]);\n\t     * // => undefined\n\t     */\n\t    function head(array) {\n\t      return (array && array.length) ? array[0] : undefined;\n\t    }\n\t\n\t    /**\n\t     * Gets the index at which the first occurrence of `value` is found in `array`\n\t     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n\t     * for equality comparisons. If `fromIndex` is negative, it's used as the\n\t     * offset from the end of `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Array\n\t     * @param {Array} array The array to inspect.\n\t     * @param {*} value The value to search for.\n\t     * @param {number} [fromIndex=0] The index to search from.\n\t     * @returns {number} Returns the index of the matched value, else `-1`.\n\t     * @example\n\t     *\n\t     * _.indexOf([1, 2, 1, 2], 2);\n\t     * // => 1\n\t     *\n\t     * // Search from the `fromIndex`.\n\t     * _.indexOf([1, 2, 1, 2], 2, 2);\n\t     * // => 3\n\t     */\n\t    function indexOf(array, value, fromIndex) {\n\t      var length = array == null ? 0 : array.length;\n\t      if (!length) {\n\t        return -1;\n\t      }\n\t      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n\t      if (index < 0) {\n\t        index = nativeMax(length + index, 0);\n\t      }\n\t      return baseIndexOf(array, value, index);\n\t    }\n\t\n\t    /**\n\t     * Gets all but the last element of `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * _.initial([1, 2, 3]);\n\t     * // => [1, 2]\n\t     */\n\t    function initial(array) {\n\t      var length = array == null ? 0 : array.length;\n\t      return length ? baseSlice(array, 0, -1) : [];\n\t    }\n\t\n\t    /**\n\t     * Creates an array of unique values that are included in all given arrays\n\t     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n\t     * for equality comparisons. The order and references of result values are\n\t     * determined by the first array.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Array\n\t     * @param {...Array} [arrays] The arrays to inspect.\n\t     * @returns {Array} Returns the new array of intersecting values.\n\t     * @example\n\t     *\n\t     * _.intersection([2, 1], [2, 3]);\n\t     * // => [2]\n\t     */\n\t    var intersection = baseRest(function(arrays) {\n\t      var mapped = arrayMap(arrays, castArrayLikeObject);\n\t      return (mapped.length && mapped[0] === arrays[0])\n\t        ? baseIntersection(mapped)\n\t        : [];\n\t    });\n\t\n\t    /**\n\t     * This method is like `_.intersection` except that it accepts `iteratee`\n\t     * which is invoked for each element of each `arrays` to generate the criterion\n\t     * by which they're compared. The order and references of result values are\n\t     * determined by the first array. The iteratee is invoked with one argument:\n\t     * (value).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Array\n\t     * @param {...Array} [arrays] The arrays to inspect.\n\t     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n\t     * @returns {Array} Returns the new array of intersecting values.\n\t     * @example\n\t     *\n\t     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n\t     * // => [2.1]\n\t     *\n\t     * // The `_.property` iteratee shorthand.\n\t     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n\t     * // => [{ 'x': 1 }]\n\t     */\n\t    var intersectionBy = baseRest(function(arrays) {\n\t      var iteratee = last(arrays),\n\t          mapped = arrayMap(arrays, castArrayLikeObject);\n\t\n\t      if (iteratee === last(mapped)) {\n\t        iteratee = undefined;\n\t      } else {\n\t        mapped.pop();\n\t      }\n\t      return (mapped.length && mapped[0] === arrays[0])\n\t        ? baseIntersection(mapped, getIteratee(iteratee, 2))\n\t        : [];\n\t    });\n\t\n\t    /**\n\t     * This method is like `_.intersection` except that it accepts `comparator`\n\t     * which is invoked to compare elements of `arrays`. The order and references\n\t     * of result values are determined by the first array. The comparator is\n\t     * invoked with two arguments: (arrVal, othVal).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Array\n\t     * @param {...Array} [arrays] The arrays to inspect.\n\t     * @param {Function} [comparator] The comparator invoked per element.\n\t     * @returns {Array} Returns the new array of intersecting values.\n\t     * @example\n\t     *\n\t     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n\t     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n\t     *\n\t     * _.intersectionWith(objects, others, _.isEqual);\n\t     * // => [{ 'x': 1, 'y': 2 }]\n\t     */\n\t    var intersectionWith = baseRest(function(arrays) {\n\t      var comparator = last(arrays),\n\t          mapped = arrayMap(arrays, castArrayLikeObject);\n\t\n\t      comparator = typeof comparator == 'function' ? comparator : undefined;\n\t      if (comparator) {\n\t        mapped.pop();\n\t      }\n\t      return (mapped.length && mapped[0] === arrays[0])\n\t        ? baseIntersection(mapped, undefined, comparator)\n\t        : [];\n\t    });\n\t\n\t    /**\n\t     * Converts all elements in `array` into a string separated by `separator`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Array\n\t     * @param {Array} array The array to convert.\n\t     * @param {string} [separator=','] The element separator.\n\t     * @returns {string} Returns the joined string.\n\t     * @example\n\t     *\n\t     * _.join(['a', 'b', 'c'], '~');\n\t     * // => 'a~b~c'\n\t     */\n\t    function join(array, separator) {\n\t      return array == null ? '' : nativeJoin.call(array, separator);\n\t    }\n\t\n\t    /**\n\t     * Gets the last element of `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @returns {*} Returns the last element of `array`.\n\t     * @example\n\t     *\n\t     * _.last([1, 2, 3]);\n\t     * // => 3\n\t     */\n\t    function last(array) {\n\t      var length = array == null ? 0 : array.length;\n\t      return length ? array[length - 1] : undefined;\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.indexOf` except that it iterates over elements of\n\t     * `array` from right to left.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Array\n\t     * @param {Array} array The array to inspect.\n\t     * @param {*} value The value to search for.\n\t     * @param {number} [fromIndex=array.length-1] The index to search from.\n\t     * @returns {number} Returns the index of the matched value, else `-1`.\n\t     * @example\n\t     *\n\t     * _.lastIndexOf([1, 2, 1, 2], 2);\n\t     * // => 3\n\t     *\n\t     * // Search from the `fromIndex`.\n\t     * _.lastIndexOf([1, 2, 1, 2], 2, 2);\n\t     * // => 1\n\t     */\n\t    function lastIndexOf(array, value, fromIndex) {\n\t      var length = array == null ? 0 : array.length;\n\t      if (!length) {\n\t        return -1;\n\t      }\n\t      var index = length;\n\t      if (fromIndex !== undefined) {\n\t        index = toInteger(fromIndex);\n\t        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);\n\t      }\n\t      return value === value\n\t        ? strictLastIndexOf(array, value, index)\n\t        : baseFindIndex(array, baseIsNaN, index, true);\n\t    }\n\t\n\t    /**\n\t     * Gets the element at index `n` of `array`. If `n` is negative, the nth\n\t     * element from the end is returned.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.11.0\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @param {number} [n=0] The index of the element to return.\n\t     * @returns {*} Returns the nth element of `array`.\n\t     * @example\n\t     *\n\t     * var array = ['a', 'b', 'c', 'd'];\n\t     *\n\t     * _.nth(array, 1);\n\t     * // => 'b'\n\t     *\n\t     * _.nth(array, -2);\n\t     * // => 'c';\n\t     */\n\t    function nth(array, n) {\n\t      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;\n\t    }\n\t\n\t    /**\n\t     * Removes all given values from `array` using\n\t     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n\t     * for equality comparisons.\n\t     *\n\t     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`\n\t     * to remove elements from an array by predicate.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 2.0.0\n\t     * @category Array\n\t     * @param {Array} array The array to modify.\n\t     * @param {...*} [values] The values to remove.\n\t     * @returns {Array} Returns `array`.\n\t     * @example\n\t     *\n\t     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n\t     *\n\t     * _.pull(array, 'a', 'c');\n\t     * console.log(array);\n\t     * // => ['b', 'b']\n\t     */\n\t    var pull = baseRest(pullAll);\n\t\n\t    /**\n\t     * This method is like `_.pull` except that it accepts an array of values to remove.\n\t     *\n\t     * **Note:** Unlike `_.difference`, this method mutates `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Array\n\t     * @param {Array} array The array to modify.\n\t     * @param {Array} values The values to remove.\n\t     * @returns {Array} Returns `array`.\n\t     * @example\n\t     *\n\t     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n\t     *\n\t     * _.pullAll(array, ['a', 'c']);\n\t     * console.log(array);\n\t     * // => ['b', 'b']\n\t     */\n\t    function pullAll(array, values) {\n\t      return (array && array.length && values && values.length)\n\t        ? basePullAll(array, values)\n\t        : array;\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.pullAll` except that it accepts `iteratee` which is\n\t     * invoked for each element of `array` and `values` to generate the criterion\n\t     * by which they're compared. The iteratee is invoked with one argument: (value).\n\t     *\n\t     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Array\n\t     * @param {Array} array The array to modify.\n\t     * @param {Array} values The values to remove.\n\t     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n\t     * @returns {Array} Returns `array`.\n\t     * @example\n\t     *\n\t     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];\n\t     *\n\t     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');\n\t     * console.log(array);\n\t     * // => [{ 'x': 2 }]\n\t     */\n\t    function pullAllBy(array, values, iteratee) {\n\t      return (array && array.length && values && values.length)\n\t        ? basePullAll(array, values, getIteratee(iteratee, 2))\n\t        : array;\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.pullAll` except that it accepts `comparator` which\n\t     * is invoked to compare elements of `array` to `values`. The comparator is\n\t     * invoked with two arguments: (arrVal, othVal).\n\t     *\n\t     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.6.0\n\t     * @category Array\n\t     * @param {Array} array The array to modify.\n\t     * @param {Array} values The values to remove.\n\t     * @param {Function} [comparator] The comparator invoked per element.\n\t     * @returns {Array} Returns `array`.\n\t     * @example\n\t     *\n\t     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];\n\t     *\n\t     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);\n\t     * console.log(array);\n\t     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]\n\t     */\n\t    function pullAllWith(array, values, comparator) {\n\t      return (array && array.length && values && values.length)\n\t        ? basePullAll(array, values, undefined, comparator)\n\t        : array;\n\t    }\n\t\n\t    /**\n\t     * Removes elements from `array` corresponding to `indexes` and returns an\n\t     * array of removed elements.\n\t     *\n\t     * **Note:** Unlike `_.at`, this method mutates `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category Array\n\t     * @param {Array} array The array to modify.\n\t     * @param {...(number|number[])} [indexes] The indexes of elements to remove.\n\t     * @returns {Array} Returns the new array of removed elements.\n\t     * @example\n\t     *\n\t     * var array = ['a', 'b', 'c', 'd'];\n\t     * var pulled = _.pullAt(array, [1, 3]);\n\t     *\n\t     * console.log(array);\n\t     * // => ['a', 'c']\n\t     *\n\t     * console.log(pulled);\n\t     * // => ['b', 'd']\n\t     */\n\t    var pullAt = flatRest(function(array, indexes) {\n\t      var length = array == null ? 0 : array.length,\n\t          result = baseAt(array, indexes);\n\t\n\t      basePullAt(array, arrayMap(indexes, function(index) {\n\t        return isIndex(index, length) ? +index : index;\n\t      }).sort(compareAscending));\n\t\n\t      return result;\n\t    });\n\t\n\t    /**\n\t     * Removes all elements from `array` that `predicate` returns truthy for\n\t     * and returns an array of the removed elements. The predicate is invoked\n\t     * with three arguments: (value, index, array).\n\t     *\n\t     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`\n\t     * to pull elements from an array by value.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 2.0.0\n\t     * @category Array\n\t     * @param {Array} array The array to modify.\n\t     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n\t     * @returns {Array} Returns the new array of removed elements.\n\t     * @example\n\t     *\n\t     * var array = [1, 2, 3, 4];\n\t     * var evens = _.remove(array, function(n) {\n\t     *   return n % 2 == 0;\n\t     * });\n\t     *\n\t     * console.log(array);\n\t     * // => [1, 3]\n\t     *\n\t     * console.log(evens);\n\t     * // => [2, 4]\n\t     */\n\t    function remove(array, predicate) {\n\t      var result = [];\n\t      if (!(array && array.length)) {\n\t        return result;\n\t      }\n\t      var index = -1,\n\t          indexes = [],\n\t          length = array.length;\n\t\n\t      predicate = getIteratee(predicate, 3);\n\t      while (++index < length) {\n\t        var value = array[index];\n\t        if (predicate(value, index, array)) {\n\t          result.push(value);\n\t          indexes.push(index);\n\t        }\n\t      }\n\t      basePullAt(array, indexes);\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Reverses `array` so that the first element becomes the last, the second\n\t     * element becomes the second to last, and so on.\n\t     *\n\t     * **Note:** This method mutates `array` and is based on\n\t     * [`Array#reverse`](https://mdn.io/Array/reverse).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Array\n\t     * @param {Array} array The array to modify.\n\t     * @returns {Array} Returns `array`.\n\t     * @example\n\t     *\n\t     * var array = [1, 2, 3];\n\t     *\n\t     * _.reverse(array);\n\t     * // => [3, 2, 1]\n\t     *\n\t     * console.log(array);\n\t     * // => [3, 2, 1]\n\t     */\n\t    function reverse(array) {\n\t      return array == null ? array : nativeReverse.call(array);\n\t    }\n\t\n\t    /**\n\t     * Creates a slice of `array` from `start` up to, but not including, `end`.\n\t     *\n\t     * **Note:** This method is used instead of\n\t     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are\n\t     * returned.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category Array\n\t     * @param {Array} array The array to slice.\n\t     * @param {number} [start=0] The start position.\n\t     * @param {number} [end=array.length] The end position.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     */\n\t    function slice(array, start, end) {\n\t      var length = array == null ? 0 : array.length;\n\t      if (!length) {\n\t        return [];\n\t      }\n\t      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {\n\t        start = 0;\n\t        end = length;\n\t      }\n\t      else {\n\t        start = start == null ? 0 : toInteger(start);\n\t        end = end === undefined ? length : toInteger(end);\n\t      }\n\t      return baseSlice(array, start, end);\n\t    }\n\t\n\t    /**\n\t     * Uses a binary search to determine the lowest index at which `value`\n\t     * should be inserted into `array` in order to maintain its sort order.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Array\n\t     * @param {Array} array The sorted array to inspect.\n\t     * @param {*} value The value to evaluate.\n\t     * @returns {number} Returns the index at which `value` should be inserted\n\t     *  into `array`.\n\t     * @example\n\t     *\n\t     * _.sortedIndex([30, 50], 40);\n\t     * // => 1\n\t     */\n\t    function sortedIndex(array, value) {\n\t      return baseSortedIndex(array, value);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.sortedIndex` except that it accepts `iteratee`\n\t     * which is invoked for `value` and each element of `array` to compute their\n\t     * sort ranking. The iteratee is invoked with one argument: (value).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Array\n\t     * @param {Array} array The sorted array to inspect.\n\t     * @param {*} value The value to evaluate.\n\t     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n\t     * @returns {number} Returns the index at which `value` should be inserted\n\t     *  into `array`.\n\t     * @example\n\t     *\n\t     * var objects = [{ 'x': 4 }, { 'x': 5 }];\n\t     *\n\t     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n\t     * // => 0\n\t     *\n\t     * // The `_.property` iteratee shorthand.\n\t     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');\n\t     * // => 0\n\t     */\n\t    function sortedIndexBy(array, value, iteratee) {\n\t      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.indexOf` except that it performs a binary\n\t     * search on a sorted `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Array\n\t     * @param {Array} array The array to inspect.\n\t     * @param {*} value The value to search for.\n\t     * @returns {number} Returns the index of the matched value, else `-1`.\n\t     * @example\n\t     *\n\t     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);\n\t     * // => 1\n\t     */\n\t    function sortedIndexOf(array, value) {\n\t      var length = array == null ? 0 : array.length;\n\t      if (length) {\n\t        var index = baseSortedIndex(array, value);\n\t        if (index < length && eq(array[index], value)) {\n\t          return index;\n\t        }\n\t      }\n\t      return -1;\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.sortedIndex` except that it returns the highest\n\t     * index at which `value` should be inserted into `array` in order to\n\t     * maintain its sort order.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category Array\n\t     * @param {Array} array The sorted array to inspect.\n\t     * @param {*} value The value to evaluate.\n\t     * @returns {number} Returns the index at which `value` should be inserted\n\t     *  into `array`.\n\t     * @example\n\t     *\n\t     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);\n\t     * // => 4\n\t     */\n\t    function sortedLastIndex(array, value) {\n\t      return baseSortedIndex(array, value, true);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`\n\t     * which is invoked for `value` and each element of `array` to compute their\n\t     * sort ranking. The iteratee is invoked with one argument: (value).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Array\n\t     * @param {Array} array The sorted array to inspect.\n\t     * @param {*} value The value to evaluate.\n\t     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n\t     * @returns {number} Returns the index at which `value` should be inserted\n\t     *  into `array`.\n\t     * @example\n\t     *\n\t     * var objects = [{ 'x': 4 }, { 'x': 5 }];\n\t     *\n\t     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n\t     * // => 1\n\t     *\n\t     * // The `_.property` iteratee shorthand.\n\t     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');\n\t     * // => 1\n\t     */\n\t    function sortedLastIndexBy(array, value, iteratee) {\n\t      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.lastIndexOf` except that it performs a binary\n\t     * search on a sorted `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Array\n\t     * @param {Array} array The array to inspect.\n\t     * @param {*} value The value to search for.\n\t     * @returns {number} Returns the index of the matched value, else `-1`.\n\t     * @example\n\t     *\n\t     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);\n\t     * // => 3\n\t     */\n\t    function sortedLastIndexOf(array, value) {\n\t      var length = array == null ? 0 : array.length;\n\t      if (length) {\n\t        var index = baseSortedIndex(array, value, true) - 1;\n\t        if (eq(array[index], value)) {\n\t          return index;\n\t        }\n\t      }\n\t      return -1;\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.uniq` except that it's designed and optimized\n\t     * for sorted arrays.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Array\n\t     * @param {Array} array The array to inspect.\n\t     * @returns {Array} Returns the new duplicate free array.\n\t     * @example\n\t     *\n\t     * _.sortedUniq([1, 1, 2]);\n\t     * // => [1, 2]\n\t     */\n\t    function sortedUniq(array) {\n\t      return (array && array.length)\n\t        ? baseSortedUniq(array)\n\t        : [];\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.uniqBy` except that it's designed and optimized\n\t     * for sorted arrays.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Array\n\t     * @param {Array} array The array to inspect.\n\t     * @param {Function} [iteratee] The iteratee invoked per element.\n\t     * @returns {Array} Returns the new duplicate free array.\n\t     * @example\n\t     *\n\t     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);\n\t     * // => [1.1, 2.3]\n\t     */\n\t    function sortedUniqBy(array, iteratee) {\n\t      return (array && array.length)\n\t        ? baseSortedUniq(array, getIteratee(iteratee, 2))\n\t        : [];\n\t    }\n\t\n\t    /**\n\t     * Gets all but the first element of `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * _.tail([1, 2, 3]);\n\t     * // => [2, 3]\n\t     */\n\t    function tail(array) {\n\t      var length = array == null ? 0 : array.length;\n\t      return length ? baseSlice(array, 1, length) : [];\n\t    }\n\t\n\t    /**\n\t     * Creates a slice of `array` with `n` elements taken from the beginning.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @param {number} [n=1] The number of elements to take.\n\t     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * _.take([1, 2, 3]);\n\t     * // => [1]\n\t     *\n\t     * _.take([1, 2, 3], 2);\n\t     * // => [1, 2]\n\t     *\n\t     * _.take([1, 2, 3], 5);\n\t     * // => [1, 2, 3]\n\t     *\n\t     * _.take([1, 2, 3], 0);\n\t     * // => []\n\t     */\n\t    function take(array, n, guard) {\n\t      if (!(array && array.length)) {\n\t        return [];\n\t      }\n\t      n = (guard || n === undefined) ? 1 : toInteger(n);\n\t      return baseSlice(array, 0, n < 0 ? 0 : n);\n\t    }\n\t\n\t    /**\n\t     * Creates a slice of `array` with `n` elements taken from the end.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @param {number} [n=1] The number of elements to take.\n\t     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * _.takeRight([1, 2, 3]);\n\t     * // => [3]\n\t     *\n\t     * _.takeRight([1, 2, 3], 2);\n\t     * // => [2, 3]\n\t     *\n\t     * _.takeRight([1, 2, 3], 5);\n\t     * // => [1, 2, 3]\n\t     *\n\t     * _.takeRight([1, 2, 3], 0);\n\t     * // => []\n\t     */\n\t    function takeRight(array, n, guard) {\n\t      var length = array == null ? 0 : array.length;\n\t      if (!length) {\n\t        return [];\n\t      }\n\t      n = (guard || n === undefined) ? 1 : toInteger(n);\n\t      n = length - n;\n\t      return baseSlice(array, n < 0 ? 0 : n, length);\n\t    }\n\t\n\t    /**\n\t     * Creates a slice of `array` with elements taken from the end. Elements are\n\t     * taken until `predicate` returns falsey. The predicate is invoked with\n\t     * three arguments: (value, index, array).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney',  'active': true },\n\t     *   { 'user': 'fred',    'active': false },\n\t     *   { 'user': 'pebbles', 'active': false }\n\t     * ];\n\t     *\n\t     * _.takeRightWhile(users, function(o) { return !o.active; });\n\t     * // => objects for ['fred', 'pebbles']\n\t     *\n\t     * // The `_.matches` iteratee shorthand.\n\t     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });\n\t     * // => objects for ['pebbles']\n\t     *\n\t     * // The `_.matchesProperty` iteratee shorthand.\n\t     * _.takeRightWhile(users, ['active', false]);\n\t     * // => objects for ['fred', 'pebbles']\n\t     *\n\t     * // The `_.property` iteratee shorthand.\n\t     * _.takeRightWhile(users, 'active');\n\t     * // => []\n\t     */\n\t    function takeRightWhile(array, predicate) {\n\t      return (array && array.length)\n\t        ? baseWhile(array, getIteratee(predicate, 3), false, true)\n\t        : [];\n\t    }\n\t\n\t    /**\n\t     * Creates a slice of `array` with elements taken from the beginning. Elements\n\t     * are taken until `predicate` returns falsey. The predicate is invoked with\n\t     * three arguments: (value, index, array).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney',  'active': false },\n\t     *   { 'user': 'fred',    'active': false},\n\t     *   { 'user': 'pebbles', 'active': true }\n\t     * ];\n\t     *\n\t     * _.takeWhile(users, function(o) { return !o.active; });\n\t     * // => objects for ['barney', 'fred']\n\t     *\n\t     * // The `_.matches` iteratee shorthand.\n\t     * _.takeWhile(users, { 'user': 'barney', 'active': false });\n\t     * // => objects for ['barney']\n\t     *\n\t     * // The `_.matchesProperty` iteratee shorthand.\n\t     * _.takeWhile(users, ['active', false]);\n\t     * // => objects for ['barney', 'fred']\n\t     *\n\t     * // The `_.property` iteratee shorthand.\n\t     * _.takeWhile(users, 'active');\n\t     * // => []\n\t     */\n\t    function takeWhile(array, predicate) {\n\t      return (array && array.length)\n\t        ? baseWhile(array, getIteratee(predicate, 3))\n\t        : [];\n\t    }\n\t\n\t    /**\n\t     * Creates an array of unique values, in order, from all given arrays using\n\t     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n\t     * for equality comparisons.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Array\n\t     * @param {...Array} [arrays] The arrays to inspect.\n\t     * @returns {Array} Returns the new array of combined values.\n\t     * @example\n\t     *\n\t     * _.union([2], [1, 2]);\n\t     * // => [2, 1]\n\t     */\n\t    var union = baseRest(function(arrays) {\n\t      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));\n\t    });\n\t\n\t    /**\n\t     * This method is like `_.union` except that it accepts `iteratee` which is\n\t     * invoked for each element of each `arrays` to generate the criterion by\n\t     * which uniqueness is computed. Result values are chosen from the first\n\t     * array in which the value occurs. The iteratee is invoked with one argument:\n\t     * (value).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Array\n\t     * @param {...Array} [arrays] The arrays to inspect.\n\t     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n\t     * @returns {Array} Returns the new array of combined values.\n\t     * @example\n\t     *\n\t     * _.unionBy([2.1], [1.2, 2.3], Math.floor);\n\t     * // => [2.1, 1.2]\n\t     *\n\t     * // The `_.property` iteratee shorthand.\n\t     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n\t     * // => [{ 'x': 1 }, { 'x': 2 }]\n\t     */\n\t    var unionBy = baseRest(function(arrays) {\n\t      var iteratee = last(arrays);\n\t      if (isArrayLikeObject(iteratee)) {\n\t        iteratee = undefined;\n\t      }\n\t      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));\n\t    });\n\t\n\t    /**\n\t     * This method is like `_.union` except that it accepts `comparator` which\n\t     * is invoked to compare elements of `arrays`. Result values are chosen from\n\t     * the first array in which the value occurs. The comparator is invoked\n\t     * with two arguments: (arrVal, othVal).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Array\n\t     * @param {...Array} [arrays] The arrays to inspect.\n\t     * @param {Function} [comparator] The comparator invoked per element.\n\t     * @returns {Array} Returns the new array of combined values.\n\t     * @example\n\t     *\n\t     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n\t     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n\t     *\n\t     * _.unionWith(objects, others, _.isEqual);\n\t     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n\t     */\n\t    var unionWith = baseRest(function(arrays) {\n\t      var comparator = last(arrays);\n\t      comparator = typeof comparator == 'function' ? comparator : undefined;\n\t      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);\n\t    });\n\t\n\t    /**\n\t     * Creates a duplicate-free version of an array, using\n\t     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n\t     * for equality comparisons, in which only the first occurrence of each element\n\t     * is kept. The order of result values is determined by the order they occur\n\t     * in the array.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Array\n\t     * @param {Array} array The array to inspect.\n\t     * @returns {Array} Returns the new duplicate free array.\n\t     * @example\n\t     *\n\t     * _.uniq([2, 1, 2]);\n\t     * // => [2, 1]\n\t     */\n\t    function uniq(array) {\n\t      return (array && array.length) ? baseUniq(array) : [];\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.uniq` except that it accepts `iteratee` which is\n\t     * invoked for each element in `array` to generate the criterion by which\n\t     * uniqueness is computed. The order of result values is determined by the\n\t     * order they occur in the array. The iteratee is invoked with one argument:\n\t     * (value).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Array\n\t     * @param {Array} array The array to inspect.\n\t     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n\t     * @returns {Array} Returns the new duplicate free array.\n\t     * @example\n\t     *\n\t     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n\t     * // => [2.1, 1.2]\n\t     *\n\t     * // The `_.property` iteratee shorthand.\n\t     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n\t     * // => [{ 'x': 1 }, { 'x': 2 }]\n\t     */\n\t    function uniqBy(array, iteratee) {\n\t      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.uniq` except that it accepts `comparator` which\n\t     * is invoked to compare elements of `array`. The order of result values is\n\t     * determined by the order they occur in the array.The comparator is invoked\n\t     * with two arguments: (arrVal, othVal).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Array\n\t     * @param {Array} array The array to inspect.\n\t     * @param {Function} [comparator] The comparator invoked per element.\n\t     * @returns {Array} Returns the new duplicate free array.\n\t     * @example\n\t     *\n\t     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];\n\t     *\n\t     * _.uniqWith(objects, _.isEqual);\n\t     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]\n\t     */\n\t    function uniqWith(array, comparator) {\n\t      comparator = typeof comparator == 'function' ? comparator : undefined;\n\t      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.zip` except that it accepts an array of grouped\n\t     * elements and creates an array regrouping the elements to their pre-zip\n\t     * configuration.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 1.2.0\n\t     * @category Array\n\t     * @param {Array} array The array of grouped elements to process.\n\t     * @returns {Array} Returns the new array of regrouped elements.\n\t     * @example\n\t     *\n\t     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);\n\t     * // => [['a', 1, true], ['b', 2, false]]\n\t     *\n\t     * _.unzip(zipped);\n\t     * // => [['a', 'b'], [1, 2], [true, false]]\n\t     */\n\t    function unzip(array) {\n\t      if (!(array && array.length)) {\n\t        return [];\n\t      }\n\t      var length = 0;\n\t      array = arrayFilter(array, function(group) {\n\t        if (isArrayLikeObject(group)) {\n\t          length = nativeMax(group.length, length);\n\t          return true;\n\t        }\n\t      });\n\t      return baseTimes(length, function(index) {\n\t        return arrayMap(array, baseProperty(index));\n\t      });\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.unzip` except that it accepts `iteratee` to specify\n\t     * how regrouped values should be combined. The iteratee is invoked with the\n\t     * elements of each group: (...group).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.8.0\n\t     * @category Array\n\t     * @param {Array} array The array of grouped elements to process.\n\t     * @param {Function} [iteratee=_.identity] The function to combine\n\t     *  regrouped values.\n\t     * @returns {Array} Returns the new array of regrouped elements.\n\t     * @example\n\t     *\n\t     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);\n\t     * // => [[1, 10, 100], [2, 20, 200]]\n\t     *\n\t     * _.unzipWith(zipped, _.add);\n\t     * // => [3, 30, 300]\n\t     */\n\t    function unzipWith(array, iteratee) {\n\t      if (!(array && array.length)) {\n\t        return [];\n\t      }\n\t      var result = unzip(array);\n\t      if (iteratee == null) {\n\t        return result;\n\t      }\n\t      return arrayMap(result, function(group) {\n\t        return apply(iteratee, undefined, group);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Creates an array excluding all given values using\n\t     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n\t     * for equality comparisons.\n\t     *\n\t     * **Note:** Unlike `_.pull`, this method returns a new array.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Array\n\t     * @param {Array} array The array to inspect.\n\t     * @param {...*} [values] The values to exclude.\n\t     * @returns {Array} Returns the new array of filtered values.\n\t     * @see _.difference, _.xor\n\t     * @example\n\t     *\n\t     * _.without([2, 1, 2, 3], 1, 2);\n\t     * // => [3]\n\t     */\n\t    var without = baseRest(function(array, values) {\n\t      return isArrayLikeObject(array)\n\t        ? baseDifference(array, values)\n\t        : [];\n\t    });\n\t\n\t    /**\n\t     * Creates an array of unique values that is the\n\t     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)\n\t     * of the given arrays. The order of result values is determined by the order\n\t     * they occur in the arrays.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 2.4.0\n\t     * @category Array\n\t     * @param {...Array} [arrays] The arrays to inspect.\n\t     * @returns {Array} Returns the new array of filtered values.\n\t     * @see _.difference, _.without\n\t     * @example\n\t     *\n\t     * _.xor([2, 1], [2, 3]);\n\t     * // => [1, 3]\n\t     */\n\t    var xor = baseRest(function(arrays) {\n\t      return baseXor(arrayFilter(arrays, isArrayLikeObject));\n\t    });\n\t\n\t    /**\n\t     * This method is like `_.xor` except that it accepts `iteratee` which is\n\t     * invoked for each element of each `arrays` to generate the criterion by\n\t     * which by which they're compared. The order of result values is determined\n\t     * by the order they occur in the arrays. The iteratee is invoked with one\n\t     * argument: (value).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Array\n\t     * @param {...Array} [arrays] The arrays to inspect.\n\t     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n\t     * @returns {Array} Returns the new array of filtered values.\n\t     * @example\n\t     *\n\t     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n\t     * // => [1.2, 3.4]\n\t     *\n\t     * // The `_.property` iteratee shorthand.\n\t     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n\t     * // => [{ 'x': 2 }]\n\t     */\n\t    var xorBy = baseRest(function(arrays) {\n\t      var iteratee = last(arrays);\n\t      if (isArrayLikeObject(iteratee)) {\n\t        iteratee = undefined;\n\t      }\n\t      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));\n\t    });\n\t\n\t    /**\n\t     * This method is like `_.xor` except that it accepts `comparator` which is\n\t     * invoked to compare elements of `arrays`. The order of result values is\n\t     * determined by the order they occur in the arrays. The comparator is invoked\n\t     * with two arguments: (arrVal, othVal).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Array\n\t     * @param {...Array} [arrays] The arrays to inspect.\n\t     * @param {Function} [comparator] The comparator invoked per element.\n\t     * @returns {Array} Returns the new array of filtered values.\n\t     * @example\n\t     *\n\t     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n\t     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n\t     *\n\t     * _.xorWith(objects, others, _.isEqual);\n\t     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n\t     */\n\t    var xorWith = baseRest(function(arrays) {\n\t      var comparator = last(arrays);\n\t      comparator = typeof comparator == 'function' ? comparator : undefined;\n\t      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);\n\t    });\n\t\n\t    /**\n\t     * Creates an array of grouped elements, the first of which contains the\n\t     * first elements of the given arrays, the second of which contains the\n\t     * second elements of the given arrays, and so on.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Array\n\t     * @param {...Array} [arrays] The arrays to process.\n\t     * @returns {Array} Returns the new array of grouped elements.\n\t     * @example\n\t     *\n\t     * _.zip(['a', 'b'], [1, 2], [true, false]);\n\t     * // => [['a', 1, true], ['b', 2, false]]\n\t     */\n\t    var zip = baseRest(unzip);\n\t\n\t    /**\n\t     * This method is like `_.fromPairs` except that it accepts two arrays,\n\t     * one of property identifiers and one of corresponding values.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.4.0\n\t     * @category Array\n\t     * @param {Array} [props=[]] The property identifiers.\n\t     * @param {Array} [values=[]] The property values.\n\t     * @returns {Object} Returns the new object.\n\t     * @example\n\t     *\n\t     * _.zipObject(['a', 'b'], [1, 2]);\n\t     * // => { 'a': 1, 'b': 2 }\n\t     */\n\t    function zipObject(props, values) {\n\t      return baseZipObject(props || [], values || [], assignValue);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.zipObject` except that it supports property paths.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.1.0\n\t     * @category Array\n\t     * @param {Array} [props=[]] The property identifiers.\n\t     * @param {Array} [values=[]] The property values.\n\t     * @returns {Object} Returns the new object.\n\t     * @example\n\t     *\n\t     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);\n\t     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }\n\t     */\n\t    function zipObjectDeep(props, values) {\n\t      return baseZipObject(props || [], values || [], baseSet);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.zip` except that it accepts `iteratee` to specify\n\t     * how grouped values should be combined. The iteratee is invoked with the\n\t     * elements of each group: (...group).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.8.0\n\t     * @category Array\n\t     * @param {...Array} [arrays] The arrays to process.\n\t     * @param {Function} [iteratee=_.identity] The function to combine\n\t     *  grouped values.\n\t     * @returns {Array} Returns the new array of grouped elements.\n\t     * @example\n\t     *\n\t     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {\n\t     *   return a + b + c;\n\t     * });\n\t     * // => [111, 222]\n\t     */\n\t    var zipWith = baseRest(function(arrays) {\n\t      var length = arrays.length,\n\t          iteratee = length > 1 ? arrays[length - 1] : undefined;\n\t\n\t      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;\n\t      return unzipWith(arrays, iteratee);\n\t    });\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Creates a `lodash` wrapper instance that wraps `value` with explicit method\n\t     * chain sequences enabled. The result of such sequences must be unwrapped\n\t     * with `_#value`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 1.3.0\n\t     * @category Seq\n\t     * @param {*} value The value to wrap.\n\t     * @returns {Object} Returns the new `lodash` wrapper instance.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney',  'age': 36 },\n\t     *   { 'user': 'fred',    'age': 40 },\n\t     *   { 'user': 'pebbles', 'age': 1 }\n\t     * ];\n\t     *\n\t     * var youngest = _\n\t     *   .chain(users)\n\t     *   .sortBy('age')\n\t     *   .map(function(o) {\n\t     *     return o.user + ' is ' + o.age;\n\t     *   })\n\t     *   .head()\n\t     *   .value();\n\t     * // => 'pebbles is 1'\n\t     */\n\t    function chain(value) {\n\t      var result = lodash(value);\n\t      result.__chain__ = true;\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * This method invokes `interceptor` and returns `value`. The interceptor\n\t     * is invoked with one argument; (value). The purpose of this method is to\n\t     * \"tap into\" a method chain sequence in order to modify intermediate results.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Seq\n\t     * @param {*} value The value to provide to `interceptor`.\n\t     * @param {Function} interceptor The function to invoke.\n\t     * @returns {*} Returns `value`.\n\t     * @example\n\t     *\n\t     * _([1, 2, 3])\n\t     *  .tap(function(array) {\n\t     *    // Mutate input array.\n\t     *    array.pop();\n\t     *  })\n\t     *  .reverse()\n\t     *  .value();\n\t     * // => [2, 1]\n\t     */\n\t    function tap(value, interceptor) {\n\t      interceptor(value);\n\t      return value;\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.tap` except that it returns the result of `interceptor`.\n\t     * The purpose of this method is to \"pass thru\" values replacing intermediate\n\t     * results in a method chain sequence.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category Seq\n\t     * @param {*} value The value to provide to `interceptor`.\n\t     * @param {Function} interceptor The function to invoke.\n\t     * @returns {*} Returns the result of `interceptor`.\n\t     * @example\n\t     *\n\t     * _('  abc  ')\n\t     *  .chain()\n\t     *  .trim()\n\t     *  .thru(function(value) {\n\t     *    return [value];\n\t     *  })\n\t     *  .value();\n\t     * // => ['abc']\n\t     */\n\t    function thru(value, interceptor) {\n\t      return interceptor(value);\n\t    }\n\t\n\t    /**\n\t     * This method is the wrapper version of `_.at`.\n\t     *\n\t     * @name at\n\t     * @memberOf _\n\t     * @since 1.0.0\n\t     * @category Seq\n\t     * @param {...(string|string[])} [paths] The property paths to pick.\n\t     * @returns {Object} Returns the new `lodash` wrapper instance.\n\t     * @example\n\t     *\n\t     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n\t     *\n\t     * _(object).at(['a[0].b.c', 'a[1]']).value();\n\t     * // => [3, 4]\n\t     */\n\t    var wrapperAt = flatRest(function(paths) {\n\t      var length = paths.length,\n\t          start = length ? paths[0] : 0,\n\t          value = this.__wrapped__,\n\t          interceptor = function(object) { return baseAt(object, paths); };\n\t\n\t      if (length > 1 || this.__actions__.length ||\n\t          !(value instanceof LazyWrapper) || !isIndex(start)) {\n\t        return this.thru(interceptor);\n\t      }\n\t      value = value.slice(start, +start + (length ? 1 : 0));\n\t      value.__actions__.push({\n\t        'func': thru,\n\t        'args': [interceptor],\n\t        'thisArg': undefined\n\t      });\n\t      return new LodashWrapper(value, this.__chain__).thru(function(array) {\n\t        if (length && !array.length) {\n\t          array.push(undefined);\n\t        }\n\t        return array;\n\t      });\n\t    });\n\t\n\t    /**\n\t     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.\n\t     *\n\t     * @name chain\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Seq\n\t     * @returns {Object} Returns the new `lodash` wrapper instance.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'age': 36 },\n\t     *   { 'user': 'fred',   'age': 40 }\n\t     * ];\n\t     *\n\t     * // A sequence without explicit chaining.\n\t     * _(users).head();\n\t     * // => { 'user': 'barney', 'age': 36 }\n\t     *\n\t     * // A sequence with explicit chaining.\n\t     * _(users)\n\t     *   .chain()\n\t     *   .head()\n\t     *   .pick('user')\n\t     *   .value();\n\t     * // => { 'user': 'barney' }\n\t     */\n\t    function wrapperChain() {\n\t      return chain(this);\n\t    }\n\t\n\t    /**\n\t     * Executes the chain sequence and returns the wrapped result.\n\t     *\n\t     * @name commit\n\t     * @memberOf _\n\t     * @since 3.2.0\n\t     * @category Seq\n\t     * @returns {Object} Returns the new `lodash` wrapper instance.\n\t     * @example\n\t     *\n\t     * var array = [1, 2];\n\t     * var wrapped = _(array).push(3);\n\t     *\n\t     * console.log(array);\n\t     * // => [1, 2]\n\t     *\n\t     * wrapped = wrapped.commit();\n\t     * console.log(array);\n\t     * // => [1, 2, 3]\n\t     *\n\t     * wrapped.last();\n\t     * // => 3\n\t     *\n\t     * console.log(array);\n\t     * // => [1, 2, 3]\n\t     */\n\t    function wrapperCommit() {\n\t      return new LodashWrapper(this.value(), this.__chain__);\n\t    }\n\t\n\t    /**\n\t     * Gets the next value on a wrapped object following the\n\t     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).\n\t     *\n\t     * @name next\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Seq\n\t     * @returns {Object} Returns the next iterator value.\n\t     * @example\n\t     *\n\t     * var wrapped = _([1, 2]);\n\t     *\n\t     * wrapped.next();\n\t     * // => { 'done': false, 'value': 1 }\n\t     *\n\t     * wrapped.next();\n\t     * // => { 'done': false, 'value': 2 }\n\t     *\n\t     * wrapped.next();\n\t     * // => { 'done': true, 'value': undefined }\n\t     */\n\t    function wrapperNext() {\n\t      if (this.__values__ === undefined) {\n\t        this.__values__ = toArray(this.value());\n\t      }\n\t      var done = this.__index__ >= this.__values__.length,\n\t          value = done ? undefined : this.__values__[this.__index__++];\n\t\n\t      return { 'done': done, 'value': value };\n\t    }\n\t\n\t    /**\n\t     * Enables the wrapper to be iterable.\n\t     *\n\t     * @name Symbol.iterator\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Seq\n\t     * @returns {Object} Returns the wrapper object.\n\t     * @example\n\t     *\n\t     * var wrapped = _([1, 2]);\n\t     *\n\t     * wrapped[Symbol.iterator]() === wrapped;\n\t     * // => true\n\t     *\n\t     * Array.from(wrapped);\n\t     * // => [1, 2]\n\t     */\n\t    function wrapperToIterator() {\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Creates a clone of the chain sequence planting `value` as the wrapped value.\n\t     *\n\t     * @name plant\n\t     * @memberOf _\n\t     * @since 3.2.0\n\t     * @category Seq\n\t     * @param {*} value The value to plant.\n\t     * @returns {Object} Returns the new `lodash` wrapper instance.\n\t     * @example\n\t     *\n\t     * function square(n) {\n\t     *   return n * n;\n\t     * }\n\t     *\n\t     * var wrapped = _([1, 2]).map(square);\n\t     * var other = wrapped.plant([3, 4]);\n\t     *\n\t     * other.value();\n\t     * // => [9, 16]\n\t     *\n\t     * wrapped.value();\n\t     * // => [1, 4]\n\t     */\n\t    function wrapperPlant(value) {\n\t      var result,\n\t          parent = this;\n\t\n\t      while (parent instanceof baseLodash) {\n\t        var clone = wrapperClone(parent);\n\t        clone.__index__ = 0;\n\t        clone.__values__ = undefined;\n\t        if (result) {\n\t          previous.__wrapped__ = clone;\n\t        } else {\n\t          result = clone;\n\t        }\n\t        var previous = clone;\n\t        parent = parent.__wrapped__;\n\t      }\n\t      previous.__wrapped__ = value;\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * This method is the wrapper version of `_.reverse`.\n\t     *\n\t     * **Note:** This method mutates the wrapped array.\n\t     *\n\t     * @name reverse\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Seq\n\t     * @returns {Object} Returns the new `lodash` wrapper instance.\n\t     * @example\n\t     *\n\t     * var array = [1, 2, 3];\n\t     *\n\t     * _(array).reverse().value()\n\t     * // => [3, 2, 1]\n\t     *\n\t     * console.log(array);\n\t     * // => [3, 2, 1]\n\t     */\n\t    function wrapperReverse() {\n\t      var value = this.__wrapped__;\n\t      if (value instanceof LazyWrapper) {\n\t        var wrapped = value;\n\t        if (this.__actions__.length) {\n\t          wrapped = new LazyWrapper(this);\n\t        }\n\t        wrapped = wrapped.reverse();\n\t        wrapped.__actions__.push({\n\t          'func': thru,\n\t          'args': [reverse],\n\t          'thisArg': undefined\n\t        });\n\t        return new LodashWrapper(wrapped, this.__chain__);\n\t      }\n\t      return this.thru(reverse);\n\t    }\n\t\n\t    /**\n\t     * Executes the chain sequence to resolve the unwrapped value.\n\t     *\n\t     * @name value\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @alias toJSON, valueOf\n\t     * @category Seq\n\t     * @returns {*} Returns the resolved unwrapped value.\n\t     * @example\n\t     *\n\t     * _([1, 2, 3]).value();\n\t     * // => [1, 2, 3]\n\t     */\n\t    function wrapperValue() {\n\t      return baseWrapperValue(this.__wrapped__, this.__actions__);\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Creates an object composed of keys generated from the results of running\n\t     * each element of `collection` thru `iteratee`. The corresponding value of\n\t     * each key is the number of times the key was returned by `iteratee`. The\n\t     * iteratee is invoked with one argument: (value).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.5.0\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n\t     * @returns {Object} Returns the composed aggregate object.\n\t     * @example\n\t     *\n\t     * _.countBy([6.1, 4.2, 6.3], Math.floor);\n\t     * // => { '4': 1, '6': 2 }\n\t     *\n\t     * // The `_.property` iteratee shorthand.\n\t     * _.countBy(['one', 'two', 'three'], 'length');\n\t     * // => { '3': 2, '5': 1 }\n\t     */\n\t    var countBy = createAggregator(function(result, value, key) {\n\t      if (hasOwnProperty.call(result, key)) {\n\t        ++result[key];\n\t      } else {\n\t        baseAssignValue(result, key, 1);\n\t      }\n\t    });\n\t\n\t    /**\n\t     * Checks if `predicate` returns truthy for **all** elements of `collection`.\n\t     * Iteration is stopped once `predicate` returns falsey. The predicate is\n\t     * invoked with three arguments: (value, index|key, collection).\n\t     *\n\t     * **Note:** This method returns `true` for\n\t     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because\n\t     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of\n\t     * elements of empty collections.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n\t     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n\t     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n\t     *  else `false`.\n\t     * @example\n\t     *\n\t     * _.every([true, 1, null, 'yes'], Boolean);\n\t     * // => false\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'age': 36, 'active': false },\n\t     *   { 'user': 'fred',   'age': 40, 'active': false }\n\t     * ];\n\t     *\n\t     * // The `_.matches` iteratee shorthand.\n\t     * _.every(users, { 'user': 'barney', 'active': false });\n\t     * // => false\n\t     *\n\t     * // The `_.matchesProperty` iteratee shorthand.\n\t     * _.every(users, ['active', false]);\n\t     * // => true\n\t     *\n\t     * // The `_.property` iteratee shorthand.\n\t     * _.every(users, 'active');\n\t     * // => false\n\t     */\n\t    function every(collection, predicate, guard) {\n\t      var func = isArray(collection) ? arrayEvery : baseEvery;\n\t      if (guard && isIterateeCall(collection, predicate, guard)) {\n\t        predicate = undefined;\n\t      }\n\t      return func(collection, getIteratee(predicate, 3));\n\t    }\n\t\n\t    /**\n\t     * Iterates over elements of `collection`, returning an array of all elements\n\t     * `predicate` returns truthy for. The predicate is invoked with three\n\t     * arguments: (value, index|key, collection).\n\t     *\n\t     * **Note:** Unlike `_.remove`, this method returns a new array.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n\t     * @returns {Array} Returns the new filtered array.\n\t     * @see _.reject\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'age': 36, 'active': true },\n\t     *   { 'user': 'fred',   'age': 40, 'active': false }\n\t     * ];\n\t     *\n\t     * _.filter(users, function(o) { return !o.active; });\n\t     * // => objects for ['fred']\n\t     *\n\t     * // The `_.matches` iteratee shorthand.\n\t     * _.filter(users, { 'age': 36, 'active': true });\n\t     * // => objects for ['barney']\n\t     *\n\t     * // The `_.matchesProperty` iteratee shorthand.\n\t     * _.filter(users, ['active', false]);\n\t     * // => objects for ['fred']\n\t     *\n\t     * // The `_.property` iteratee shorthand.\n\t     * _.filter(users, 'active');\n\t     * // => objects for ['barney']\n\t     */\n\t    function filter(collection, predicate) {\n\t      var func = isArray(collection) ? arrayFilter : baseFilter;\n\t      return func(collection, getIteratee(predicate, 3));\n\t    }\n\t\n\t    /**\n\t     * Iterates over elements of `collection`, returning the first element\n\t     * `predicate` returns truthy for. The predicate is invoked with three\n\t     * arguments: (value, index|key, collection).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to inspect.\n\t     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n\t     * @param {number} [fromIndex=0] The index to search from.\n\t     * @returns {*} Returns the matched element, else `undefined`.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney',  'age': 36, 'active': true },\n\t     *   { 'user': 'fred',    'age': 40, 'active': false },\n\t     *   { 'user': 'pebbles', 'age': 1,  'active': true }\n\t     * ];\n\t     *\n\t     * _.find(users, function(o) { return o.age < 40; });\n\t     * // => object for 'barney'\n\t     *\n\t     * // The `_.matches` iteratee shorthand.\n\t     * _.find(users, { 'age': 1, 'active': true });\n\t     * // => object for 'pebbles'\n\t     *\n\t     * // The `_.matchesProperty` iteratee shorthand.\n\t     * _.find(users, ['active', false]);\n\t     * // => object for 'fred'\n\t     *\n\t     * // The `_.property` iteratee shorthand.\n\t     * _.find(users, 'active');\n\t     * // => object for 'barney'\n\t     */\n\t    var find = createFind(findIndex);\n\t\n\t    /**\n\t     * This method is like `_.find` except that it iterates over elements of\n\t     * `collection` from right to left.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 2.0.0\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to inspect.\n\t     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n\t     * @param {number} [fromIndex=collection.length-1] The index to search from.\n\t     * @returns {*} Returns the matched element, else `undefined`.\n\t     * @example\n\t     *\n\t     * _.findLast([1, 2, 3, 4], function(n) {\n\t     *   return n % 2 == 1;\n\t     * });\n\t     * // => 3\n\t     */\n\t    var findLast = createFind(findLastIndex);\n\t\n\t    /**\n\t     * Creates a flattened array of values by running each element in `collection`\n\t     * thru `iteratee` and flattening the mapped results. The iteratee is invoked\n\t     * with three arguments: (value, index|key, collection).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @returns {Array} Returns the new flattened array.\n\t     * @example\n\t     *\n\t     * function duplicate(n) {\n\t     *   return [n, n];\n\t     * }\n\t     *\n\t     * _.flatMap([1, 2], duplicate);\n\t     * // => [1, 1, 2, 2]\n\t     */\n\t    function flatMap(collection, iteratee) {\n\t      return baseFlatten(map(collection, iteratee), 1);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.flatMap` except that it recursively flattens the\n\t     * mapped results.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.7.0\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @returns {Array} Returns the new flattened array.\n\t     * @example\n\t     *\n\t     * function duplicate(n) {\n\t     *   return [[[n, n]]];\n\t     * }\n\t     *\n\t     * _.flatMapDeep([1, 2], duplicate);\n\t     * // => [1, 1, 2, 2]\n\t     */\n\t    function flatMapDeep(collection, iteratee) {\n\t      return baseFlatten(map(collection, iteratee), INFINITY);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.flatMap` except that it recursively flattens the\n\t     * mapped results up to `depth` times.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.7.0\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @param {number} [depth=1] The maximum recursion depth.\n\t     * @returns {Array} Returns the new flattened array.\n\t     * @example\n\t     *\n\t     * function duplicate(n) {\n\t     *   return [[[n, n]]];\n\t     * }\n\t     *\n\t     * _.flatMapDepth([1, 2], duplicate, 2);\n\t     * // => [[1, 1], [2, 2]]\n\t     */\n\t    function flatMapDepth(collection, iteratee, depth) {\n\t      depth = depth === undefined ? 1 : toInteger(depth);\n\t      return baseFlatten(map(collection, iteratee), depth);\n\t    }\n\t\n\t    /**\n\t     * Iterates over elements of `collection` and invokes `iteratee` for each element.\n\t     * The iteratee is invoked with three arguments: (value, index|key, collection).\n\t     * Iteratee functions may exit iteration early by explicitly returning `false`.\n\t     *\n\t     * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n\t     * property are iterated like arrays. To avoid this behavior use `_.forIn`\n\t     * or `_.forOwn` for object iteration.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @alias each\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @returns {Array|Object} Returns `collection`.\n\t     * @see _.forEachRight\n\t     * @example\n\t     *\n\t     * _.forEach([1, 2], function(value) {\n\t     *   console.log(value);\n\t     * });\n\t     * // => Logs `1` then `2`.\n\t     *\n\t     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n\t     *   console.log(key);\n\t     * });\n\t     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n\t     */\n\t    function forEach(collection, iteratee) {\n\t      var func = isArray(collection) ? arrayEach : baseEach;\n\t      return func(collection, getIteratee(iteratee, 3));\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.forEach` except that it iterates over elements of\n\t     * `collection` from right to left.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 2.0.0\n\t     * @alias eachRight\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @returns {Array|Object} Returns `collection`.\n\t     * @see _.forEach\n\t     * @example\n\t     *\n\t     * _.forEachRight([1, 2], function(value) {\n\t     *   console.log(value);\n\t     * });\n\t     * // => Logs `2` then `1`.\n\t     */\n\t    function forEachRight(collection, iteratee) {\n\t      var func = isArray(collection) ? arrayEachRight : baseEachRight;\n\t      return func(collection, getIteratee(iteratee, 3));\n\t    }\n\t\n\t    /**\n\t     * Creates an object composed of keys generated from the results of running\n\t     * each element of `collection` thru `iteratee`. The order of grouped values\n\t     * is determined by the order they occur in `collection`. The corresponding\n\t     * value of each key is an array of elements responsible for generating the\n\t     * key. The iteratee is invoked with one argument: (value).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n\t     * @returns {Object} Returns the composed aggregate object.\n\t     * @example\n\t     *\n\t     * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n\t     * // => { '4': [4.2], '6': [6.1, 6.3] }\n\t     *\n\t     * // The `_.property` iteratee shorthand.\n\t     * _.groupBy(['one', 'two', 'three'], 'length');\n\t     * // => { '3': ['one', 'two'], '5': ['three'] }\n\t     */\n\t    var groupBy = createAggregator(function(result, value, key) {\n\t      if (hasOwnProperty.call(result, key)) {\n\t        result[key].push(value);\n\t      } else {\n\t        baseAssignValue(result, key, [value]);\n\t      }\n\t    });\n\t\n\t    /**\n\t     * Checks if `value` is in `collection`. If `collection` is a string, it's\n\t     * checked for a substring of `value`, otherwise\n\t     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n\t     * is used for equality comparisons. If `fromIndex` is negative, it's used as\n\t     * the offset from the end of `collection`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to inspect.\n\t     * @param {*} value The value to search for.\n\t     * @param {number} [fromIndex=0] The index to search from.\n\t     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n\t     * @returns {boolean} Returns `true` if `value` is found, else `false`.\n\t     * @example\n\t     *\n\t     * _.includes([1, 2, 3], 1);\n\t     * // => true\n\t     *\n\t     * _.includes([1, 2, 3], 1, 2);\n\t     * // => false\n\t     *\n\t     * _.includes({ 'a': 1, 'b': 2 }, 1);\n\t     * // => true\n\t     *\n\t     * _.includes('abcd', 'bc');\n\t     * // => true\n\t     */\n\t    function includes(collection, value, fromIndex, guard) {\n\t      collection = isArrayLike(collection) ? collection : values(collection);\n\t      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\n\t\n\t      var length = collection.length;\n\t      if (fromIndex < 0) {\n\t        fromIndex = nativeMax(length + fromIndex, 0);\n\t      }\n\t      return isString(collection)\n\t        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\n\t        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\n\t    }\n\t\n\t    /**\n\t     * Invokes the method at `path` of each element in `collection`, returning\n\t     * an array of the results of each invoked method. Any additional arguments\n\t     * are provided to each invoked method. If `path` is a function, it's invoked\n\t     * for, and `this` bound to, each element in `collection`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Array|Function|string} path The path of the method to invoke or\n\t     *  the function invoked per iteration.\n\t     * @param {...*} [args] The arguments to invoke each method with.\n\t     * @returns {Array} Returns the array of results.\n\t     * @example\n\t     *\n\t     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');\n\t     * // => [[1, 5, 7], [1, 2, 3]]\n\t     *\n\t     * _.invokeMap([123, 456], String.prototype.split, '');\n\t     * // => [['1', '2', '3'], ['4', '5', '6']]\n\t     */\n\t    var invokeMap = baseRest(function(collection, path, args) {\n\t      var index = -1,\n\t          isFunc = typeof path == 'function',\n\t          result = isArrayLike(collection) ? Array(collection.length) : [];\n\t\n\t      baseEach(collection, function(value) {\n\t        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);\n\t      });\n\t      return result;\n\t    });\n\t\n\t    /**\n\t     * Creates an object composed of keys generated from the results of running\n\t     * each element of `collection` thru `iteratee`. The corresponding value of\n\t     * each key is the last element responsible for generating the key. The\n\t     * iteratee is invoked with one argument: (value).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n\t     * @returns {Object} Returns the composed aggregate object.\n\t     * @example\n\t     *\n\t     * var array = [\n\t     *   { 'dir': 'left', 'code': 97 },\n\t     *   { 'dir': 'right', 'code': 100 }\n\t     * ];\n\t     *\n\t     * _.keyBy(array, function(o) {\n\t     *   return String.fromCharCode(o.code);\n\t     * });\n\t     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n\t     *\n\t     * _.keyBy(array, 'dir');\n\t     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n\t     */\n\t    var keyBy = createAggregator(function(result, value, key) {\n\t      baseAssignValue(result, key, value);\n\t    });\n\t\n\t    /**\n\t     * Creates an array of values by running each element in `collection` thru\n\t     * `iteratee`. The iteratee is invoked with three arguments:\n\t     * (value, index|key, collection).\n\t     *\n\t     * Many lodash methods are guarded to work as iteratees for methods like\n\t     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n\t     *\n\t     * The guarded methods are:\n\t     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n\t     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n\t     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n\t     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @returns {Array} Returns the new mapped array.\n\t     * @example\n\t     *\n\t     * function square(n) {\n\t     *   return n * n;\n\t     * }\n\t     *\n\t     * _.map([4, 8], square);\n\t     * // => [16, 64]\n\t     *\n\t     * _.map({ 'a': 4, 'b': 8 }, square);\n\t     * // => [16, 64] (iteration order is not guaranteed)\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney' },\n\t     *   { 'user': 'fred' }\n\t     * ];\n\t     *\n\t     * // The `_.property` iteratee shorthand.\n\t     * _.map(users, 'user');\n\t     * // => ['barney', 'fred']\n\t     */\n\t    function map(collection, iteratee) {\n\t      var func = isArray(collection) ? arrayMap : baseMap;\n\t      return func(collection, getIteratee(iteratee, 3));\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.sortBy` except that it allows specifying the sort\n\t     * orders of the iteratees to sort by. If `orders` is unspecified, all values\n\t     * are sorted in ascending order. Otherwise, specify an order of \"desc\" for\n\t     * descending or \"asc\" for ascending sort order of corresponding values.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]\n\t     *  The iteratees to sort by.\n\t     * @param {string[]} [orders] The sort orders of `iteratees`.\n\t     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n\t     * @returns {Array} Returns the new sorted array.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'fred',   'age': 48 },\n\t     *   { 'user': 'barney', 'age': 34 },\n\t     *   { 'user': 'fred',   'age': 40 },\n\t     *   { 'user': 'barney', 'age': 36 }\n\t     * ];\n\t     *\n\t     * // Sort by `user` in ascending order and by `age` in descending order.\n\t     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);\n\t     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n\t     */\n\t    function orderBy(collection, iteratees, orders, guard) {\n\t      if (collection == null) {\n\t        return [];\n\t      }\n\t      if (!isArray(iteratees)) {\n\t        iteratees = iteratees == null ? [] : [iteratees];\n\t      }\n\t      orders = guard ? undefined : orders;\n\t      if (!isArray(orders)) {\n\t        orders = orders == null ? [] : [orders];\n\t      }\n\t      return baseOrderBy(collection, iteratees, orders);\n\t    }\n\t\n\t    /**\n\t     * Creates an array of elements split into two groups, the first of which\n\t     * contains elements `predicate` returns truthy for, the second of which\n\t     * contains elements `predicate` returns falsey for. The predicate is\n\t     * invoked with one argument: (value).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n\t     * @returns {Array} Returns the array of grouped elements.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney',  'age': 36, 'active': false },\n\t     *   { 'user': 'fred',    'age': 40, 'active': true },\n\t     *   { 'user': 'pebbles', 'age': 1,  'active': false }\n\t     * ];\n\t     *\n\t     * _.partition(users, function(o) { return o.active; });\n\t     * // => objects for [['fred'], ['barney', 'pebbles']]\n\t     *\n\t     * // The `_.matches` iteratee shorthand.\n\t     * _.partition(users, { 'age': 1, 'active': false });\n\t     * // => objects for [['pebbles'], ['barney', 'fred']]\n\t     *\n\t     * // The `_.matchesProperty` iteratee shorthand.\n\t     * _.partition(users, ['active', false]);\n\t     * // => objects for [['barney', 'pebbles'], ['fred']]\n\t     *\n\t     * // The `_.property` iteratee shorthand.\n\t     * _.partition(users, 'active');\n\t     * // => objects for [['fred'], ['barney', 'pebbles']]\n\t     */\n\t    var partition = createAggregator(function(result, value, key) {\n\t      result[key ? 0 : 1].push(value);\n\t    }, function() { return [[], []]; });\n\t\n\t    /**\n\t     * Reduces `collection` to a value which is the accumulated result of running\n\t     * each element in `collection` thru `iteratee`, where each successive\n\t     * invocation is supplied the return value of the previous. If `accumulator`\n\t     * is not given, the first element of `collection` is used as the initial\n\t     * value. The iteratee is invoked with four arguments:\n\t     * (accumulator, value, index|key, collection).\n\t     *\n\t     * Many lodash methods are guarded to work as iteratees for methods like\n\t     * `_.reduce`, `_.reduceRight`, and `_.transform`.\n\t     *\n\t     * The guarded methods are:\n\t     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n\t     * and `sortBy`\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @param {*} [accumulator] The initial value.\n\t     * @returns {*} Returns the accumulated value.\n\t     * @see _.reduceRight\n\t     * @example\n\t     *\n\t     * _.reduce([1, 2], function(sum, n) {\n\t     *   return sum + n;\n\t     * }, 0);\n\t     * // => 3\n\t     *\n\t     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n\t     *   (result[value] || (result[value] = [])).push(key);\n\t     *   return result;\n\t     * }, {});\n\t     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n\t     */\n\t    function reduce(collection, iteratee, accumulator) {\n\t      var func = isArray(collection) ? arrayReduce : baseReduce,\n\t          initAccum = arguments.length < 3;\n\t\n\t      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.reduce` except that it iterates over elements of\n\t     * `collection` from right to left.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @param {*} [accumulator] The initial value.\n\t     * @returns {*} Returns the accumulated value.\n\t     * @see _.reduce\n\t     * @example\n\t     *\n\t     * var array = [[0, 1], [2, 3], [4, 5]];\n\t     *\n\t     * _.reduceRight(array, function(flattened, other) {\n\t     *   return flattened.concat(other);\n\t     * }, []);\n\t     * // => [4, 5, 2, 3, 0, 1]\n\t     */\n\t    function reduceRight(collection, iteratee, accumulator) {\n\t      var func = isArray(collection) ? arrayReduceRight : baseReduce,\n\t          initAccum = arguments.length < 3;\n\t\n\t      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);\n\t    }\n\t\n\t    /**\n\t     * The opposite of `_.filter`; this method returns the elements of `collection`\n\t     * that `predicate` does **not** return truthy for.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n\t     * @returns {Array} Returns the new filtered array.\n\t     * @see _.filter\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'age': 36, 'active': false },\n\t     *   { 'user': 'fred',   'age': 40, 'active': true }\n\t     * ];\n\t     *\n\t     * _.reject(users, function(o) { return !o.active; });\n\t     * // => objects for ['fred']\n\t     *\n\t     * // The `_.matches` iteratee shorthand.\n\t     * _.reject(users, { 'age': 40, 'active': true });\n\t     * // => objects for ['barney']\n\t     *\n\t     * // The `_.matchesProperty` iteratee shorthand.\n\t     * _.reject(users, ['active', false]);\n\t     * // => objects for ['fred']\n\t     *\n\t     * // The `_.property` iteratee shorthand.\n\t     * _.reject(users, 'active');\n\t     * // => objects for ['barney']\n\t     */\n\t    function reject(collection, predicate) {\n\t      var func = isArray(collection) ? arrayFilter : baseFilter;\n\t      return func(collection, negate(getIteratee(predicate, 3)));\n\t    }\n\t\n\t    /**\n\t     * Gets a random element from `collection`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 2.0.0\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to sample.\n\t     * @returns {*} Returns the random element.\n\t     * @example\n\t     *\n\t     * _.sample([1, 2, 3, 4]);\n\t     * // => 2\n\t     */\n\t    function sample(collection) {\n\t      var func = isArray(collection) ? arraySample : baseSample;\n\t      return func(collection);\n\t    }\n\t\n\t    /**\n\t     * Gets `n` random elements at unique keys from `collection` up to the\n\t     * size of `collection`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to sample.\n\t     * @param {number} [n=1] The number of elements to sample.\n\t     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n\t     * @returns {Array} Returns the random elements.\n\t     * @example\n\t     *\n\t     * _.sampleSize([1, 2, 3], 2);\n\t     * // => [3, 1]\n\t     *\n\t     * _.sampleSize([1, 2, 3], 4);\n\t     * // => [2, 3, 1]\n\t     */\n\t    function sampleSize(collection, n, guard) {\n\t      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {\n\t        n = 1;\n\t      } else {\n\t        n = toInteger(n);\n\t      }\n\t      var func = isArray(collection) ? arraySampleSize : baseSampleSize;\n\t      return func(collection, n);\n\t    }\n\t\n\t    /**\n\t     * Creates an array of shuffled values, using a version of the\n\t     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to shuffle.\n\t     * @returns {Array} Returns the new shuffled array.\n\t     * @example\n\t     *\n\t     * _.shuffle([1, 2, 3, 4]);\n\t     * // => [4, 1, 3, 2]\n\t     */\n\t    function shuffle(collection) {\n\t      var func = isArray(collection) ? arrayShuffle : baseShuffle;\n\t      return func(collection);\n\t    }\n\t\n\t    /**\n\t     * Gets the size of `collection` by returning its length for array-like\n\t     * values or the number of own enumerable string keyed properties for objects.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to inspect.\n\t     * @returns {number} Returns the collection size.\n\t     * @example\n\t     *\n\t     * _.size([1, 2, 3]);\n\t     * // => 3\n\t     *\n\t     * _.size({ 'a': 1, 'b': 2 });\n\t     * // => 2\n\t     *\n\t     * _.size('pebbles');\n\t     * // => 7\n\t     */\n\t    function size(collection) {\n\t      if (collection == null) {\n\t        return 0;\n\t      }\n\t      if (isArrayLike(collection)) {\n\t        return isString(collection) ? stringSize(collection) : collection.length;\n\t      }\n\t      var tag = getTag(collection);\n\t      if (tag == mapTag || tag == setTag) {\n\t        return collection.size;\n\t      }\n\t      return baseKeys(collection).length;\n\t    }\n\t\n\t    /**\n\t     * Checks if `predicate` returns truthy for **any** element of `collection`.\n\t     * Iteration is stopped once `predicate` returns truthy. The predicate is\n\t     * invoked with three arguments: (value, index|key, collection).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n\t     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n\t     * @returns {boolean} Returns `true` if any element passes the predicate check,\n\t     *  else `false`.\n\t     * @example\n\t     *\n\t     * _.some([null, 0, 'yes', false], Boolean);\n\t     * // => true\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'active': true },\n\t     *   { 'user': 'fred',   'active': false }\n\t     * ];\n\t     *\n\t     * // The `_.matches` iteratee shorthand.\n\t     * _.some(users, { 'user': 'barney', 'active': false });\n\t     * // => false\n\t     *\n\t     * // The `_.matchesProperty` iteratee shorthand.\n\t     * _.some(users, ['active', false]);\n\t     * // => true\n\t     *\n\t     * // The `_.property` iteratee shorthand.\n\t     * _.some(users, 'active');\n\t     * // => true\n\t     */\n\t    function some(collection, predicate, guard) {\n\t      var func = isArray(collection) ? arraySome : baseSome;\n\t      if (guard && isIterateeCall(collection, predicate, guard)) {\n\t        predicate = undefined;\n\t      }\n\t      return func(collection, getIteratee(predicate, 3));\n\t    }\n\t\n\t    /**\n\t     * Creates an array of elements, sorted in ascending order by the results of\n\t     * running each element in a collection thru each iteratee. This method\n\t     * performs a stable sort, that is, it preserves the original sort order of\n\t     * equal elements. The iteratees are invoked with one argument: (value).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {...(Function|Function[])} [iteratees=[_.identity]]\n\t     *  The iteratees to sort by.\n\t     * @returns {Array} Returns the new sorted array.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'fred',   'age': 48 },\n\t     *   { 'user': 'barney', 'age': 36 },\n\t     *   { 'user': 'fred',   'age': 40 },\n\t     *   { 'user': 'barney', 'age': 34 }\n\t     * ];\n\t     *\n\t     * _.sortBy(users, [function(o) { return o.user; }]);\n\t     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n\t     *\n\t     * _.sortBy(users, ['user', 'age']);\n\t     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]\n\t     */\n\t    var sortBy = baseRest(function(collection, iteratees) {\n\t      if (collection == null) {\n\t        return [];\n\t      }\n\t      var length = iteratees.length;\n\t      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n\t        iteratees = [];\n\t      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n\t        iteratees = [iteratees[0]];\n\t      }\n\t      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n\t    });\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Gets the timestamp of the number of milliseconds that have elapsed since\n\t     * the Unix epoch (1 January 1970 00:00:00 UTC).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 2.4.0\n\t     * @category Date\n\t     * @returns {number} Returns the timestamp.\n\t     * @example\n\t     *\n\t     * _.defer(function(stamp) {\n\t     *   console.log(_.now() - stamp);\n\t     * }, _.now());\n\t     * // => Logs the number of milliseconds it took for the deferred invocation.\n\t     */\n\t    var now = ctxNow || function() {\n\t      return root.Date.now();\n\t    };\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * The opposite of `_.before`; this method creates a function that invokes\n\t     * `func` once it's called `n` or more times.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Function\n\t     * @param {number} n The number of calls before `func` is invoked.\n\t     * @param {Function} func The function to restrict.\n\t     * @returns {Function} Returns the new restricted function.\n\t     * @example\n\t     *\n\t     * var saves = ['profile', 'settings'];\n\t     *\n\t     * var done = _.after(saves.length, function() {\n\t     *   console.log('done saving!');\n\t     * });\n\t     *\n\t     * _.forEach(saves, function(type) {\n\t     *   asyncSave({ 'type': type, 'complete': done });\n\t     * });\n\t     * // => Logs 'done saving!' after the two async saves have completed.\n\t     */\n\t    function after(n, func) {\n\t      if (typeof func != 'function') {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      n = toInteger(n);\n\t      return function() {\n\t        if (--n < 1) {\n\t          return func.apply(this, arguments);\n\t        }\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that invokes `func`, with up to `n` arguments,\n\t     * ignoring any additional arguments.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category Function\n\t     * @param {Function} func The function to cap arguments for.\n\t     * @param {number} [n=func.length] The arity cap.\n\t     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n\t     * @returns {Function} Returns the new capped function.\n\t     * @example\n\t     *\n\t     * _.map(['6', '8', '10'], _.ary(parseInt, 1));\n\t     * // => [6, 8, 10]\n\t     */\n\t    function ary(func, n, guard) {\n\t      n = guard ? undefined : n;\n\t      n = (func && n == null) ? func.length : n;\n\t      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);\n\t    }\n\t\n\t    /**\n\t     * Creates a function that invokes `func`, with the `this` binding and arguments\n\t     * of the created function, while it's called less than `n` times. Subsequent\n\t     * calls to the created function return the result of the last `func` invocation.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category Function\n\t     * @param {number} n The number of calls at which `func` is no longer invoked.\n\t     * @param {Function} func The function to restrict.\n\t     * @returns {Function} Returns the new restricted function.\n\t     * @example\n\t     *\n\t     * jQuery(element).on('click', _.before(5, addContactToList));\n\t     * // => Allows adding up to 4 contacts to the list.\n\t     */\n\t    function before(n, func) {\n\t      var result;\n\t      if (typeof func != 'function') {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      n = toInteger(n);\n\t      return function() {\n\t        if (--n > 0) {\n\t          result = func.apply(this, arguments);\n\t        }\n\t        if (n <= 1) {\n\t          func = undefined;\n\t        }\n\t        return result;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that invokes `func` with the `this` binding of `thisArg`\n\t     * and `partials` prepended to the arguments it receives.\n\t     *\n\t     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\n\t     * may be used as a placeholder for partially applied arguments.\n\t     *\n\t     * **Note:** Unlike native `Function#bind`, this method doesn't set the \"length\"\n\t     * property of bound functions.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Function\n\t     * @param {Function} func The function to bind.\n\t     * @param {*} thisArg The `this` binding of `func`.\n\t     * @param {...*} [partials] The arguments to be partially applied.\n\t     * @returns {Function} Returns the new bound function.\n\t     * @example\n\t     *\n\t     * function greet(greeting, punctuation) {\n\t     *   return greeting + ' ' + this.user + punctuation;\n\t     * }\n\t     *\n\t     * var object = { 'user': 'fred' };\n\t     *\n\t     * var bound = _.bind(greet, object, 'hi');\n\t     * bound('!');\n\t     * // => 'hi fred!'\n\t     *\n\t     * // Bound with placeholders.\n\t     * var bound = _.bind(greet, object, _, '!');\n\t     * bound('hi');\n\t     * // => 'hi fred!'\n\t     */\n\t    var bind = baseRest(function(func, thisArg, partials) {\n\t      var bitmask = WRAP_BIND_FLAG;\n\t      if (partials.length) {\n\t        var holders = replaceHolders(partials, getHolder(bind));\n\t        bitmask |= WRAP_PARTIAL_FLAG;\n\t      }\n\t      return createWrap(func, bitmask, thisArg, partials, holders);\n\t    });\n\t\n\t    /**\n\t     * Creates a function that invokes the method at `object[key]` with `partials`\n\t     * prepended to the arguments it receives.\n\t     *\n\t     * This method differs from `_.bind` by allowing bound functions to reference\n\t     * methods that may be redefined or don't yet exist. See\n\t     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)\n\t     * for more details.\n\t     *\n\t     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic\n\t     * builds, may be used as a placeholder for partially applied arguments.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.10.0\n\t     * @category Function\n\t     * @param {Object} object The object to invoke the method on.\n\t     * @param {string} key The key of the method.\n\t     * @param {...*} [partials] The arguments to be partially applied.\n\t     * @returns {Function} Returns the new bound function.\n\t     * @example\n\t     *\n\t     * var object = {\n\t     *   'user': 'fred',\n\t     *   'greet': function(greeting, punctuation) {\n\t     *     return greeting + ' ' + this.user + punctuation;\n\t     *   }\n\t     * };\n\t     *\n\t     * var bound = _.bindKey(object, 'greet', 'hi');\n\t     * bound('!');\n\t     * // => 'hi fred!'\n\t     *\n\t     * object.greet = function(greeting, punctuation) {\n\t     *   return greeting + 'ya ' + this.user + punctuation;\n\t     * };\n\t     *\n\t     * bound('!');\n\t     * // => 'hiya fred!'\n\t     *\n\t     * // Bound with placeholders.\n\t     * var bound = _.bindKey(object, 'greet', _, '!');\n\t     * bound('hi');\n\t     * // => 'hiya fred!'\n\t     */\n\t    var bindKey = baseRest(function(object, key, partials) {\n\t      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;\n\t      if (partials.length) {\n\t        var holders = replaceHolders(partials, getHolder(bindKey));\n\t        bitmask |= WRAP_PARTIAL_FLAG;\n\t      }\n\t      return createWrap(key, bitmask, object, partials, holders);\n\t    });\n\t\n\t    /**\n\t     * Creates a function that accepts arguments of `func` and either invokes\n\t     * `func` returning its result, if at least `arity` number of arguments have\n\t     * been provided, or returns a function that accepts the remaining `func`\n\t     * arguments, and so on. The arity of `func` may be specified if `func.length`\n\t     * is not sufficient.\n\t     *\n\t     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,\n\t     * may be used as a placeholder for provided arguments.\n\t     *\n\t     * **Note:** This method doesn't set the \"length\" property of curried functions.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 2.0.0\n\t     * @category Function\n\t     * @param {Function} func The function to curry.\n\t     * @param {number} [arity=func.length] The arity of `func`.\n\t     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n\t     * @returns {Function} Returns the new curried function.\n\t     * @example\n\t     *\n\t     * var abc = function(a, b, c) {\n\t     *   return [a, b, c];\n\t     * };\n\t     *\n\t     * var curried = _.curry(abc);\n\t     *\n\t     * curried(1)(2)(3);\n\t     * // => [1, 2, 3]\n\t     *\n\t     * curried(1, 2)(3);\n\t     * // => [1, 2, 3]\n\t     *\n\t     * curried(1, 2, 3);\n\t     * // => [1, 2, 3]\n\t     *\n\t     * // Curried with placeholders.\n\t     * curried(1)(_, 3)(2);\n\t     * // => [1, 2, 3]\n\t     */\n\t    function curry(func, arity, guard) {\n\t      arity = guard ? undefined : arity;\n\t      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n\t      result.placeholder = curry.placeholder;\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.curry` except that arguments are applied to `func`\n\t     * in the manner of `_.partialRight` instead of `_.partial`.\n\t     *\n\t     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic\n\t     * builds, may be used as a placeholder for provided arguments.\n\t     *\n\t     * **Note:** This method doesn't set the \"length\" property of curried functions.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category Function\n\t     * @param {Function} func The function to curry.\n\t     * @param {number} [arity=func.length] The arity of `func`.\n\t     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n\t     * @returns {Function} Returns the new curried function.\n\t     * @example\n\t     *\n\t     * var abc = function(a, b, c) {\n\t     *   return [a, b, c];\n\t     * };\n\t     *\n\t     * var curried = _.curryRight(abc);\n\t     *\n\t     * curried(3)(2)(1);\n\t     * // => [1, 2, 3]\n\t     *\n\t     * curried(2, 3)(1);\n\t     * // => [1, 2, 3]\n\t     *\n\t     * curried(1, 2, 3);\n\t     * // => [1, 2, 3]\n\t     *\n\t     * // Curried with placeholders.\n\t     * curried(3)(1, _)(2);\n\t     * // => [1, 2, 3]\n\t     */\n\t    function curryRight(func, arity, guard) {\n\t      arity = guard ? undefined : arity;\n\t      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n\t      result.placeholder = curryRight.placeholder;\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Creates a debounced function that delays invoking `func` until after `wait`\n\t     * milliseconds have elapsed since the last time the debounced function was\n\t     * invoked. The debounced function comes with a `cancel` method to cancel\n\t     * delayed `func` invocations and a `flush` method to immediately invoke them.\n\t     * Provide `options` to indicate whether `func` should be invoked on the\n\t     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n\t     * with the last arguments provided to the debounced function. Subsequent\n\t     * calls to the debounced function return the result of the last `func`\n\t     * invocation.\n\t     *\n\t     * **Note:** If `leading` and `trailing` options are `true`, `func` is\n\t     * invoked on the trailing edge of the timeout only if the debounced function\n\t     * is invoked more than once during the `wait` timeout.\n\t     *\n\t     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n\t     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n\t     *\n\t     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n\t     * for details over the differences between `_.debounce` and `_.throttle`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Function\n\t     * @param {Function} func The function to debounce.\n\t     * @param {number} [wait=0] The number of milliseconds to delay.\n\t     * @param {Object} [options={}] The options object.\n\t     * @param {boolean} [options.leading=false]\n\t     *  Specify invoking on the leading edge of the timeout.\n\t     * @param {number} [options.maxWait]\n\t     *  The maximum time `func` is allowed to be delayed before it's invoked.\n\t     * @param {boolean} [options.trailing=true]\n\t     *  Specify invoking on the trailing edge of the timeout.\n\t     * @returns {Function} Returns the new debounced function.\n\t     * @example\n\t     *\n\t     * // Avoid costly calculations while the window size is in flux.\n\t     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n\t     *\n\t     * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n\t     * jQuery(element).on('click', _.debounce(sendMail, 300, {\n\t     *   'leading': true,\n\t     *   'trailing': false\n\t     * }));\n\t     *\n\t     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n\t     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n\t     * var source = new EventSource('/stream');\n\t     * jQuery(source).on('message', debounced);\n\t     *\n\t     * // Cancel the trailing debounced invocation.\n\t     * jQuery(window).on('popstate', debounced.cancel);\n\t     */\n\t    function debounce(func, wait, options) {\n\t      var lastArgs,\n\t          lastThis,\n\t          maxWait,\n\t          result,\n\t          timerId,\n\t          lastCallTime,\n\t          lastInvokeTime = 0,\n\t          leading = false,\n\t          maxing = false,\n\t          trailing = true;\n\t\n\t      if (typeof func != 'function') {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      wait = toNumber(wait) || 0;\n\t      if (isObject(options)) {\n\t        leading = !!options.leading;\n\t        maxing = 'maxWait' in options;\n\t        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n\t        trailing = 'trailing' in options ? !!options.trailing : trailing;\n\t      }\n\t\n\t      function invokeFunc(time) {\n\t        var args = lastArgs,\n\t            thisArg = lastThis;\n\t\n\t        lastArgs = lastThis = undefined;\n\t        lastInvokeTime = time;\n\t        result = func.apply(thisArg, args);\n\t        return result;\n\t      }\n\t\n\t      function leadingEdge(time) {\n\t        // Reset any `maxWait` timer.\n\t        lastInvokeTime = time;\n\t        // Start the timer for the trailing edge.\n\t        timerId = setTimeout(timerExpired, wait);\n\t        // Invoke the leading edge.\n\t        return leading ? invokeFunc(time) : result;\n\t      }\n\t\n\t      function remainingWait(time) {\n\t        var timeSinceLastCall = time - lastCallTime,\n\t            timeSinceLastInvoke = time - lastInvokeTime,\n\t            result = wait - timeSinceLastCall;\n\t\n\t        return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n\t      }\n\t\n\t      function shouldInvoke(time) {\n\t        var timeSinceLastCall = time - lastCallTime,\n\t            timeSinceLastInvoke = time - lastInvokeTime;\n\t\n\t        // Either this is the first call, activity has stopped and we're at the\n\t        // trailing edge, the system time has gone backwards and we're treating\n\t        // it as the trailing edge, or we've hit the `maxWait` limit.\n\t        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n\t          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n\t      }\n\t\n\t      function timerExpired() {\n\t        var time = now();\n\t        if (shouldInvoke(time)) {\n\t          return trailingEdge(time);\n\t        }\n\t        // Restart the timer.\n\t        timerId = setTimeout(timerExpired, remainingWait(time));\n\t      }\n\t\n\t      function trailingEdge(time) {\n\t        timerId = undefined;\n\t\n\t        // Only invoke if we have `lastArgs` which means `func` has been\n\t        // debounced at least once.\n\t        if (trailing && lastArgs) {\n\t          return invokeFunc(time);\n\t        }\n\t        lastArgs = lastThis = undefined;\n\t        return result;\n\t      }\n\t\n\t      function cancel() {\n\t        if (timerId !== undefined) {\n\t          clearTimeout(timerId);\n\t        }\n\t        lastInvokeTime = 0;\n\t        lastArgs = lastCallTime = lastThis = timerId = undefined;\n\t      }\n\t\n\t      function flush() {\n\t        return timerId === undefined ? result : trailingEdge(now());\n\t      }\n\t\n\t      function debounced() {\n\t        var time = now(),\n\t            isInvoking = shouldInvoke(time);\n\t\n\t        lastArgs = arguments;\n\t        lastThis = this;\n\t        lastCallTime = time;\n\t\n\t        if (isInvoking) {\n\t          if (timerId === undefined) {\n\t            return leadingEdge(lastCallTime);\n\t          }\n\t          if (maxing) {\n\t            // Handle invocations in a tight loop.\n\t            timerId = setTimeout(timerExpired, wait);\n\t            return invokeFunc(lastCallTime);\n\t          }\n\t        }\n\t        if (timerId === undefined) {\n\t          timerId = setTimeout(timerExpired, wait);\n\t        }\n\t        return result;\n\t      }\n\t      debounced.cancel = cancel;\n\t      debounced.flush = flush;\n\t      return debounced;\n\t    }\n\t\n\t    /**\n\t     * Defers invoking the `func` until the current call stack has cleared. Any\n\t     * additional arguments are provided to `func` when it's invoked.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Function\n\t     * @param {Function} func The function to defer.\n\t     * @param {...*} [args] The arguments to invoke `func` with.\n\t     * @returns {number} Returns the timer id.\n\t     * @example\n\t     *\n\t     * _.defer(function(text) {\n\t     *   console.log(text);\n\t     * }, 'deferred');\n\t     * // => Logs 'deferred' after one millisecond.\n\t     */\n\t    var defer = baseRest(function(func, args) {\n\t      return baseDelay(func, 1, args);\n\t    });\n\t\n\t    /**\n\t     * Invokes `func` after `wait` milliseconds. Any additional arguments are\n\t     * provided to `func` when it's invoked.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Function\n\t     * @param {Function} func The function to delay.\n\t     * @param {number} wait The number of milliseconds to delay invocation.\n\t     * @param {...*} [args] The arguments to invoke `func` with.\n\t     * @returns {number} Returns the timer id.\n\t     * @example\n\t     *\n\t     * _.delay(function(text) {\n\t     *   console.log(text);\n\t     * }, 1000, 'later');\n\t     * // => Logs 'later' after one second.\n\t     */\n\t    var delay = baseRest(function(func, wait, args) {\n\t      return baseDelay(func, toNumber(wait) || 0, args);\n\t    });\n\t\n\t    /**\n\t     * Creates a function that invokes `func` with arguments reversed.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Function\n\t     * @param {Function} func The function to flip arguments for.\n\t     * @returns {Function} Returns the new flipped function.\n\t     * @example\n\t     *\n\t     * var flipped = _.flip(function() {\n\t     *   return _.toArray(arguments);\n\t     * });\n\t     *\n\t     * flipped('a', 'b', 'c', 'd');\n\t     * // => ['d', 'c', 'b', 'a']\n\t     */\n\t    function flip(func) {\n\t      return createWrap(func, WRAP_FLIP_FLAG);\n\t    }\n\t\n\t    /**\n\t     * Creates a function that memoizes the result of `func`. If `resolver` is\n\t     * provided, it determines the cache key for storing the result based on the\n\t     * arguments provided to the memoized function. By default, the first argument\n\t     * provided to the memoized function is used as the map cache key. The `func`\n\t     * is invoked with the `this` binding of the memoized function.\n\t     *\n\t     * **Note:** The cache is exposed as the `cache` property on the memoized\n\t     * function. Its creation may be customized by replacing the `_.memoize.Cache`\n\t     * constructor with one whose instances implement the\n\t     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n\t     * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Function\n\t     * @param {Function} func The function to have its output memoized.\n\t     * @param {Function} [resolver] The function to resolve the cache key.\n\t     * @returns {Function} Returns the new memoized function.\n\t     * @example\n\t     *\n\t     * var object = { 'a': 1, 'b': 2 };\n\t     * var other = { 'c': 3, 'd': 4 };\n\t     *\n\t     * var values = _.memoize(_.values);\n\t     * values(object);\n\t     * // => [1, 2]\n\t     *\n\t     * values(other);\n\t     * // => [3, 4]\n\t     *\n\t     * object.a = 2;\n\t     * values(object);\n\t     * // => [1, 2]\n\t     *\n\t     * // Modify the result cache.\n\t     * values.cache.set(object, ['a', 'b']);\n\t     * values(object);\n\t     * // => ['a', 'b']\n\t     *\n\t     * // Replace `_.memoize.Cache`.\n\t     * _.memoize.Cache = WeakMap;\n\t     */\n\t    function memoize(func, resolver) {\n\t      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      var memoized = function() {\n\t        var args = arguments,\n\t            key = resolver ? resolver.apply(this, args) : args[0],\n\t            cache = memoized.cache;\n\t\n\t        if (cache.has(key)) {\n\t          return cache.get(key);\n\t        }\n\t        var result = func.apply(this, args);\n\t        memoized.cache = cache.set(key, result) || cache;\n\t        return result;\n\t      };\n\t      memoized.cache = new (memoize.Cache || MapCache);\n\t      return memoized;\n\t    }\n\t\n\t    // Expose `MapCache`.\n\t    memoize.Cache = MapCache;\n\t\n\t    /**\n\t     * Creates a function that negates the result of the predicate `func`. The\n\t     * `func` predicate is invoked with the `this` binding and arguments of the\n\t     * created function.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category Function\n\t     * @param {Function} predicate The predicate to negate.\n\t     * @returns {Function} Returns the new negated function.\n\t     * @example\n\t     *\n\t     * function isEven(n) {\n\t     *   return n % 2 == 0;\n\t     * }\n\t     *\n\t     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n\t     * // => [1, 3, 5]\n\t     */\n\t    function negate(predicate) {\n\t      if (typeof predicate != 'function') {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      return function() {\n\t        var args = arguments;\n\t        switch (args.length) {\n\t          case 0: return !predicate.call(this);\n\t          case 1: return !predicate.call(this, args[0]);\n\t          case 2: return !predicate.call(this, args[0], args[1]);\n\t          case 3: return !predicate.call(this, args[0], args[1], args[2]);\n\t        }\n\t        return !predicate.apply(this, args);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that is restricted to invoking `func` once. Repeat calls\n\t     * to the function return the value of the first invocation. The `func` is\n\t     * invoked with the `this` binding and arguments of the created function.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Function\n\t     * @param {Function} func The function to restrict.\n\t     * @returns {Function} Returns the new restricted function.\n\t     * @example\n\t     *\n\t     * var initialize = _.once(createApplication);\n\t     * initialize();\n\t     * initialize();\n\t     * // => `createApplication` is invoked once\n\t     */\n\t    function once(func) {\n\t      return before(2, func);\n\t    }\n\t\n\t    /**\n\t     * Creates a function that invokes `func` with its arguments transformed.\n\t     *\n\t     * @static\n\t     * @since 4.0.0\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to wrap.\n\t     * @param {...(Function|Function[])} [transforms=[_.identity]]\n\t     *  The argument transforms.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * function doubled(n) {\n\t     *   return n * 2;\n\t     * }\n\t     *\n\t     * function square(n) {\n\t     *   return n * n;\n\t     * }\n\t     *\n\t     * var func = _.overArgs(function(x, y) {\n\t     *   return [x, y];\n\t     * }, [square, doubled]);\n\t     *\n\t     * func(9, 3);\n\t     * // => [81, 6]\n\t     *\n\t     * func(10, 5);\n\t     * // => [100, 10]\n\t     */\n\t    var overArgs = castRest(function(func, transforms) {\n\t      transforms = (transforms.length == 1 && isArray(transforms[0]))\n\t        ? arrayMap(transforms[0], baseUnary(getIteratee()))\n\t        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));\n\t\n\t      var funcsLength = transforms.length;\n\t      return baseRest(function(args) {\n\t        var index = -1,\n\t            length = nativeMin(args.length, funcsLength);\n\t\n\t        while (++index < length) {\n\t          args[index] = transforms[index].call(this, args[index]);\n\t        }\n\t        return apply(func, this, args);\n\t      });\n\t    });\n\t\n\t    /**\n\t     * Creates a function that invokes `func` with `partials` prepended to the\n\t     * arguments it receives. This method is like `_.bind` except it does **not**\n\t     * alter the `this` binding.\n\t     *\n\t     * The `_.partial.placeholder` value, which defaults to `_` in monolithic\n\t     * builds, may be used as a placeholder for partially applied arguments.\n\t     *\n\t     * **Note:** This method doesn't set the \"length\" property of partially\n\t     * applied functions.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.2.0\n\t     * @category Function\n\t     * @param {Function} func The function to partially apply arguments to.\n\t     * @param {...*} [partials] The arguments to be partially applied.\n\t     * @returns {Function} Returns the new partially applied function.\n\t     * @example\n\t     *\n\t     * function greet(greeting, name) {\n\t     *   return greeting + ' ' + name;\n\t     * }\n\t     *\n\t     * var sayHelloTo = _.partial(greet, 'hello');\n\t     * sayHelloTo('fred');\n\t     * // => 'hello fred'\n\t     *\n\t     * // Partially applied with placeholders.\n\t     * var greetFred = _.partial(greet, _, 'fred');\n\t     * greetFred('hi');\n\t     * // => 'hi fred'\n\t     */\n\t    var partial = baseRest(function(func, partials) {\n\t      var holders = replaceHolders(partials, getHolder(partial));\n\t      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);\n\t    });\n\t\n\t    /**\n\t     * This method is like `_.partial` except that partially applied arguments\n\t     * are appended to the arguments it receives.\n\t     *\n\t     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic\n\t     * builds, may be used as a placeholder for partially applied arguments.\n\t     *\n\t     * **Note:** This method doesn't set the \"length\" property of partially\n\t     * applied functions.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 1.0.0\n\t     * @category Function\n\t     * @param {Function} func The function to partially apply arguments to.\n\t     * @param {...*} [partials] The arguments to be partially applied.\n\t     * @returns {Function} Returns the new partially applied function.\n\t     * @example\n\t     *\n\t     * function greet(greeting, name) {\n\t     *   return greeting + ' ' + name;\n\t     * }\n\t     *\n\t     * var greetFred = _.partialRight(greet, 'fred');\n\t     * greetFred('hi');\n\t     * // => 'hi fred'\n\t     *\n\t     * // Partially applied with placeholders.\n\t     * var sayHelloTo = _.partialRight(greet, 'hello', _);\n\t     * sayHelloTo('fred');\n\t     * // => 'hello fred'\n\t     */\n\t    var partialRight = baseRest(function(func, partials) {\n\t      var holders = replaceHolders(partials, getHolder(partialRight));\n\t      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);\n\t    });\n\t\n\t    /**\n\t     * Creates a function that invokes `func` with arguments arranged according\n\t     * to the specified `indexes` where the argument value at the first index is\n\t     * provided as the first argument, the argument value at the second index is\n\t     * provided as the second argument, and so on.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category Function\n\t     * @param {Function} func The function to rearrange arguments for.\n\t     * @param {...(number|number[])} indexes The arranged argument indexes.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var rearged = _.rearg(function(a, b, c) {\n\t     *   return [a, b, c];\n\t     * }, [2, 0, 1]);\n\t     *\n\t     * rearged('b', 'c', 'a')\n\t     * // => ['a', 'b', 'c']\n\t     */\n\t    var rearg = flatRest(function(func, indexes) {\n\t      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);\n\t    });\n\t\n\t    /**\n\t     * Creates a function that invokes `func` with the `this` binding of the\n\t     * created function and arguments from `start` and beyond provided as\n\t     * an array.\n\t     *\n\t     * **Note:** This method is based on the\n\t     * [rest parameter](https://mdn.io/rest_parameters).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Function\n\t     * @param {Function} func The function to apply a rest parameter to.\n\t     * @param {number} [start=func.length-1] The start position of the rest parameter.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var say = _.rest(function(what, names) {\n\t     *   return what + ' ' + _.initial(names).join(', ') +\n\t     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\n\t     * });\n\t     *\n\t     * say('hello', 'fred', 'barney', 'pebbles');\n\t     * // => 'hello fred, barney, & pebbles'\n\t     */\n\t    function rest(func, start) {\n\t      if (typeof func != 'function') {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      start = start === undefined ? start : toInteger(start);\n\t      return baseRest(func, start);\n\t    }\n\t\n\t    /**\n\t     * Creates a function that invokes `func` with the `this` binding of the\n\t     * create function and an array of arguments much like\n\t     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).\n\t     *\n\t     * **Note:** This method is based on the\n\t     * [spread operator](https://mdn.io/spread_operator).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.2.0\n\t     * @category Function\n\t     * @param {Function} func The function to spread arguments over.\n\t     * @param {number} [start=0] The start position of the spread.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var say = _.spread(function(who, what) {\n\t     *   return who + ' says ' + what;\n\t     * });\n\t     *\n\t     * say(['fred', 'hello']);\n\t     * // => 'fred says hello'\n\t     *\n\t     * var numbers = Promise.all([\n\t     *   Promise.resolve(40),\n\t     *   Promise.resolve(36)\n\t     * ]);\n\t     *\n\t     * numbers.then(_.spread(function(x, y) {\n\t     *   return x + y;\n\t     * }));\n\t     * // => a Promise of 76\n\t     */\n\t    function spread(func, start) {\n\t      if (typeof func != 'function') {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      start = start === undefined ? 0 : nativeMax(toInteger(start), 0);\n\t      return baseRest(function(args) {\n\t        var array = args[start],\n\t            otherArgs = castSlice(args, 0, start);\n\t\n\t        if (array) {\n\t          arrayPush(otherArgs, array);\n\t        }\n\t        return apply(func, this, otherArgs);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Creates a throttled function that only invokes `func` at most once per\n\t     * every `wait` milliseconds. The throttled function comes with a `cancel`\n\t     * method to cancel delayed `func` invocations and a `flush` method to\n\t     * immediately invoke them. Provide `options` to indicate whether `func`\n\t     * should be invoked on the leading and/or trailing edge of the `wait`\n\t     * timeout. The `func` is invoked with the last arguments provided to the\n\t     * throttled function. Subsequent calls to the throttled function return the\n\t     * result of the last `func` invocation.\n\t     *\n\t     * **Note:** If `leading` and `trailing` options are `true`, `func` is\n\t     * invoked on the trailing edge of the timeout only if the throttled function\n\t     * is invoked more than once during the `wait` timeout.\n\t     *\n\t     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n\t     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n\t     *\n\t     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n\t     * for details over the differences between `_.throttle` and `_.debounce`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Function\n\t     * @param {Function} func The function to throttle.\n\t     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n\t     * @param {Object} [options={}] The options object.\n\t     * @param {boolean} [options.leading=true]\n\t     *  Specify invoking on the leading edge of the timeout.\n\t     * @param {boolean} [options.trailing=true]\n\t     *  Specify invoking on the trailing edge of the timeout.\n\t     * @returns {Function} Returns the new throttled function.\n\t     * @example\n\t     *\n\t     * // Avoid excessively updating the position while scrolling.\n\t     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n\t     *\n\t     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n\t     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n\t     * jQuery(element).on('click', throttled);\n\t     *\n\t     * // Cancel the trailing throttled invocation.\n\t     * jQuery(window).on('popstate', throttled.cancel);\n\t     */\n\t    function throttle(func, wait, options) {\n\t      var leading = true,\n\t          trailing = true;\n\t\n\t      if (typeof func != 'function') {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      if (isObject(options)) {\n\t        leading = 'leading' in options ? !!options.leading : leading;\n\t        trailing = 'trailing' in options ? !!options.trailing : trailing;\n\t      }\n\t      return debounce(func, wait, {\n\t        'leading': leading,\n\t        'maxWait': wait,\n\t        'trailing': trailing\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Creates a function that accepts up to one argument, ignoring any\n\t     * additional arguments.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Function\n\t     * @param {Function} func The function to cap arguments for.\n\t     * @returns {Function} Returns the new capped function.\n\t     * @example\n\t     *\n\t     * _.map(['6', '8', '10'], _.unary(parseInt));\n\t     * // => [6, 8, 10]\n\t     */\n\t    function unary(func) {\n\t      return ary(func, 1);\n\t    }\n\t\n\t    /**\n\t     * Creates a function that provides `value` to `wrapper` as its first\n\t     * argument. Any additional arguments provided to the function are appended\n\t     * to those provided to the `wrapper`. The wrapper is invoked with the `this`\n\t     * binding of the created function.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Function\n\t     * @param {*} value The value to wrap.\n\t     * @param {Function} [wrapper=identity] The wrapper function.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var p = _.wrap(_.escape, function(func, text) {\n\t     *   return '<p>' + func(text) + '</p>';\n\t     * });\n\t     *\n\t     * p('fred, barney, & pebbles');\n\t     * // => '<p>fred, barney, &amp; pebbles</p>'\n\t     */\n\t    function wrap(value, wrapper) {\n\t      return partial(castFunction(wrapper), value);\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Casts `value` as an array if it's not one.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.4.0\n\t     * @category Lang\n\t     * @param {*} value The value to inspect.\n\t     * @returns {Array} Returns the cast array.\n\t     * @example\n\t     *\n\t     * _.castArray(1);\n\t     * // => [1]\n\t     *\n\t     * _.castArray({ 'a': 1 });\n\t     * // => [{ 'a': 1 }]\n\t     *\n\t     * _.castArray('abc');\n\t     * // => ['abc']\n\t     *\n\t     * _.castArray(null);\n\t     * // => [null]\n\t     *\n\t     * _.castArray(undefined);\n\t     * // => [undefined]\n\t     *\n\t     * _.castArray();\n\t     * // => []\n\t     *\n\t     * var array = [1, 2, 3];\n\t     * console.log(_.castArray(array) === array);\n\t     * // => true\n\t     */\n\t    function castArray() {\n\t      if (!arguments.length) {\n\t        return [];\n\t      }\n\t      var value = arguments[0];\n\t      return isArray(value) ? value : [value];\n\t    }\n\t\n\t    /**\n\t     * Creates a shallow clone of `value`.\n\t     *\n\t     * **Note:** This method is loosely based on the\n\t     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n\t     * and supports cloning arrays, array buffers, booleans, date objects, maps,\n\t     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n\t     * arrays. The own enumerable properties of `arguments` objects are cloned\n\t     * as plain objects. An empty object is returned for uncloneable values such\n\t     * as error objects, functions, DOM nodes, and WeakMaps.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Lang\n\t     * @param {*} value The value to clone.\n\t     * @returns {*} Returns the cloned value.\n\t     * @see _.cloneDeep\n\t     * @example\n\t     *\n\t     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n\t     *\n\t     * var shallow = _.clone(objects);\n\t     * console.log(shallow[0] === objects[0]);\n\t     * // => true\n\t     */\n\t    function clone(value) {\n\t      return baseClone(value, CLONE_SYMBOLS_FLAG);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.clone` except that it accepts `customizer` which\n\t     * is invoked to produce the cloned value. If `customizer` returns `undefined`,\n\t     * cloning is handled by the method instead. The `customizer` is invoked with\n\t     * up to four arguments; (value [, index|key, object, stack]).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Lang\n\t     * @param {*} value The value to clone.\n\t     * @param {Function} [customizer] The function to customize cloning.\n\t     * @returns {*} Returns the cloned value.\n\t     * @see _.cloneDeepWith\n\t     * @example\n\t     *\n\t     * function customizer(value) {\n\t     *   if (_.isElement(value)) {\n\t     *     return value.cloneNode(false);\n\t     *   }\n\t     * }\n\t     *\n\t     * var el = _.cloneWith(document.body, customizer);\n\t     *\n\t     * console.log(el === document.body);\n\t     * // => false\n\t     * console.log(el.nodeName);\n\t     * // => 'BODY'\n\t     * console.log(el.childNodes.length);\n\t     * // => 0\n\t     */\n\t    function cloneWith(value, customizer) {\n\t      customizer = typeof customizer == 'function' ? customizer : undefined;\n\t      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.clone` except that it recursively clones `value`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 1.0.0\n\t     * @category Lang\n\t     * @param {*} value The value to recursively clone.\n\t     * @returns {*} Returns the deep cloned value.\n\t     * @see _.clone\n\t     * @example\n\t     *\n\t     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n\t     *\n\t     * var deep = _.cloneDeep(objects);\n\t     * console.log(deep[0] === objects[0]);\n\t     * // => false\n\t     */\n\t    function cloneDeep(value) {\n\t      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.cloneWith` except that it recursively clones `value`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Lang\n\t     * @param {*} value The value to recursively clone.\n\t     * @param {Function} [customizer] The function to customize cloning.\n\t     * @returns {*} Returns the deep cloned value.\n\t     * @see _.cloneWith\n\t     * @example\n\t     *\n\t     * function customizer(value) {\n\t     *   if (_.isElement(value)) {\n\t     *     return value.cloneNode(true);\n\t     *   }\n\t     * }\n\t     *\n\t     * var el = _.cloneDeepWith(document.body, customizer);\n\t     *\n\t     * console.log(el === document.body);\n\t     * // => false\n\t     * console.log(el.nodeName);\n\t     * // => 'BODY'\n\t     * console.log(el.childNodes.length);\n\t     * // => 20\n\t     */\n\t    function cloneDeepWith(value, customizer) {\n\t      customizer = typeof customizer == 'function' ? customizer : undefined;\n\t      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);\n\t    }\n\t\n\t    /**\n\t     * Checks if `object` conforms to `source` by invoking the predicate\n\t     * properties of `source` with the corresponding property values of `object`.\n\t     *\n\t     * **Note:** This method is equivalent to `_.conforms` when `source` is\n\t     * partially applied.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.14.0\n\t     * @category Lang\n\t     * @param {Object} object The object to inspect.\n\t     * @param {Object} source The object of property predicates to conform to.\n\t     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n\t     * @example\n\t     *\n\t     * var object = { 'a': 1, 'b': 2 };\n\t     *\n\t     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });\n\t     * // => true\n\t     *\n\t     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });\n\t     * // => false\n\t     */\n\t    function conformsTo(object, source) {\n\t      return source == null || baseConformsTo(object, source, keys(source));\n\t    }\n\t\n\t    /**\n\t     * Performs a\n\t     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n\t     * comparison between two values to determine if they are equivalent.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Lang\n\t     * @param {*} value The value to compare.\n\t     * @param {*} other The other value to compare.\n\t     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n\t     * @example\n\t     *\n\t     * var object = { 'a': 1 };\n\t     * var other = { 'a': 1 };\n\t     *\n\t     * _.eq(object, object);\n\t     * // => true\n\t     *\n\t     * _.eq(object, other);\n\t     * // => false\n\t     *\n\t     * _.eq('a', 'a');\n\t     * // => true\n\t     *\n\t     * _.eq('a', Object('a'));\n\t     * // => false\n\t     *\n\t     * _.eq(NaN, NaN);\n\t     * // => true\n\t     */\n\t    function eq(value, other) {\n\t      return value === other || (value !== value && other !== other);\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is greater than `other`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.9.0\n\t     * @category Lang\n\t     * @param {*} value The value to compare.\n\t     * @param {*} other The other value to compare.\n\t     * @returns {boolean} Returns `true` if `value` is greater than `other`,\n\t     *  else `false`.\n\t     * @see _.lt\n\t     * @example\n\t     *\n\t     * _.gt(3, 1);\n\t     * // => true\n\t     *\n\t     * _.gt(3, 3);\n\t     * // => false\n\t     *\n\t     * _.gt(1, 3);\n\t     * // => false\n\t     */\n\t    var gt = createRelationalOperation(baseGt);\n\t\n\t    /**\n\t     * Checks if `value` is greater than or equal to `other`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.9.0\n\t     * @category Lang\n\t     * @param {*} value The value to compare.\n\t     * @param {*} other The other value to compare.\n\t     * @returns {boolean} Returns `true` if `value` is greater than or equal to\n\t     *  `other`, else `false`.\n\t     * @see _.lte\n\t     * @example\n\t     *\n\t     * _.gte(3, 1);\n\t     * // => true\n\t     *\n\t     * _.gte(3, 3);\n\t     * // => true\n\t     *\n\t     * _.gte(1, 3);\n\t     * // => false\n\t     */\n\t    var gte = createRelationalOperation(function(value, other) {\n\t      return value >= other;\n\t    });\n\t\n\t    /**\n\t     * Checks if `value` is likely an `arguments` object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n\t     *  else `false`.\n\t     * @example\n\t     *\n\t     * _.isArguments(function() { return arguments; }());\n\t     * // => true\n\t     *\n\t     * _.isArguments([1, 2, 3]);\n\t     * // => false\n\t     */\n\t    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n\t      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n\t        !propertyIsEnumerable.call(value, 'callee');\n\t    };\n\t\n\t    /**\n\t     * Checks if `value` is classified as an `Array` object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n\t     * @example\n\t     *\n\t     * _.isArray([1, 2, 3]);\n\t     * // => true\n\t     *\n\t     * _.isArray(document.body.children);\n\t     * // => false\n\t     *\n\t     * _.isArray('abc');\n\t     * // => false\n\t     *\n\t     * _.isArray(_.noop);\n\t     * // => false\n\t     */\n\t    var isArray = Array.isArray;\n\t\n\t    /**\n\t     * Checks if `value` is classified as an `ArrayBuffer` object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.3.0\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n\t     * @example\n\t     *\n\t     * _.isArrayBuffer(new ArrayBuffer(2));\n\t     * // => true\n\t     *\n\t     * _.isArrayBuffer(new Array(2));\n\t     * // => false\n\t     */\n\t    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;\n\t\n\t    /**\n\t     * Checks if `value` is array-like. A value is considered array-like if it's\n\t     * not a function and has a `value.length` that's an integer greater than or\n\t     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n\t     * @example\n\t     *\n\t     * _.isArrayLike([1, 2, 3]);\n\t     * // => true\n\t     *\n\t     * _.isArrayLike(document.body.children);\n\t     * // => true\n\t     *\n\t     * _.isArrayLike('abc');\n\t     * // => true\n\t     *\n\t     * _.isArrayLike(_.noop);\n\t     * // => false\n\t     */\n\t    function isArrayLike(value) {\n\t      return value != null && isLength(value.length) && !isFunction(value);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.isArrayLike` except that it also checks if `value`\n\t     * is an object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is an array-like object,\n\t     *  else `false`.\n\t     * @example\n\t     *\n\t     * _.isArrayLikeObject([1, 2, 3]);\n\t     * // => true\n\t     *\n\t     * _.isArrayLikeObject(document.body.children);\n\t     * // => true\n\t     *\n\t     * _.isArrayLikeObject('abc');\n\t     * // => false\n\t     *\n\t     * _.isArrayLikeObject(_.noop);\n\t     * // => false\n\t     */\n\t    function isArrayLikeObject(value) {\n\t      return isObjectLike(value) && isArrayLike(value);\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is classified as a boolean primitive or object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.\n\t     * @example\n\t     *\n\t     * _.isBoolean(false);\n\t     * // => true\n\t     *\n\t     * _.isBoolean(null);\n\t     * // => false\n\t     */\n\t    function isBoolean(value) {\n\t      return value === true || value === false ||\n\t        (isObjectLike(value) && baseGetTag(value) == boolTag);\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is a buffer.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.3.0\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n\t     * @example\n\t     *\n\t     * _.isBuffer(new Buffer(2));\n\t     * // => true\n\t     *\n\t     * _.isBuffer(new Uint8Array(2));\n\t     * // => false\n\t     */\n\t    var isBuffer = nativeIsBuffer || stubFalse;\n\t\n\t    /**\n\t     * Checks if `value` is classified as a `Date` object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n\t     * @example\n\t     *\n\t     * _.isDate(new Date);\n\t     * // => true\n\t     *\n\t     * _.isDate('Mon April 23 2012');\n\t     * // => false\n\t     */\n\t    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;\n\t\n\t    /**\n\t     * Checks if `value` is likely a DOM element.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.\n\t     * @example\n\t     *\n\t     * _.isElement(document.body);\n\t     * // => true\n\t     *\n\t     * _.isElement('<body>');\n\t     * // => false\n\t     */\n\t    function isElement(value) {\n\t      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is an empty object, collection, map, or set.\n\t     *\n\t     * Objects are considered empty if they have no own enumerable string keyed\n\t     * properties.\n\t     *\n\t     * Array-like values such as `arguments` objects, arrays, buffers, strings, or\n\t     * jQuery-like collections are considered empty if they have a `length` of `0`.\n\t     * Similarly, maps and sets are considered empty if they have a `size` of `0`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n\t     * @example\n\t     *\n\t     * _.isEmpty(null);\n\t     * // => true\n\t     *\n\t     * _.isEmpty(true);\n\t     * // => true\n\t     *\n\t     * _.isEmpty(1);\n\t     * // => true\n\t     *\n\t     * _.isEmpty([1, 2, 3]);\n\t     * // => false\n\t     *\n\t     * _.isEmpty({ 'a': 1 });\n\t     * // => false\n\t     */\n\t    function isEmpty(value) {\n\t      if (value == null) {\n\t        return true;\n\t      }\n\t      if (isArrayLike(value) &&\n\t          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||\n\t            isBuffer(value) || isTypedArray(value) || isArguments(value))) {\n\t        return !value.length;\n\t      }\n\t      var tag = getTag(value);\n\t      if (tag == mapTag || tag == setTag) {\n\t        return !value.size;\n\t      }\n\t      if (isPrototype(value)) {\n\t        return !baseKeys(value).length;\n\t      }\n\t      for (var key in value) {\n\t        if (hasOwnProperty.call(value, key)) {\n\t          return false;\n\t        }\n\t      }\n\t      return true;\n\t    }\n\t\n\t    /**\n\t     * Performs a deep comparison between two values to determine if they are\n\t     * equivalent.\n\t     *\n\t     * **Note:** This method supports comparing arrays, array buffers, booleans,\n\t     * date objects, error objects, maps, numbers, `Object` objects, regexes,\n\t     * sets, strings, symbols, and typed arrays. `Object` objects are compared\n\t     * by their own, not inherited, enumerable properties. Functions and DOM\n\t     * nodes are **not** supported.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Lang\n\t     * @param {*} value The value to compare.\n\t     * @param {*} other The other value to compare.\n\t     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n\t     * @example\n\t     *\n\t     * var object = { 'a': 1 };\n\t     * var other = { 'a': 1 };\n\t     *\n\t     * _.isEqual(object, other);\n\t     * // => true\n\t     *\n\t     * object === other;\n\t     * // => false\n\t     */\n\t    function isEqual(value, other) {\n\t      return baseIsEqual(value, other);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.isEqual` except that it accepts `customizer` which\n\t     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n\t     * are handled by the method instead. The `customizer` is invoked with up to\n\t     * six arguments: (objValue, othValue [, index|key, object, other, stack]).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Lang\n\t     * @param {*} value The value to compare.\n\t     * @param {*} other The other value to compare.\n\t     * @param {Function} [customizer] The function to customize comparisons.\n\t     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n\t     * @example\n\t     *\n\t     * function isGreeting(value) {\n\t     *   return /^h(?:i|ello)$/.test(value);\n\t     * }\n\t     *\n\t     * function customizer(objValue, othValue) {\n\t     *   if (isGreeting(objValue) && isGreeting(othValue)) {\n\t     *     return true;\n\t     *   }\n\t     * }\n\t     *\n\t     * var array = ['hello', 'goodbye'];\n\t     * var other = ['hi', 'goodbye'];\n\t     *\n\t     * _.isEqualWith(array, other, customizer);\n\t     * // => true\n\t     */\n\t    function isEqualWith(value, other, customizer) {\n\t      customizer = typeof customizer == 'function' ? customizer : undefined;\n\t      var result = customizer ? customizer(value, other) : undefined;\n\t      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,\n\t     * `SyntaxError`, `TypeError`, or `URIError` object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.\n\t     * @example\n\t     *\n\t     * _.isError(new Error);\n\t     * // => true\n\t     *\n\t     * _.isError(Error);\n\t     * // => false\n\t     */\n\t    function isError(value) {\n\t      if (!isObjectLike(value)) {\n\t        return false;\n\t      }\n\t      var tag = baseGetTag(value);\n\t      return tag == errorTag || tag == domExcTag ||\n\t        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is a finite primitive number.\n\t     *\n\t     * **Note:** This method is based on\n\t     * [`Number.isFinite`](https://mdn.io/Number/isFinite).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.\n\t     * @example\n\t     *\n\t     * _.isFinite(3);\n\t     * // => true\n\t     *\n\t     * _.isFinite(Number.MIN_VALUE);\n\t     * // => true\n\t     *\n\t     * _.isFinite(Infinity);\n\t     * // => false\n\t     *\n\t     * _.isFinite('3');\n\t     * // => false\n\t     */\n\t    function isFinite(value) {\n\t      return typeof value == 'number' && nativeIsFinite(value);\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is classified as a `Function` object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n\t     * @example\n\t     *\n\t     * _.isFunction(_);\n\t     * // => true\n\t     *\n\t     * _.isFunction(/abc/);\n\t     * // => false\n\t     */\n\t    function isFunction(value) {\n\t      if (!isObject(value)) {\n\t        return false;\n\t      }\n\t      // The use of `Object#toString` avoids issues with the `typeof` operator\n\t      // in Safari 9 which returns 'object' for typed arrays and other constructors.\n\t      var tag = baseGetTag(value);\n\t      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is an integer.\n\t     *\n\t     * **Note:** This method is based on\n\t     * [`Number.isInteger`](https://mdn.io/Number/isInteger).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.\n\t     * @example\n\t     *\n\t     * _.isInteger(3);\n\t     * // => true\n\t     *\n\t     * _.isInteger(Number.MIN_VALUE);\n\t     * // => false\n\t     *\n\t     * _.isInteger(Infinity);\n\t     * // => false\n\t     *\n\t     * _.isInteger('3');\n\t     * // => false\n\t     */\n\t    function isInteger(value) {\n\t      return typeof value == 'number' && value == toInteger(value);\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is a valid array-like length.\n\t     *\n\t     * **Note:** This method is loosely based on\n\t     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n\t     * @example\n\t     *\n\t     * _.isLength(3);\n\t     * // => true\n\t     *\n\t     * _.isLength(Number.MIN_VALUE);\n\t     * // => false\n\t     *\n\t     * _.isLength(Infinity);\n\t     * // => false\n\t     *\n\t     * _.isLength('3');\n\t     * // => false\n\t     */\n\t    function isLength(value) {\n\t      return typeof value == 'number' &&\n\t        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is the\n\t     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n\t     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n\t     * @example\n\t     *\n\t     * _.isObject({});\n\t     * // => true\n\t     *\n\t     * _.isObject([1, 2, 3]);\n\t     * // => true\n\t     *\n\t     * _.isObject(_.noop);\n\t     * // => true\n\t     *\n\t     * _.isObject(null);\n\t     * // => false\n\t     */\n\t    function isObject(value) {\n\t      var type = typeof value;\n\t      return value != null && (type == 'object' || type == 'function');\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is object-like. A value is object-like if it's not `null`\n\t     * and has a `typeof` result of \"object\".\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n\t     * @example\n\t     *\n\t     * _.isObjectLike({});\n\t     * // => true\n\t     *\n\t     * _.isObjectLike([1, 2, 3]);\n\t     * // => true\n\t     *\n\t     * _.isObjectLike(_.noop);\n\t     * // => false\n\t     *\n\t     * _.isObjectLike(null);\n\t     * // => false\n\t     */\n\t    function isObjectLike(value) {\n\t      return value != null && typeof value == 'object';\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is classified as a `Map` object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.3.0\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n\t     * @example\n\t     *\n\t     * _.isMap(new Map);\n\t     * // => true\n\t     *\n\t     * _.isMap(new WeakMap);\n\t     * // => false\n\t     */\n\t    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\t\n\t    /**\n\t     * Performs a partial deep comparison between `object` and `source` to\n\t     * determine if `object` contains equivalent property values.\n\t     *\n\t     * **Note:** This method is equivalent to `_.matches` when `source` is\n\t     * partially applied.\n\t     *\n\t     * Partial comparisons will match empty array and empty object `source`\n\t     * values against any array or object value, respectively. See `_.isEqual`\n\t     * for a list of supported value comparisons.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category Lang\n\t     * @param {Object} object The object to inspect.\n\t     * @param {Object} source The object of property values to match.\n\t     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n\t     * @example\n\t     *\n\t     * var object = { 'a': 1, 'b': 2 };\n\t     *\n\t     * _.isMatch(object, { 'b': 2 });\n\t     * // => true\n\t     *\n\t     * _.isMatch(object, { 'b': 1 });\n\t     * // => false\n\t     */\n\t    function isMatch(object, source) {\n\t      return object === source || baseIsMatch(object, source, getMatchData(source));\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.isMatch` except that it accepts `customizer` which\n\t     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n\t     * are handled by the method instead. The `customizer` is invoked with five\n\t     * arguments: (objValue, srcValue, index|key, object, source).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Lang\n\t     * @param {Object} object The object to inspect.\n\t     * @param {Object} source The object of property values to match.\n\t     * @param {Function} [customizer] The function to customize comparisons.\n\t     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n\t     * @example\n\t     *\n\t     * function isGreeting(value) {\n\t     *   return /^h(?:i|ello)$/.test(value);\n\t     * }\n\t     *\n\t     * function customizer(objValue, srcValue) {\n\t     *   if (isGreeting(objValue) && isGreeting(srcValue)) {\n\t     *     return true;\n\t     *   }\n\t     * }\n\t     *\n\t     * var object = { 'greeting': 'hello' };\n\t     * var source = { 'greeting': 'hi' };\n\t     *\n\t     * _.isMatchWith(object, source, customizer);\n\t     * // => true\n\t     */\n\t    function isMatchWith(object, source, customizer) {\n\t      customizer = typeof customizer == 'function' ? customizer : undefined;\n\t      return baseIsMatch(object, source, getMatchData(source), customizer);\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is `NaN`.\n\t     *\n\t     * **Note:** This method is based on\n\t     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as\n\t     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for\n\t     * `undefined` and other non-number values.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n\t     * @example\n\t     *\n\t     * _.isNaN(NaN);\n\t     * // => true\n\t     *\n\t     * _.isNaN(new Number(NaN));\n\t     * // => true\n\t     *\n\t     * isNaN(undefined);\n\t     * // => true\n\t     *\n\t     * _.isNaN(undefined);\n\t     * // => false\n\t     */\n\t    function isNaN(value) {\n\t      // An `NaN` primitive is the only value that is not equal to itself.\n\t      // Perform the `toStringTag` check first to avoid errors with some\n\t      // ActiveX objects in IE.\n\t      return isNumber(value) && value != +value;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is a pristine native function.\n\t     *\n\t     * **Note:** This method can't reliably detect native functions in the presence\n\t     * of the core-js package because core-js circumvents this kind of detection.\n\t     * Despite multiple requests, the core-js maintainer has made it clear: any\n\t     * attempt to fix the detection will be obstructed. As a result, we're left\n\t     * with little choice but to throw an error. Unfortunately, this also affects\n\t     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),\n\t     * which rely on core-js.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a native function,\n\t     *  else `false`.\n\t     * @example\n\t     *\n\t     * _.isNative(Array.prototype.push);\n\t     * // => true\n\t     *\n\t     * _.isNative(_);\n\t     * // => false\n\t     */\n\t    function isNative(value) {\n\t      if (isMaskable(value)) {\n\t        throw new Error(CORE_ERROR_TEXT);\n\t      }\n\t      return baseIsNative(value);\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is `null`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.\n\t     * @example\n\t     *\n\t     * _.isNull(null);\n\t     * // => true\n\t     *\n\t     * _.isNull(void 0);\n\t     * // => false\n\t     */\n\t    function isNull(value) {\n\t      return value === null;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is `null` or `undefined`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.\n\t     * @example\n\t     *\n\t     * _.isNil(null);\n\t     * // => true\n\t     *\n\t     * _.isNil(void 0);\n\t     * // => true\n\t     *\n\t     * _.isNil(NaN);\n\t     * // => false\n\t     */\n\t    function isNil(value) {\n\t      return value == null;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is classified as a `Number` primitive or object.\n\t     *\n\t     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are\n\t     * classified as numbers, use the `_.isFinite` method.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a number, else `false`.\n\t     * @example\n\t     *\n\t     * _.isNumber(3);\n\t     * // => true\n\t     *\n\t     * _.isNumber(Number.MIN_VALUE);\n\t     * // => true\n\t     *\n\t     * _.isNumber(Infinity);\n\t     * // => true\n\t     *\n\t     * _.isNumber('3');\n\t     * // => false\n\t     */\n\t    function isNumber(value) {\n\t      return typeof value == 'number' ||\n\t        (isObjectLike(value) && baseGetTag(value) == numberTag);\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is a plain object, that is, an object created by the\n\t     * `Object` constructor or one with a `[[Prototype]]` of `null`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.8.0\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     * }\n\t     *\n\t     * _.isPlainObject(new Foo);\n\t     * // => false\n\t     *\n\t     * _.isPlainObject([1, 2, 3]);\n\t     * // => false\n\t     *\n\t     * _.isPlainObject({ 'x': 0, 'y': 0 });\n\t     * // => true\n\t     *\n\t     * _.isPlainObject(Object.create(null));\n\t     * // => true\n\t     */\n\t    function isPlainObject(value) {\n\t      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n\t        return false;\n\t      }\n\t      var proto = getPrototype(value);\n\t      if (proto === null) {\n\t        return true;\n\t      }\n\t      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n\t      return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n\t        funcToString.call(Ctor) == objectCtorString;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is classified as a `RegExp` object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.1.0\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n\t     * @example\n\t     *\n\t     * _.isRegExp(/abc/);\n\t     * // => true\n\t     *\n\t     * _.isRegExp('/abc/');\n\t     * // => false\n\t     */\n\t    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n\t\n\t    /**\n\t     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754\n\t     * double precision number which isn't the result of a rounded unsafe integer.\n\t     *\n\t     * **Note:** This method is based on\n\t     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.\n\t     * @example\n\t     *\n\t     * _.isSafeInteger(3);\n\t     * // => true\n\t     *\n\t     * _.isSafeInteger(Number.MIN_VALUE);\n\t     * // => false\n\t     *\n\t     * _.isSafeInteger(Infinity);\n\t     * // => false\n\t     *\n\t     * _.isSafeInteger('3');\n\t     * // => false\n\t     */\n\t    function isSafeInteger(value) {\n\t      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is classified as a `Set` object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.3.0\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n\t     * @example\n\t     *\n\t     * _.isSet(new Set);\n\t     * // => true\n\t     *\n\t     * _.isSet(new WeakSet);\n\t     * // => false\n\t     */\n\t    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\t\n\t    /**\n\t     * Checks if `value` is classified as a `String` primitive or object.\n\t     *\n\t     * @static\n\t     * @since 0.1.0\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n\t     * @example\n\t     *\n\t     * _.isString('abc');\n\t     * // => true\n\t     *\n\t     * _.isString(1);\n\t     * // => false\n\t     */\n\t    function isString(value) {\n\t      return typeof value == 'string' ||\n\t        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is classified as a `Symbol` primitive or object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n\t     * @example\n\t     *\n\t     * _.isSymbol(Symbol.iterator);\n\t     * // => true\n\t     *\n\t     * _.isSymbol('abc');\n\t     * // => false\n\t     */\n\t    function isSymbol(value) {\n\t      return typeof value == 'symbol' ||\n\t        (isObjectLike(value) && baseGetTag(value) == symbolTag);\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is classified as a typed array.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n\t     * @example\n\t     *\n\t     * _.isTypedArray(new Uint8Array);\n\t     * // => true\n\t     *\n\t     * _.isTypedArray([]);\n\t     * // => false\n\t     */\n\t    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\t\n\t    /**\n\t     * Checks if `value` is `undefined`.\n\t     *\n\t     * @static\n\t     * @since 0.1.0\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n\t     * @example\n\t     *\n\t     * _.isUndefined(void 0);\n\t     * // => true\n\t     *\n\t     * _.isUndefined(null);\n\t     * // => false\n\t     */\n\t    function isUndefined(value) {\n\t      return value === undefined;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is classified as a `WeakMap` object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.3.0\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.\n\t     * @example\n\t     *\n\t     * _.isWeakMap(new WeakMap);\n\t     * // => true\n\t     *\n\t     * _.isWeakMap(new Map);\n\t     * // => false\n\t     */\n\t    function isWeakMap(value) {\n\t      return isObjectLike(value) && getTag(value) == weakMapTag;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is classified as a `WeakSet` object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.3.0\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.\n\t     * @example\n\t     *\n\t     * _.isWeakSet(new WeakSet);\n\t     * // => true\n\t     *\n\t     * _.isWeakSet(new Set);\n\t     * // => false\n\t     */\n\t    function isWeakSet(value) {\n\t      return isObjectLike(value) && baseGetTag(value) == weakSetTag;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is less than `other`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.9.0\n\t     * @category Lang\n\t     * @param {*} value The value to compare.\n\t     * @param {*} other The other value to compare.\n\t     * @returns {boolean} Returns `true` if `value` is less than `other`,\n\t     *  else `false`.\n\t     * @see _.gt\n\t     * @example\n\t     *\n\t     * _.lt(1, 3);\n\t     * // => true\n\t     *\n\t     * _.lt(3, 3);\n\t     * // => false\n\t     *\n\t     * _.lt(3, 1);\n\t     * // => false\n\t     */\n\t    var lt = createRelationalOperation(baseLt);\n\t\n\t    /**\n\t     * Checks if `value` is less than or equal to `other`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.9.0\n\t     * @category Lang\n\t     * @param {*} value The value to compare.\n\t     * @param {*} other The other value to compare.\n\t     * @returns {boolean} Returns `true` if `value` is less than or equal to\n\t     *  `other`, else `false`.\n\t     * @see _.gte\n\t     * @example\n\t     *\n\t     * _.lte(1, 3);\n\t     * // => true\n\t     *\n\t     * _.lte(3, 3);\n\t     * // => true\n\t     *\n\t     * _.lte(3, 1);\n\t     * // => false\n\t     */\n\t    var lte = createRelationalOperation(function(value, other) {\n\t      return value <= other;\n\t    });\n\t\n\t    /**\n\t     * Converts `value` to an array.\n\t     *\n\t     * @static\n\t     * @since 0.1.0\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to convert.\n\t     * @returns {Array} Returns the converted array.\n\t     * @example\n\t     *\n\t     * _.toArray({ 'a': 1, 'b': 2 });\n\t     * // => [1, 2]\n\t     *\n\t     * _.toArray('abc');\n\t     * // => ['a', 'b', 'c']\n\t     *\n\t     * _.toArray(1);\n\t     * // => []\n\t     *\n\t     * _.toArray(null);\n\t     * // => []\n\t     */\n\t    function toArray(value) {\n\t      if (!value) {\n\t        return [];\n\t      }\n\t      if (isArrayLike(value)) {\n\t        return isString(value) ? stringToArray(value) : copyArray(value);\n\t      }\n\t      if (symIterator && value[symIterator]) {\n\t        return iteratorToArray(value[symIterator]());\n\t      }\n\t      var tag = getTag(value),\n\t          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);\n\t\n\t      return func(value);\n\t    }\n\t\n\t    /**\n\t     * Converts `value` to a finite number.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.12.0\n\t     * @category Lang\n\t     * @param {*} value The value to convert.\n\t     * @returns {number} Returns the converted number.\n\t     * @example\n\t     *\n\t     * _.toFinite(3.2);\n\t     * // => 3.2\n\t     *\n\t     * _.toFinite(Number.MIN_VALUE);\n\t     * // => 5e-324\n\t     *\n\t     * _.toFinite(Infinity);\n\t     * // => 1.7976931348623157e+308\n\t     *\n\t     * _.toFinite('3.2');\n\t     * // => 3.2\n\t     */\n\t    function toFinite(value) {\n\t      if (!value) {\n\t        return value === 0 ? value : 0;\n\t      }\n\t      value = toNumber(value);\n\t      if (value === INFINITY || value === -INFINITY) {\n\t        var sign = (value < 0 ? -1 : 1);\n\t        return sign * MAX_INTEGER;\n\t      }\n\t      return value === value ? value : 0;\n\t    }\n\t\n\t    /**\n\t     * Converts `value` to an integer.\n\t     *\n\t     * **Note:** This method is loosely based on\n\t     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Lang\n\t     * @param {*} value The value to convert.\n\t     * @returns {number} Returns the converted integer.\n\t     * @example\n\t     *\n\t     * _.toInteger(3.2);\n\t     * // => 3\n\t     *\n\t     * _.toInteger(Number.MIN_VALUE);\n\t     * // => 0\n\t     *\n\t     * _.toInteger(Infinity);\n\t     * // => 1.7976931348623157e+308\n\t     *\n\t     * _.toInteger('3.2');\n\t     * // => 3\n\t     */\n\t    function toInteger(value) {\n\t      var result = toFinite(value),\n\t          remainder = result % 1;\n\t\n\t      return result === result ? (remainder ? result - remainder : result) : 0;\n\t    }\n\t\n\t    /**\n\t     * Converts `value` to an integer suitable for use as the length of an\n\t     * array-like object.\n\t     *\n\t     * **Note:** This method is based on\n\t     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Lang\n\t     * @param {*} value The value to convert.\n\t     * @returns {number} Returns the converted integer.\n\t     * @example\n\t     *\n\t     * _.toLength(3.2);\n\t     * // => 3\n\t     *\n\t     * _.toLength(Number.MIN_VALUE);\n\t     * // => 0\n\t     *\n\t     * _.toLength(Infinity);\n\t     * // => 4294967295\n\t     *\n\t     * _.toLength('3.2');\n\t     * // => 3\n\t     */\n\t    function toLength(value) {\n\t      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;\n\t    }\n\t\n\t    /**\n\t     * Converts `value` to a number.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Lang\n\t     * @param {*} value The value to process.\n\t     * @returns {number} Returns the number.\n\t     * @example\n\t     *\n\t     * _.toNumber(3.2);\n\t     * // => 3.2\n\t     *\n\t     * _.toNumber(Number.MIN_VALUE);\n\t     * // => 5e-324\n\t     *\n\t     * _.toNumber(Infinity);\n\t     * // => Infinity\n\t     *\n\t     * _.toNumber('3.2');\n\t     * // => 3.2\n\t     */\n\t    function toNumber(value) {\n\t      if (typeof value == 'number') {\n\t        return value;\n\t      }\n\t      if (isSymbol(value)) {\n\t        return NAN;\n\t      }\n\t      if (isObject(value)) {\n\t        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n\t        value = isObject(other) ? (other + '') : other;\n\t      }\n\t      if (typeof value != 'string') {\n\t        return value === 0 ? value : +value;\n\t      }\n\t      value = value.replace(reTrim, '');\n\t      var isBinary = reIsBinary.test(value);\n\t      return (isBinary || reIsOctal.test(value))\n\t        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n\t        : (reIsBadHex.test(value) ? NAN : +value);\n\t    }\n\t\n\t    /**\n\t     * Converts `value` to a plain object flattening inherited enumerable string\n\t     * keyed properties of `value` to own properties of the plain object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category Lang\n\t     * @param {*} value The value to convert.\n\t     * @returns {Object} Returns the converted plain object.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.assign({ 'a': 1 }, new Foo);\n\t     * // => { 'a': 1, 'b': 2 }\n\t     *\n\t     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n\t     * // => { 'a': 1, 'b': 2, 'c': 3 }\n\t     */\n\t    function toPlainObject(value) {\n\t      return copyObject(value, keysIn(value));\n\t    }\n\t\n\t    /**\n\t     * Converts `value` to a safe integer. A safe integer can be compared and\n\t     * represented correctly.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Lang\n\t     * @param {*} value The value to convert.\n\t     * @returns {number} Returns the converted integer.\n\t     * @example\n\t     *\n\t     * _.toSafeInteger(3.2);\n\t     * // => 3\n\t     *\n\t     * _.toSafeInteger(Number.MIN_VALUE);\n\t     * // => 0\n\t     *\n\t     * _.toSafeInteger(Infinity);\n\t     * // => 9007199254740991\n\t     *\n\t     * _.toSafeInteger('3.2');\n\t     * // => 3\n\t     */\n\t    function toSafeInteger(value) {\n\t      return baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);\n\t    }\n\t\n\t    /**\n\t     * Converts `value` to a string. An empty string is returned for `null`\n\t     * and `undefined` values. The sign of `-0` is preserved.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Lang\n\t     * @param {*} value The value to convert.\n\t     * @returns {string} Returns the converted string.\n\t     * @example\n\t     *\n\t     * _.toString(null);\n\t     * // => ''\n\t     *\n\t     * _.toString(-0);\n\t     * // => '-0'\n\t     *\n\t     * _.toString([1, 2, 3]);\n\t     * // => '1,2,3'\n\t     */\n\t    function toString(value) {\n\t      return value == null ? '' : baseToString(value);\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Assigns own enumerable string keyed properties of source objects to the\n\t     * destination object. Source objects are applied from left to right.\n\t     * Subsequent sources overwrite property assignments of previous sources.\n\t     *\n\t     * **Note:** This method mutates `object` and is loosely based on\n\t     * [`Object.assign`](https://mdn.io/Object/assign).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.10.0\n\t     * @category Object\n\t     * @param {Object} object The destination object.\n\t     * @param {...Object} [sources] The source objects.\n\t     * @returns {Object} Returns `object`.\n\t     * @see _.assignIn\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     * }\n\t     *\n\t     * function Bar() {\n\t     *   this.c = 3;\n\t     * }\n\t     *\n\t     * Foo.prototype.b = 2;\n\t     * Bar.prototype.d = 4;\n\t     *\n\t     * _.assign({ 'a': 0 }, new Foo, new Bar);\n\t     * // => { 'a': 1, 'c': 3 }\n\t     */\n\t    var assign = createAssigner(function(object, source) {\n\t      if (isPrototype(source) || isArrayLike(source)) {\n\t        copyObject(source, keys(source), object);\n\t        return;\n\t      }\n\t      for (var key in source) {\n\t        if (hasOwnProperty.call(source, key)) {\n\t          assignValue(object, key, source[key]);\n\t        }\n\t      }\n\t    });\n\t\n\t    /**\n\t     * This method is like `_.assign` except that it iterates over own and\n\t     * inherited source properties.\n\t     *\n\t     * **Note:** This method mutates `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @alias extend\n\t     * @category Object\n\t     * @param {Object} object The destination object.\n\t     * @param {...Object} [sources] The source objects.\n\t     * @returns {Object} Returns `object`.\n\t     * @see _.assign\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     * }\n\t     *\n\t     * function Bar() {\n\t     *   this.c = 3;\n\t     * }\n\t     *\n\t     * Foo.prototype.b = 2;\n\t     * Bar.prototype.d = 4;\n\t     *\n\t     * _.assignIn({ 'a': 0 }, new Foo, new Bar);\n\t     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }\n\t     */\n\t    var assignIn = createAssigner(function(object, source) {\n\t      copyObject(source, keysIn(source), object);\n\t    });\n\t\n\t    /**\n\t     * This method is like `_.assignIn` except that it accepts `customizer`\n\t     * which is invoked to produce the assigned values. If `customizer` returns\n\t     * `undefined`, assignment is handled by the method instead. The `customizer`\n\t     * is invoked with five arguments: (objValue, srcValue, key, object, source).\n\t     *\n\t     * **Note:** This method mutates `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @alias extendWith\n\t     * @category Object\n\t     * @param {Object} object The destination object.\n\t     * @param {...Object} sources The source objects.\n\t     * @param {Function} [customizer] The function to customize assigned values.\n\t     * @returns {Object} Returns `object`.\n\t     * @see _.assignWith\n\t     * @example\n\t     *\n\t     * function customizer(objValue, srcValue) {\n\t     *   return _.isUndefined(objValue) ? srcValue : objValue;\n\t     * }\n\t     *\n\t     * var defaults = _.partialRight(_.assignInWith, customizer);\n\t     *\n\t     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n\t     * // => { 'a': 1, 'b': 2 }\n\t     */\n\t    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {\n\t      copyObject(source, keysIn(source), object, customizer);\n\t    });\n\t\n\t    /**\n\t     * This method is like `_.assign` except that it accepts `customizer`\n\t     * which is invoked to produce the assigned values. If `customizer` returns\n\t     * `undefined`, assignment is handled by the method instead. The `customizer`\n\t     * is invoked with five arguments: (objValue, srcValue, key, object, source).\n\t     *\n\t     * **Note:** This method mutates `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Object\n\t     * @param {Object} object The destination object.\n\t     * @param {...Object} sources The source objects.\n\t     * @param {Function} [customizer] The function to customize assigned values.\n\t     * @returns {Object} Returns `object`.\n\t     * @see _.assignInWith\n\t     * @example\n\t     *\n\t     * function customizer(objValue, srcValue) {\n\t     *   return _.isUndefined(objValue) ? srcValue : objValue;\n\t     * }\n\t     *\n\t     * var defaults = _.partialRight(_.assignWith, customizer);\n\t     *\n\t     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n\t     * // => { 'a': 1, 'b': 2 }\n\t     */\n\t    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {\n\t      copyObject(source, keys(source), object, customizer);\n\t    });\n\t\n\t    /**\n\t     * Creates an array of values corresponding to `paths` of `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 1.0.0\n\t     * @category Object\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {...(string|string[])} [paths] The property paths to pick.\n\t     * @returns {Array} Returns the picked values.\n\t     * @example\n\t     *\n\t     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n\t     *\n\t     * _.at(object, ['a[0].b.c', 'a[1]']);\n\t     * // => [3, 4]\n\t     */\n\t    var at = flatRest(baseAt);\n\t\n\t    /**\n\t     * Creates an object that inherits from the `prototype` object. If a\n\t     * `properties` object is given, its own enumerable string keyed properties\n\t     * are assigned to the created object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 2.3.0\n\t     * @category Object\n\t     * @param {Object} prototype The object to inherit from.\n\t     * @param {Object} [properties] The properties to assign to the object.\n\t     * @returns {Object} Returns the new object.\n\t     * @example\n\t     *\n\t     * function Shape() {\n\t     *   this.x = 0;\n\t     *   this.y = 0;\n\t     * }\n\t     *\n\t     * function Circle() {\n\t     *   Shape.call(this);\n\t     * }\n\t     *\n\t     * Circle.prototype = _.create(Shape.prototype, {\n\t     *   'constructor': Circle\n\t     * });\n\t     *\n\t     * var circle = new Circle;\n\t     * circle instanceof Circle;\n\t     * // => true\n\t     *\n\t     * circle instanceof Shape;\n\t     * // => true\n\t     */\n\t    function create(prototype, properties) {\n\t      var result = baseCreate(prototype);\n\t      return properties == null ? result : baseAssign(result, properties);\n\t    }\n\t\n\t    /**\n\t     * Assigns own and inherited enumerable string keyed properties of source\n\t     * objects to the destination object for all destination properties that\n\t     * resolve to `undefined`. Source objects are applied from left to right.\n\t     * Once a property is set, additional values of the same property are ignored.\n\t     *\n\t     * **Note:** This method mutates `object`.\n\t     *\n\t     * @static\n\t     * @since 0.1.0\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The destination object.\n\t     * @param {...Object} [sources] The source objects.\n\t     * @returns {Object} Returns `object`.\n\t     * @see _.defaultsDeep\n\t     * @example\n\t     *\n\t     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n\t     * // => { 'a': 1, 'b': 2 }\n\t     */\n\t    var defaults = baseRest(function(args) {\n\t      args.push(undefined, assignInDefaults);\n\t      return apply(assignInWith, undefined, args);\n\t    });\n\t\n\t    /**\n\t     * This method is like `_.defaults` except that it recursively assigns\n\t     * default properties.\n\t     *\n\t     * **Note:** This method mutates `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.10.0\n\t     * @category Object\n\t     * @param {Object} object The destination object.\n\t     * @param {...Object} [sources] The source objects.\n\t     * @returns {Object} Returns `object`.\n\t     * @see _.defaults\n\t     * @example\n\t     *\n\t     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });\n\t     * // => { 'a': { 'b': 2, 'c': 3 } }\n\t     */\n\t    var defaultsDeep = baseRest(function(args) {\n\t      args.push(undefined, mergeDefaults);\n\t      return apply(mergeWith, undefined, args);\n\t    });\n\t\n\t    /**\n\t     * This method is like `_.find` except that it returns the key of the first\n\t     * element `predicate` returns truthy for instead of the element itself.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 1.1.0\n\t     * @category Object\n\t     * @param {Object} object The object to inspect.\n\t     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n\t     * @returns {string|undefined} Returns the key of the matched element,\n\t     *  else `undefined`.\n\t     * @example\n\t     *\n\t     * var users = {\n\t     *   'barney':  { 'age': 36, 'active': true },\n\t     *   'fred':    { 'age': 40, 'active': false },\n\t     *   'pebbles': { 'age': 1,  'active': true }\n\t     * };\n\t     *\n\t     * _.findKey(users, function(o) { return o.age < 40; });\n\t     * // => 'barney' (iteration order is not guaranteed)\n\t     *\n\t     * // The `_.matches` iteratee shorthand.\n\t     * _.findKey(users, { 'age': 1, 'active': true });\n\t     * // => 'pebbles'\n\t     *\n\t     * // The `_.matchesProperty` iteratee shorthand.\n\t     * _.findKey(users, ['active', false]);\n\t     * // => 'fred'\n\t     *\n\t     * // The `_.property` iteratee shorthand.\n\t     * _.findKey(users, 'active');\n\t     * // => 'barney'\n\t     */\n\t    function findKey(object, predicate) {\n\t      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.findKey` except that it iterates over elements of\n\t     * a collection in the opposite order.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 2.0.0\n\t     * @category Object\n\t     * @param {Object} object The object to inspect.\n\t     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n\t     * @returns {string|undefined} Returns the key of the matched element,\n\t     *  else `undefined`.\n\t     * @example\n\t     *\n\t     * var users = {\n\t     *   'barney':  { 'age': 36, 'active': true },\n\t     *   'fred':    { 'age': 40, 'active': false },\n\t     *   'pebbles': { 'age': 1,  'active': true }\n\t     * };\n\t     *\n\t     * _.findLastKey(users, function(o) { return o.age < 40; });\n\t     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'\n\t     *\n\t     * // The `_.matches` iteratee shorthand.\n\t     * _.findLastKey(users, { 'age': 36, 'active': true });\n\t     * // => 'barney'\n\t     *\n\t     * // The `_.matchesProperty` iteratee shorthand.\n\t     * _.findLastKey(users, ['active', false]);\n\t     * // => 'fred'\n\t     *\n\t     * // The `_.property` iteratee shorthand.\n\t     * _.findLastKey(users, 'active');\n\t     * // => 'pebbles'\n\t     */\n\t    function findLastKey(object, predicate) {\n\t      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);\n\t    }\n\t\n\t    /**\n\t     * Iterates over own and inherited enumerable string keyed properties of an\n\t     * object and invokes `iteratee` for each property. The iteratee is invoked\n\t     * with three arguments: (value, key, object). Iteratee functions may exit\n\t     * iteration early by explicitly returning `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.3.0\n\t     * @category Object\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @returns {Object} Returns `object`.\n\t     * @see _.forInRight\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.forIn(new Foo, function(value, key) {\n\t     *   console.log(key);\n\t     * });\n\t     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).\n\t     */\n\t    function forIn(object, iteratee) {\n\t      return object == null\n\t        ? object\n\t        : baseFor(object, getIteratee(iteratee, 3), keysIn);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.forIn` except that it iterates over properties of\n\t     * `object` in the opposite order.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 2.0.0\n\t     * @category Object\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @returns {Object} Returns `object`.\n\t     * @see _.forIn\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.forInRight(new Foo, function(value, key) {\n\t     *   console.log(key);\n\t     * });\n\t     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.\n\t     */\n\t    function forInRight(object, iteratee) {\n\t      return object == null\n\t        ? object\n\t        : baseForRight(object, getIteratee(iteratee, 3), keysIn);\n\t    }\n\t\n\t    /**\n\t     * Iterates over own enumerable string keyed properties of an object and\n\t     * invokes `iteratee` for each property. The iteratee is invoked with three\n\t     * arguments: (value, key, object). Iteratee functions may exit iteration\n\t     * early by explicitly returning `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.3.0\n\t     * @category Object\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @returns {Object} Returns `object`.\n\t     * @see _.forOwnRight\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.forOwn(new Foo, function(value, key) {\n\t     *   console.log(key);\n\t     * });\n\t     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n\t     */\n\t    function forOwn(object, iteratee) {\n\t      return object && baseForOwn(object, getIteratee(iteratee, 3));\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.forOwn` except that it iterates over properties of\n\t     * `object` in the opposite order.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 2.0.0\n\t     * @category Object\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @returns {Object} Returns `object`.\n\t     * @see _.forOwn\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.forOwnRight(new Foo, function(value, key) {\n\t     *   console.log(key);\n\t     * });\n\t     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.\n\t     */\n\t    function forOwnRight(object, iteratee) {\n\t      return object && baseForOwnRight(object, getIteratee(iteratee, 3));\n\t    }\n\t\n\t    /**\n\t     * Creates an array of function property names from own enumerable properties\n\t     * of `object`.\n\t     *\n\t     * @static\n\t     * @since 0.1.0\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to inspect.\n\t     * @returns {Array} Returns the function names.\n\t     * @see _.functionsIn\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = _.constant('a');\n\t     *   this.b = _.constant('b');\n\t     * }\n\t     *\n\t     * Foo.prototype.c = _.constant('c');\n\t     *\n\t     * _.functions(new Foo);\n\t     * // => ['a', 'b']\n\t     */\n\t    function functions(object) {\n\t      return object == null ? [] : baseFunctions(object, keys(object));\n\t    }\n\t\n\t    /**\n\t     * Creates an array of function property names from own and inherited\n\t     * enumerable properties of `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Object\n\t     * @param {Object} object The object to inspect.\n\t     * @returns {Array} Returns the function names.\n\t     * @see _.functions\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = _.constant('a');\n\t     *   this.b = _.constant('b');\n\t     * }\n\t     *\n\t     * Foo.prototype.c = _.constant('c');\n\t     *\n\t     * _.functionsIn(new Foo);\n\t     * // => ['a', 'b', 'c']\n\t     */\n\t    function functionsIn(object) {\n\t      return object == null ? [] : baseFunctions(object, keysIn(object));\n\t    }\n\t\n\t    /**\n\t     * Gets the value at `path` of `object`. If the resolved value is\n\t     * `undefined`, the `defaultValue` is returned in its place.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.7.0\n\t     * @category Object\n\t     * @param {Object} object The object to query.\n\t     * @param {Array|string} path The path of the property to get.\n\t     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n\t     * @returns {*} Returns the resolved value.\n\t     * @example\n\t     *\n\t     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n\t     *\n\t     * _.get(object, 'a[0].b.c');\n\t     * // => 3\n\t     *\n\t     * _.get(object, ['a', '0', 'b', 'c']);\n\t     * // => 3\n\t     *\n\t     * _.get(object, 'a.b.c', 'default');\n\t     * // => 'default'\n\t     */\n\t    function get(object, path, defaultValue) {\n\t      var result = object == null ? undefined : baseGet(object, path);\n\t      return result === undefined ? defaultValue : result;\n\t    }\n\t\n\t    /**\n\t     * Checks if `path` is a direct property of `object`.\n\t     *\n\t     * @static\n\t     * @since 0.1.0\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to query.\n\t     * @param {Array|string} path The path to check.\n\t     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n\t     * @example\n\t     *\n\t     * var object = { 'a': { 'b': 2 } };\n\t     * var other = _.create({ 'a': _.create({ 'b': 2 }) });\n\t     *\n\t     * _.has(object, 'a');\n\t     * // => true\n\t     *\n\t     * _.has(object, 'a.b');\n\t     * // => true\n\t     *\n\t     * _.has(object, ['a', 'b']);\n\t     * // => true\n\t     *\n\t     * _.has(other, 'a');\n\t     * // => false\n\t     */\n\t    function has(object, path) {\n\t      return object != null && hasPath(object, path, baseHas);\n\t    }\n\t\n\t    /**\n\t     * Checks if `path` is a direct or inherited property of `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Object\n\t     * @param {Object} object The object to query.\n\t     * @param {Array|string} path The path to check.\n\t     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n\t     * @example\n\t     *\n\t     * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n\t     *\n\t     * _.hasIn(object, 'a');\n\t     * // => true\n\t     *\n\t     * _.hasIn(object, 'a.b');\n\t     * // => true\n\t     *\n\t     * _.hasIn(object, ['a', 'b']);\n\t     * // => true\n\t     *\n\t     * _.hasIn(object, 'b');\n\t     * // => false\n\t     */\n\t    function hasIn(object, path) {\n\t      return object != null && hasPath(object, path, baseHasIn);\n\t    }\n\t\n\t    /**\n\t     * Creates an object composed of the inverted keys and values of `object`.\n\t     * If `object` contains duplicate values, subsequent values overwrite\n\t     * property assignments of previous values.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.7.0\n\t     * @category Object\n\t     * @param {Object} object The object to invert.\n\t     * @returns {Object} Returns the new inverted object.\n\t     * @example\n\t     *\n\t     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n\t     *\n\t     * _.invert(object);\n\t     * // => { '1': 'c', '2': 'b' }\n\t     */\n\t    var invert = createInverter(function(result, value, key) {\n\t      result[value] = key;\n\t    }, constant(identity));\n\t\n\t    /**\n\t     * This method is like `_.invert` except that the inverted object is generated\n\t     * from the results of running each element of `object` thru `iteratee`. The\n\t     * corresponding inverted value of each inverted key is an array of keys\n\t     * responsible for generating the inverted value. The iteratee is invoked\n\t     * with one argument: (value).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.1.0\n\t     * @category Object\n\t     * @param {Object} object The object to invert.\n\t     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n\t     * @returns {Object} Returns the new inverted object.\n\t     * @example\n\t     *\n\t     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n\t     *\n\t     * _.invertBy(object);\n\t     * // => { '1': ['a', 'c'], '2': ['b'] }\n\t     *\n\t     * _.invertBy(object, function(value) {\n\t     *   return 'group' + value;\n\t     * });\n\t     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }\n\t     */\n\t    var invertBy = createInverter(function(result, value, key) {\n\t      if (hasOwnProperty.call(result, value)) {\n\t        result[value].push(key);\n\t      } else {\n\t        result[value] = [key];\n\t      }\n\t    }, getIteratee);\n\t\n\t    /**\n\t     * Invokes the method at `path` of `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Object\n\t     * @param {Object} object The object to query.\n\t     * @param {Array|string} path The path of the method to invoke.\n\t     * @param {...*} [args] The arguments to invoke the method with.\n\t     * @returns {*} Returns the result of the invoked method.\n\t     * @example\n\t     *\n\t     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };\n\t     *\n\t     * _.invoke(object, 'a[0].b.c.slice', 1, 3);\n\t     * // => [2, 3]\n\t     */\n\t    var invoke = baseRest(baseInvoke);\n\t\n\t    /**\n\t     * Creates an array of the own enumerable property names of `object`.\n\t     *\n\t     * **Note:** Non-object values are coerced to objects. See the\n\t     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n\t     * for more details.\n\t     *\n\t     * @static\n\t     * @since 0.1.0\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to query.\n\t     * @returns {Array} Returns the array of property names.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.keys(new Foo);\n\t     * // => ['a', 'b'] (iteration order is not guaranteed)\n\t     *\n\t     * _.keys('hi');\n\t     * // => ['0', '1']\n\t     */\n\t    function keys(object) {\n\t      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n\t    }\n\t\n\t    /**\n\t     * Creates an array of the own and inherited enumerable property names of `object`.\n\t     *\n\t     * **Note:** Non-object values are coerced to objects.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category Object\n\t     * @param {Object} object The object to query.\n\t     * @returns {Array} Returns the array of property names.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.keysIn(new Foo);\n\t     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n\t     */\n\t    function keysIn(object) {\n\t      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n\t    }\n\t\n\t    /**\n\t     * The opposite of `_.mapValues`; this method creates an object with the\n\t     * same values as `object` and keys generated by running each own enumerable\n\t     * string keyed property of `object` thru `iteratee`. The iteratee is invoked\n\t     * with three arguments: (value, key, object).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.8.0\n\t     * @category Object\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @returns {Object} Returns the new mapped object.\n\t     * @see _.mapValues\n\t     * @example\n\t     *\n\t     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {\n\t     *   return key + value;\n\t     * });\n\t     * // => { 'a1': 1, 'b2': 2 }\n\t     */\n\t    function mapKeys(object, iteratee) {\n\t      var result = {};\n\t      iteratee = getIteratee(iteratee, 3);\n\t\n\t      baseForOwn(object, function(value, key, object) {\n\t        baseAssignValue(result, iteratee(value, key, object), value);\n\t      });\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Creates an object with the same keys as `object` and values generated\n\t     * by running each own enumerable string keyed property of `object` thru\n\t     * `iteratee`. The iteratee is invoked with three arguments:\n\t     * (value, key, object).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 2.4.0\n\t     * @category Object\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @returns {Object} Returns the new mapped object.\n\t     * @see _.mapKeys\n\t     * @example\n\t     *\n\t     * var users = {\n\t     *   'fred':    { 'user': 'fred',    'age': 40 },\n\t     *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n\t     * };\n\t     *\n\t     * _.mapValues(users, function(o) { return o.age; });\n\t     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n\t     *\n\t     * // The `_.property` iteratee shorthand.\n\t     * _.mapValues(users, 'age');\n\t     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n\t     */\n\t    function mapValues(object, iteratee) {\n\t      var result = {};\n\t      iteratee = getIteratee(iteratee, 3);\n\t\n\t      baseForOwn(object, function(value, key, object) {\n\t        baseAssignValue(result, key, iteratee(value, key, object));\n\t      });\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.assign` except that it recursively merges own and\n\t     * inherited enumerable string keyed properties of source objects into the\n\t     * destination object. Source properties that resolve to `undefined` are\n\t     * skipped if a destination value exists. Array and plain object properties\n\t     * are merged recursively. Other objects and value types are overridden by\n\t     * assignment. Source objects are applied from left to right. Subsequent\n\t     * sources overwrite property assignments of previous sources.\n\t     *\n\t     * **Note:** This method mutates `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.5.0\n\t     * @category Object\n\t     * @param {Object} object The destination object.\n\t     * @param {...Object} [sources] The source objects.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * var object = {\n\t     *   'a': [{ 'b': 2 }, { 'd': 4 }]\n\t     * };\n\t     *\n\t     * var other = {\n\t     *   'a': [{ 'c': 3 }, { 'e': 5 }]\n\t     * };\n\t     *\n\t     * _.merge(object, other);\n\t     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n\t     */\n\t    var merge = createAssigner(function(object, source, srcIndex) {\n\t      baseMerge(object, source, srcIndex);\n\t    });\n\t\n\t    /**\n\t     * This method is like `_.merge` except that it accepts `customizer` which\n\t     * is invoked to produce the merged values of the destination and source\n\t     * properties. If `customizer` returns `undefined`, merging is handled by the\n\t     * method instead. The `customizer` is invoked with six arguments:\n\t     * (objValue, srcValue, key, object, source, stack).\n\t     *\n\t     * **Note:** This method mutates `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Object\n\t     * @param {Object} object The destination object.\n\t     * @param {...Object} sources The source objects.\n\t     * @param {Function} customizer The function to customize assigned values.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * function customizer(objValue, srcValue) {\n\t     *   if (_.isArray(objValue)) {\n\t     *     return objValue.concat(srcValue);\n\t     *   }\n\t     * }\n\t     *\n\t     * var object = { 'a': [1], 'b': [2] };\n\t     * var other = { 'a': [3], 'b': [4] };\n\t     *\n\t     * _.mergeWith(object, other, customizer);\n\t     * // => { 'a': [1, 3], 'b': [2, 4] }\n\t     */\n\t    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {\n\t      baseMerge(object, source, srcIndex, customizer);\n\t    });\n\t\n\t    /**\n\t     * The opposite of `_.pick`; this method creates an object composed of the\n\t     * own and inherited enumerable property paths of `object` that are not omitted.\n\t     *\n\t     * **Note:** This method is considerably slower than `_.pick`.\n\t     *\n\t     * @static\n\t     * @since 0.1.0\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The source object.\n\t     * @param {...(string|string[])} [paths] The property paths to omit.\n\t     * @returns {Object} Returns the new object.\n\t     * @example\n\t     *\n\t     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n\t     *\n\t     * _.omit(object, ['a', 'c']);\n\t     * // => { 'b': '2' }\n\t     */\n\t    var omit = flatRest(function(object, paths) {\n\t      var result = {};\n\t      if (object == null) {\n\t        return result;\n\t      }\n\t      var isDeep = false;\n\t      paths = arrayMap(paths, function(path) {\n\t        path = castPath(path, object);\n\t        isDeep || (isDeep = path.length > 1);\n\t        return path;\n\t      });\n\t      copyObject(object, getAllKeysIn(object), result);\n\t      if (isDeep) {\n\t        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG);\n\t      }\n\t      var length = paths.length;\n\t      while (length--) {\n\t        baseUnset(result, paths[length]);\n\t      }\n\t      return result;\n\t    });\n\t\n\t    /**\n\t     * The opposite of `_.pickBy`; this method creates an object composed of\n\t     * the own and inherited enumerable string keyed properties of `object` that\n\t     * `predicate` doesn't return truthy for. The predicate is invoked with two\n\t     * arguments: (value, key).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Object\n\t     * @param {Object} object The source object.\n\t     * @param {Function} [predicate=_.identity] The function invoked per property.\n\t     * @returns {Object} Returns the new object.\n\t     * @example\n\t     *\n\t     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n\t     *\n\t     * _.omitBy(object, _.isNumber);\n\t     * // => { 'b': '2' }\n\t     */\n\t    function omitBy(object, predicate) {\n\t      return pickBy(object, negate(getIteratee(predicate)));\n\t    }\n\t\n\t    /**\n\t     * Creates an object composed of the picked `object` properties.\n\t     *\n\t     * @static\n\t     * @since 0.1.0\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The source object.\n\t     * @param {...(string|string[])} [paths] The property paths to pick.\n\t     * @returns {Object} Returns the new object.\n\t     * @example\n\t     *\n\t     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n\t     *\n\t     * _.pick(object, ['a', 'c']);\n\t     * // => { 'a': 1, 'c': 3 }\n\t     */\n\t    var pick = flatRest(function(object, paths) {\n\t      return object == null ? {} : basePick(object, paths);\n\t    });\n\t\n\t    /**\n\t     * Creates an object composed of the `object` properties `predicate` returns\n\t     * truthy for. The predicate is invoked with two arguments: (value, key).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Object\n\t     * @param {Object} object The source object.\n\t     * @param {Function} [predicate=_.identity] The function invoked per property.\n\t     * @returns {Object} Returns the new object.\n\t     * @example\n\t     *\n\t     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n\t     *\n\t     * _.pickBy(object, _.isNumber);\n\t     * // => { 'a': 1, 'c': 3 }\n\t     */\n\t    function pickBy(object, predicate) {\n\t      if (object == null) {\n\t        return {};\n\t      }\n\t      var props = arrayMap(getAllKeysIn(object), function(prop) {\n\t        return [prop];\n\t      });\n\t      predicate = getIteratee(predicate);\n\t      return basePickBy(object, props, function(value, path) {\n\t        return predicate(value, path[0]);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.get` except that if the resolved value is a\n\t     * function it's invoked with the `this` binding of its parent object and\n\t     * its result is returned.\n\t     *\n\t     * @static\n\t     * @since 0.1.0\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to query.\n\t     * @param {Array|string} path The path of the property to resolve.\n\t     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n\t     * @returns {*} Returns the resolved value.\n\t     * @example\n\t     *\n\t     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };\n\t     *\n\t     * _.result(object, 'a[0].b.c1');\n\t     * // => 3\n\t     *\n\t     * _.result(object, 'a[0].b.c2');\n\t     * // => 4\n\t     *\n\t     * _.result(object, 'a[0].b.c3', 'default');\n\t     * // => 'default'\n\t     *\n\t     * _.result(object, 'a[0].b.c3', _.constant('default'));\n\t     * // => 'default'\n\t     */\n\t    function result(object, path, defaultValue) {\n\t      path = castPath(path, object);\n\t\n\t      var index = -1,\n\t          length = path.length;\n\t\n\t      // Ensure the loop is entered when path is empty.\n\t      if (!length) {\n\t        length = 1;\n\t        object = undefined;\n\t      }\n\t      while (++index < length) {\n\t        var value = object == null ? undefined : object[toKey(path[index])];\n\t        if (value === undefined) {\n\t          index = length;\n\t          value = defaultValue;\n\t        }\n\t        object = isFunction(value) ? value.call(object) : value;\n\t      }\n\t      return object;\n\t    }\n\t\n\t    /**\n\t     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\n\t     * it's created. Arrays are created for missing index properties while objects\n\t     * are created for all other missing properties. Use `_.setWith` to customize\n\t     * `path` creation.\n\t     *\n\t     * **Note:** This method mutates `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.7.0\n\t     * @category Object\n\t     * @param {Object} object The object to modify.\n\t     * @param {Array|string} path The path of the property to set.\n\t     * @param {*} value The value to set.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n\t     *\n\t     * _.set(object, 'a[0].b.c', 4);\n\t     * console.log(object.a[0].b.c);\n\t     * // => 4\n\t     *\n\t     * _.set(object, ['x', '0', 'y', 'z'], 5);\n\t     * console.log(object.x[0].y.z);\n\t     * // => 5\n\t     */\n\t    function set(object, path, value) {\n\t      return object == null ? object : baseSet(object, path, value);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.set` except that it accepts `customizer` which is\n\t     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n\t     * path creation is handled by the method instead. The `customizer` is invoked\n\t     * with three arguments: (nsValue, key, nsObject).\n\t     *\n\t     * **Note:** This method mutates `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Object\n\t     * @param {Object} object The object to modify.\n\t     * @param {Array|string} path The path of the property to set.\n\t     * @param {*} value The value to set.\n\t     * @param {Function} [customizer] The function to customize assigned values.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * var object = {};\n\t     *\n\t     * _.setWith(object, '[0][1]', 'a', Object);\n\t     * // => { '0': { '1': 'a' } }\n\t     */\n\t    function setWith(object, path, value, customizer) {\n\t      customizer = typeof customizer == 'function' ? customizer : undefined;\n\t      return object == null ? object : baseSet(object, path, value, customizer);\n\t    }\n\t\n\t    /**\n\t     * Creates an array of own enumerable string keyed-value pairs for `object`\n\t     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its\n\t     * entries are returned.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @alias entries\n\t     * @category Object\n\t     * @param {Object} object The object to query.\n\t     * @returns {Array} Returns the key-value pairs.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.toPairs(new Foo);\n\t     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)\n\t     */\n\t    var toPairs = createToPairs(keys);\n\t\n\t    /**\n\t     * Creates an array of own and inherited enumerable string keyed-value pairs\n\t     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map\n\t     * or set, its entries are returned.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @alias entriesIn\n\t     * @category Object\n\t     * @param {Object} object The object to query.\n\t     * @returns {Array} Returns the key-value pairs.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.toPairsIn(new Foo);\n\t     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)\n\t     */\n\t    var toPairsIn = createToPairs(keysIn);\n\t\n\t    /**\n\t     * An alternative to `_.reduce`; this method transforms `object` to a new\n\t     * `accumulator` object which is the result of running each of its own\n\t     * enumerable string keyed properties thru `iteratee`, with each invocation\n\t     * potentially mutating the `accumulator` object. If `accumulator` is not\n\t     * provided, a new object with the same `[[Prototype]]` will be used. The\n\t     * iteratee is invoked with four arguments: (accumulator, value, key, object).\n\t     * Iteratee functions may exit iteration early by explicitly returning `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 1.3.0\n\t     * @category Object\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @param {*} [accumulator] The custom accumulator value.\n\t     * @returns {*} Returns the accumulated value.\n\t     * @example\n\t     *\n\t     * _.transform([2, 3, 4], function(result, n) {\n\t     *   result.push(n *= n);\n\t     *   return n % 2 == 0;\n\t     * }, []);\n\t     * // => [4, 9]\n\t     *\n\t     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n\t     *   (result[value] || (result[value] = [])).push(key);\n\t     * }, {});\n\t     * // => { '1': ['a', 'c'], '2': ['b'] }\n\t     */\n\t    function transform(object, iteratee, accumulator) {\n\t      var isArr = isArray(object),\n\t          isArrLike = isArr || isBuffer(object) || isTypedArray(object);\n\t\n\t      iteratee = getIteratee(iteratee, 4);\n\t      if (accumulator == null) {\n\t        var Ctor = object && object.constructor;\n\t        if (isArrLike) {\n\t          accumulator = isArr ? new Ctor : [];\n\t        }\n\t        else if (isObject(object)) {\n\t          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};\n\t        }\n\t        else {\n\t          accumulator = {};\n\t        }\n\t      }\n\t      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {\n\t        return iteratee(accumulator, value, index, object);\n\t      });\n\t      return accumulator;\n\t    }\n\t\n\t    /**\n\t     * Removes the property at `path` of `object`.\n\t     *\n\t     * **Note:** This method mutates `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Object\n\t     * @param {Object} object The object to modify.\n\t     * @param {Array|string} path The path of the property to unset.\n\t     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n\t     * @example\n\t     *\n\t     * var object = { 'a': [{ 'b': { 'c': 7 } }] };\n\t     * _.unset(object, 'a[0].b.c');\n\t     * // => true\n\t     *\n\t     * console.log(object);\n\t     * // => { 'a': [{ 'b': {} }] };\n\t     *\n\t     * _.unset(object, ['a', '0', 'b', 'c']);\n\t     * // => true\n\t     *\n\t     * console.log(object);\n\t     * // => { 'a': [{ 'b': {} }] };\n\t     */\n\t    function unset(object, path) {\n\t      return object == null ? true : baseUnset(object, path);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.set` except that accepts `updater` to produce the\n\t     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`\n\t     * is invoked with one argument: (value).\n\t     *\n\t     * **Note:** This method mutates `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.6.0\n\t     * @category Object\n\t     * @param {Object} object The object to modify.\n\t     * @param {Array|string} path The path of the property to set.\n\t     * @param {Function} updater The function to produce the updated value.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n\t     *\n\t     * _.update(object, 'a[0].b.c', function(n) { return n * n; });\n\t     * console.log(object.a[0].b.c);\n\t     * // => 9\n\t     *\n\t     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });\n\t     * console.log(object.x[0].y.z);\n\t     * // => 0\n\t     */\n\t    function update(object, path, updater) {\n\t      return object == null ? object : baseUpdate(object, path, castFunction(updater));\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.update` except that it accepts `customizer` which is\n\t     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n\t     * path creation is handled by the method instead. The `customizer` is invoked\n\t     * with three arguments: (nsValue, key, nsObject).\n\t     *\n\t     * **Note:** This method mutates `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.6.0\n\t     * @category Object\n\t     * @param {Object} object The object to modify.\n\t     * @param {Array|string} path The path of the property to set.\n\t     * @param {Function} updater The function to produce the updated value.\n\t     * @param {Function} [customizer] The function to customize assigned values.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * var object = {};\n\t     *\n\t     * _.updateWith(object, '[0][1]', _.constant('a'), Object);\n\t     * // => { '0': { '1': 'a' } }\n\t     */\n\t    function updateWith(object, path, updater, customizer) {\n\t      customizer = typeof customizer == 'function' ? customizer : undefined;\n\t      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);\n\t    }\n\t\n\t    /**\n\t     * Creates an array of the own enumerable string keyed property values of `object`.\n\t     *\n\t     * **Note:** Non-object values are coerced to objects.\n\t     *\n\t     * @static\n\t     * @since 0.1.0\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to query.\n\t     * @returns {Array} Returns the array of property values.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.values(new Foo);\n\t     * // => [1, 2] (iteration order is not guaranteed)\n\t     *\n\t     * _.values('hi');\n\t     * // => ['h', 'i']\n\t     */\n\t    function values(object) {\n\t      return object == null ? [] : baseValues(object, keys(object));\n\t    }\n\t\n\t    /**\n\t     * Creates an array of the own and inherited enumerable string keyed property\n\t     * values of `object`.\n\t     *\n\t     * **Note:** Non-object values are coerced to objects.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category Object\n\t     * @param {Object} object The object to query.\n\t     * @returns {Array} Returns the array of property values.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.valuesIn(new Foo);\n\t     * // => [1, 2, 3] (iteration order is not guaranteed)\n\t     */\n\t    function valuesIn(object) {\n\t      return object == null ? [] : baseValues(object, keysIn(object));\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Clamps `number` within the inclusive `lower` and `upper` bounds.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Number\n\t     * @param {number} number The number to clamp.\n\t     * @param {number} [lower] The lower bound.\n\t     * @param {number} upper The upper bound.\n\t     * @returns {number} Returns the clamped number.\n\t     * @example\n\t     *\n\t     * _.clamp(-10, -5, 5);\n\t     * // => -5\n\t     *\n\t     * _.clamp(10, -5, 5);\n\t     * // => 5\n\t     */\n\t    function clamp(number, lower, upper) {\n\t      if (upper === undefined) {\n\t        upper = lower;\n\t        lower = undefined;\n\t      }\n\t      if (upper !== undefined) {\n\t        upper = toNumber(upper);\n\t        upper = upper === upper ? upper : 0;\n\t      }\n\t      if (lower !== undefined) {\n\t        lower = toNumber(lower);\n\t        lower = lower === lower ? lower : 0;\n\t      }\n\t      return baseClamp(toNumber(number), lower, upper);\n\t    }\n\t\n\t    /**\n\t     * Checks if `n` is between `start` and up to, but not including, `end`. If\n\t     * `end` is not specified, it's set to `start` with `start` then set to `0`.\n\t     * If `start` is greater than `end` the params are swapped to support\n\t     * negative ranges.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.3.0\n\t     * @category Number\n\t     * @param {number} number The number to check.\n\t     * @param {number} [start=0] The start of the range.\n\t     * @param {number} end The end of the range.\n\t     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n\t     * @see _.range, _.rangeRight\n\t     * @example\n\t     *\n\t     * _.inRange(3, 2, 4);\n\t     * // => true\n\t     *\n\t     * _.inRange(4, 8);\n\t     * // => true\n\t     *\n\t     * _.inRange(4, 2);\n\t     * // => false\n\t     *\n\t     * _.inRange(2, 2);\n\t     * // => false\n\t     *\n\t     * _.inRange(1.2, 2);\n\t     * // => true\n\t     *\n\t     * _.inRange(5.2, 4);\n\t     * // => false\n\t     *\n\t     * _.inRange(-3, -2, -6);\n\t     * // => true\n\t     */\n\t    function inRange(number, start, end) {\n\t      start = toFinite(start);\n\t      if (end === undefined) {\n\t        end = start;\n\t        start = 0;\n\t      } else {\n\t        end = toFinite(end);\n\t      }\n\t      number = toNumber(number);\n\t      return baseInRange(number, start, end);\n\t    }\n\t\n\t    /**\n\t     * Produces a random number between the inclusive `lower` and `upper` bounds.\n\t     * If only one argument is provided a number between `0` and the given number\n\t     * is returned. If `floating` is `true`, or either `lower` or `upper` are\n\t     * floats, a floating-point number is returned instead of an integer.\n\t     *\n\t     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n\t     * floating-point values which can produce unexpected results.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.7.0\n\t     * @category Number\n\t     * @param {number} [lower=0] The lower bound.\n\t     * @param {number} [upper=1] The upper bound.\n\t     * @param {boolean} [floating] Specify returning a floating-point number.\n\t     * @returns {number} Returns the random number.\n\t     * @example\n\t     *\n\t     * _.random(0, 5);\n\t     * // => an integer between 0 and 5\n\t     *\n\t     * _.random(5);\n\t     * // => also an integer between 0 and 5\n\t     *\n\t     * _.random(5, true);\n\t     * // => a floating-point number between 0 and 5\n\t     *\n\t     * _.random(1.2, 5.2);\n\t     * // => a floating-point number between 1.2 and 5.2\n\t     */\n\t    function random(lower, upper, floating) {\n\t      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {\n\t        upper = floating = undefined;\n\t      }\n\t      if (floating === undefined) {\n\t        if (typeof upper == 'boolean') {\n\t          floating = upper;\n\t          upper = undefined;\n\t        }\n\t        else if (typeof lower == 'boolean') {\n\t          floating = lower;\n\t          lower = undefined;\n\t        }\n\t      }\n\t      if (lower === undefined && upper === undefined) {\n\t        lower = 0;\n\t        upper = 1;\n\t      }\n\t      else {\n\t        lower = toFinite(lower);\n\t        if (upper === undefined) {\n\t          upper = lower;\n\t          lower = 0;\n\t        } else {\n\t          upper = toFinite(upper);\n\t        }\n\t      }\n\t      if (lower > upper) {\n\t        var temp = lower;\n\t        lower = upper;\n\t        upper = temp;\n\t      }\n\t      if (floating || lower % 1 || upper % 1) {\n\t        var rand = nativeRandom();\n\t        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);\n\t      }\n\t      return baseRandom(lower, upper);\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category String\n\t     * @param {string} [string=''] The string to convert.\n\t     * @returns {string} Returns the camel cased string.\n\t     * @example\n\t     *\n\t     * _.camelCase('Foo Bar');\n\t     * // => 'fooBar'\n\t     *\n\t     * _.camelCase('--foo-bar--');\n\t     * // => 'fooBar'\n\t     *\n\t     * _.camelCase('__FOO_BAR__');\n\t     * // => 'fooBar'\n\t     */\n\t    var camelCase = createCompounder(function(result, word, index) {\n\t      word = word.toLowerCase();\n\t      return result + (index ? capitalize(word) : word);\n\t    });\n\t\n\t    /**\n\t     * Converts the first character of `string` to upper case and the remaining\n\t     * to lower case.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category String\n\t     * @param {string} [string=''] The string to capitalize.\n\t     * @returns {string} Returns the capitalized string.\n\t     * @example\n\t     *\n\t     * _.capitalize('FRED');\n\t     * // => 'Fred'\n\t     */\n\t    function capitalize(string) {\n\t      return upperFirst(toString(string).toLowerCase());\n\t    }\n\t\n\t    /**\n\t     * Deburrs `string` by converting\n\t     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\n\t     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)\n\t     * letters to basic Latin letters and removing\n\t     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category String\n\t     * @param {string} [string=''] The string to deburr.\n\t     * @returns {string} Returns the deburred string.\n\t     * @example\n\t     *\n\t     * _.deburr('déjà vu');\n\t     * // => 'deja vu'\n\t     */\n\t    function deburr(string) {\n\t      string = toString(string);\n\t      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');\n\t    }\n\t\n\t    /**\n\t     * Checks if `string` ends with the given target string.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category String\n\t     * @param {string} [string=''] The string to inspect.\n\t     * @param {string} [target] The string to search for.\n\t     * @param {number} [position=string.length] The position to search up to.\n\t     * @returns {boolean} Returns `true` if `string` ends with `target`,\n\t     *  else `false`.\n\t     * @example\n\t     *\n\t     * _.endsWith('abc', 'c');\n\t     * // => true\n\t     *\n\t     * _.endsWith('abc', 'b');\n\t     * // => false\n\t     *\n\t     * _.endsWith('abc', 'b', 2);\n\t     * // => true\n\t     */\n\t    function endsWith(string, target, position) {\n\t      string = toString(string);\n\t      target = baseToString(target);\n\t\n\t      var length = string.length;\n\t      position = position === undefined\n\t        ? length\n\t        : baseClamp(toInteger(position), 0, length);\n\t\n\t      var end = position;\n\t      position -= target.length;\n\t      return position >= 0 && string.slice(position, end) == target;\n\t    }\n\t\n\t    /**\n\t     * Converts the characters \"&\", \"<\", \">\", '\"', and \"'\" in `string` to their\n\t     * corresponding HTML entities.\n\t     *\n\t     * **Note:** No other characters are escaped. To escape additional\n\t     * characters use a third-party library like [_he_](https://mths.be/he).\n\t     *\n\t     * Though the \">\" character is escaped for symmetry, characters like\n\t     * \">\" and \"/\" don't need escaping in HTML and have no special meaning\n\t     * unless they're part of a tag or unquoted attribute value. See\n\t     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)\n\t     * (under \"semi-related fun fact\") for more details.\n\t     *\n\t     * When working with HTML you should always\n\t     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce\n\t     * XSS vectors.\n\t     *\n\t     * @static\n\t     * @since 0.1.0\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to escape.\n\t     * @returns {string} Returns the escaped string.\n\t     * @example\n\t     *\n\t     * _.escape('fred, barney, & pebbles');\n\t     * // => 'fred, barney, &amp; pebbles'\n\t     */\n\t    function escape(string) {\n\t      string = toString(string);\n\t      return (string && reHasUnescapedHtml.test(string))\n\t        ? string.replace(reUnescapedHtml, escapeHtmlChar)\n\t        : string;\n\t    }\n\t\n\t    /**\n\t     * Escapes the `RegExp` special characters \"^\", \"$\", \"\\\", \".\", \"*\", \"+\",\n\t     * \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `string`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category String\n\t     * @param {string} [string=''] The string to escape.\n\t     * @returns {string} Returns the escaped string.\n\t     * @example\n\t     *\n\t     * _.escapeRegExp('[lodash](https://lodash.com/)');\n\t     * // => '\\[lodash\\]\\(https://lodash\\.com/\\)'\n\t     */\n\t    function escapeRegExp(string) {\n\t      string = toString(string);\n\t      return (string && reHasRegExpChar.test(string))\n\t        ? string.replace(reRegExpChar, '\\\\$&')\n\t        : string;\n\t    }\n\t\n\t    /**\n\t     * Converts `string` to\n\t     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category String\n\t     * @param {string} [string=''] The string to convert.\n\t     * @returns {string} Returns the kebab cased string.\n\t     * @example\n\t     *\n\t     * _.kebabCase('Foo Bar');\n\t     * // => 'foo-bar'\n\t     *\n\t     * _.kebabCase('fooBar');\n\t     * // => 'foo-bar'\n\t     *\n\t     * _.kebabCase('__FOO_BAR__');\n\t     * // => 'foo-bar'\n\t     */\n\t    var kebabCase = createCompounder(function(result, word, index) {\n\t      return result + (index ? '-' : '') + word.toLowerCase();\n\t    });\n\t\n\t    /**\n\t     * Converts `string`, as space separated words, to lower case.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category String\n\t     * @param {string} [string=''] The string to convert.\n\t     * @returns {string} Returns the lower cased string.\n\t     * @example\n\t     *\n\t     * _.lowerCase('--Foo-Bar--');\n\t     * // => 'foo bar'\n\t     *\n\t     * _.lowerCase('fooBar');\n\t     * // => 'foo bar'\n\t     *\n\t     * _.lowerCase('__FOO_BAR__');\n\t     * // => 'foo bar'\n\t     */\n\t    var lowerCase = createCompounder(function(result, word, index) {\n\t      return result + (index ? ' ' : '') + word.toLowerCase();\n\t    });\n\t\n\t    /**\n\t     * Converts the first character of `string` to lower case.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category String\n\t     * @param {string} [string=''] The string to convert.\n\t     * @returns {string} Returns the converted string.\n\t     * @example\n\t     *\n\t     * _.lowerFirst('Fred');\n\t     * // => 'fred'\n\t     *\n\t     * _.lowerFirst('FRED');\n\t     * // => 'fRED'\n\t     */\n\t    var lowerFirst = createCaseFirst('toLowerCase');\n\t\n\t    /**\n\t     * Pads `string` on the left and right sides if it's shorter than `length`.\n\t     * Padding characters are truncated if they can't be evenly divided by `length`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category String\n\t     * @param {string} [string=''] The string to pad.\n\t     * @param {number} [length=0] The padding length.\n\t     * @param {string} [chars=' '] The string used as padding.\n\t     * @returns {string} Returns the padded string.\n\t     * @example\n\t     *\n\t     * _.pad('abc', 8);\n\t     * // => '  abc   '\n\t     *\n\t     * _.pad('abc', 8, '_-');\n\t     * // => '_-abc_-_'\n\t     *\n\t     * _.pad('abc', 3);\n\t     * // => 'abc'\n\t     */\n\t    function pad(string, length, chars) {\n\t      string = toString(string);\n\t      length = toInteger(length);\n\t\n\t      var strLength = length ? stringSize(string) : 0;\n\t      if (!length || strLength >= length) {\n\t        return string;\n\t      }\n\t      var mid = (length - strLength) / 2;\n\t      return (\n\t        createPadding(nativeFloor(mid), chars) +\n\t        string +\n\t        createPadding(nativeCeil(mid), chars)\n\t      );\n\t    }\n\t\n\t    /**\n\t     * Pads `string` on the right side if it's shorter than `length`. Padding\n\t     * characters are truncated if they exceed `length`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category String\n\t     * @param {string} [string=''] The string to pad.\n\t     * @param {number} [length=0] The padding length.\n\t     * @param {string} [chars=' '] The string used as padding.\n\t     * @returns {string} Returns the padded string.\n\t     * @example\n\t     *\n\t     * _.padEnd('abc', 6);\n\t     * // => 'abc   '\n\t     *\n\t     * _.padEnd('abc', 6, '_-');\n\t     * // => 'abc_-_'\n\t     *\n\t     * _.padEnd('abc', 3);\n\t     * // => 'abc'\n\t     */\n\t    function padEnd(string, length, chars) {\n\t      string = toString(string);\n\t      length = toInteger(length);\n\t\n\t      var strLength = length ? stringSize(string) : 0;\n\t      return (length && strLength < length)\n\t        ? (string + createPadding(length - strLength, chars))\n\t        : string;\n\t    }\n\t\n\t    /**\n\t     * Pads `string` on the left side if it's shorter than `length`. Padding\n\t     * characters are truncated if they exceed `length`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category String\n\t     * @param {string} [string=''] The string to pad.\n\t     * @param {number} [length=0] The padding length.\n\t     * @param {string} [chars=' '] The string used as padding.\n\t     * @returns {string} Returns the padded string.\n\t     * @example\n\t     *\n\t     * _.padStart('abc', 6);\n\t     * // => '   abc'\n\t     *\n\t     * _.padStart('abc', 6, '_-');\n\t     * // => '_-_abc'\n\t     *\n\t     * _.padStart('abc', 3);\n\t     * // => 'abc'\n\t     */\n\t    function padStart(string, length, chars) {\n\t      string = toString(string);\n\t      length = toInteger(length);\n\t\n\t      var strLength = length ? stringSize(string) : 0;\n\t      return (length && strLength < length)\n\t        ? (createPadding(length - strLength, chars) + string)\n\t        : string;\n\t    }\n\t\n\t    /**\n\t     * Converts `string` to an integer of the specified radix. If `radix` is\n\t     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a\n\t     * hexadecimal, in which case a `radix` of `16` is used.\n\t     *\n\t     * **Note:** This method aligns with the\n\t     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 1.1.0\n\t     * @category String\n\t     * @param {string} string The string to convert.\n\t     * @param {number} [radix=10] The radix to interpret `value` by.\n\t     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n\t     * @returns {number} Returns the converted integer.\n\t     * @example\n\t     *\n\t     * _.parseInt('08');\n\t     * // => 8\n\t     *\n\t     * _.map(['6', '08', '10'], _.parseInt);\n\t     * // => [6, 8, 10]\n\t     */\n\t    function parseInt(string, radix, guard) {\n\t      if (guard || radix == null) {\n\t        radix = 0;\n\t      } else if (radix) {\n\t        radix = +radix;\n\t      }\n\t      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);\n\t    }\n\t\n\t    /**\n\t     * Repeats the given string `n` times.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category String\n\t     * @param {string} [string=''] The string to repeat.\n\t     * @param {number} [n=1] The number of times to repeat the string.\n\t     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n\t     * @returns {string} Returns the repeated string.\n\t     * @example\n\t     *\n\t     * _.repeat('*', 3);\n\t     * // => '***'\n\t     *\n\t     * _.repeat('abc', 2);\n\t     * // => 'abcabc'\n\t     *\n\t     * _.repeat('abc', 0);\n\t     * // => ''\n\t     */\n\t    function repeat(string, n, guard) {\n\t      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {\n\t        n = 1;\n\t      } else {\n\t        n = toInteger(n);\n\t      }\n\t      return baseRepeat(toString(string), n);\n\t    }\n\t\n\t    /**\n\t     * Replaces matches for `pattern` in `string` with `replacement`.\n\t     *\n\t     * **Note:** This method is based on\n\t     * [`String#replace`](https://mdn.io/String/replace).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category String\n\t     * @param {string} [string=''] The string to modify.\n\t     * @param {RegExp|string} pattern The pattern to replace.\n\t     * @param {Function|string} replacement The match replacement.\n\t     * @returns {string} Returns the modified string.\n\t     * @example\n\t     *\n\t     * _.replace('Hi Fred', 'Fred', 'Barney');\n\t     * // => 'Hi Barney'\n\t     */\n\t    function replace() {\n\t      var args = arguments,\n\t          string = toString(args[0]);\n\t\n\t      return args.length < 3 ? string : string.replace(args[1], args[2]);\n\t    }\n\t\n\t    /**\n\t     * Converts `string` to\n\t     * [snake case](https://en.wikipedia.org/wiki/Snake_case).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category String\n\t     * @param {string} [string=''] The string to convert.\n\t     * @returns {string} Returns the snake cased string.\n\t     * @example\n\t     *\n\t     * _.snakeCase('Foo Bar');\n\t     * // => 'foo_bar'\n\t     *\n\t     * _.snakeCase('fooBar');\n\t     * // => 'foo_bar'\n\t     *\n\t     * _.snakeCase('--FOO-BAR--');\n\t     * // => 'foo_bar'\n\t     */\n\t    var snakeCase = createCompounder(function(result, word, index) {\n\t      return result + (index ? '_' : '') + word.toLowerCase();\n\t    });\n\t\n\t    /**\n\t     * Splits `string` by `separator`.\n\t     *\n\t     * **Note:** This method is based on\n\t     * [`String#split`](https://mdn.io/String/split).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category String\n\t     * @param {string} [string=''] The string to split.\n\t     * @param {RegExp|string} separator The separator pattern to split by.\n\t     * @param {number} [limit] The length to truncate results to.\n\t     * @returns {Array} Returns the string segments.\n\t     * @example\n\t     *\n\t     * _.split('a-b-c', '-', 2);\n\t     * // => ['a', 'b']\n\t     */\n\t    function split(string, separator, limit) {\n\t      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {\n\t        separator = limit = undefined;\n\t      }\n\t      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;\n\t      if (!limit) {\n\t        return [];\n\t      }\n\t      string = toString(string);\n\t      if (string && (\n\t            typeof separator == 'string' ||\n\t            (separator != null && !isRegExp(separator))\n\t          )) {\n\t        separator = baseToString(separator);\n\t        if (!separator && hasUnicode(string)) {\n\t          return castSlice(stringToArray(string), 0, limit);\n\t        }\n\t      }\n\t      return string.split(separator, limit);\n\t    }\n\t\n\t    /**\n\t     * Converts `string` to\n\t     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.1.0\n\t     * @category String\n\t     * @param {string} [string=''] The string to convert.\n\t     * @returns {string} Returns the start cased string.\n\t     * @example\n\t     *\n\t     * _.startCase('--foo-bar--');\n\t     * // => 'Foo Bar'\n\t     *\n\t     * _.startCase('fooBar');\n\t     * // => 'Foo Bar'\n\t     *\n\t     * _.startCase('__FOO_BAR__');\n\t     * // => 'FOO BAR'\n\t     */\n\t    var startCase = createCompounder(function(result, word, index) {\n\t      return result + (index ? ' ' : '') + upperFirst(word);\n\t    });\n\t\n\t    /**\n\t     * Checks if `string` starts with the given target string.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category String\n\t     * @param {string} [string=''] The string to inspect.\n\t     * @param {string} [target] The string to search for.\n\t     * @param {number} [position=0] The position to search from.\n\t     * @returns {boolean} Returns `true` if `string` starts with `target`,\n\t     *  else `false`.\n\t     * @example\n\t     *\n\t     * _.startsWith('abc', 'a');\n\t     * // => true\n\t     *\n\t     * _.startsWith('abc', 'b');\n\t     * // => false\n\t     *\n\t     * _.startsWith('abc', 'b', 1);\n\t     * // => true\n\t     */\n\t    function startsWith(string, target, position) {\n\t      string = toString(string);\n\t      position = baseClamp(toInteger(position), 0, string.length);\n\t      target = baseToString(target);\n\t      return string.slice(position, position + target.length) == target;\n\t    }\n\t\n\t    /**\n\t     * Creates a compiled template function that can interpolate data properties\n\t     * in \"interpolate\" delimiters, HTML-escape interpolated data properties in\n\t     * \"escape\" delimiters, and execute JavaScript in \"evaluate\" delimiters. Data\n\t     * properties may be accessed as free variables in the template. If a setting\n\t     * object is given, it takes precedence over `_.templateSettings` values.\n\t     *\n\t     * **Note:** In the development build `_.template` utilizes\n\t     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)\n\t     * for easier debugging.\n\t     *\n\t     * For more information on precompiling templates see\n\t     * [lodash's custom builds documentation](https://lodash.com/custom-builds).\n\t     *\n\t     * For more information on Chrome extension sandboxes see\n\t     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).\n\t     *\n\t     * @static\n\t     * @since 0.1.0\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The template string.\n\t     * @param {Object} [options={}] The options object.\n\t     * @param {RegExp} [options.escape=_.templateSettings.escape]\n\t     *  The HTML \"escape\" delimiter.\n\t     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]\n\t     *  The \"evaluate\" delimiter.\n\t     * @param {Object} [options.imports=_.templateSettings.imports]\n\t     *  An object to import into the template as free variables.\n\t     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]\n\t     *  The \"interpolate\" delimiter.\n\t     * @param {string} [options.sourceURL='lodash.templateSources[n]']\n\t     *  The sourceURL of the compiled template.\n\t     * @param {string} [options.variable='obj']\n\t     *  The data object variable name.\n\t     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n\t     * @returns {Function} Returns the compiled template function.\n\t     * @example\n\t     *\n\t     * // Use the \"interpolate\" delimiter to create a compiled template.\n\t     * var compiled = _.template('hello <%= user %>!');\n\t     * compiled({ 'user': 'fred' });\n\t     * // => 'hello fred!'\n\t     *\n\t     * // Use the HTML \"escape\" delimiter to escape data property values.\n\t     * var compiled = _.template('<b><%- value %></b>');\n\t     * compiled({ 'value': '<script>' });\n\t     * // => '<b>&lt;script&gt;</b>'\n\t     *\n\t     * // Use the \"evaluate\" delimiter to execute JavaScript and generate HTML.\n\t     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');\n\t     * compiled({ 'users': ['fred', 'barney'] });\n\t     * // => '<li>fred</li><li>barney</li>'\n\t     *\n\t     * // Use the internal `print` function in \"evaluate\" delimiters.\n\t     * var compiled = _.template('<% print(\"hello \" + user); %>!');\n\t     * compiled({ 'user': 'barney' });\n\t     * // => 'hello barney!'\n\t     *\n\t     * // Use the ES template literal delimiter as an \"interpolate\" delimiter.\n\t     * // Disable support by replacing the \"interpolate\" delimiter.\n\t     * var compiled = _.template('hello ${ user }!');\n\t     * compiled({ 'user': 'pebbles' });\n\t     * // => 'hello pebbles!'\n\t     *\n\t     * // Use backslashes to treat delimiters as plain text.\n\t     * var compiled = _.template('<%= \"\\\\<%- value %\\\\>\" %>');\n\t     * compiled({ 'value': 'ignored' });\n\t     * // => '<%- value %>'\n\t     *\n\t     * // Use the `imports` option to import `jQuery` as `jq`.\n\t     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';\n\t     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });\n\t     * compiled({ 'users': ['fred', 'barney'] });\n\t     * // => '<li>fred</li><li>barney</li>'\n\t     *\n\t     * // Use the `sourceURL` option to specify a custom sourceURL for the template.\n\t     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });\n\t     * compiled(data);\n\t     * // => Find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector.\n\t     *\n\t     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.\n\t     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });\n\t     * compiled.source;\n\t     * // => function(data) {\n\t     * //   var __t, __p = '';\n\t     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';\n\t     * //   return __p;\n\t     * // }\n\t     *\n\t     * // Use custom template delimiters.\n\t     * _.templateSettings.interpolate = /{{([\\s\\S]+?)}}/g;\n\t     * var compiled = _.template('hello {{ user }}!');\n\t     * compiled({ 'user': 'mustache' });\n\t     * // => 'hello mustache!'\n\t     *\n\t     * // Use the `source` property to inline compiled templates for meaningful\n\t     * // line numbers in error messages and stack traces.\n\t     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\\\n\t     *   var JST = {\\\n\t     *     \"main\": ' + _.template(mainText).source + '\\\n\t     *   };\\\n\t     * ');\n\t     */\n\t    function template(string, options, guard) {\n\t      // Based on John Resig's `tmpl` implementation\n\t      // (http://ejohn.org/blog/javascript-micro-templating/)\n\t      // and Laura Doktorova's doT.js (https://github.com/olado/doT).\n\t      var settings = lodash.templateSettings;\n\t\n\t      if (guard && isIterateeCall(string, options, guard)) {\n\t        options = undefined;\n\t      }\n\t      string = toString(string);\n\t      options = assignInWith({}, options, settings, assignInDefaults);\n\t\n\t      var imports = assignInWith({}, options.imports, settings.imports, assignInDefaults),\n\t          importsKeys = keys(imports),\n\t          importsValues = baseValues(imports, importsKeys);\n\t\n\t      var isEscaping,\n\t          isEvaluating,\n\t          index = 0,\n\t          interpolate = options.interpolate || reNoMatch,\n\t          source = \"__p += '\";\n\t\n\t      // Compile the regexp to match each delimiter.\n\t      var reDelimiters = RegExp(\n\t        (options.escape || reNoMatch).source + '|' +\n\t        interpolate.source + '|' +\n\t        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +\n\t        (options.evaluate || reNoMatch).source + '|$'\n\t      , 'g');\n\t\n\t      // Use a sourceURL for easier debugging.\n\t      var sourceURL = '//# sourceURL=' +\n\t        ('sourceURL' in options\n\t          ? options.sourceURL\n\t          : ('lodash.templateSources[' + (++templateCounter) + ']')\n\t        ) + '\\n';\n\t\n\t      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n\t        interpolateValue || (interpolateValue = esTemplateValue);\n\t\n\t        // Escape characters that can't be included in string literals.\n\t        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n\t\n\t        // Replace delimiters with snippets.\n\t        if (escapeValue) {\n\t          isEscaping = true;\n\t          source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\n\t        }\n\t        if (evaluateValue) {\n\t          isEvaluating = true;\n\t          source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n\t        }\n\t        if (interpolateValue) {\n\t          source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n\t        }\n\t        index = offset + match.length;\n\t\n\t        // The JS engine embedded in Adobe products needs `match` returned in\n\t        // order to produce the correct `offset` value.\n\t        return match;\n\t      });\n\t\n\t      source += \"';\\n\";\n\t\n\t      // If `variable` is not specified wrap a with-statement around the generated\n\t      // code to add the data object to the top of the scope chain.\n\t      var variable = options.variable;\n\t      if (!variable) {\n\t        source = 'with (obj) {\\n' + source + '\\n}\\n';\n\t      }\n\t      // Cleanup code by stripping empty strings.\n\t      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)\n\t        .replace(reEmptyStringMiddle, '$1')\n\t        .replace(reEmptyStringTrailing, '$1;');\n\t\n\t      // Frame code as the function body.\n\t      source = 'function(' + (variable || 'obj') + ') {\\n' +\n\t        (variable\n\t          ? ''\n\t          : 'obj || (obj = {});\\n'\n\t        ) +\n\t        \"var __t, __p = ''\" +\n\t        (isEscaping\n\t           ? ', __e = _.escape'\n\t           : ''\n\t        ) +\n\t        (isEvaluating\n\t          ? ', __j = Array.prototype.join;\\n' +\n\t            \"function print() { __p += __j.call(arguments, '') }\\n\"\n\t          : ';\\n'\n\t        ) +\n\t        source +\n\t        'return __p\\n}';\n\t\n\t      var result = attempt(function() {\n\t        return Function(importsKeys, sourceURL + 'return ' + source)\n\t          .apply(undefined, importsValues);\n\t      });\n\t\n\t      // Provide the compiled function's source by its `toString` method or\n\t      // the `source` property as a convenience for inlining compiled templates.\n\t      result.source = source;\n\t      if (isError(result)) {\n\t        throw result;\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Converts `string`, as a whole, to lower case just like\n\t     * [String#toLowerCase](https://mdn.io/toLowerCase).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category String\n\t     * @param {string} [string=''] The string to convert.\n\t     * @returns {string} Returns the lower cased string.\n\t     * @example\n\t     *\n\t     * _.toLower('--Foo-Bar--');\n\t     * // => '--foo-bar--'\n\t     *\n\t     * _.toLower('fooBar');\n\t     * // => 'foobar'\n\t     *\n\t     * _.toLower('__FOO_BAR__');\n\t     * // => '__foo_bar__'\n\t     */\n\t    function toLower(value) {\n\t      return toString(value).toLowerCase();\n\t    }\n\t\n\t    /**\n\t     * Converts `string`, as a whole, to upper case just like\n\t     * [String#toUpperCase](https://mdn.io/toUpperCase).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category String\n\t     * @param {string} [string=''] The string to convert.\n\t     * @returns {string} Returns the upper cased string.\n\t     * @example\n\t     *\n\t     * _.toUpper('--foo-bar--');\n\t     * // => '--FOO-BAR--'\n\t     *\n\t     * _.toUpper('fooBar');\n\t     * // => 'FOOBAR'\n\t     *\n\t     * _.toUpper('__foo_bar__');\n\t     * // => '__FOO_BAR__'\n\t     */\n\t    function toUpper(value) {\n\t      return toString(value).toUpperCase();\n\t    }\n\t\n\t    /**\n\t     * Removes leading and trailing whitespace or specified characters from `string`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category String\n\t     * @param {string} [string=''] The string to trim.\n\t     * @param {string} [chars=whitespace] The characters to trim.\n\t     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n\t     * @returns {string} Returns the trimmed string.\n\t     * @example\n\t     *\n\t     * _.trim('  abc  ');\n\t     * // => 'abc'\n\t     *\n\t     * _.trim('-_-abc-_-', '_-');\n\t     * // => 'abc'\n\t     *\n\t     * _.map(['  foo  ', '  bar  '], _.trim);\n\t     * // => ['foo', 'bar']\n\t     */\n\t    function trim(string, chars, guard) {\n\t      string = toString(string);\n\t      if (string && (guard || chars === undefined)) {\n\t        return string.replace(reTrim, '');\n\t      }\n\t      if (!string || !(chars = baseToString(chars))) {\n\t        return string;\n\t      }\n\t      var strSymbols = stringToArray(string),\n\t          chrSymbols = stringToArray(chars),\n\t          start = charsStartIndex(strSymbols, chrSymbols),\n\t          end = charsEndIndex(strSymbols, chrSymbols) + 1;\n\t\n\t      return castSlice(strSymbols, start, end).join('');\n\t    }\n\t\n\t    /**\n\t     * Removes trailing whitespace or specified characters from `string`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category String\n\t     * @param {string} [string=''] The string to trim.\n\t     * @param {string} [chars=whitespace] The characters to trim.\n\t     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n\t     * @returns {string} Returns the trimmed string.\n\t     * @example\n\t     *\n\t     * _.trimEnd('  abc  ');\n\t     * // => '  abc'\n\t     *\n\t     * _.trimEnd('-_-abc-_-', '_-');\n\t     * // => '-_-abc'\n\t     */\n\t    function trimEnd(string, chars, guard) {\n\t      string = toString(string);\n\t      if (string && (guard || chars === undefined)) {\n\t        return string.replace(reTrimEnd, '');\n\t      }\n\t      if (!string || !(chars = baseToString(chars))) {\n\t        return string;\n\t      }\n\t      var strSymbols = stringToArray(string),\n\t          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;\n\t\n\t      return castSlice(strSymbols, 0, end).join('');\n\t    }\n\t\n\t    /**\n\t     * Removes leading whitespace or specified characters from `string`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category String\n\t     * @param {string} [string=''] The string to trim.\n\t     * @param {string} [chars=whitespace] The characters to trim.\n\t     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n\t     * @returns {string} Returns the trimmed string.\n\t     * @example\n\t     *\n\t     * _.trimStart('  abc  ');\n\t     * // => 'abc  '\n\t     *\n\t     * _.trimStart('-_-abc-_-', '_-');\n\t     * // => 'abc-_-'\n\t     */\n\t    function trimStart(string, chars, guard) {\n\t      string = toString(string);\n\t      if (string && (guard || chars === undefined)) {\n\t        return string.replace(reTrimStart, '');\n\t      }\n\t      if (!string || !(chars = baseToString(chars))) {\n\t        return string;\n\t      }\n\t      var strSymbols = stringToArray(string),\n\t          start = charsStartIndex(strSymbols, stringToArray(chars));\n\t\n\t      return castSlice(strSymbols, start).join('');\n\t    }\n\t\n\t    /**\n\t     * Truncates `string` if it's longer than the given maximum string length.\n\t     * The last characters of the truncated string are replaced with the omission\n\t     * string which defaults to \"...\".\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category String\n\t     * @param {string} [string=''] The string to truncate.\n\t     * @param {Object} [options={}] The options object.\n\t     * @param {number} [options.length=30] The maximum string length.\n\t     * @param {string} [options.omission='...'] The string to indicate text is omitted.\n\t     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.\n\t     * @returns {string} Returns the truncated string.\n\t     * @example\n\t     *\n\t     * _.truncate('hi-diddly-ho there, neighborino');\n\t     * // => 'hi-diddly-ho there, neighbo...'\n\t     *\n\t     * _.truncate('hi-diddly-ho there, neighborino', {\n\t     *   'length': 24,\n\t     *   'separator': ' '\n\t     * });\n\t     * // => 'hi-diddly-ho there,...'\n\t     *\n\t     * _.truncate('hi-diddly-ho there, neighborino', {\n\t     *   'length': 24,\n\t     *   'separator': /,? +/\n\t     * });\n\t     * // => 'hi-diddly-ho there...'\n\t     *\n\t     * _.truncate('hi-diddly-ho there, neighborino', {\n\t     *   'omission': ' [...]'\n\t     * });\n\t     * // => 'hi-diddly-ho there, neig [...]'\n\t     */\n\t    function truncate(string, options) {\n\t      var length = DEFAULT_TRUNC_LENGTH,\n\t          omission = DEFAULT_TRUNC_OMISSION;\n\t\n\t      if (isObject(options)) {\n\t        var separator = 'separator' in options ? options.separator : separator;\n\t        length = 'length' in options ? toInteger(options.length) : length;\n\t        omission = 'omission' in options ? baseToString(options.omission) : omission;\n\t      }\n\t      string = toString(string);\n\t\n\t      var strLength = string.length;\n\t      if (hasUnicode(string)) {\n\t        var strSymbols = stringToArray(string);\n\t        strLength = strSymbols.length;\n\t      }\n\t      if (length >= strLength) {\n\t        return string;\n\t      }\n\t      var end = length - stringSize(omission);\n\t      if (end < 1) {\n\t        return omission;\n\t      }\n\t      var result = strSymbols\n\t        ? castSlice(strSymbols, 0, end).join('')\n\t        : string.slice(0, end);\n\t\n\t      if (separator === undefined) {\n\t        return result + omission;\n\t      }\n\t      if (strSymbols) {\n\t        end += (result.length - end);\n\t      }\n\t      if (isRegExp(separator)) {\n\t        if (string.slice(end).search(separator)) {\n\t          var match,\n\t              substring = result;\n\t\n\t          if (!separator.global) {\n\t            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');\n\t          }\n\t          separator.lastIndex = 0;\n\t          while ((match = separator.exec(substring))) {\n\t            var newEnd = match.index;\n\t          }\n\t          result = result.slice(0, newEnd === undefined ? end : newEnd);\n\t        }\n\t      } else if (string.indexOf(baseToString(separator), end) != end) {\n\t        var index = result.lastIndexOf(separator);\n\t        if (index > -1) {\n\t          result = result.slice(0, index);\n\t        }\n\t      }\n\t      return result + omission;\n\t    }\n\t\n\t    /**\n\t     * The inverse of `_.escape`; this method converts the HTML entities\n\t     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to\n\t     * their corresponding characters.\n\t     *\n\t     * **Note:** No other HTML entities are unescaped. To unescape additional\n\t     * HTML entities use a third-party library like [_he_](https://mths.be/he).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 0.6.0\n\t     * @category String\n\t     * @param {string} [string=''] The string to unescape.\n\t     * @returns {string} Returns the unescaped string.\n\t     * @example\n\t     *\n\t     * _.unescape('fred, barney, &amp; pebbles');\n\t     * // => 'fred, barney, & pebbles'\n\t     */\n\t    function unescape(string) {\n\t      string = toString(string);\n\t      return (string && reHasEscapedHtml.test(string))\n\t        ? string.replace(reEscapedHtml, unescapeHtmlChar)\n\t        : string;\n\t    }\n\t\n\t    /**\n\t     * Converts `string`, as space separated words, to upper case.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category String\n\t     * @param {string} [string=''] The string to convert.\n\t     * @returns {string} Returns the upper cased string.\n\t     * @example\n\t     *\n\t     * _.upperCase('--foo-bar');\n\t     * // => 'FOO BAR'\n\t     *\n\t     * _.upperCase('fooBar');\n\t     * // => 'FOO BAR'\n\t     *\n\t     * _.upperCase('__foo_bar__');\n\t     * // => 'FOO BAR'\n\t     */\n\t    var upperCase = createCompounder(function(result, word, index) {\n\t      return result + (index ? ' ' : '') + word.toUpperCase();\n\t    });\n\t\n\t    /**\n\t     * Converts the first character of `string` to upper case.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category String\n\t     * @param {string} [string=''] The string to convert.\n\t     * @returns {string} Returns the converted string.\n\t     * @example\n\t     *\n\t     * _.upperFirst('fred');\n\t     * // => 'Fred'\n\t     *\n\t     * _.upperFirst('FRED');\n\t     * // => 'FRED'\n\t     */\n\t    var upperFirst = createCaseFirst('toUpperCase');\n\t\n\t    /**\n\t     * Splits `string` into an array of its words.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category String\n\t     * @param {string} [string=''] The string to inspect.\n\t     * @param {RegExp|string} [pattern] The pattern to match words.\n\t     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n\t     * @returns {Array} Returns the words of `string`.\n\t     * @example\n\t     *\n\t     * _.words('fred, barney, & pebbles');\n\t     * // => ['fred', 'barney', 'pebbles']\n\t     *\n\t     * _.words('fred, barney, & pebbles', /[^, ]+/g);\n\t     * // => ['fred', 'barney', '&', 'pebbles']\n\t     */\n\t    function words(string, pattern, guard) {\n\t      string = toString(string);\n\t      pattern = guard ? undefined : pattern;\n\t\n\t      if (pattern === undefined) {\n\t        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\n\t      }\n\t      return string.match(pattern) || [];\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Attempts to invoke `func`, returning either the result or the caught error\n\t     * object. Any additional arguments are provided to `func` when it's invoked.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category Util\n\t     * @param {Function} func The function to attempt.\n\t     * @param {...*} [args] The arguments to invoke `func` with.\n\t     * @returns {*} Returns the `func` result or error object.\n\t     * @example\n\t     *\n\t     * // Avoid throwing errors for invalid selectors.\n\t     * var elements = _.attempt(function(selector) {\n\t     *   return document.querySelectorAll(selector);\n\t     * }, '>_>');\n\t     *\n\t     * if (_.isError(elements)) {\n\t     *   elements = [];\n\t     * }\n\t     */\n\t    var attempt = baseRest(function(func, args) {\n\t      try {\n\t        return apply(func, undefined, args);\n\t      } catch (e) {\n\t        return isError(e) ? e : new Error(e);\n\t      }\n\t    });\n\t\n\t    /**\n\t     * Binds methods of an object to the object itself, overwriting the existing\n\t     * method.\n\t     *\n\t     * **Note:** This method doesn't set the \"length\" property of bound functions.\n\t     *\n\t     * @static\n\t     * @since 0.1.0\n\t     * @memberOf _\n\t     * @category Util\n\t     * @param {Object} object The object to bind and assign the bound methods to.\n\t     * @param {...(string|string[])} methodNames The object method names to bind.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * var view = {\n\t     *   'label': 'docs',\n\t     *   'click': function() {\n\t     *     console.log('clicked ' + this.label);\n\t     *   }\n\t     * };\n\t     *\n\t     * _.bindAll(view, ['click']);\n\t     * jQuery(element).on('click', view.click);\n\t     * // => Logs 'clicked docs' when clicked.\n\t     */\n\t    var bindAll = flatRest(function(object, methodNames) {\n\t      arrayEach(methodNames, function(key) {\n\t        key = toKey(key);\n\t        baseAssignValue(object, key, bind(object[key], object));\n\t      });\n\t      return object;\n\t    });\n\t\n\t    /**\n\t     * Creates a function that iterates over `pairs` and invokes the corresponding\n\t     * function of the first predicate to return truthy. The predicate-function\n\t     * pairs are invoked with the `this` binding and arguments of the created\n\t     * function.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Util\n\t     * @param {Array} pairs The predicate-function pairs.\n\t     * @returns {Function} Returns the new composite function.\n\t     * @example\n\t     *\n\t     * var func = _.cond([\n\t     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],\n\t     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],\n\t     *   [_.stubTrue,                      _.constant('no match')]\n\t     * ]);\n\t     *\n\t     * func({ 'a': 1, 'b': 2 });\n\t     * // => 'matches A'\n\t     *\n\t     * func({ 'a': 0, 'b': 1 });\n\t     * // => 'matches B'\n\t     *\n\t     * func({ 'a': '1', 'b': '2' });\n\t     * // => 'no match'\n\t     */\n\t    function cond(pairs) {\n\t      var length = pairs == null ? 0 : pairs.length,\n\t          toIteratee = getIteratee();\n\t\n\t      pairs = !length ? [] : arrayMap(pairs, function(pair) {\n\t        if (typeof pair[1] != 'function') {\n\t          throw new TypeError(FUNC_ERROR_TEXT);\n\t        }\n\t        return [toIteratee(pair[0]), pair[1]];\n\t      });\n\t\n\t      return baseRest(function(args) {\n\t        var index = -1;\n\t        while (++index < length) {\n\t          var pair = pairs[index];\n\t          if (apply(pair[0], this, args)) {\n\t            return apply(pair[1], this, args);\n\t          }\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Creates a function that invokes the predicate properties of `source` with\n\t     * the corresponding property values of a given object, returning `true` if\n\t     * all predicates return truthy, else `false`.\n\t     *\n\t     * **Note:** The created function is equivalent to `_.conformsTo` with\n\t     * `source` partially applied.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Util\n\t     * @param {Object} source The object of property predicates to conform to.\n\t     * @returns {Function} Returns the new spec function.\n\t     * @example\n\t     *\n\t     * var objects = [\n\t     *   { 'a': 2, 'b': 1 },\n\t     *   { 'a': 1, 'b': 2 }\n\t     * ];\n\t     *\n\t     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));\n\t     * // => [{ 'a': 1, 'b': 2 }]\n\t     */\n\t    function conforms(source) {\n\t      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));\n\t    }\n\t\n\t    /**\n\t     * Creates a function that returns `value`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 2.4.0\n\t     * @category Util\n\t     * @param {*} value The value to return from the new function.\n\t     * @returns {Function} Returns the new constant function.\n\t     * @example\n\t     *\n\t     * var objects = _.times(2, _.constant({ 'a': 1 }));\n\t     *\n\t     * console.log(objects);\n\t     * // => [{ 'a': 1 }, { 'a': 1 }]\n\t     *\n\t     * console.log(objects[0] === objects[1]);\n\t     * // => true\n\t     */\n\t    function constant(value) {\n\t      return function() {\n\t        return value;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Checks `value` to determine whether a default value should be returned in\n\t     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,\n\t     * or `undefined`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.14.0\n\t     * @category Util\n\t     * @param {*} value The value to check.\n\t     * @param {*} defaultValue The default value.\n\t     * @returns {*} Returns the resolved value.\n\t     * @example\n\t     *\n\t     * _.defaultTo(1, 10);\n\t     * // => 1\n\t     *\n\t     * _.defaultTo(undefined, 10);\n\t     * // => 10\n\t     */\n\t    function defaultTo(value, defaultValue) {\n\t      return (value == null || value !== value) ? defaultValue : value;\n\t    }\n\t\n\t    /**\n\t     * Creates a function that returns the result of invoking the given functions\n\t     * with the `this` binding of the created function, where each successive\n\t     * invocation is supplied the return value of the previous.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category Util\n\t     * @param {...(Function|Function[])} [funcs] The functions to invoke.\n\t     * @returns {Function} Returns the new composite function.\n\t     * @see _.flowRight\n\t     * @example\n\t     *\n\t     * function square(n) {\n\t     *   return n * n;\n\t     * }\n\t     *\n\t     * var addSquare = _.flow([_.add, square]);\n\t     * addSquare(1, 2);\n\t     * // => 9\n\t     */\n\t    var flow = createFlow();\n\t\n\t    /**\n\t     * This method is like `_.flow` except that it creates a function that\n\t     * invokes the given functions from right to left.\n\t     *\n\t     * @static\n\t     * @since 3.0.0\n\t     * @memberOf _\n\t     * @category Util\n\t     * @param {...(Function|Function[])} [funcs] The functions to invoke.\n\t     * @returns {Function} Returns the new composite function.\n\t     * @see _.flow\n\t     * @example\n\t     *\n\t     * function square(n) {\n\t     *   return n * n;\n\t     * }\n\t     *\n\t     * var addSquare = _.flowRight([square, _.add]);\n\t     * addSquare(1, 2);\n\t     * // => 9\n\t     */\n\t    var flowRight = createFlow(true);\n\t\n\t    /**\n\t     * This method returns the first argument it receives.\n\t     *\n\t     * @static\n\t     * @since 0.1.0\n\t     * @memberOf _\n\t     * @category Util\n\t     * @param {*} value Any value.\n\t     * @returns {*} Returns `value`.\n\t     * @example\n\t     *\n\t     * var object = { 'a': 1 };\n\t     *\n\t     * console.log(_.identity(object) === object);\n\t     * // => true\n\t     */\n\t    function identity(value) {\n\t      return value;\n\t    }\n\t\n\t    /**\n\t     * Creates a function that invokes `func` with the arguments of the created\n\t     * function. If `func` is a property name, the created function returns the\n\t     * property value for a given element. If `func` is an array or object, the\n\t     * created function returns `true` for elements that contain the equivalent\n\t     * source properties, otherwise it returns `false`.\n\t     *\n\t     * @static\n\t     * @since 4.0.0\n\t     * @memberOf _\n\t     * @category Util\n\t     * @param {*} [func=_.identity] The value to convert to a callback.\n\t     * @returns {Function} Returns the callback.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'age': 36, 'active': true },\n\t     *   { 'user': 'fred',   'age': 40, 'active': false }\n\t     * ];\n\t     *\n\t     * // The `_.matches` iteratee shorthand.\n\t     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));\n\t     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]\n\t     *\n\t     * // The `_.matchesProperty` iteratee shorthand.\n\t     * _.filter(users, _.iteratee(['user', 'fred']));\n\t     * // => [{ 'user': 'fred', 'age': 40 }]\n\t     *\n\t     * // The `_.property` iteratee shorthand.\n\t     * _.map(users, _.iteratee('user'));\n\t     * // => ['barney', 'fred']\n\t     *\n\t     * // Create custom iteratee shorthands.\n\t     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {\n\t     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {\n\t     *     return func.test(string);\n\t     *   };\n\t     * });\n\t     *\n\t     * _.filter(['abc', 'def'], /ef/);\n\t     * // => ['def']\n\t     */\n\t    function iteratee(func) {\n\t      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));\n\t    }\n\t\n\t    /**\n\t     * Creates a function that performs a partial deep comparison between a given\n\t     * object and `source`, returning `true` if the given object has equivalent\n\t     * property values, else `false`.\n\t     *\n\t     * **Note:** The created function is equivalent to `_.isMatch` with `source`\n\t     * partially applied.\n\t     *\n\t     * Partial comparisons will match empty array and empty object `source`\n\t     * values against any array or object value, respectively. See `_.isEqual`\n\t     * for a list of supported value comparisons.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category Util\n\t     * @param {Object} source The object of property values to match.\n\t     * @returns {Function} Returns the new spec function.\n\t     * @example\n\t     *\n\t     * var objects = [\n\t     *   { 'a': 1, 'b': 2, 'c': 3 },\n\t     *   { 'a': 4, 'b': 5, 'c': 6 }\n\t     * ];\n\t     *\n\t     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));\n\t     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]\n\t     */\n\t    function matches(source) {\n\t      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));\n\t    }\n\t\n\t    /**\n\t     * Creates a function that performs a partial deep comparison between the\n\t     * value at `path` of a given object to `srcValue`, returning `true` if the\n\t     * object value is equivalent, else `false`.\n\t     *\n\t     * **Note:** Partial comparisons will match empty array and empty object\n\t     * `srcValue` values against any array or object value, respectively. See\n\t     * `_.isEqual` for a list of supported value comparisons.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.2.0\n\t     * @category Util\n\t     * @param {Array|string} path The path of the property to get.\n\t     * @param {*} srcValue The value to match.\n\t     * @returns {Function} Returns the new spec function.\n\t     * @example\n\t     *\n\t     * var objects = [\n\t     *   { 'a': 1, 'b': 2, 'c': 3 },\n\t     *   { 'a': 4, 'b': 5, 'c': 6 }\n\t     * ];\n\t     *\n\t     * _.find(objects, _.matchesProperty('a', 4));\n\t     * // => { 'a': 4, 'b': 5, 'c': 6 }\n\t     */\n\t    function matchesProperty(path, srcValue) {\n\t      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));\n\t    }\n\t\n\t    /**\n\t     * Creates a function that invokes the method at `path` of a given object.\n\t     * Any additional arguments are provided to the invoked method.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.7.0\n\t     * @category Util\n\t     * @param {Array|string} path The path of the method to invoke.\n\t     * @param {...*} [args] The arguments to invoke the method with.\n\t     * @returns {Function} Returns the new invoker function.\n\t     * @example\n\t     *\n\t     * var objects = [\n\t     *   { 'a': { 'b': _.constant(2) } },\n\t     *   { 'a': { 'b': _.constant(1) } }\n\t     * ];\n\t     *\n\t     * _.map(objects, _.method('a.b'));\n\t     * // => [2, 1]\n\t     *\n\t     * _.map(objects, _.method(['a', 'b']));\n\t     * // => [2, 1]\n\t     */\n\t    var method = baseRest(function(path, args) {\n\t      return function(object) {\n\t        return baseInvoke(object, path, args);\n\t      };\n\t    });\n\t\n\t    /**\n\t     * The opposite of `_.method`; this method creates a function that invokes\n\t     * the method at a given path of `object`. Any additional arguments are\n\t     * provided to the invoked method.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.7.0\n\t     * @category Util\n\t     * @param {Object} object The object to query.\n\t     * @param {...*} [args] The arguments to invoke the method with.\n\t     * @returns {Function} Returns the new invoker function.\n\t     * @example\n\t     *\n\t     * var array = _.times(3, _.constant),\n\t     *     object = { 'a': array, 'b': array, 'c': array };\n\t     *\n\t     * _.map(['a[2]', 'c[0]'], _.methodOf(object));\n\t     * // => [2, 0]\n\t     *\n\t     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));\n\t     * // => [2, 0]\n\t     */\n\t    var methodOf = baseRest(function(object, args) {\n\t      return function(path) {\n\t        return baseInvoke(object, path, args);\n\t      };\n\t    });\n\t\n\t    /**\n\t     * Adds all own enumerable string keyed function properties of a source\n\t     * object to the destination object. If `object` is a function, then methods\n\t     * are added to its prototype as well.\n\t     *\n\t     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to\n\t     * avoid conflicts caused by modifying the original.\n\t     *\n\t     * @static\n\t     * @since 0.1.0\n\t     * @memberOf _\n\t     * @category Util\n\t     * @param {Function|Object} [object=lodash] The destination object.\n\t     * @param {Object} source The object of functions to add.\n\t     * @param {Object} [options={}] The options object.\n\t     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.\n\t     * @returns {Function|Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * function vowels(string) {\n\t     *   return _.filter(string, function(v) {\n\t     *     return /[aeiou]/i.test(v);\n\t     *   });\n\t     * }\n\t     *\n\t     * _.mixin({ 'vowels': vowels });\n\t     * _.vowels('fred');\n\t     * // => ['e']\n\t     *\n\t     * _('fred').vowels().value();\n\t     * // => ['e']\n\t     *\n\t     * _.mixin({ 'vowels': vowels }, { 'chain': false });\n\t     * _('fred').vowels();\n\t     * // => ['e']\n\t     */\n\t    function mixin(object, source, options) {\n\t      var props = keys(source),\n\t          methodNames = baseFunctions(source, props);\n\t\n\t      if (options == null &&\n\t          !(isObject(source) && (methodNames.length || !props.length))) {\n\t        options = source;\n\t        source = object;\n\t        object = this;\n\t        methodNames = baseFunctions(source, keys(source));\n\t      }\n\t      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,\n\t          isFunc = isFunction(object);\n\t\n\t      arrayEach(methodNames, function(methodName) {\n\t        var func = source[methodName];\n\t        object[methodName] = func;\n\t        if (isFunc) {\n\t          object.prototype[methodName] = function() {\n\t            var chainAll = this.__chain__;\n\t            if (chain || chainAll) {\n\t              var result = object(this.__wrapped__),\n\t                  actions = result.__actions__ = copyArray(this.__actions__);\n\t\n\t              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });\n\t              result.__chain__ = chainAll;\n\t              return result;\n\t            }\n\t            return func.apply(object, arrayPush([this.value()], arguments));\n\t          };\n\t        }\n\t      });\n\t\n\t      return object;\n\t    }\n\t\n\t    /**\n\t     * Reverts the `_` variable to its previous value and returns a reference to\n\t     * the `lodash` function.\n\t     *\n\t     * @static\n\t     * @since 0.1.0\n\t     * @memberOf _\n\t     * @category Util\n\t     * @returns {Function} Returns the `lodash` function.\n\t     * @example\n\t     *\n\t     * var lodash = _.noConflict();\n\t     */\n\t    function noConflict() {\n\t      if (root._ === this) {\n\t        root._ = oldDash;\n\t      }\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * This method returns `undefined`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 2.3.0\n\t     * @category Util\n\t     * @example\n\t     *\n\t     * _.times(2, _.noop);\n\t     * // => [undefined, undefined]\n\t     */\n\t    function noop() {\n\t      // No operation performed.\n\t    }\n\t\n\t    /**\n\t     * Creates a function that gets the argument at index `n`. If `n` is negative,\n\t     * the nth argument from the end is returned.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Util\n\t     * @param {number} [n=0] The index of the argument to return.\n\t     * @returns {Function} Returns the new pass-thru function.\n\t     * @example\n\t     *\n\t     * var func = _.nthArg(1);\n\t     * func('a', 'b', 'c', 'd');\n\t     * // => 'b'\n\t     *\n\t     * var func = _.nthArg(-2);\n\t     * func('a', 'b', 'c', 'd');\n\t     * // => 'c'\n\t     */\n\t    function nthArg(n) {\n\t      n = toInteger(n);\n\t      return baseRest(function(args) {\n\t        return baseNth(args, n);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Creates a function that invokes `iteratees` with the arguments it receives\n\t     * and returns their results.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Util\n\t     * @param {...(Function|Function[])} [iteratees=[_.identity]]\n\t     *  The iteratees to invoke.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var func = _.over([Math.max, Math.min]);\n\t     *\n\t     * func(1, 2, 3, 4);\n\t     * // => [4, 1]\n\t     */\n\t    var over = createOver(arrayMap);\n\t\n\t    /**\n\t     * Creates a function that checks if **all** of the `predicates` return\n\t     * truthy when invoked with the arguments it receives.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Util\n\t     * @param {...(Function|Function[])} [predicates=[_.identity]]\n\t     *  The predicates to check.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var func = _.overEvery([Boolean, isFinite]);\n\t     *\n\t     * func('1');\n\t     * // => true\n\t     *\n\t     * func(null);\n\t     * // => false\n\t     *\n\t     * func(NaN);\n\t     * // => false\n\t     */\n\t    var overEvery = createOver(arrayEvery);\n\t\n\t    /**\n\t     * Creates a function that checks if **any** of the `predicates` return\n\t     * truthy when invoked with the arguments it receives.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Util\n\t     * @param {...(Function|Function[])} [predicates=[_.identity]]\n\t     *  The predicates to check.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var func = _.overSome([Boolean, isFinite]);\n\t     *\n\t     * func('1');\n\t     * // => true\n\t     *\n\t     * func(null);\n\t     * // => true\n\t     *\n\t     * func(NaN);\n\t     * // => false\n\t     */\n\t    var overSome = createOver(arraySome);\n\t\n\t    /**\n\t     * Creates a function that returns the value at `path` of a given object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 2.4.0\n\t     * @category Util\n\t     * @param {Array|string} path The path of the property to get.\n\t     * @returns {Function} Returns the new accessor function.\n\t     * @example\n\t     *\n\t     * var objects = [\n\t     *   { 'a': { 'b': 2 } },\n\t     *   { 'a': { 'b': 1 } }\n\t     * ];\n\t     *\n\t     * _.map(objects, _.property('a.b'));\n\t     * // => [2, 1]\n\t     *\n\t     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n\t     * // => [1, 2]\n\t     */\n\t    function property(path) {\n\t      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n\t    }\n\t\n\t    /**\n\t     * The opposite of `_.property`; this method creates a function that returns\n\t     * the value at a given path of `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.0.0\n\t     * @category Util\n\t     * @param {Object} object The object to query.\n\t     * @returns {Function} Returns the new accessor function.\n\t     * @example\n\t     *\n\t     * var array = [0, 1, 2],\n\t     *     object = { 'a': array, 'b': array, 'c': array };\n\t     *\n\t     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));\n\t     * // => [2, 0]\n\t     *\n\t     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));\n\t     * // => [2, 0]\n\t     */\n\t    function propertyOf(object) {\n\t      return function(path) {\n\t        return object == null ? undefined : baseGet(object, path);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates an array of numbers (positive and/or negative) progressing from\n\t     * `start` up to, but not including, `end`. A step of `-1` is used if a negative\n\t     * `start` is specified without an `end` or `step`. If `end` is not specified,\n\t     * it's set to `start` with `start` then set to `0`.\n\t     *\n\t     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n\t     * floating-point values which can produce unexpected results.\n\t     *\n\t     * @static\n\t     * @since 0.1.0\n\t     * @memberOf _\n\t     * @category Util\n\t     * @param {number} [start=0] The start of the range.\n\t     * @param {number} end The end of the range.\n\t     * @param {number} [step=1] The value to increment or decrement by.\n\t     * @returns {Array} Returns the range of numbers.\n\t     * @see _.inRange, _.rangeRight\n\t     * @example\n\t     *\n\t     * _.range(4);\n\t     * // => [0, 1, 2, 3]\n\t     *\n\t     * _.range(-4);\n\t     * // => [0, -1, -2, -3]\n\t     *\n\t     * _.range(1, 5);\n\t     * // => [1, 2, 3, 4]\n\t     *\n\t     * _.range(0, 20, 5);\n\t     * // => [0, 5, 10, 15]\n\t     *\n\t     * _.range(0, -4, -1);\n\t     * // => [0, -1, -2, -3]\n\t     *\n\t     * _.range(1, 4, 0);\n\t     * // => [1, 1, 1]\n\t     *\n\t     * _.range(0);\n\t     * // => []\n\t     */\n\t    var range = createRange();\n\t\n\t    /**\n\t     * This method is like `_.range` except that it populates values in\n\t     * descending order.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Util\n\t     * @param {number} [start=0] The start of the range.\n\t     * @param {number} end The end of the range.\n\t     * @param {number} [step=1] The value to increment or decrement by.\n\t     * @returns {Array} Returns the range of numbers.\n\t     * @see _.inRange, _.range\n\t     * @example\n\t     *\n\t     * _.rangeRight(4);\n\t     * // => [3, 2, 1, 0]\n\t     *\n\t     * _.rangeRight(-4);\n\t     * // => [-3, -2, -1, 0]\n\t     *\n\t     * _.rangeRight(1, 5);\n\t     * // => [4, 3, 2, 1]\n\t     *\n\t     * _.rangeRight(0, 20, 5);\n\t     * // => [15, 10, 5, 0]\n\t     *\n\t     * _.rangeRight(0, -4, -1);\n\t     * // => [-3, -2, -1, 0]\n\t     *\n\t     * _.rangeRight(1, 4, 0);\n\t     * // => [1, 1, 1]\n\t     *\n\t     * _.rangeRight(0);\n\t     * // => []\n\t     */\n\t    var rangeRight = createRange(true);\n\t\n\t    /**\n\t     * This method returns a new empty array.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.13.0\n\t     * @category Util\n\t     * @returns {Array} Returns the new empty array.\n\t     * @example\n\t     *\n\t     * var arrays = _.times(2, _.stubArray);\n\t     *\n\t     * console.log(arrays);\n\t     * // => [[], []]\n\t     *\n\t     * console.log(arrays[0] === arrays[1]);\n\t     * // => false\n\t     */\n\t    function stubArray() {\n\t      return [];\n\t    }\n\t\n\t    /**\n\t     * This method returns `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.13.0\n\t     * @category Util\n\t     * @returns {boolean} Returns `false`.\n\t     * @example\n\t     *\n\t     * _.times(2, _.stubFalse);\n\t     * // => [false, false]\n\t     */\n\t    function stubFalse() {\n\t      return false;\n\t    }\n\t\n\t    /**\n\t     * This method returns a new empty object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.13.0\n\t     * @category Util\n\t     * @returns {Object} Returns the new empty object.\n\t     * @example\n\t     *\n\t     * var objects = _.times(2, _.stubObject);\n\t     *\n\t     * console.log(objects);\n\t     * // => [{}, {}]\n\t     *\n\t     * console.log(objects[0] === objects[1]);\n\t     * // => false\n\t     */\n\t    function stubObject() {\n\t      return {};\n\t    }\n\t\n\t    /**\n\t     * This method returns an empty string.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.13.0\n\t     * @category Util\n\t     * @returns {string} Returns the empty string.\n\t     * @example\n\t     *\n\t     * _.times(2, _.stubString);\n\t     * // => ['', '']\n\t     */\n\t    function stubString() {\n\t      return '';\n\t    }\n\t\n\t    /**\n\t     * This method returns `true`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.13.0\n\t     * @category Util\n\t     * @returns {boolean} Returns `true`.\n\t     * @example\n\t     *\n\t     * _.times(2, _.stubTrue);\n\t     * // => [true, true]\n\t     */\n\t    function stubTrue() {\n\t      return true;\n\t    }\n\t\n\t    /**\n\t     * Invokes the iteratee `n` times, returning an array of the results of\n\t     * each invocation. The iteratee is invoked with one argument; (index).\n\t     *\n\t     * @static\n\t     * @since 0.1.0\n\t     * @memberOf _\n\t     * @category Util\n\t     * @param {number} n The number of times to invoke `iteratee`.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @returns {Array} Returns the array of results.\n\t     * @example\n\t     *\n\t     * _.times(3, String);\n\t     * // => ['0', '1', '2']\n\t     *\n\t     *  _.times(4, _.constant(0));\n\t     * // => [0, 0, 0, 0]\n\t     */\n\t    function times(n, iteratee) {\n\t      n = toInteger(n);\n\t      if (n < 1 || n > MAX_SAFE_INTEGER) {\n\t        return [];\n\t      }\n\t      var index = MAX_ARRAY_LENGTH,\n\t          length = nativeMin(n, MAX_ARRAY_LENGTH);\n\t\n\t      iteratee = getIteratee(iteratee);\n\t      n -= MAX_ARRAY_LENGTH;\n\t\n\t      var result = baseTimes(length, iteratee);\n\t      while (++index < n) {\n\t        iteratee(index);\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Converts `value` to a property path array.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Util\n\t     * @param {*} value The value to convert.\n\t     * @returns {Array} Returns the new property path array.\n\t     * @example\n\t     *\n\t     * _.toPath('a.b.c');\n\t     * // => ['a', 'b', 'c']\n\t     *\n\t     * _.toPath('a[0].b.c');\n\t     * // => ['a', '0', 'b', 'c']\n\t     */\n\t    function toPath(value) {\n\t      if (isArray(value)) {\n\t        return arrayMap(value, toKey);\n\t      }\n\t      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));\n\t    }\n\t\n\t    /**\n\t     * Generates a unique ID. If `prefix` is given, the ID is appended to it.\n\t     *\n\t     * @static\n\t     * @since 0.1.0\n\t     * @memberOf _\n\t     * @category Util\n\t     * @param {string} [prefix=''] The value to prefix the ID with.\n\t     * @returns {string} Returns the unique ID.\n\t     * @example\n\t     *\n\t     * _.uniqueId('contact_');\n\t     * // => 'contact_104'\n\t     *\n\t     * _.uniqueId();\n\t     * // => '105'\n\t     */\n\t    function uniqueId(prefix) {\n\t      var id = ++idCounter;\n\t      return toString(prefix) + id;\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Adds two numbers.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.4.0\n\t     * @category Math\n\t     * @param {number} augend The first number in an addition.\n\t     * @param {number} addend The second number in an addition.\n\t     * @returns {number} Returns the total.\n\t     * @example\n\t     *\n\t     * _.add(6, 4);\n\t     * // => 10\n\t     */\n\t    var add = createMathOperation(function(augend, addend) {\n\t      return augend + addend;\n\t    }, 0);\n\t\n\t    /**\n\t     * Computes `number` rounded up to `precision`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.10.0\n\t     * @category Math\n\t     * @param {number} number The number to round up.\n\t     * @param {number} [precision=0] The precision to round up to.\n\t     * @returns {number} Returns the rounded up number.\n\t     * @example\n\t     *\n\t     * _.ceil(4.006);\n\t     * // => 5\n\t     *\n\t     * _.ceil(6.004, 2);\n\t     * // => 6.01\n\t     *\n\t     * _.ceil(6040, -2);\n\t     * // => 6100\n\t     */\n\t    var ceil = createRound('ceil');\n\t\n\t    /**\n\t     * Divide two numbers.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.7.0\n\t     * @category Math\n\t     * @param {number} dividend The first number in a division.\n\t     * @param {number} divisor The second number in a division.\n\t     * @returns {number} Returns the quotient.\n\t     * @example\n\t     *\n\t     * _.divide(6, 4);\n\t     * // => 1.5\n\t     */\n\t    var divide = createMathOperation(function(dividend, divisor) {\n\t      return dividend / divisor;\n\t    }, 1);\n\t\n\t    /**\n\t     * Computes `number` rounded down to `precision`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.10.0\n\t     * @category Math\n\t     * @param {number} number The number to round down.\n\t     * @param {number} [precision=0] The precision to round down to.\n\t     * @returns {number} Returns the rounded down number.\n\t     * @example\n\t     *\n\t     * _.floor(4.006);\n\t     * // => 4\n\t     *\n\t     * _.floor(0.046, 2);\n\t     * // => 0.04\n\t     *\n\t     * _.floor(4060, -2);\n\t     * // => 4000\n\t     */\n\t    var floor = createRound('floor');\n\t\n\t    /**\n\t     * Computes the maximum value of `array`. If `array` is empty or falsey,\n\t     * `undefined` is returned.\n\t     *\n\t     * @static\n\t     * @since 0.1.0\n\t     * @memberOf _\n\t     * @category Math\n\t     * @param {Array} array The array to iterate over.\n\t     * @returns {*} Returns the maximum value.\n\t     * @example\n\t     *\n\t     * _.max([4, 2, 8, 6]);\n\t     * // => 8\n\t     *\n\t     * _.max([]);\n\t     * // => undefined\n\t     */\n\t    function max(array) {\n\t      return (array && array.length)\n\t        ? baseExtremum(array, identity, baseGt)\n\t        : undefined;\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.max` except that it accepts `iteratee` which is\n\t     * invoked for each element in `array` to generate the criterion by which\n\t     * the value is ranked. The iteratee is invoked with one argument: (value).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Math\n\t     * @param {Array} array The array to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n\t     * @returns {*} Returns the maximum value.\n\t     * @example\n\t     *\n\t     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n\t     *\n\t     * _.maxBy(objects, function(o) { return o.n; });\n\t     * // => { 'n': 2 }\n\t     *\n\t     * // The `_.property` iteratee shorthand.\n\t     * _.maxBy(objects, 'n');\n\t     * // => { 'n': 2 }\n\t     */\n\t    function maxBy(array, iteratee) {\n\t      return (array && array.length)\n\t        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)\n\t        : undefined;\n\t    }\n\t\n\t    /**\n\t     * Computes the mean of the values in `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Math\n\t     * @param {Array} array The array to iterate over.\n\t     * @returns {number} Returns the mean.\n\t     * @example\n\t     *\n\t     * _.mean([4, 2, 8, 6]);\n\t     * // => 5\n\t     */\n\t    function mean(array) {\n\t      return baseMean(array, identity);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.mean` except that it accepts `iteratee` which is\n\t     * invoked for each element in `array` to generate the value to be averaged.\n\t     * The iteratee is invoked with one argument: (value).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.7.0\n\t     * @category Math\n\t     * @param {Array} array The array to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n\t     * @returns {number} Returns the mean.\n\t     * @example\n\t     *\n\t     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n\t     *\n\t     * _.meanBy(objects, function(o) { return o.n; });\n\t     * // => 5\n\t     *\n\t     * // The `_.property` iteratee shorthand.\n\t     * _.meanBy(objects, 'n');\n\t     * // => 5\n\t     */\n\t    function meanBy(array, iteratee) {\n\t      return baseMean(array, getIteratee(iteratee, 2));\n\t    }\n\t\n\t    /**\n\t     * Computes the minimum value of `array`. If `array` is empty or falsey,\n\t     * `undefined` is returned.\n\t     *\n\t     * @static\n\t     * @since 0.1.0\n\t     * @memberOf _\n\t     * @category Math\n\t     * @param {Array} array The array to iterate over.\n\t     * @returns {*} Returns the minimum value.\n\t     * @example\n\t     *\n\t     * _.min([4, 2, 8, 6]);\n\t     * // => 2\n\t     *\n\t     * _.min([]);\n\t     * // => undefined\n\t     */\n\t    function min(array) {\n\t      return (array && array.length)\n\t        ? baseExtremum(array, identity, baseLt)\n\t        : undefined;\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.min` except that it accepts `iteratee` which is\n\t     * invoked for each element in `array` to generate the criterion by which\n\t     * the value is ranked. The iteratee is invoked with one argument: (value).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Math\n\t     * @param {Array} array The array to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n\t     * @returns {*} Returns the minimum value.\n\t     * @example\n\t     *\n\t     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n\t     *\n\t     * _.minBy(objects, function(o) { return o.n; });\n\t     * // => { 'n': 1 }\n\t     *\n\t     * // The `_.property` iteratee shorthand.\n\t     * _.minBy(objects, 'n');\n\t     * // => { 'n': 1 }\n\t     */\n\t    function minBy(array, iteratee) {\n\t      return (array && array.length)\n\t        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)\n\t        : undefined;\n\t    }\n\t\n\t    /**\n\t     * Multiply two numbers.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.7.0\n\t     * @category Math\n\t     * @param {number} multiplier The first number in a multiplication.\n\t     * @param {number} multiplicand The second number in a multiplication.\n\t     * @returns {number} Returns the product.\n\t     * @example\n\t     *\n\t     * _.multiply(6, 4);\n\t     * // => 24\n\t     */\n\t    var multiply = createMathOperation(function(multiplier, multiplicand) {\n\t      return multiplier * multiplicand;\n\t    }, 1);\n\t\n\t    /**\n\t     * Computes `number` rounded to `precision`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.10.0\n\t     * @category Math\n\t     * @param {number} number The number to round.\n\t     * @param {number} [precision=0] The precision to round to.\n\t     * @returns {number} Returns the rounded number.\n\t     * @example\n\t     *\n\t     * _.round(4.006);\n\t     * // => 4\n\t     *\n\t     * _.round(4.006, 2);\n\t     * // => 4.01\n\t     *\n\t     * _.round(4060, -2);\n\t     * // => 4100\n\t     */\n\t    var round = createRound('round');\n\t\n\t    /**\n\t     * Subtract two numbers.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Math\n\t     * @param {number} minuend The first number in a subtraction.\n\t     * @param {number} subtrahend The second number in a subtraction.\n\t     * @returns {number} Returns the difference.\n\t     * @example\n\t     *\n\t     * _.subtract(6, 4);\n\t     * // => 2\n\t     */\n\t    var subtract = createMathOperation(function(minuend, subtrahend) {\n\t      return minuend - subtrahend;\n\t    }, 0);\n\t\n\t    /**\n\t     * Computes the sum of the values in `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 3.4.0\n\t     * @category Math\n\t     * @param {Array} array The array to iterate over.\n\t     * @returns {number} Returns the sum.\n\t     * @example\n\t     *\n\t     * _.sum([4, 2, 8, 6]);\n\t     * // => 20\n\t     */\n\t    function sum(array) {\n\t      return (array && array.length)\n\t        ? baseSum(array, identity)\n\t        : 0;\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.sum` except that it accepts `iteratee` which is\n\t     * invoked for each element in `array` to generate the value to be summed.\n\t     * The iteratee is invoked with one argument: (value).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @since 4.0.0\n\t     * @category Math\n\t     * @param {Array} array The array to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n\t     * @returns {number} Returns the sum.\n\t     * @example\n\t     *\n\t     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n\t     *\n\t     * _.sumBy(objects, function(o) { return o.n; });\n\t     * // => 20\n\t     *\n\t     * // The `_.property` iteratee shorthand.\n\t     * _.sumBy(objects, 'n');\n\t     * // => 20\n\t     */\n\t    function sumBy(array, iteratee) {\n\t      return (array && array.length)\n\t        ? baseSum(array, getIteratee(iteratee, 2))\n\t        : 0;\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    // Add methods that return wrapped values in chain sequences.\n\t    lodash.after = after;\n\t    lodash.ary = ary;\n\t    lodash.assign = assign;\n\t    lodash.assignIn = assignIn;\n\t    lodash.assignInWith = assignInWith;\n\t    lodash.assignWith = assignWith;\n\t    lodash.at = at;\n\t    lodash.before = before;\n\t    lodash.bind = bind;\n\t    lodash.bindAll = bindAll;\n\t    lodash.bindKey = bindKey;\n\t    lodash.castArray = castArray;\n\t    lodash.chain = chain;\n\t    lodash.chunk = chunk;\n\t    lodash.compact = compact;\n\t    lodash.concat = concat;\n\t    lodash.cond = cond;\n\t    lodash.conforms = conforms;\n\t    lodash.constant = constant;\n\t    lodash.countBy = countBy;\n\t    lodash.create = create;\n\t    lodash.curry = curry;\n\t    lodash.curryRight = curryRight;\n\t    lodash.debounce = debounce;\n\t    lodash.defaults = defaults;\n\t    lodash.defaultsDeep = defaultsDeep;\n\t    lodash.defer = defer;\n\t    lodash.delay = delay;\n\t    lodash.difference = difference;\n\t    lodash.differenceBy = differenceBy;\n\t    lodash.differenceWith = differenceWith;\n\t    lodash.drop = drop;\n\t    lodash.dropRight = dropRight;\n\t    lodash.dropRightWhile = dropRightWhile;\n\t    lodash.dropWhile = dropWhile;\n\t    lodash.fill = fill;\n\t    lodash.filter = filter;\n\t    lodash.flatMap = flatMap;\n\t    lodash.flatMapDeep = flatMapDeep;\n\t    lodash.flatMapDepth = flatMapDepth;\n\t    lodash.flatten = flatten;\n\t    lodash.flattenDeep = flattenDeep;\n\t    lodash.flattenDepth = flattenDepth;\n\t    lodash.flip = flip;\n\t    lodash.flow = flow;\n\t    lodash.flowRight = flowRight;\n\t    lodash.fromPairs = fromPairs;\n\t    lodash.functions = functions;\n\t    lodash.functionsIn = functionsIn;\n\t    lodash.groupBy = groupBy;\n\t    lodash.initial = initial;\n\t    lodash.intersection = intersection;\n\t    lodash.intersectionBy = intersectionBy;\n\t    lodash.intersectionWith = intersectionWith;\n\t    lodash.invert = invert;\n\t    lodash.invertBy = invertBy;\n\t    lodash.invokeMap = invokeMap;\n\t    lodash.iteratee = iteratee;\n\t    lodash.keyBy = keyBy;\n\t    lodash.keys = keys;\n\t    lodash.keysIn = keysIn;\n\t    lodash.map = map;\n\t    lodash.mapKeys = mapKeys;\n\t    lodash.mapValues = mapValues;\n\t    lodash.matches = matches;\n\t    lodash.matchesProperty = matchesProperty;\n\t    lodash.memoize = memoize;\n\t    lodash.merge = merge;\n\t    lodash.mergeWith = mergeWith;\n\t    lodash.method = method;\n\t    lodash.methodOf = methodOf;\n\t    lodash.mixin = mixin;\n\t    lodash.negate = negate;\n\t    lodash.nthArg = nthArg;\n\t    lodash.omit = omit;\n\t    lodash.omitBy = omitBy;\n\t    lodash.once = once;\n\t    lodash.orderBy = orderBy;\n\t    lodash.over = over;\n\t    lodash.overArgs = overArgs;\n\t    lodash.overEvery = overEvery;\n\t    lodash.overSome = overSome;\n\t    lodash.partial = partial;\n\t    lodash.partialRight = partialRight;\n\t    lodash.partition = partition;\n\t    lodash.pick = pick;\n\t    lodash.pickBy = pickBy;\n\t    lodash.property = property;\n\t    lodash.propertyOf = propertyOf;\n\t    lodash.pull = pull;\n\t    lodash.pullAll = pullAll;\n\t    lodash.pullAllBy = pullAllBy;\n\t    lodash.pullAllWith = pullAllWith;\n\t    lodash.pullAt = pullAt;\n\t    lodash.range = range;\n\t    lodash.rangeRight = rangeRight;\n\t    lodash.rearg = rearg;\n\t    lodash.reject = reject;\n\t    lodash.remove = remove;\n\t    lodash.rest = rest;\n\t    lodash.reverse = reverse;\n\t    lodash.sampleSize = sampleSize;\n\t    lodash.set = set;\n\t    lodash.setWith = setWith;\n\t    lodash.shuffle = shuffle;\n\t    lodash.slice = slice;\n\t    lodash.sortBy = sortBy;\n\t    lodash.sortedUniq = sortedUniq;\n\t    lodash.sortedUniqBy = sortedUniqBy;\n\t    lodash.split = split;\n\t    lodash.spread = spread;\n\t    lodash.tail = tail;\n\t    lodash.take = take;\n\t    lodash.takeRight = takeRight;\n\t    lodash.takeRightWhile = takeRightWhile;\n\t    lodash.takeWhile = takeWhile;\n\t    lodash.tap = tap;\n\t    lodash.throttle = throttle;\n\t    lodash.thru = thru;\n\t    lodash.toArray = toArray;\n\t    lodash.toPairs = toPairs;\n\t    lodash.toPairsIn = toPairsIn;\n\t    lodash.toPath = toPath;\n\t    lodash.toPlainObject = toPlainObject;\n\t    lodash.transform = transform;\n\t    lodash.unary = unary;\n\t    lodash.union = union;\n\t    lodash.unionBy = unionBy;\n\t    lodash.unionWith = unionWith;\n\t    lodash.uniq = uniq;\n\t    lodash.uniqBy = uniqBy;\n\t    lodash.uniqWith = uniqWith;\n\t    lodash.unset = unset;\n\t    lodash.unzip = unzip;\n\t    lodash.unzipWith = unzipWith;\n\t    lodash.update = update;\n\t    lodash.updateWith = updateWith;\n\t    lodash.values = values;\n\t    lodash.valuesIn = valuesIn;\n\t    lodash.without = without;\n\t    lodash.words = words;\n\t    lodash.wrap = wrap;\n\t    lodash.xor = xor;\n\t    lodash.xorBy = xorBy;\n\t    lodash.xorWith = xorWith;\n\t    lodash.zip = zip;\n\t    lodash.zipObject = zipObject;\n\t    lodash.zipObjectDeep = zipObjectDeep;\n\t    lodash.zipWith = zipWith;\n\t\n\t    // Add aliases.\n\t    lodash.entries = toPairs;\n\t    lodash.entriesIn = toPairsIn;\n\t    lodash.extend = assignIn;\n\t    lodash.extendWith = assignInWith;\n\t\n\t    // Add methods to `lodash.prototype`.\n\t    mixin(lodash, lodash);\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    // Add methods that return unwrapped values in chain sequences.\n\t    lodash.add = add;\n\t    lodash.attempt = attempt;\n\t    lodash.camelCase = camelCase;\n\t    lodash.capitalize = capitalize;\n\t    lodash.ceil = ceil;\n\t    lodash.clamp = clamp;\n\t    lodash.clone = clone;\n\t    lodash.cloneDeep = cloneDeep;\n\t    lodash.cloneDeepWith = cloneDeepWith;\n\t    lodash.cloneWith = cloneWith;\n\t    lodash.conformsTo = conformsTo;\n\t    lodash.deburr = deburr;\n\t    lodash.defaultTo = defaultTo;\n\t    lodash.divide = divide;\n\t    lodash.endsWith = endsWith;\n\t    lodash.eq = eq;\n\t    lodash.escape = escape;\n\t    lodash.escapeRegExp = escapeRegExp;\n\t    lodash.every = every;\n\t    lodash.find = find;\n\t    lodash.findIndex = findIndex;\n\t    lodash.findKey = findKey;\n\t    lodash.findLast = findLast;\n\t    lodash.findLastIndex = findLastIndex;\n\t    lodash.findLastKey = findLastKey;\n\t    lodash.floor = floor;\n\t    lodash.forEach = forEach;\n\t    lodash.forEachRight = forEachRight;\n\t    lodash.forIn = forIn;\n\t    lodash.forInRight = forInRight;\n\t    lodash.forOwn = forOwn;\n\t    lodash.forOwnRight = forOwnRight;\n\t    lodash.get = get;\n\t    lodash.gt = gt;\n\t    lodash.gte = gte;\n\t    lodash.has = has;\n\t    lodash.hasIn = hasIn;\n\t    lodash.head = head;\n\t    lodash.identity = identity;\n\t    lodash.includes = includes;\n\t    lodash.indexOf = indexOf;\n\t    lodash.inRange = inRange;\n\t    lodash.invoke = invoke;\n\t    lodash.isArguments = isArguments;\n\t    lodash.isArray = isArray;\n\t    lodash.isArrayBuffer = isArrayBuffer;\n\t    lodash.isArrayLike = isArrayLike;\n\t    lodash.isArrayLikeObject = isArrayLikeObject;\n\t    lodash.isBoolean = isBoolean;\n\t    lodash.isBuffer = isBuffer;\n\t    lodash.isDate = isDate;\n\t    lodash.isElement = isElement;\n\t    lodash.isEmpty = isEmpty;\n\t    lodash.isEqual = isEqual;\n\t    lodash.isEqualWith = isEqualWith;\n\t    lodash.isError = isError;\n\t    lodash.isFinite = isFinite;\n\t    lodash.isFunction = isFunction;\n\t    lodash.isInteger = isInteger;\n\t    lodash.isLength = isLength;\n\t    lodash.isMap = isMap;\n\t    lodash.isMatch = isMatch;\n\t    lodash.isMatchWith = isMatchWith;\n\t    lodash.isNaN = isNaN;\n\t    lodash.isNative = isNative;\n\t    lodash.isNil = isNil;\n\t    lodash.isNull = isNull;\n\t    lodash.isNumber = isNumber;\n\t    lodash.isObject = isObject;\n\t    lodash.isObjectLike = isObjectLike;\n\t    lodash.isPlainObject = isPlainObject;\n\t    lodash.isRegExp = isRegExp;\n\t    lodash.isSafeInteger = isSafeInteger;\n\t    lodash.isSet = isSet;\n\t    lodash.isString = isString;\n\t    lodash.isSymbol = isSymbol;\n\t    lodash.isTypedArray = isTypedArray;\n\t    lodash.isUndefined = isUndefined;\n\t    lodash.isWeakMap = isWeakMap;\n\t    lodash.isWeakSet = isWeakSet;\n\t    lodash.join = join;\n\t    lodash.kebabCase = kebabCase;\n\t    lodash.last = last;\n\t    lodash.lastIndexOf = lastIndexOf;\n\t    lodash.lowerCase = lowerCase;\n\t    lodash.lowerFirst = lowerFirst;\n\t    lodash.lt = lt;\n\t    lodash.lte = lte;\n\t    lodash.max = max;\n\t    lodash.maxBy = maxBy;\n\t    lodash.mean = mean;\n\t    lodash.meanBy = meanBy;\n\t    lodash.min = min;\n\t    lodash.minBy = minBy;\n\t    lodash.stubArray = stubArray;\n\t    lodash.stubFalse = stubFalse;\n\t    lodash.stubObject = stubObject;\n\t    lodash.stubString = stubString;\n\t    lodash.stubTrue = stubTrue;\n\t    lodash.multiply = multiply;\n\t    lodash.nth = nth;\n\t    lodash.noConflict = noConflict;\n\t    lodash.noop = noop;\n\t    lodash.now = now;\n\t    lodash.pad = pad;\n\t    lodash.padEnd = padEnd;\n\t    lodash.padStart = padStart;\n\t    lodash.parseInt = parseInt;\n\t    lodash.random = random;\n\t    lodash.reduce = reduce;\n\t    lodash.reduceRight = reduceRight;\n\t    lodash.repeat = repeat;\n\t    lodash.replace = replace;\n\t    lodash.result = result;\n\t    lodash.round = round;\n\t    lodash.runInContext = runInContext;\n\t    lodash.sample = sample;\n\t    lodash.size = size;\n\t    lodash.snakeCase = snakeCase;\n\t    lodash.some = some;\n\t    lodash.sortedIndex = sortedIndex;\n\t    lodash.sortedIndexBy = sortedIndexBy;\n\t    lodash.sortedIndexOf = sortedIndexOf;\n\t    lodash.sortedLastIndex = sortedLastIndex;\n\t    lodash.sortedLastIndexBy = sortedLastIndexBy;\n\t    lodash.sortedLastIndexOf = sortedLastIndexOf;\n\t    lodash.startCase = startCase;\n\t    lodash.startsWith = startsWith;\n\t    lodash.subtract = subtract;\n\t    lodash.sum = sum;\n\t    lodash.sumBy = sumBy;\n\t    lodash.template = template;\n\t    lodash.times = times;\n\t    lodash.toFinite = toFinite;\n\t    lodash.toInteger = toInteger;\n\t    lodash.toLength = toLength;\n\t    lodash.toLower = toLower;\n\t    lodash.toNumber = toNumber;\n\t    lodash.toSafeInteger = toSafeInteger;\n\t    lodash.toString = toString;\n\t    lodash.toUpper = toUpper;\n\t    lodash.trim = trim;\n\t    lodash.trimEnd = trimEnd;\n\t    lodash.trimStart = trimStart;\n\t    lodash.truncate = truncate;\n\t    lodash.unescape = unescape;\n\t    lodash.uniqueId = uniqueId;\n\t    lodash.upperCase = upperCase;\n\t    lodash.upperFirst = upperFirst;\n\t\n\t    // Add aliases.\n\t    lodash.each = forEach;\n\t    lodash.eachRight = forEachRight;\n\t    lodash.first = head;\n\t\n\t    mixin(lodash, (function() {\n\t      var source = {};\n\t      baseForOwn(lodash, function(func, methodName) {\n\t        if (!hasOwnProperty.call(lodash.prototype, methodName)) {\n\t          source[methodName] = func;\n\t        }\n\t      });\n\t      return source;\n\t    }()), { 'chain': false });\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * The semantic version number.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @type {string}\n\t     */\n\t    lodash.VERSION = VERSION;\n\t\n\t    // Assign default placeholders.\n\t    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {\n\t      lodash[methodName].placeholder = lodash;\n\t    });\n\t\n\t    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.\n\t    arrayEach(['drop', 'take'], function(methodName, index) {\n\t      LazyWrapper.prototype[methodName] = function(n) {\n\t        var filtered = this.__filtered__;\n\t        if (filtered && !index) {\n\t          return new LazyWrapper(this);\n\t        }\n\t        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);\n\t\n\t        var result = this.clone();\n\t        if (filtered) {\n\t          result.__takeCount__ = nativeMin(n, result.__takeCount__);\n\t        } else {\n\t          result.__views__.push({\n\t            'size': nativeMin(n, MAX_ARRAY_LENGTH),\n\t            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')\n\t          });\n\t        }\n\t        return result;\n\t      };\n\t\n\t      LazyWrapper.prototype[methodName + 'Right'] = function(n) {\n\t        return this.reverse()[methodName](n).reverse();\n\t      };\n\t    });\n\t\n\t    // Add `LazyWrapper` methods that accept an `iteratee` value.\n\t    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {\n\t      var type = index + 1,\n\t          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;\n\t\n\t      LazyWrapper.prototype[methodName] = function(iteratee) {\n\t        var result = this.clone();\n\t        result.__iteratees__.push({\n\t          'iteratee': getIteratee(iteratee, 3),\n\t          'type': type\n\t        });\n\t        result.__filtered__ = result.__filtered__ || isFilter;\n\t        return result;\n\t      };\n\t    });\n\t\n\t    // Add `LazyWrapper` methods for `_.head` and `_.last`.\n\t    arrayEach(['head', 'last'], function(methodName, index) {\n\t      var takeName = 'take' + (index ? 'Right' : '');\n\t\n\t      LazyWrapper.prototype[methodName] = function() {\n\t        return this[takeName](1).value()[0];\n\t      };\n\t    });\n\t\n\t    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.\n\t    arrayEach(['initial', 'tail'], function(methodName, index) {\n\t      var dropName = 'drop' + (index ? '' : 'Right');\n\t\n\t      LazyWrapper.prototype[methodName] = function() {\n\t        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);\n\t      };\n\t    });\n\t\n\t    LazyWrapper.prototype.compact = function() {\n\t      return this.filter(identity);\n\t    };\n\t\n\t    LazyWrapper.prototype.find = function(predicate) {\n\t      return this.filter(predicate).head();\n\t    };\n\t\n\t    LazyWrapper.prototype.findLast = function(predicate) {\n\t      return this.reverse().find(predicate);\n\t    };\n\t\n\t    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {\n\t      if (typeof path == 'function') {\n\t        return new LazyWrapper(this);\n\t      }\n\t      return this.map(function(value) {\n\t        return baseInvoke(value, path, args);\n\t      });\n\t    });\n\t\n\t    LazyWrapper.prototype.reject = function(predicate) {\n\t      return this.filter(negate(getIteratee(predicate)));\n\t    };\n\t\n\t    LazyWrapper.prototype.slice = function(start, end) {\n\t      start = toInteger(start);\n\t\n\t      var result = this;\n\t      if (result.__filtered__ && (start > 0 || end < 0)) {\n\t        return new LazyWrapper(result);\n\t      }\n\t      if (start < 0) {\n\t        result = result.takeRight(-start);\n\t      } else if (start) {\n\t        result = result.drop(start);\n\t      }\n\t      if (end !== undefined) {\n\t        end = toInteger(end);\n\t        result = end < 0 ? result.dropRight(-end) : result.take(end - start);\n\t      }\n\t      return result;\n\t    };\n\t\n\t    LazyWrapper.prototype.takeRightWhile = function(predicate) {\n\t      return this.reverse().takeWhile(predicate).reverse();\n\t    };\n\t\n\t    LazyWrapper.prototype.toArray = function() {\n\t      return this.take(MAX_ARRAY_LENGTH);\n\t    };\n\t\n\t    // Add `LazyWrapper` methods to `lodash.prototype`.\n\t    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n\t      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),\n\t          isTaker = /^(?:head|last)$/.test(methodName),\n\t          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],\n\t          retUnwrapped = isTaker || /^find/.test(methodName);\n\t\n\t      if (!lodashFunc) {\n\t        return;\n\t      }\n\t      lodash.prototype[methodName] = function() {\n\t        var value = this.__wrapped__,\n\t            args = isTaker ? [1] : arguments,\n\t            isLazy = value instanceof LazyWrapper,\n\t            iteratee = args[0],\n\t            useLazy = isLazy || isArray(value);\n\t\n\t        var interceptor = function(value) {\n\t          var result = lodashFunc.apply(lodash, arrayPush([value], args));\n\t          return (isTaker && chainAll) ? result[0] : result;\n\t        };\n\t\n\t        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {\n\t          // Avoid lazy use if the iteratee has a \"length\" value other than `1`.\n\t          isLazy = useLazy = false;\n\t        }\n\t        var chainAll = this.__chain__,\n\t            isHybrid = !!this.__actions__.length,\n\t            isUnwrapped = retUnwrapped && !chainAll,\n\t            onlyLazy = isLazy && !isHybrid;\n\t\n\t        if (!retUnwrapped && useLazy) {\n\t          value = onlyLazy ? value : new LazyWrapper(this);\n\t          var result = func.apply(value, args);\n\t          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });\n\t          return new LodashWrapper(result, chainAll);\n\t        }\n\t        if (isUnwrapped && onlyLazy) {\n\t          return func.apply(this, args);\n\t        }\n\t        result = this.thru(interceptor);\n\t        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;\n\t      };\n\t    });\n\t\n\t    // Add `Array` methods to `lodash.prototype`.\n\t    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {\n\t      var func = arrayProto[methodName],\n\t          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',\n\t          retUnwrapped = /^(?:pop|shift)$/.test(methodName);\n\t\n\t      lodash.prototype[methodName] = function() {\n\t        var args = arguments;\n\t        if (retUnwrapped && !this.__chain__) {\n\t          var value = this.value();\n\t          return func.apply(isArray(value) ? value : [], args);\n\t        }\n\t        return this[chainName](function(value) {\n\t          return func.apply(isArray(value) ? value : [], args);\n\t        });\n\t      };\n\t    });\n\t\n\t    // Map minified method names to their real names.\n\t    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n\t      var lodashFunc = lodash[methodName];\n\t      if (lodashFunc) {\n\t        var key = (lodashFunc.name + ''),\n\t            names = realNames[key] || (realNames[key] = []);\n\t\n\t        names.push({ 'name': methodName, 'func': lodashFunc });\n\t      }\n\t    });\n\t\n\t    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{\n\t      'name': 'wrapper',\n\t      'func': undefined\n\t    }];\n\t\n\t    // Add methods to `LazyWrapper`.\n\t    LazyWrapper.prototype.clone = lazyClone;\n\t    LazyWrapper.prototype.reverse = lazyReverse;\n\t    LazyWrapper.prototype.value = lazyValue;\n\t\n\t    // Add chain sequence methods to the `lodash` wrapper.\n\t    lodash.prototype.at = wrapperAt;\n\t    lodash.prototype.chain = wrapperChain;\n\t    lodash.prototype.commit = wrapperCommit;\n\t    lodash.prototype.next = wrapperNext;\n\t    lodash.prototype.plant = wrapperPlant;\n\t    lodash.prototype.reverse = wrapperReverse;\n\t    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;\n\t\n\t    // Add lazy aliases.\n\t    lodash.prototype.first = lodash.prototype.head;\n\t\n\t    if (symIterator) {\n\t      lodash.prototype[symIterator] = wrapperToIterator;\n\t    }\n\t    return lodash;\n\t  });\n\t\n\t  /*--------------------------------------------------------------------------*/\n\t\n\t  // Export lodash.\n\t  var _ = runInContext();\n\t\n\t  // Some AMD build optimizers, like r.js, check for condition patterns like:\n\t  if (true) {\n\t    // Expose Lodash on the global object to prevent errors when Lodash is\n\t    // loaded by a script tag in the presence of an AMD loader.\n\t    // See http://requirejs.org/docs/errors.html#mismatch for more details.\n\t    // Use `_.noConflict` to remove Lodash from the global object.\n\t    root._ = _;\n\t\n\t    // Define as an anonymous module so, through path mapping, it can be\n\t    // referenced as the \"underscore\" module.\n\t    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t      return _;\n\t    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  }\n\t  // Check for `exports` after `define` in case a build optimizer adds it.\n\t  else if (freeModule) {\n\t    // Export for Node.js.\n\t    (freeModule.exports = _)._ = _;\n\t    // Export for CommonJS support.\n\t    freeExports._ = _;\n\t  }\n\t  else {\n\t    // Export to the global object.\n\t    root._ = _;\n\t  }\n\t}.call(this));\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(3)(module)))\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(module) {\n\t\tif(!module.webpackPolyfill) {\n\t\t\tmodule.deprecate = function() {};\n\t\t\tmodule.paths = [];\n\t\t\t// module.parent = undefined by default\n\t\t\tmodule.children = [];\n\t\t\tmodule.webpackPolyfill = 1;\n\t\t}\n\t\treturn module;\n\t}\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // The Regexper class manages the top-level behavior for the entire\n\t// application. This includes event handlers for all user interactions.\n\t\n\tvar _util = __webpack_require__(1);\n\t\n\tvar _util2 = _interopRequireDefault(_util);\n\t\n\tvar _javascript = __webpack_require__(5);\n\t\n\tvar _javascript2 = _interopRequireDefault(_javascript);\n\t\n\tvar _lodash = __webpack_require__(2);\n\t\n\tvar _lodash2 = _interopRequireDefault(_lodash);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Regexper = function () {\n\t  function Regexper(root) {\n\t    _classCallCheck(this, Regexper);\n\t\n\t    this.root = root;\n\t    this.buggyHash = false;\n\t    this.form = root.querySelector('#regexp-form');\n\t    this.field = root.querySelector('#regexp-input');\n\t    this.error = root.querySelector('#error');\n\t    this.warnings = root.querySelector('#warnings');\n\t\n\t    this.links = this.form.querySelector('ul');\n\t    this.permalink = this.links.querySelector('a[data-action=\"permalink\"]');\n\t    this.download = this.links.querySelector('a[data-action=\"download\"]');\n\t\n\t    this.svgContainer = root.querySelector('#regexp-render');\n\t  }\n\t\n\t  // Event handler for key presses in the regular expression form field.\n\t\n\t\n\t  _createClass(Regexper, [{\n\t    key: 'keypressListener',\n\t    value: function keypressListener(event) {\n\t      // Pressing Shift-Enter displays the expression.\n\t      if (event.shiftKey && event.keyCode === 13) {\n\t        event.returnValue = false;\n\t        if (event.preventDefault) {\n\t          event.preventDefault();\n\t        }\n\t\n\t        this.form.dispatchEvent(_util2.default.customEvent('submit'));\n\t      }\n\t    }\n\t\n\t    // Event handler for key presses while focused anywhere in the application.\n\t\n\t  }, {\n\t    key: 'documentKeypressListener',\n\t    value: function documentKeypressListener(event) {\n\t      // Pressing escape will cancel a currently running render.\n\t      if (event.keyCode === 27 && this.running) {\n\t        this.running.cancel();\n\t      }\n\t    }\n\t\n\t    // Event handler for submission of the regular expression. Changes the URL\n\t    // hash which leads to the expression being rendered.\n\t\n\t  }, {\n\t    key: 'submitListener',\n\t    value: function submitListener(event) {\n\t      event.returnValue = false;\n\t      if (event.preventDefault) {\n\t        event.preventDefault();\n\t      }\n\t\n\t      try {\n\t        this._setHash(this.field.value);\n\t      } catch (e) {\n\t        // Failed to set the URL hash (probably because the expression is too\n\t        // long). Turn off display of the permalink and just show the expression.\n\t        this.permalinkEnabled = false;\n\t        this.showExpression(this.field.value);\n\t      }\n\t    }\n\t\n\t    // Event handler for URL hash changes. Starts rendering of the expression.\n\t\n\t  }, {\n\t    key: 'hashchangeListener',\n\t    value: function hashchangeListener() {\n\t      var expr = this._getHash();\n\t\n\t      if (expr instanceof Error) {\n\t        this.state = 'has-error';\n\t        this.error.innerHTML = 'Malformed expression in URL';\n\t        _util2.default.track('send', 'event', 'visualization', 'malformed URL');\n\t      } else {\n\t        this.permalinkEnabled = true;\n\t        this.showExpression(expr);\n\t      }\n\t    }\n\t\n\t    // Binds all event listeners.\n\t\n\t  }, {\n\t    key: 'bindListeners',\n\t    value: function bindListeners() {\n\t      this.field.addEventListener('keypress', this.keypressListener.bind(this));\n\t      this.form.addEventListener('submit', this.submitListener.bind(this));\n\t      this.root.addEventListener('keyup', this.documentKeypressListener.bind(this));\n\t      window.addEventListener('hashchange', this.hashchangeListener.bind(this));\n\t    }\n\t\n\t    // Detect if https://bugzilla.mozilla.org/show_bug.cgi?id=483304 is in effect\n\t\n\t  }, {\n\t    key: 'detectBuggyHash',\n\t    value: function detectBuggyHash() {\n\t      if (typeof window.URL === 'function') {\n\t        try {\n\t          var url = new URL('http://regexper.com/#%25');\n\t          this.buggyHash = url.hash === '#%';\n\t        } catch (e) {\n\t          this.buggyHash = false;\n\t        }\n\t      }\n\t    }\n\t\n\t    // Set the URL hash. This method exists to facilitate automated testing\n\t    // (since changing the URL can throw off most JavaScript testing tools).\n\t\n\t  }, {\n\t    key: '_setHash',\n\t    value: function _setHash(hash) {\n\t      location.hash = encodeURIComponent(hash);\n\t    }\n\t\n\t    // Retrieve the current URL hash. This method is also mostly for supporting\n\t    // automated testing, but also does some basic error handling for malformed\n\t    // URLs.\n\t\n\t  }, {\n\t    key: '_getHash',\n\t    value: function _getHash() {\n\t      try {\n\t        var hash = location.hash.slice(1);\n\t        return this.buggyHash ? hash : decodeURIComponent(hash);\n\t      } catch (e) {\n\t        return e;\n\t      }\n\t    }\n\t\n\t    // Currently state of the application. Useful values are:\n\t    //  - `''` - State of the application when the page initially loads\n\t    //  - `'is-loading'` - Displays the loading indicator\n\t    //  - `'has-error'` - Displays the error message\n\t    //  - `'has-results'` - Displays rendered results\n\t\n\t  }, {\n\t    key: 'showExpression',\n\t\n\t\n\t    // Start the rendering of a regular expression.\n\t    //\n\t    // - __expression__ - Regular expression to display.\n\t    value: function showExpression(expression) {\n\t      this.field.value = expression;\n\t      this.state = '';\n\t\n\t      if (expression !== '') {\n\t        this.renderRegexp(expression).catch(_util2.default.exposeError);\n\t      }\n\t    }\n\t\n\t    // Creates a blob URL for linking to a rendered regular expression image.\n\t    //\n\t    // - __content__ - SVG image markup.\n\t\n\t  }, {\n\t    key: 'buildBlobURL',\n\t    value: function buildBlobURL(content) {\n\t      // Blob object has to stick around for IE, so the instance is stored on the\n\t      // `window` object.\n\t      window.blob = new Blob([content], { type: 'image/svg+xml' });\n\t      return URL.createObjectURL(window.blob);\n\t    }\n\t\n\t    // Update the URLs of the 'download' and 'permalink' links.\n\t\n\t  }, {\n\t    key: 'updateLinks',\n\t    value: function updateLinks() {\n\t      var classes = _lodash2.default.without(this.links.className.split(' '), ['hide-download', 'hide-permalink']);\n\t\n\t      // Create the 'download' image URL.\n\t      try {\n\t        this.download.parentNode.style.display = null;\n\t        this.download.href = this.buildBlobURL(this.svgContainer.querySelector('.svg').innerHTML);\n\t      } catch (e) {\n\t        // Blobs or URLs created from a blob URL don't work in the current\n\t        // browser. Giving up on the download link.\n\t        classes.push('hide-download');\n\t      }\n\t\n\t      // Create the 'permalink' URL.\n\t      if (this.permalinkEnabled) {\n\t        this.permalink.parentNode.style.display = null;\n\t        this.permalink.href = location.toString();\n\t      } else {\n\t        classes.push('hide-permalink');\n\t      }\n\t\n\t      this.links.className = classes.join(' ');\n\t    }\n\t\n\t    // Display any warnings that were generated while rendering a regular expression.\n\t    //\n\t    // - __warnings__ - Array of warning messages to display.\n\t\n\t  }, {\n\t    key: 'displayWarnings',\n\t    value: function displayWarnings(warnings) {\n\t      this.warnings.innerHTML = _lodash2.default.map(warnings, function (warning) {\n\t        return '<li class=\"inline-icon\">' + _util2.default.icon(\"#warning\") + warning + '</li>';\n\t      }).join('');\n\t    }\n\t\n\t    // Render regular expression\n\t    //\n\t    // - __expression__ - Regular expression to render\n\t\n\t  }, {\n\t    key: 'renderRegexp',\n\t    value: function renderRegexp(expression) {\n\t      var _this = this;\n\t\n\t      var parseError = false,\n\t          startTime = void 0,\n\t          endTime = void 0;\n\t\n\t      // When a render is already in progress, cancel it and try rendering again\n\t      // after a short delay (canceling a render is not instantaneous).\n\t      if (this.running) {\n\t        this.running.cancel();\n\t\n\t        return _util2.default.wait(10).then(function () {\n\t          return _this.renderRegexp(expression);\n\t        });\n\t      }\n\t\n\t      this.state = 'is-loading';\n\t      _util2.default.track('send', 'event', 'visualization', 'start');\n\t      startTime = new Date().getTime();\n\t\n\t      this.running = new _javascript2.default(this.svgContainer);\n\t\n\t      return this.running\n\t      // Parse the expression.\n\t      .parse(expression)\n\t      // Display any error messages from the parser and abort the render.\n\t      .catch(function (message) {\n\t        _this.state = 'has-error';\n\t        _this.error.innerHTML = '';\n\t        _this.error.appendChild(document.createTextNode(message));\n\t\n\t        parseError = true;\n\t\n\t        throw message;\n\t      })\n\t      // When parsing is successful, render the parsed expression.\n\t      .then(function (parser) {\n\t        return parser.render();\n\t      })\n\t      // Once rendering is complete:\n\t      //  - Update links\n\t      //  - Display any warnings\n\t      //  - Track the completion of the render and how long it took\n\t      .then(function () {\n\t        _this.state = 'has-results';\n\t        _this.updateLinks();\n\t        _this.displayWarnings(_this.running.warnings);\n\t        _util2.default.track('send', 'event', 'visualization', 'complete');\n\t\n\t        endTime = new Date().getTime();\n\t        _util2.default.track('send', 'timing', 'visualization', 'total time', endTime - startTime);\n\t      })\n\t      // Handle any errors that happened during the rendering pipeline.\n\t      // Swallows parse errors and render cancellations. Any other exceptions\n\t      // are allowed to continue on to be tracked by the global error handler.\n\t      .catch(function (message) {\n\t        if (message === 'Render cancelled') {\n\t          _util2.default.track('send', 'event', 'visualization', 'cancelled');\n\t          _this.state = '';\n\t        } else if (parseError) {\n\t          _util2.default.track('send', 'event', 'visualization', 'parse error');\n\t        } else {\n\t          throw message;\n\t        }\n\t      })\n\t      // Finally, mark rendering as complete (and pass along any exceptions\n\t      // that were thrown).\n\t      .then(function () {\n\t        _this.running = false;\n\t      }, function (message) {\n\t        _this.running = false;\n\t        throw message;\n\t      });\n\t    }\n\t  }, {\n\t    key: 'state',\n\t    set: function set(state) {\n\t      this.root.className = state;\n\t    },\n\t    get: function get() {\n\t      return this.root.className;\n\t    }\n\t  }]);\n\t\n\t  return Regexper;\n\t}();\n\t\n\texports.default = Regexper;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Entry point for the JavaScript-flavor regular expression parsing and\n\t// rendering. Actual parsing code is in\n\t// [parser.js](./javascript/parser.html) and the grammar file. Rendering code\n\t// is contained in the various subclasses of\n\t// [Node](./javascript/node.html)\n\t\n\tvar _snapsvg = __webpack_require__(6);\n\t\n\tvar _snapsvg2 = _interopRequireDefault(_snapsvg);\n\t\n\tvar _lodash = __webpack_require__(2);\n\t\n\tvar _lodash2 = _interopRequireDefault(_lodash);\n\t\n\tvar _util = __webpack_require__(1);\n\t\n\tvar _util2 = _interopRequireDefault(_util);\n\t\n\tvar _parser = __webpack_require__(7);\n\t\n\tvar _parser2 = _interopRequireDefault(_parser);\n\t\n\tvar _parser_state = __webpack_require__(27);\n\t\n\tvar _parser_state2 = _interopRequireDefault(_parser_state);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Parser = function () {\n\t  // - __container__ - DOM node that will contain the rendered expression\n\t  // - __options.keepContent__ - Boolean indicating if content of the container\n\t  //    should be preserved after rendering. Defaults to false (don't keep\n\t  //    contents)\n\t  function Parser(container, options) {\n\t    _classCallCheck(this, Parser);\n\t\n\t    this.options = options || {};\n\t    _lodash2.default.defaults(this.options, {\n\t      keepContent: false\n\t    });\n\t\n\t    this.container = container;\n\t\n\t    // The [ParserState](./javascript/parser_state.html) instance is used to\n\t    // communicate between the parser and a running render, and to update the\n\t    // progress bar for the running render.\n\t    this.state = new _parser_state2.default(this.container.querySelector('.progress div'));\n\t  }\n\t\n\t  // DOM node that will contain the rendered expression. Setting this will add\n\t  // the base markup necessary for rendering the expression, and set the\n\t  // `svg-container` class\n\t\n\t\n\t  _createClass(Parser, [{\n\t    key: '_addClass',\n\t\n\t\n\t    // Helper method to simplify adding classes to the container.\n\t    value: function _addClass(className) {\n\t      this.container.className = (0, _lodash2.default)(this.container.className.split(' ')).union([className]).join(' ');\n\t    }\n\t\n\t    // Helper method to simplify removing classes from the container.\n\t\n\t  }, {\n\t    key: '_removeClass',\n\t    value: function _removeClass(className) {\n\t      this.container.className = (0, _lodash2.default)(this.container.className.split(' ')).without(className).join(' ');\n\t    }\n\t\n\t    // Parse a regular expression into a tree of\n\t    // [Nodes](./javascript/node.html) that can then be used to render an SVG.\n\t    // - __expression__ - Regular expression to parse.\n\t\n\t  }, {\n\t    key: 'parse',\n\t    value: function parse(expression) {\n\t      var _this = this;\n\t\n\t      this._addClass('loading');\n\t\n\t      // Allow the browser to repaint before parsing so that the loading bar is\n\t      // displayed before the (possibly lengthy) parsing begins.\n\t      return _util2.default.tick().then(function () {\n\t        _parser2.default.Parser.SyntaxNode.state = _this.state;\n\t\n\t        _this.parsed = _parser2.default.parse(expression.replace(/\\n/g, '\\\\n'));\n\t        return _this;\n\t      });\n\t    }\n\t\n\t    // Render the parsed expression to an SVG.\n\t\n\t  }, {\n\t    key: 'render',\n\t    value: function render() {\n\t      var _this2 = this;\n\t\n\t      var svg = (0, _snapsvg2.default)(this.container.querySelector('svg'));\n\t\n\t      return this.parsed.render(svg.group())\n\t      // Once rendering is complete, the rendered expression is positioned and\n\t      // the SVG resized to create some padding around the image contents.\n\t      .then(function (result) {\n\t        var box = result.getBBox();\n\t\n\t        result.transform(_snapsvg2.default.matrix().translate(10 - box.x, 10 - box.y));\n\t        svg.attr({\n\t          width: box.width + 20,\n\t          height: box.height + 20\n\t        });\n\t      })\n\t      // Stop and remove loading indicator after render is totally complete.\n\t      .then(function () {\n\t        _this2._removeClass('loading');\n\t        _this2.container.removeChild(_this2.container.querySelector('.progress'));\n\t      });\n\t    }\n\t\n\t    // Cancels any currently in-progress render.\n\t\n\t  }, {\n\t    key: 'cancel',\n\t    value: function cancel() {\n\t      this.state.cancelRender = true;\n\t    }\n\t\n\t    // Returns any warnings that may have been set during the rendering process.\n\t\n\t  }, {\n\t    key: 'container',\n\t    set: function set(cont) {\n\t      this._container = cont;\n\t      this._container.innerHTML = [document.querySelector('#svg-container-base').innerHTML, this.options.keepContent ? this.container.innerHTML : ''].join('');\n\t      this._addClass('svg-container');\n\t    },\n\t    get: function get() {\n\t      return this._container;\n\t    }\n\t  }, {\n\t    key: 'warnings',\n\t    get: function get() {\n\t      return this.state.warnings;\n\t    }\n\t  }]);\n\t\n\t  return Parser;\n\t}();\n\t\n\texports.default = Parser;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_0__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/\n\t(function() {\n\tvar fix = module.exports=0;\n\t\n\t// Snap.svg 0.4.0\n\t// \n\t// Copyright (c) 2013 – 2015 Adobe Systems Incorporated. All rights reserved.\n\t// \n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t// \n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t// \n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\t// \n\t// build: 2015-04-07\n\t\n\t// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t// \n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t// \n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t// \n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\t// ┌────────────────────────────────────────────────────────────┐ \\\\\n\t// │ Eve 0.4.2 - JavaScript Events Library                      │ \\\\\n\t// ├────────────────────────────────────────────────────────────┤ \\\\\n\t// │ Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/) │ \\\\\n\t// └────────────────────────────────────────────────────────────┘ \\\\\n\t\n\t(function (glob) {\n\t    var version = \"0.4.2\",\n\t        has = \"hasOwnProperty\",\n\t        separator = /[\\.\\/]/,\n\t        comaseparator = /\\s*,\\s*/,\n\t        wildcard = \"*\",\n\t        fun = function () {},\n\t        numsort = function (a, b) {\n\t            return a - b;\n\t        },\n\t        current_event,\n\t        stop,\n\t        events = {n: {}},\n\t        firstDefined = function () {\n\t            for (var i = 0, ii = this.length; i < ii; i++) {\n\t                if (typeof this[i] != \"undefined\") {\n\t                    return this[i];\n\t                }\n\t            }\n\t        },\n\t        lastDefined = function () {\n\t            var i = this.length;\n\t            while (--i) {\n\t                if (typeof this[i] != \"undefined\") {\n\t                    return this[i];\n\t                }\n\t            }\n\t        },\n\t    /*\\\n\t     * eve\n\t     [ method ]\n\t\n\t     * Fires event with given `name`, given scope and other parameters.\n\t\n\t     > Arguments\n\t\n\t     - name (string) name of the *event*, dot (`.`) or slash (`/`) separated\n\t     - scope (object) context for the event handlers\n\t     - varargs (...) the rest of arguments will be sent to event handlers\n\t\n\t     = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.\n\t    \\*/\n\t        eve = function (name, scope) {\n\t            name = String(name);\n\t            var e = events,\n\t                oldstop = stop,\n\t                args = Array.prototype.slice.call(arguments, 2),\n\t                listeners = eve.listeners(name),\n\t                z = 0,\n\t                f = false,\n\t                l,\n\t                indexed = [],\n\t                queue = {},\n\t                out = [],\n\t                ce = current_event,\n\t                errors = [];\n\t            out.firstDefined = firstDefined;\n\t            out.lastDefined = lastDefined;\n\t            current_event = name;\n\t            stop = 0;\n\t            for (var i = 0, ii = listeners.length; i < ii; i++) if (\"zIndex\" in listeners[i]) {\n\t                indexed.push(listeners[i].zIndex);\n\t                if (listeners[i].zIndex < 0) {\n\t                    queue[listeners[i].zIndex] = listeners[i];\n\t                }\n\t            }\n\t            indexed.sort(numsort);\n\t            while (indexed[z] < 0) {\n\t                l = queue[indexed[z++]];\n\t                out.push(l.apply(scope, args));\n\t                if (stop) {\n\t                    stop = oldstop;\n\t                    return out;\n\t                }\n\t            }\n\t            for (i = 0; i < ii; i++) {\n\t                l = listeners[i];\n\t                if (\"zIndex\" in l) {\n\t                    if (l.zIndex == indexed[z]) {\n\t                        out.push(l.apply(scope, args));\n\t                        if (stop) {\n\t                            break;\n\t                        }\n\t                        do {\n\t                            z++;\n\t                            l = queue[indexed[z]];\n\t                            l && out.push(l.apply(scope, args));\n\t                            if (stop) {\n\t                                break;\n\t                            }\n\t                        } while (l)\n\t                    } else {\n\t                        queue[l.zIndex] = l;\n\t                    }\n\t                } else {\n\t                    out.push(l.apply(scope, args));\n\t                    if (stop) {\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\t            stop = oldstop;\n\t            current_event = ce;\n\t            return out;\n\t        };\n\t        // Undocumented. Debug only.\n\t        eve._events = events;\n\t    /*\\\n\t     * eve.listeners\n\t     [ method ]\n\t\n\t     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.\n\t\n\t     > Arguments\n\t\n\t     - name (string) name of the event, dot (`.`) or slash (`/`) separated\n\t\n\t     = (array) array of event handlers\n\t    \\*/\n\t    eve.listeners = function (name) {\n\t        var names = name.split(separator),\n\t            e = events,\n\t            item,\n\t            items,\n\t            k,\n\t            i,\n\t            ii,\n\t            j,\n\t            jj,\n\t            nes,\n\t            es = [e],\n\t            out = [];\n\t        for (i = 0, ii = names.length; i < ii; i++) {\n\t            nes = [];\n\t            for (j = 0, jj = es.length; j < jj; j++) {\n\t                e = es[j].n;\n\t                items = [e[names[i]], e[wildcard]];\n\t                k = 2;\n\t                while (k--) {\n\t                    item = items[k];\n\t                    if (item) {\n\t                        nes.push(item);\n\t                        out = out.concat(item.f || []);\n\t                    }\n\t                }\n\t            }\n\t            es = nes;\n\t        }\n\t        return out;\n\t    };\n\t    \n\t    /*\\\n\t     * eve.on\n\t     [ method ]\n\t     **\n\t     * Binds given event handler with a given name. You can use wildcards “`*`” for the names:\n\t     | eve.on(\"*.under.*\", f);\n\t     | eve(\"mouse.under.floor\"); // triggers f\n\t     * Use @eve to trigger the listener.\n\t     **\n\t     > Arguments\n\t     **\n\t     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n\t     - f (function) event handler function\n\t     **\n\t     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment. \n\t     > Example:\n\t     | eve.on(\"mouse\", eatIt)(2);\n\t     | eve.on(\"mouse\", scream);\n\t     | eve.on(\"mouse\", catchIt)(1);\n\t     * This will ensure that `catchIt` function will be called before `eatIt`.\n\t     *\n\t     * If you want to put your handler before non-indexed handlers, specify a negative value.\n\t     * Note: I assume most of the time you don’t need to worry about z-index, but it’s nice to have this feature “just in case”.\n\t    \\*/\n\t    eve.on = function (name, f) {\n\t        name = String(name);\n\t        if (typeof f != \"function\") {\n\t            return function () {};\n\t        }\n\t        var names = name.split(comaseparator);\n\t        for (var i = 0, ii = names.length; i < ii; i++) {\n\t            (function (name) {\n\t                var names = name.split(separator),\n\t                    e = events,\n\t                    exist;\n\t                for (var i = 0, ii = names.length; i < ii; i++) {\n\t                    e = e.n;\n\t                    e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {n: {}});\n\t                }\n\t                e.f = e.f || [];\n\t                for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {\n\t                    exist = true;\n\t                    break;\n\t                }\n\t                !exist && e.f.push(f);\n\t            }(names[i]));\n\t        }\n\t        return function (zIndex) {\n\t            if (+zIndex == +zIndex) {\n\t                f.zIndex = +zIndex;\n\t            }\n\t        };\n\t    };\n\t    /*\\\n\t     * eve.f\n\t     [ method ]\n\t     **\n\t     * Returns function that will fire given event with optional arguments.\n\t     * Arguments that will be passed to the result function will be also\n\t     * concated to the list of final arguments.\n\t     | el.onclick = eve.f(\"click\", 1, 2);\n\t     | eve.on(\"click\", function (a, b, c) {\n\t     |     console.log(a, b, c); // 1, 2, [event object]\n\t     | });\n\t     > Arguments\n\t     - event (string) event name\n\t     - varargs (…) and any other arguments\n\t     = (function) possible event handler function\n\t    \\*/\n\t    eve.f = function (event) {\n\t        var attrs = [].slice.call(arguments, 1);\n\t        return function () {\n\t            eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));\n\t        };\n\t    };\n\t    /*\\\n\t     * eve.stop\n\t     [ method ]\n\t     **\n\t     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.\n\t    \\*/\n\t    eve.stop = function () {\n\t        stop = 1;\n\t    };\n\t    /*\\\n\t     * eve.nt\n\t     [ method ]\n\t     **\n\t     * Could be used inside event handler to figure out actual name of the event.\n\t     **\n\t     > Arguments\n\t     **\n\t     - subname (string) #optional subname of the event\n\t     **\n\t     = (string) name of the event, if `subname` is not specified\n\t     * or\n\t     = (boolean) `true`, if current event’s name contains `subname`\n\t    \\*/\n\t    eve.nt = function (subname) {\n\t        if (subname) {\n\t            return new RegExp(\"(?:\\\\.|\\\\/|^)\" + subname + \"(?:\\\\.|\\\\/|$)\").test(current_event);\n\t        }\n\t        return current_event;\n\t    };\n\t    /*\\\n\t     * eve.nts\n\t     [ method ]\n\t     **\n\t     * Could be used inside event handler to figure out actual name of the event.\n\t     **\n\t     **\n\t     = (array) names of the event\n\t    \\*/\n\t    eve.nts = function () {\n\t        return current_event.split(separator);\n\t    };\n\t    /*\\\n\t     * eve.off\n\t     [ method ]\n\t     **\n\t     * Removes given function from the list of event listeners assigned to given name.\n\t     * If no arguments specified all the events will be cleared.\n\t     **\n\t     > Arguments\n\t     **\n\t     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n\t     - f (function) event handler function\n\t    \\*/\n\t    /*\\\n\t     * eve.unbind\n\t     [ method ]\n\t     **\n\t     * See @eve.off\n\t    \\*/\n\t    eve.off = eve.unbind = function (name, f) {\n\t        if (!name) {\n\t            eve._events = events = {n: {}};\n\t            return;\n\t        }\n\t        var names = name.split(comaseparator);\n\t        if (names.length > 1) {\n\t            for (var i = 0, ii = names.length; i < ii; i++) {\n\t                eve.off(names[i], f);\n\t            }\n\t            return;\n\t        }\n\t        names = name.split(separator);\n\t        var e,\n\t            key,\n\t            splice,\n\t            i, ii, j, jj,\n\t            cur = [events];\n\t        for (i = 0, ii = names.length; i < ii; i++) {\n\t            for (j = 0; j < cur.length; j += splice.length - 2) {\n\t                splice = [j, 1];\n\t                e = cur[j].n;\n\t                if (names[i] != wildcard) {\n\t                    if (e[names[i]]) {\n\t                        splice.push(e[names[i]]);\n\t                    }\n\t                } else {\n\t                    for (key in e) if (e[has](key)) {\n\t                        splice.push(e[key]);\n\t                    }\n\t                }\n\t                cur.splice.apply(cur, splice);\n\t            }\n\t        }\n\t        for (i = 0, ii = cur.length; i < ii; i++) {\n\t            e = cur[i];\n\t            while (e.n) {\n\t                if (f) {\n\t                    if (e.f) {\n\t                        for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {\n\t                            e.f.splice(j, 1);\n\t                            break;\n\t                        }\n\t                        !e.f.length && delete e.f;\n\t                    }\n\t                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n\t                        var funcs = e.n[key].f;\n\t                        for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {\n\t                            funcs.splice(j, 1);\n\t                            break;\n\t                        }\n\t                        !funcs.length && delete e.n[key].f;\n\t                    }\n\t                } else {\n\t                    delete e.f;\n\t                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n\t                        delete e.n[key].f;\n\t                    }\n\t                }\n\t                e = e.n;\n\t            }\n\t        }\n\t    };\n\t    /*\\\n\t     * eve.once\n\t     [ method ]\n\t     **\n\t     * Binds given event handler with a given name to only run once then unbind itself.\n\t     | eve.once(\"login\", f);\n\t     | eve(\"login\"); // triggers f\n\t     | eve(\"login\"); // no listeners\n\t     * Use @eve to trigger the listener.\n\t     **\n\t     > Arguments\n\t     **\n\t     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n\t     - f (function) event handler function\n\t     **\n\t     = (function) same return function as @eve.on\n\t    \\*/\n\t    eve.once = function (name, f) {\n\t        var f2 = function () {\n\t            eve.unbind(name, f2);\n\t            return f.apply(this, arguments);\n\t        };\n\t        return eve.on(name, f2);\n\t    };\n\t    /*\\\n\t     * eve.version\n\t     [ property (string) ]\n\t     **\n\t     * Current version of the library.\n\t    \\*/\n\t    eve.version = version;\n\t    eve.toString = function () {\n\t        return \"You are running Eve \" + version;\n\t    };\n\t    (typeof module != \"undefined\" && module.exports) ? (module.exports = eve) : ( true ? (!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_LOCAL_MODULE_0__ = (function() { return eve; }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)))) : (glob.eve = eve));\n\t})(this);\n\t\n\t(function (glob, factory) {\n\t    // AMD support\n\t    if (true) {\n\t        // Define as an anonymous module\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_0__], __WEBPACK_AMD_DEFINE_RESULT__ = function (eve) {\n\t            return factory(glob, eve);\n\t        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof exports != 'undefined') {\n\t        // Next for Node.js or CommonJS\n\t        var eve = require('eve');\n\t        module.exports = factory(glob, eve);\n\t    } else {\n\t        // Browser globals (glob is window)\n\t        // Snap adds itself to window\n\t        factory(glob, glob.eve);\n\t    }\n\t}(window || this, function (window, eve) {\n\t\n\t// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t// \n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t// \n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t// \n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tvar mina = (function (eve) {\n\t    var animations = {},\n\t    requestAnimFrame = window.requestAnimationFrame       ||\n\t                       window.webkitRequestAnimationFrame ||\n\t                       window.mozRequestAnimationFrame    ||\n\t                       window.oRequestAnimationFrame      ||\n\t                       window.msRequestAnimationFrame     ||\n\t                       function (callback) {\n\t                           setTimeout(callback, 16);\n\t                       },\n\t    isArray = Array.isArray || function (a) {\n\t        return a instanceof Array ||\n\t            Object.prototype.toString.call(a) == \"[object Array]\";\n\t    },\n\t    idgen = 0,\n\t    idprefix = \"M\" + (+new Date).toString(36),\n\t    ID = function () {\n\t        return idprefix + (idgen++).toString(36);\n\t    },\n\t    diff = function (a, b, A, B) {\n\t        if (isArray(a)) {\n\t            res = [];\n\t            for (var i = 0, ii = a.length; i < ii; i++) {\n\t                res[i] = diff(a[i], b, A[i], B);\n\t            }\n\t            return res;\n\t        }\n\t        var dif = (A - a) / (B - b);\n\t        return function (bb) {\n\t            return a + dif * (bb - b);\n\t        };\n\t    },\n\t    timer = Date.now || function () {\n\t        return +new Date;\n\t    },\n\t    sta = function (val) {\n\t        var a = this;\n\t        if (val == null) {\n\t            return a.s;\n\t        }\n\t        var ds = a.s - val;\n\t        a.b += a.dur * ds;\n\t        a.B += a.dur * ds;\n\t        a.s = val;\n\t    },\n\t    speed = function (val) {\n\t        var a = this;\n\t        if (val == null) {\n\t            return a.spd;\n\t        }\n\t        a.spd = val;\n\t    },\n\t    duration = function (val) {\n\t        var a = this;\n\t        if (val == null) {\n\t            return a.dur;\n\t        }\n\t        a.s = a.s * val / a.dur;\n\t        a.dur = val;\n\t    },\n\t    stopit = function () {\n\t        var a = this;\n\t        delete animations[a.id];\n\t        a.update();\n\t        eve(\"mina.stop.\" + a.id, a);\n\t    },\n\t    pause = function () {\n\t        var a = this;\n\t        if (a.pdif) {\n\t            return;\n\t        }\n\t        delete animations[a.id];\n\t        a.update();\n\t        a.pdif = a.get() - a.b;\n\t    },\n\t    resume = function () {\n\t        var a = this;\n\t        if (!a.pdif) {\n\t            return;\n\t        }\n\t        a.b = a.get() - a.pdif;\n\t        delete a.pdif;\n\t        animations[a.id] = a;\n\t    },\n\t    update = function () {\n\t        var a = this,\n\t            res;\n\t        if (isArray(a.start)) {\n\t            res = [];\n\t            for (var j = 0, jj = a.start.length; j < jj; j++) {\n\t                res[j] = +a.start[j] +\n\t                    (a.end[j] - a.start[j]) * a.easing(a.s);\n\t            }\n\t        } else {\n\t            res = +a.start + (a.end - a.start) * a.easing(a.s);\n\t        }\n\t        a.set(res);\n\t    },\n\t    frame = function () {\n\t        var len = 0;\n\t        for (var i in animations) if (animations.hasOwnProperty(i)) {\n\t            var a = animations[i],\n\t                b = a.get(),\n\t                res;\n\t            len++;\n\t            a.s = (b - a.b) / (a.dur / a.spd);\n\t            if (a.s >= 1) {\n\t                delete animations[i];\n\t                a.s = 1;\n\t                len--;\n\t                (function (a) {\n\t                    setTimeout(function () {\n\t                        eve(\"mina.finish.\" + a.id, a);\n\t                    });\n\t                }(a));\n\t            }\n\t            a.update();\n\t        }\n\t        len && requestAnimFrame(frame);\n\t    },\n\t    /*\\\n\t     * mina\n\t     [ method ]\n\t     **\n\t     * Generic animation of numbers\n\t     **\n\t     - a (number) start _slave_ number\n\t     - A (number) end _slave_ number\n\t     - b (number) start _master_ number (start time in general case)\n\t     - B (number) end _master_ number (end time in gereal case)\n\t     - get (function) getter of _master_ number (see @mina.time)\n\t     - set (function) setter of _slave_ number\n\t     - easing (function) #optional easing function, default is @mina.linear\n\t     = (object) animation descriptor\n\t     o {\n\t     o         id (string) animation id,\n\t     o         start (number) start _slave_ number,\n\t     o         end (number) end _slave_ number,\n\t     o         b (number) start _master_ number,\n\t     o         s (number) animation status (0..1),\n\t     o         dur (number) animation duration,\n\t     o         spd (number) animation speed,\n\t     o         get (function) getter of _master_ number (see @mina.time),\n\t     o         set (function) setter of _slave_ number,\n\t     o         easing (function) easing function, default is @mina.linear,\n\t     o         status (function) status getter/setter,\n\t     o         speed (function) speed getter/setter,\n\t     o         duration (function) duration getter/setter,\n\t     o         stop (function) animation stopper\n\t     o         pause (function) pauses the animation\n\t     o         resume (function) resumes the animation\n\t     o         update (function) calles setter with the right value of the animation\n\t     o }\n\t    \\*/\n\t    mina = function (a, A, b, B, get, set, easing) {\n\t        var anim = {\n\t            id: ID(),\n\t            start: a,\n\t            end: A,\n\t            b: b,\n\t            s: 0,\n\t            dur: B - b,\n\t            spd: 1,\n\t            get: get,\n\t            set: set,\n\t            easing: easing || mina.linear,\n\t            status: sta,\n\t            speed: speed,\n\t            duration: duration,\n\t            stop: stopit,\n\t            pause: pause,\n\t            resume: resume,\n\t            update: update\n\t        };\n\t        animations[anim.id] = anim;\n\t        var len = 0, i;\n\t        for (i in animations) if (animations.hasOwnProperty(i)) {\n\t            len++;\n\t            if (len == 2) {\n\t                break;\n\t            }\n\t        }\n\t        len == 1 && requestAnimFrame(frame);\n\t        return anim;\n\t    };\n\t    /*\\\n\t     * mina.time\n\t     [ method ]\n\t     **\n\t     * Returns the current time. Equivalent to:\n\t     | function () {\n\t     |     return (new Date).getTime();\n\t     | }\n\t    \\*/\n\t    mina.time = timer;\n\t    /*\\\n\t     * mina.getById\n\t     [ method ]\n\t     **\n\t     * Returns an animation by its id\n\t     - id (string) animation's id\n\t     = (object) See @mina\n\t    \\*/\n\t    mina.getById = function (id) {\n\t        return animations[id] || null;\n\t    };\n\t\n\t    /*\\\n\t     * mina.linear\n\t     [ method ]\n\t     **\n\t     * Default linear easing\n\t     - n (number) input 0..1\n\t     = (number) output 0..1\n\t    \\*/\n\t    mina.linear = function (n) {\n\t        return n;\n\t    };\n\t    /*\\\n\t     * mina.easeout\n\t     [ method ]\n\t     **\n\t     * Easeout easing\n\t     - n (number) input 0..1\n\t     = (number) output 0..1\n\t    \\*/\n\t    mina.easeout = function (n) {\n\t        return Math.pow(n, 1.7);\n\t    };\n\t    /*\\\n\t     * mina.easein\n\t     [ method ]\n\t     **\n\t     * Easein easing\n\t     - n (number) input 0..1\n\t     = (number) output 0..1\n\t    \\*/\n\t    mina.easein = function (n) {\n\t        return Math.pow(n, .48);\n\t    };\n\t    /*\\\n\t     * mina.easeinout\n\t     [ method ]\n\t     **\n\t     * Easeinout easing\n\t     - n (number) input 0..1\n\t     = (number) output 0..1\n\t    \\*/\n\t    mina.easeinout = function (n) {\n\t        if (n == 1) {\n\t            return 1;\n\t        }\n\t        if (n == 0) {\n\t            return 0;\n\t        }\n\t        var q = .48 - n / 1.04,\n\t            Q = Math.sqrt(.1734 + q * q),\n\t            x = Q - q,\n\t            X = Math.pow(Math.abs(x), 1 / 3) * (x < 0 ? -1 : 1),\n\t            y = -Q - q,\n\t            Y = Math.pow(Math.abs(y), 1 / 3) * (y < 0 ? -1 : 1),\n\t            t = X + Y + .5;\n\t        return (1 - t) * 3 * t * t + t * t * t;\n\t    };\n\t    /*\\\n\t     * mina.backin\n\t     [ method ]\n\t     **\n\t     * Backin easing\n\t     - n (number) input 0..1\n\t     = (number) output 0..1\n\t    \\*/\n\t    mina.backin = function (n) {\n\t        if (n == 1) {\n\t            return 1;\n\t        }\n\t        var s = 1.70158;\n\t        return n * n * ((s + 1) * n - s);\n\t    };\n\t    /*\\\n\t     * mina.backout\n\t     [ method ]\n\t     **\n\t     * Backout easing\n\t     - n (number) input 0..1\n\t     = (number) output 0..1\n\t    \\*/\n\t    mina.backout = function (n) {\n\t        if (n == 0) {\n\t            return 0;\n\t        }\n\t        n = n - 1;\n\t        var s = 1.70158;\n\t        return n * n * ((s + 1) * n + s) + 1;\n\t    };\n\t    /*\\\n\t     * mina.elastic\n\t     [ method ]\n\t     **\n\t     * Elastic easing\n\t     - n (number) input 0..1\n\t     = (number) output 0..1\n\t    \\*/\n\t    mina.elastic = function (n) {\n\t        if (n == !!n) {\n\t            return n;\n\t        }\n\t        return Math.pow(2, -10 * n) * Math.sin((n - .075) *\n\t            (2 * Math.PI) / .3) + 1;\n\t    };\n\t    /*\\\n\t     * mina.bounce\n\t     [ method ]\n\t     **\n\t     * Bounce easing\n\t     - n (number) input 0..1\n\t     = (number) output 0..1\n\t    \\*/\n\t    mina.bounce = function (n) {\n\t        var s = 7.5625,\n\t            p = 2.75,\n\t            l;\n\t        if (n < (1 / p)) {\n\t            l = s * n * n;\n\t        } else {\n\t            if (n < (2 / p)) {\n\t                n -= (1.5 / p);\n\t                l = s * n * n + .75;\n\t            } else {\n\t                if (n < (2.5 / p)) {\n\t                    n -= (2.25 / p);\n\t                    l = s * n * n + .9375;\n\t                } else {\n\t                    n -= (2.625 / p);\n\t                    l = s * n * n + .984375;\n\t                }\n\t            }\n\t        }\n\t        return l;\n\t    };\n\t    window.mina = mina;\n\t    return mina;\n\t})(typeof eve == \"undefined\" ? function () {} : eve);\n\t// Copyright (c) 2013 - 2015 Adobe Systems Incorporated. All rights reserved.\n\t// \n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t// \n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t// \n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\t\n\tvar Snap = (function(root) {\n\tSnap.version = \"0.4.0\";\n\t/*\\\n\t * Snap\n\t [ method ]\n\t **\n\t * Creates a drawing surface or wraps existing SVG element.\n\t **\n\t - width (number|string) width of surface\n\t - height (number|string) height of surface\n\t * or\n\t - DOM (SVGElement) element to be wrapped into Snap structure\n\t * or\n\t - array (array) array of elements (will return set of elements)\n\t * or\n\t - query (string) CSS query selector\n\t = (object) @Element\n\t\\*/\n\tfunction Snap(w, h) {\n\t    if (w) {\n\t        if (w.nodeType) {\n\t            return wrap(w);\n\t        }\n\t        if (is(w, \"array\") && Snap.set) {\n\t            return Snap.set.apply(Snap, w);\n\t        }\n\t        if (w instanceof Element) {\n\t            return w;\n\t        }\n\t        if (h == null) {\n\t            w = glob.doc.querySelector(String(w));\n\t            return wrap(w);\n\t        }\n\t    }\n\t    w = w == null ? \"100%\" : w;\n\t    h = h == null ? \"100%\" : h;\n\t    return new Paper(w, h);\n\t}\n\tSnap.toString = function () {\n\t    return \"Snap v\" + this.version;\n\t};\n\tSnap._ = {};\n\tvar glob = {\n\t    win: root.window,\n\t    doc: root.window.document\n\t};\n\tSnap._.glob = glob;\n\tvar has = \"hasOwnProperty\",\n\t    Str = String,\n\t    toFloat = parseFloat,\n\t    toInt = parseInt,\n\t    math = Math,\n\t    mmax = math.max,\n\t    mmin = math.min,\n\t    abs = math.abs,\n\t    pow = math.pow,\n\t    PI = math.PI,\n\t    round = math.round,\n\t    E = \"\",\n\t    S = \" \",\n\t    objectToString = Object.prototype.toString,\n\t    ISURL = /^url\\(['\"]?([^\\)]+?)['\"]?\\)$/i,\n\t    colourRegExp = /^\\s*((#[a-f\\d]{6})|(#[a-f\\d]{3})|rgba?\\(\\s*([\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?(?:\\s*,\\s*[\\d\\.]+%?)?)\\s*\\)|hsba?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+(?:%?\\s*,\\s*[\\d\\.]+)?%?)\\s*\\)|hsla?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+(?:%?\\s*,\\s*[\\d\\.]+)?%?)\\s*\\))\\s*$/i,\n\t    bezierrg = /^(?:cubic-)?bezier\\(([^,]+),([^,]+),([^,]+),([^\\)]+)\\)/,\n\t    reURLValue = /^url\\(#?([^)]+)\\)$/,\n\t    separator = Snap._.separator = /[,\\s]+/,\n\t    whitespace = /[\\s]/g,\n\t    commaSpaces = /[\\s]*,[\\s]*/,\n\t    hsrg = {hs: 1, rg: 1},\n\t    pathCommand = /([a-z])[\\s,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\s]*,?[\\s]*)+)/ig,\n\t    tCommand = /([rstm])[\\s,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\s]*,?[\\s]*)+)/ig,\n\t    pathValues = /(-?\\d*\\.?\\d*(?:e[\\-+]?\\\\d+)?)[\\s]*,?[\\s]*/ig,\n\t    idgen = 0,\n\t    idprefix = \"S\" + (+new Date).toString(36),\n\t    ID = function (el) {\n\t        return (el && el.type ? el.type : E) + idprefix + (idgen++).toString(36);\n\t    },\n\t    xlink = \"http://www.w3.org/1999/xlink\",\n\t    xmlns = \"http://www.w3.org/2000/svg\",\n\t    hub = {},\n\t    URL = Snap.url = function (url) {\n\t        return \"url('#\" + url + \"')\";\n\t    };\n\t\n\tfunction $(el, attr) {\n\t    if (attr) {\n\t        if (el == \"#text\") {\n\t            el = glob.doc.createTextNode(attr.text || attr[\"#text\"] || \"\");\n\t        }\n\t        if (el == \"#comment\") {\n\t            el = glob.doc.createComment(attr.text || attr[\"#text\"] || \"\");\n\t        }\n\t        if (typeof el == \"string\") {\n\t            el = $(el);\n\t        }\n\t        if (typeof attr == \"string\") {\n\t            if (el.nodeType == 1) {\n\t                if (attr.substring(0, 6) == \"xlink:\") {\n\t                    return el.getAttributeNS(xlink, attr.substring(6));\n\t                }\n\t                if (attr.substring(0, 4) == \"xml:\") {\n\t                    return el.getAttributeNS(xmlns, attr.substring(4));\n\t                }\n\t                return el.getAttribute(attr);\n\t            } else if (attr == \"text\") {\n\t                return el.nodeValue;\n\t            } else {\n\t                return null;\n\t            }\n\t        }\n\t        if (el.nodeType == 1) {\n\t            for (var key in attr) if (attr[has](key)) {\n\t                var val = Str(attr[key]);\n\t                if (val) {\n\t                    if (key.substring(0, 6) == \"xlink:\") {\n\t                        el.setAttributeNS(xlink, key.substring(6), val);\n\t                    } else if (key.substring(0, 4) == \"xml:\") {\n\t                        el.setAttributeNS(xmlns, key.substring(4), val);\n\t                    } else {\n\t                        el.setAttribute(key, val);\n\t                    }\n\t                } else {\n\t                    el.removeAttribute(key);\n\t                }\n\t            }\n\t        } else if (\"text\" in attr) {\n\t            el.nodeValue = attr.text;\n\t        }\n\t    } else {\n\t        el = glob.doc.createElementNS(xmlns, el);\n\t    }\n\t    return el;\n\t}\n\tSnap._.$ = $;\n\tSnap._.id = ID;\n\tfunction getAttrs(el) {\n\t    var attrs = el.attributes,\n\t        name,\n\t        out = {};\n\t    for (var i = 0; i < attrs.length; i++) {\n\t        if (attrs[i].namespaceURI == xlink) {\n\t            name = \"xlink:\";\n\t        } else {\n\t            name = \"\";\n\t        }\n\t        name += attrs[i].name;\n\t        out[name] = attrs[i].textContent;\n\t    }\n\t    return out;\n\t}\n\tfunction is(o, type) {\n\t    type = Str.prototype.toLowerCase.call(type);\n\t    if (type == \"finite\") {\n\t        return isFinite(o);\n\t    }\n\t    if (type == \"array\" &&\n\t        (o instanceof Array || Array.isArray && Array.isArray(o))) {\n\t        return true;\n\t    }\n\t    return  (type == \"null\" && o === null) ||\n\t            (type == typeof o && o !== null) ||\n\t            (type == \"object\" && o === Object(o)) ||\n\t            objectToString.call(o).slice(8, -1).toLowerCase() == type;\n\t}\n\t/*\\\n\t * Snap.format\n\t [ method ]\n\t **\n\t * Replaces construction of type `{<name>}` to the corresponding argument\n\t **\n\t - token (string) string to format\n\t - json (object) object which properties are used as a replacement\n\t = (string) formatted string\n\t > Usage\n\t | // this draws a rectangular shape equivalent to \"M10,20h40v50h-40z\"\n\t | paper.path(Snap.format(\"M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z\", {\n\t |     x: 10,\n\t |     y: 20,\n\t |     dim: {\n\t |         width: 40,\n\t |         height: 50,\n\t |         \"negative width\": -40\n\t |     }\n\t | }));\n\t\\*/\n\tSnap.format = (function () {\n\t    var tokenRegex = /\\{([^\\}]+)\\}/g,\n\t        objNotationRegex = /(?:(?:^|\\.)(.+?)(?=\\[|\\.|$|\\()|\\[('|\")(.+?)\\2\\])(\\(\\))?/g, // matches .xxxxx or [\"xxxxx\"] to run over object properties\n\t        replacer = function (all, key, obj) {\n\t            var res = obj;\n\t            key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {\n\t                name = name || quotedName;\n\t                if (res) {\n\t                    if (name in res) {\n\t                        res = res[name];\n\t                    }\n\t                    typeof res == \"function\" && isFunc && (res = res());\n\t                }\n\t            });\n\t            res = (res == null || res == obj ? all : res) + \"\";\n\t            return res;\n\t        };\n\t    return function (str, obj) {\n\t        return Str(str).replace(tokenRegex, function (all, key) {\n\t            return replacer(all, key, obj);\n\t        });\n\t    };\n\t})();\n\tfunction clone(obj) {\n\t    if (typeof obj == \"function\" || Object(obj) !== obj) {\n\t        return obj;\n\t    }\n\t    var res = new obj.constructor;\n\t    for (var key in obj) if (obj[has](key)) {\n\t        res[key] = clone(obj[key]);\n\t    }\n\t    return res;\n\t}\n\tSnap._.clone = clone;\n\tfunction repush(array, item) {\n\t    for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {\n\t        return array.push(array.splice(i, 1)[0]);\n\t    }\n\t}\n\tfunction cacher(f, scope, postprocessor) {\n\t    function newf() {\n\t        var arg = Array.prototype.slice.call(arguments, 0),\n\t            args = arg.join(\"\\u2400\"),\n\t            cache = newf.cache = newf.cache || {},\n\t            count = newf.count = newf.count || [];\n\t        if (cache[has](args)) {\n\t            repush(count, args);\n\t            return postprocessor ? postprocessor(cache[args]) : cache[args];\n\t        }\n\t        count.length >= 1e3 && delete cache[count.shift()];\n\t        count.push(args);\n\t        cache[args] = f.apply(scope, arg);\n\t        return postprocessor ? postprocessor(cache[args]) : cache[args];\n\t    }\n\t    return newf;\n\t}\n\tSnap._.cacher = cacher;\n\tfunction angle(x1, y1, x2, y2, x3, y3) {\n\t    if (x3 == null) {\n\t        var x = x1 - x2,\n\t            y = y1 - y2;\n\t        if (!x && !y) {\n\t            return 0;\n\t        }\n\t        return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;\n\t    } else {\n\t        return angle(x1, y1, x3, y3) - angle(x2, y2, x3, y3);\n\t    }\n\t}\n\tfunction rad(deg) {\n\t    return deg % 360 * PI / 180;\n\t}\n\tfunction deg(rad) {\n\t    return rad * 180 / PI % 360;\n\t}\n\tfunction x_y() {\n\t    return this.x + S + this.y;\n\t}\n\tfunction x_y_w_h() {\n\t    return this.x + S + this.y + S + this.width + \" \\xd7 \" + this.height;\n\t}\n\t\n\t/*\\\n\t * Snap.rad\n\t [ method ]\n\t **\n\t * Transform angle to radians\n\t - deg (number) angle in degrees\n\t = (number) angle in radians\n\t\\*/\n\tSnap.rad = rad;\n\t/*\\\n\t * Snap.deg\n\t [ method ]\n\t **\n\t * Transform angle to degrees\n\t - rad (number) angle in radians\n\t = (number) angle in degrees\n\t\\*/\n\tSnap.deg = deg;\n\t/*\\\n\t * Snap.sin\n\t [ method ]\n\t **\n\t * Equivalent to `Math.sin()` only works with degrees, not radians.\n\t - angle (number) angle in degrees\n\t = (number) sin\n\t\\*/\n\tSnap.sin = function (angle) {\n\t    return math.sin(Snap.rad(angle));\n\t};\n\t/*\\\n\t * Snap.tan\n\t [ method ]\n\t **\n\t * Equivalent to `Math.tan()` only works with degrees, not radians.\n\t - angle (number) angle in degrees\n\t = (number) tan\n\t\\*/\n\tSnap.tan = function (angle) {\n\t    return math.tan(Snap.rad(angle));\n\t};\n\t/*\\\n\t * Snap.cos\n\t [ method ]\n\t **\n\t * Equivalent to `Math.cos()` only works with degrees, not radians.\n\t - angle (number) angle in degrees\n\t = (number) cos\n\t\\*/\n\tSnap.cos = function (angle) {\n\t    return math.cos(Snap.rad(angle));\n\t};\n\t/*\\\n\t * Snap.asin\n\t [ method ]\n\t **\n\t * Equivalent to `Math.asin()` only works with degrees, not radians.\n\t - num (number) value\n\t = (number) asin in degrees\n\t\\*/\n\tSnap.asin = function (num) {\n\t    return Snap.deg(math.asin(num));\n\t};\n\t/*\\\n\t * Snap.acos\n\t [ method ]\n\t **\n\t * Equivalent to `Math.acos()` only works with degrees, not radians.\n\t - num (number) value\n\t = (number) acos in degrees\n\t\\*/\n\tSnap.acos = function (num) {\n\t    return Snap.deg(math.acos(num));\n\t};\n\t/*\\\n\t * Snap.atan\n\t [ method ]\n\t **\n\t * Equivalent to `Math.atan()` only works with degrees, not radians.\n\t - num (number) value\n\t = (number) atan in degrees\n\t\\*/\n\tSnap.atan = function (num) {\n\t    return Snap.deg(math.atan(num));\n\t};\n\t/*\\\n\t * Snap.atan2\n\t [ method ]\n\t **\n\t * Equivalent to `Math.atan2()` only works with degrees, not radians.\n\t - num (number) value\n\t = (number) atan2 in degrees\n\t\\*/\n\tSnap.atan2 = function (num) {\n\t    return Snap.deg(math.atan2(num));\n\t};\n\t/*\\\n\t * Snap.angle\n\t [ method ]\n\t **\n\t * Returns an angle between two or three points\n\t > Parameters\n\t - x1 (number) x coord of first point\n\t - y1 (number) y coord of first point\n\t - x2 (number) x coord of second point\n\t - y2 (number) y coord of second point\n\t - x3 (number) #optional x coord of third point\n\t - y3 (number) #optional y coord of third point\n\t = (number) angle in degrees\n\t\\*/\n\tSnap.angle = angle;\n\t/*\\\n\t * Snap.len\n\t [ method ]\n\t **\n\t * Returns distance between two points\n\t > Parameters\n\t - x1 (number) x coord of first point\n\t - y1 (number) y coord of first point\n\t - x2 (number) x coord of second point\n\t - y2 (number) y coord of second point\n\t = (number) distance\n\t\\*/\n\tSnap.len = function (x1, y1, x2, y2) {\n\t    return Math.sqrt(Snap.len2(x1, y1, x2, y2));\n\t};\n\t/*\\\n\t * Snap.len2\n\t [ method ]\n\t **\n\t * Returns squared distance between two points\n\t > Parameters\n\t - x1 (number) x coord of first point\n\t - y1 (number) y coord of first point\n\t - x2 (number) x coord of second point\n\t - y2 (number) y coord of second point\n\t = (number) distance\n\t\\*/\n\tSnap.len2 = function (x1, y1, x2, y2) {\n\t    return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\n\t};\n\t/*\\\n\t * Snap.closestPoint\n\t [ method ]\n\t **\n\t * Returns closest point to a given one on a given path.\n\t > Parameters\n\t - path (Element) path element\n\t - x (number) x coord of a point\n\t - y (number) y coord of a point\n\t = (object) in format\n\t {\n\t    x (number) x coord of the point on the path\n\t    y (number) y coord of the point on the path\n\t    length (number) length of the path to the point\n\t    distance (number) distance from the given point to the path\n\t }\n\t\\*/\n\t// Copied from http://bl.ocks.org/mbostock/8027637\n\tSnap.closestPoint = function (path, x, y) {\n\t    function distance2(p) {\n\t        var dx = p.x - x,\n\t            dy = p.y - y;\n\t        return dx * dx + dy * dy;\n\t    }\n\t    var pathNode = path.node,\n\t        pathLength = pathNode.getTotalLength(),\n\t        precision = pathLength / pathNode.pathSegList.numberOfItems * .125,\n\t        best,\n\t        bestLength,\n\t        bestDistance = Infinity;\n\t\n\t    // linear scan for coarse approximation\n\t    for (var scan, scanLength = 0, scanDistance; scanLength <= pathLength; scanLength += precision) {\n\t        if ((scanDistance = distance2(scan = pathNode.getPointAtLength(scanLength))) < bestDistance) {\n\t            best = scan, bestLength = scanLength, bestDistance = scanDistance;\n\t        }\n\t    }\n\t\n\t    // binary search for precise estimate\n\t    precision *= .5;\n\t    while (precision > .5) {\n\t        var before,\n\t            after,\n\t            beforeLength,\n\t            afterLength,\n\t            beforeDistance,\n\t            afterDistance;\n\t        if ((beforeLength = bestLength - precision) >= 0 && (beforeDistance = distance2(before = pathNode.getPointAtLength(beforeLength))) < bestDistance) {\n\t            best = before, bestLength = beforeLength, bestDistance = beforeDistance;\n\t        } else if ((afterLength = bestLength + precision) <= pathLength && (afterDistance = distance2(after = pathNode.getPointAtLength(afterLength))) < bestDistance) {\n\t            best = after, bestLength = afterLength, bestDistance = afterDistance;\n\t        } else {\n\t            precision *= .5;\n\t        }\n\t    }\n\t\n\t    best = {\n\t        x: best.x,\n\t        y: best.y,\n\t        length: bestLength,\n\t        distance: Math.sqrt(bestDistance)\n\t    };\n\t    return best;\n\t}\n\t/*\\\n\t * Snap.is\n\t [ method ]\n\t **\n\t * Handy replacement for the `typeof` operator\n\t - o (…) any object or primitive\n\t - type (string) name of the type, e.g., `string`, `function`, `number`, etc.\n\t = (boolean) `true` if given value is of given type\n\t\\*/\n\tSnap.is = is;\n\t/*\\\n\t * Snap.snapTo\n\t [ method ]\n\t **\n\t * Snaps given value to given grid\n\t - values (array|number) given array of values or step of the grid\n\t - value (number) value to adjust\n\t - tolerance (number) #optional maximum distance to the target value that would trigger the snap. Default is `10`.\n\t = (number) adjusted value\n\t\\*/\n\tSnap.snapTo = function (values, value, tolerance) {\n\t    tolerance = is(tolerance, \"finite\") ? tolerance : 10;\n\t    if (is(values, \"array\")) {\n\t        var i = values.length;\n\t        while (i--) if (abs(values[i] - value) <= tolerance) {\n\t            return values[i];\n\t        }\n\t    } else {\n\t        values = +values;\n\t        var rem = value % values;\n\t        if (rem < tolerance) {\n\t            return value - rem;\n\t        }\n\t        if (rem > values - tolerance) {\n\t            return value - rem + values;\n\t        }\n\t    }\n\t    return value;\n\t};\n\t// Colour\n\t/*\\\n\t * Snap.getRGB\n\t [ method ]\n\t **\n\t * Parses color string as RGB object\n\t - color (string) color string in one of the following formats:\n\t # <ul>\n\t #     <li>Color name (<code>red</code>, <code>green</code>, <code>cornflowerblue</code>, etc)</li>\n\t #     <li>#••• — shortened HTML color: (<code>#000</code>, <code>#fc0</code>, etc.)</li>\n\t #     <li>#•••••• — full length HTML color: (<code>#000000</code>, <code>#bd2300</code>)</li>\n\t #     <li>rgb(•••, •••, •••) — red, green and blue channels values: (<code>rgb(200,&nbsp;100,&nbsp;0)</code>)</li>\n\t #     <li>rgba(•••, •••, •••, •••) — also with opacity</li>\n\t #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>)</li>\n\t #     <li>rgba(•••%, •••%, •••%, •••%) — also with opacity</li>\n\t #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>)</li>\n\t #     <li>hsba(•••, •••, •••, •••) — also with opacity</li>\n\t #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>\n\t #     <li>hsba(•••%, •••%, •••%, •••%) — also with opacity</li>\n\t #     <li>hsl(•••, •••, •••) — hue, saturation and luminosity values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;0.5)</code>)</li>\n\t #     <li>hsla(•••, •••, •••, •••) — also with opacity</li>\n\t #     <li>hsl(•••%, •••%, •••%) — same as above, but in %</li>\n\t #     <li>hsla(•••%, •••%, •••%, •••%) — also with opacity</li>\n\t # </ul>\n\t * Note that `%` can be used any time: `rgb(20%, 255, 50%)`.\n\t = (object) RGB object in the following format:\n\t o {\n\t o     r (number) red,\n\t o     g (number) green,\n\t o     b (number) blue,\n\t o     hex (string) color in HTML/CSS format: #••••••,\n\t o     error (boolean) true if string can't be parsed\n\t o }\n\t\\*/\n\tSnap.getRGB = cacher(function (colour) {\n\t    if (!colour || !!((colour = Str(colour)).indexOf(\"-\") + 1)) {\n\t        return {r: -1, g: -1, b: -1, hex: \"none\", error: 1, toString: rgbtoString};\n\t    }\n\t    if (colour == \"none\") {\n\t        return {r: -1, g: -1, b: -1, hex: \"none\", toString: rgbtoString};\n\t    }\n\t    !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == \"#\") && (colour = toHex(colour));\n\t    if (!colour) {\n\t        return {r: -1, g: -1, b: -1, hex: \"none\", error: 1, toString: rgbtoString};\n\t    }\n\t    var res,\n\t        red,\n\t        green,\n\t        blue,\n\t        opacity,\n\t        t,\n\t        values,\n\t        rgb = colour.match(colourRegExp);\n\t    if (rgb) {\n\t        if (rgb[2]) {\n\t            blue = toInt(rgb[2].substring(5), 16);\n\t            green = toInt(rgb[2].substring(3, 5), 16);\n\t            red = toInt(rgb[2].substring(1, 3), 16);\n\t        }\n\t        if (rgb[3]) {\n\t            blue = toInt((t = rgb[3].charAt(3)) + t, 16);\n\t            green = toInt((t = rgb[3].charAt(2)) + t, 16);\n\t            red = toInt((t = rgb[3].charAt(1)) + t, 16);\n\t        }\n\t        if (rgb[4]) {\n\t            values = rgb[4].split(commaSpaces);\n\t            red = toFloat(values[0]);\n\t            values[0].slice(-1) == \"%\" && (red *= 2.55);\n\t            green = toFloat(values[1]);\n\t            values[1].slice(-1) == \"%\" && (green *= 2.55);\n\t            blue = toFloat(values[2]);\n\t            values[2].slice(-1) == \"%\" && (blue *= 2.55);\n\t            rgb[1].toLowerCase().slice(0, 4) == \"rgba\" && (opacity = toFloat(values[3]));\n\t            values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n\t        }\n\t        if (rgb[5]) {\n\t            values = rgb[5].split(commaSpaces);\n\t            red = toFloat(values[0]);\n\t            values[0].slice(-1) == \"%\" && (red /= 100);\n\t            green = toFloat(values[1]);\n\t            values[1].slice(-1) == \"%\" && (green /= 100);\n\t            blue = toFloat(values[2]);\n\t            values[2].slice(-1) == \"%\" && (blue /= 100);\n\t            (values[0].slice(-3) == \"deg\" || values[0].slice(-1) == \"\\xb0\") && (red /= 360);\n\t            rgb[1].toLowerCase().slice(0, 4) == \"hsba\" && (opacity = toFloat(values[3]));\n\t            values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n\t            return Snap.hsb2rgb(red, green, blue, opacity);\n\t        }\n\t        if (rgb[6]) {\n\t            values = rgb[6].split(commaSpaces);\n\t            red = toFloat(values[0]);\n\t            values[0].slice(-1) == \"%\" && (red /= 100);\n\t            green = toFloat(values[1]);\n\t            values[1].slice(-1) == \"%\" && (green /= 100);\n\t            blue = toFloat(values[2]);\n\t            values[2].slice(-1) == \"%\" && (blue /= 100);\n\t            (values[0].slice(-3) == \"deg\" || values[0].slice(-1) == \"\\xb0\") && (red /= 360);\n\t            rgb[1].toLowerCase().slice(0, 4) == \"hsla\" && (opacity = toFloat(values[3]));\n\t            values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n\t            return Snap.hsl2rgb(red, green, blue, opacity);\n\t        }\n\t        red = mmin(math.round(red), 255);\n\t        green = mmin(math.round(green), 255);\n\t        blue = mmin(math.round(blue), 255);\n\t        opacity = mmin(mmax(opacity, 0), 1);\n\t        rgb = {r: red, g: green, b: blue, toString: rgbtoString};\n\t        rgb.hex = \"#\" + (16777216 | blue | (green << 8) | (red << 16)).toString(16).slice(1);\n\t        rgb.opacity = is(opacity, \"finite\") ? opacity : 1;\n\t        return rgb;\n\t    }\n\t    return {r: -1, g: -1, b: -1, hex: \"none\", error: 1, toString: rgbtoString};\n\t}, Snap);\n\t/*\\\n\t * Snap.hsb\n\t [ method ]\n\t **\n\t * Converts HSB values to a hex representation of the color\n\t - h (number) hue\n\t - s (number) saturation\n\t - b (number) value or brightness\n\t = (string) hex representation of the color\n\t\\*/\n\tSnap.hsb = cacher(function (h, s, b) {\n\t    return Snap.hsb2rgb(h, s, b).hex;\n\t});\n\t/*\\\n\t * Snap.hsl\n\t [ method ]\n\t **\n\t * Converts HSL values to a hex representation of the color\n\t - h (number) hue\n\t - s (number) saturation\n\t - l (number) luminosity\n\t = (string) hex representation of the color\n\t\\*/\n\tSnap.hsl = cacher(function (h, s, l) {\n\t    return Snap.hsl2rgb(h, s, l).hex;\n\t});\n\t/*\\\n\t * Snap.rgb\n\t [ method ]\n\t **\n\t * Converts RGB values to a hex representation of the color\n\t - r (number) red\n\t - g (number) green\n\t - b (number) blue\n\t = (string) hex representation of the color\n\t\\*/\n\tSnap.rgb = cacher(function (r, g, b, o) {\n\t    if (is(o, \"finite\")) {\n\t        var round = math.round;\n\t        return \"rgba(\" + [round(r), round(g), round(b), +o.toFixed(2)] + \")\";\n\t    }\n\t    return \"#\" + (16777216 | b | (g << 8) | (r << 16)).toString(16).slice(1);\n\t});\n\tvar toHex = function (color) {\n\t    var i = glob.doc.getElementsByTagName(\"head\")[0] || glob.doc.getElementsByTagName(\"svg\")[0],\n\t        red = \"rgb(255, 0, 0)\";\n\t    toHex = cacher(function (color) {\n\t        if (color.toLowerCase() == \"red\") {\n\t            return red;\n\t        }\n\t        i.style.color = red;\n\t        i.style.color = color;\n\t        var out = glob.doc.defaultView.getComputedStyle(i, E).getPropertyValue(\"color\");\n\t        return out == red ? null : out;\n\t    });\n\t    return toHex(color);\n\t},\n\thsbtoString = function () {\n\t    return \"hsb(\" + [this.h, this.s, this.b] + \")\";\n\t},\n\thsltoString = function () {\n\t    return \"hsl(\" + [this.h, this.s, this.l] + \")\";\n\t},\n\trgbtoString = function () {\n\t    return this.opacity == 1 || this.opacity == null ?\n\t            this.hex :\n\t            \"rgba(\" + [this.r, this.g, this.b, this.opacity] + \")\";\n\t},\n\tprepareRGB = function (r, g, b) {\n\t    if (g == null && is(r, \"object\") && \"r\" in r && \"g\" in r && \"b\" in r) {\n\t        b = r.b;\n\t        g = r.g;\n\t        r = r.r;\n\t    }\n\t    if (g == null && is(r, string)) {\n\t        var clr = Snap.getRGB(r);\n\t        r = clr.r;\n\t        g = clr.g;\n\t        b = clr.b;\n\t    }\n\t    if (r > 1 || g > 1 || b > 1) {\n\t        r /= 255;\n\t        g /= 255;\n\t        b /= 255;\n\t    }\n\t    \n\t    return [r, g, b];\n\t},\n\tpackageRGB = function (r, g, b, o) {\n\t    r = math.round(r * 255);\n\t    g = math.round(g * 255);\n\t    b = math.round(b * 255);\n\t    var rgb = {\n\t        r: r,\n\t        g: g,\n\t        b: b,\n\t        opacity: is(o, \"finite\") ? o : 1,\n\t        hex: Snap.rgb(r, g, b),\n\t        toString: rgbtoString\n\t    };\n\t    is(o, \"finite\") && (rgb.opacity = o);\n\t    return rgb;\n\t};\n\t/*\\\n\t * Snap.color\n\t [ method ]\n\t **\n\t * Parses the color string and returns an object featuring the color's component values\n\t - clr (string) color string in one of the supported formats (see @Snap.getRGB)\n\t = (object) Combined RGB/HSB object in the following format:\n\t o {\n\t o     r (number) red,\n\t o     g (number) green,\n\t o     b (number) blue,\n\t o     hex (string) color in HTML/CSS format: #••••••,\n\t o     error (boolean) `true` if string can't be parsed,\n\t o     h (number) hue,\n\t o     s (number) saturation,\n\t o     v (number) value (brightness),\n\t o     l (number) lightness\n\t o }\n\t\\*/\n\tSnap.color = function (clr) {\n\t    var rgb;\n\t    if (is(clr, \"object\") && \"h\" in clr && \"s\" in clr && \"b\" in clr) {\n\t        rgb = Snap.hsb2rgb(clr);\n\t        clr.r = rgb.r;\n\t        clr.g = rgb.g;\n\t        clr.b = rgb.b;\n\t        clr.opacity = 1;\n\t        clr.hex = rgb.hex;\n\t    } else if (is(clr, \"object\") && \"h\" in clr && \"s\" in clr && \"l\" in clr) {\n\t        rgb = Snap.hsl2rgb(clr);\n\t        clr.r = rgb.r;\n\t        clr.g = rgb.g;\n\t        clr.b = rgb.b;\n\t        clr.opacity = 1;\n\t        clr.hex = rgb.hex;\n\t    } else {\n\t        if (is(clr, \"string\")) {\n\t            clr = Snap.getRGB(clr);\n\t        }\n\t        if (is(clr, \"object\") && \"r\" in clr && \"g\" in clr && \"b\" in clr && !(\"error\" in clr)) {\n\t            rgb = Snap.rgb2hsl(clr);\n\t            clr.h = rgb.h;\n\t            clr.s = rgb.s;\n\t            clr.l = rgb.l;\n\t            rgb = Snap.rgb2hsb(clr);\n\t            clr.v = rgb.b;\n\t        } else {\n\t            clr = {hex: \"none\"};\n\t            clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;\n\t            clr.error = 1;\n\t        }\n\t    }\n\t    clr.toString = rgbtoString;\n\t    return clr;\n\t};\n\t/*\\\n\t * Snap.hsb2rgb\n\t [ method ]\n\t **\n\t * Converts HSB values to an RGB object\n\t - h (number) hue\n\t - s (number) saturation\n\t - v (number) value or brightness\n\t = (object) RGB object in the following format:\n\t o {\n\t o     r (number) red,\n\t o     g (number) green,\n\t o     b (number) blue,\n\t o     hex (string) color in HTML/CSS format: #••••••\n\t o }\n\t\\*/\n\tSnap.hsb2rgb = function (h, s, v, o) {\n\t    if (is(h, \"object\") && \"h\" in h && \"s\" in h && \"b\" in h) {\n\t        v = h.b;\n\t        s = h.s;\n\t        o = h.o;\n\t        h = h.h;\n\t    }\n\t    h *= 360;\n\t    var R, G, B, X, C;\n\t    h = (h % 360) / 60;\n\t    C = v * s;\n\t    X = C * (1 - abs(h % 2 - 1));\n\t    R = G = B = v - C;\n\t\n\t    h = ~~h;\n\t    R += [C, X, 0, 0, X, C][h];\n\t    G += [X, C, C, X, 0, 0][h];\n\t    B += [0, 0, X, C, C, X][h];\n\t    return packageRGB(R, G, B, o);\n\t};\n\t/*\\\n\t * Snap.hsl2rgb\n\t [ method ]\n\t **\n\t * Converts HSL values to an RGB object\n\t - h (number) hue\n\t - s (number) saturation\n\t - l (number) luminosity\n\t = (object) RGB object in the following format:\n\t o {\n\t o     r (number) red,\n\t o     g (number) green,\n\t o     b (number) blue,\n\t o     hex (string) color in HTML/CSS format: #••••••\n\t o }\n\t\\*/\n\tSnap.hsl2rgb = function (h, s, l, o) {\n\t    if (is(h, \"object\") && \"h\" in h && \"s\" in h && \"l\" in h) {\n\t        l = h.l;\n\t        s = h.s;\n\t        h = h.h;\n\t    }\n\t    if (h > 1 || s > 1 || l > 1) {\n\t        h /= 360;\n\t        s /= 100;\n\t        l /= 100;\n\t    }\n\t    h *= 360;\n\t    var R, G, B, X, C;\n\t    h = (h % 360) / 60;\n\t    C = 2 * s * (l < .5 ? l : 1 - l);\n\t    X = C * (1 - abs(h % 2 - 1));\n\t    R = G = B = l - C / 2;\n\t\n\t    h = ~~h;\n\t    R += [C, X, 0, 0, X, C][h];\n\t    G += [X, C, C, X, 0, 0][h];\n\t    B += [0, 0, X, C, C, X][h];\n\t    return packageRGB(R, G, B, o);\n\t};\n\t/*\\\n\t * Snap.rgb2hsb\n\t [ method ]\n\t **\n\t * Converts RGB values to an HSB object\n\t - r (number) red\n\t - g (number) green\n\t - b (number) blue\n\t = (object) HSB object in the following format:\n\t o {\n\t o     h (number) hue,\n\t o     s (number) saturation,\n\t o     b (number) brightness\n\t o }\n\t\\*/\n\tSnap.rgb2hsb = function (r, g, b) {\n\t    b = prepareRGB(r, g, b);\n\t    r = b[0];\n\t    g = b[1];\n\t    b = b[2];\n\t\n\t    var H, S, V, C;\n\t    V = mmax(r, g, b);\n\t    C = V - mmin(r, g, b);\n\t    H = (C == 0 ? null :\n\t         V == r ? (g - b) / C :\n\t         V == g ? (b - r) / C + 2 :\n\t                  (r - g) / C + 4\n\t        );\n\t    H = ((H + 360) % 6) * 60 / 360;\n\t    S = C == 0 ? 0 : C / V;\n\t    return {h: H, s: S, b: V, toString: hsbtoString};\n\t};\n\t/*\\\n\t * Snap.rgb2hsl\n\t [ method ]\n\t **\n\t * Converts RGB values to an HSL object\n\t - r (number) red\n\t - g (number) green\n\t - b (number) blue\n\t = (object) HSL object in the following format:\n\t o {\n\t o     h (number) hue,\n\t o     s (number) saturation,\n\t o     l (number) luminosity\n\t o }\n\t\\*/\n\tSnap.rgb2hsl = function (r, g, b) {\n\t    b = prepareRGB(r, g, b);\n\t    r = b[0];\n\t    g = b[1];\n\t    b = b[2];\n\t\n\t    var H, S, L, M, m, C;\n\t    M = mmax(r, g, b);\n\t    m = mmin(r, g, b);\n\t    C = M - m;\n\t    H = (C == 0 ? null :\n\t         M == r ? (g - b) / C :\n\t         M == g ? (b - r) / C + 2 :\n\t                  (r - g) / C + 4);\n\t    H = ((H + 360) % 6) * 60 / 360;\n\t    L = (M + m) / 2;\n\t    S = (C == 0 ? 0 :\n\t         L < .5 ? C / (2 * L) :\n\t                  C / (2 - 2 * L));\n\t    return {h: H, s: S, l: L, toString: hsltoString};\n\t};\n\t\n\t// Transformations\n\t/*\\\n\t * Snap.parsePathString\n\t [ method ]\n\t **\n\t * Utility method\n\t **\n\t * Parses given path string into an array of arrays of path segments\n\t - pathString (string|array) path string or array of segments (in the last case it is returned straight away)\n\t = (array) array of segments\n\t\\*/\n\tSnap.parsePathString = function (pathString) {\n\t    if (!pathString) {\n\t        return null;\n\t    }\n\t    var pth = Snap.path(pathString);\n\t    if (pth.arr) {\n\t        return Snap.path.clone(pth.arr);\n\t    }\n\t    \n\t    var paramCounts = {a: 7, c: 6, o: 2, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, u: 3, z: 0},\n\t        data = [];\n\t    if (is(pathString, \"array\") && is(pathString[0], \"array\")) { // rough assumption\n\t        data = Snap.path.clone(pathString);\n\t    }\n\t    if (!data.length) {\n\t        Str(pathString).replace(pathCommand, function (a, b, c) {\n\t            var params = [],\n\t                name = b.toLowerCase();\n\t            c.replace(pathValues, function (a, b) {\n\t                b && params.push(+b);\n\t            });\n\t            if (name == \"m\" && params.length > 2) {\n\t                data.push([b].concat(params.splice(0, 2)));\n\t                name = \"l\";\n\t                b = b == \"m\" ? \"l\" : \"L\";\n\t            }\n\t            if (name == \"o\" && params.length == 1) {\n\t                data.push([b, params[0]]);\n\t            }\n\t            if (name == \"r\") {\n\t                data.push([b].concat(params));\n\t            } else while (params.length >= paramCounts[name]) {\n\t                data.push([b].concat(params.splice(0, paramCounts[name])));\n\t                if (!paramCounts[name]) {\n\t                    break;\n\t                }\n\t            }\n\t        });\n\t    }\n\t    data.toString = Snap.path.toString;\n\t    pth.arr = Snap.path.clone(data);\n\t    return data;\n\t};\n\t/*\\\n\t * Snap.parseTransformString\n\t [ method ]\n\t **\n\t * Utility method\n\t **\n\t * Parses given transform string into an array of transformations\n\t - TString (string|array) transform string or array of transformations (in the last case it is returned straight away)\n\t = (array) array of transformations\n\t\\*/\n\tvar parseTransformString = Snap.parseTransformString = function (TString) {\n\t    if (!TString) {\n\t        return null;\n\t    }\n\t    var paramCounts = {r: 3, s: 4, t: 2, m: 6},\n\t        data = [];\n\t    if (is(TString, \"array\") && is(TString[0], \"array\")) { // rough assumption\n\t        data = Snap.path.clone(TString);\n\t    }\n\t    if (!data.length) {\n\t        Str(TString).replace(tCommand, function (a, b, c) {\n\t            var params = [],\n\t                name = b.toLowerCase();\n\t            c.replace(pathValues, function (a, b) {\n\t                b && params.push(+b);\n\t            });\n\t            data.push([b].concat(params));\n\t        });\n\t    }\n\t    data.toString = Snap.path.toString;\n\t    return data;\n\t};\n\tfunction svgTransform2string(tstr) {\n\t    var res = [];\n\t    tstr = tstr.replace(/(?:^|\\s)(\\w+)\\(([^)]+)\\)/g, function (all, name, params) {\n\t        params = params.split(/\\s*,\\s*|\\s+/);\n\t        if (name == \"rotate\" && params.length == 1) {\n\t            params.push(0, 0);\n\t        }\n\t        if (name == \"scale\") {\n\t            if (params.length > 2) {\n\t                params = params.slice(0, 2);\n\t            } else if (params.length == 2) {\n\t                params.push(0, 0);\n\t            }\n\t            if (params.length == 1) {\n\t                params.push(params[0], 0, 0);\n\t            }\n\t        }\n\t        if (name == \"skewX\") {\n\t            res.push([\"m\", 1, 0, math.tan(rad(params[0])), 1, 0, 0]);\n\t        } else if (name == \"skewY\") {\n\t            res.push([\"m\", 1, math.tan(rad(params[0])), 0, 1, 0, 0]);\n\t        } else {\n\t            res.push([name.charAt(0)].concat(params));\n\t        }\n\t        return all;\n\t    });\n\t    return res;\n\t}\n\tSnap._.svgTransform2string = svgTransform2string;\n\tSnap._.rgTransform = /^[a-z][\\s]*-?\\.?\\d/i;\n\tfunction transform2matrix(tstr, bbox) {\n\t    var tdata = parseTransformString(tstr),\n\t        m = new Snap.Matrix;\n\t    if (tdata) {\n\t        for (var i = 0, ii = tdata.length; i < ii; i++) {\n\t            var t = tdata[i],\n\t                tlen = t.length,\n\t                command = Str(t[0]).toLowerCase(),\n\t                absolute = t[0] != command,\n\t                inver = absolute ? m.invert() : 0,\n\t                x1,\n\t                y1,\n\t                x2,\n\t                y2,\n\t                bb;\n\t            if (command == \"t\" && tlen == 2){\n\t                m.translate(t[1], 0);\n\t            } else if (command == \"t\" && tlen == 3) {\n\t                if (absolute) {\n\t                    x1 = inver.x(0, 0);\n\t                    y1 = inver.y(0, 0);\n\t                    x2 = inver.x(t[1], t[2]);\n\t                    y2 = inver.y(t[1], t[2]);\n\t                    m.translate(x2 - x1, y2 - y1);\n\t                } else {\n\t                    m.translate(t[1], t[2]);\n\t                }\n\t            } else if (command == \"r\") {\n\t                if (tlen == 2) {\n\t                    bb = bb || bbox;\n\t                    m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);\n\t                } else if (tlen == 4) {\n\t                    if (absolute) {\n\t                        x2 = inver.x(t[2], t[3]);\n\t                        y2 = inver.y(t[2], t[3]);\n\t                        m.rotate(t[1], x2, y2);\n\t                    } else {\n\t                        m.rotate(t[1], t[2], t[3]);\n\t                    }\n\t                }\n\t            } else if (command == \"s\") {\n\t                if (tlen == 2 || tlen == 3) {\n\t                    bb = bb || bbox;\n\t                    m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);\n\t                } else if (tlen == 4) {\n\t                    if (absolute) {\n\t                        x2 = inver.x(t[2], t[3]);\n\t                        y2 = inver.y(t[2], t[3]);\n\t                        m.scale(t[1], t[1], x2, y2);\n\t                    } else {\n\t                        m.scale(t[1], t[1], t[2], t[3]);\n\t                    }\n\t                } else if (tlen == 5) {\n\t                    if (absolute) {\n\t                        x2 = inver.x(t[3], t[4]);\n\t                        y2 = inver.y(t[3], t[4]);\n\t                        m.scale(t[1], t[2], x2, y2);\n\t                    } else {\n\t                        m.scale(t[1], t[2], t[3], t[4]);\n\t                    }\n\t                }\n\t            } else if (command == \"m\" && tlen == 7) {\n\t                m.add(t[1], t[2], t[3], t[4], t[5], t[6]);\n\t            }\n\t        }\n\t    }\n\t    return m;\n\t}\n\tSnap._.transform2matrix = transform2matrix;\n\tSnap._unit2px = unit2px;\n\tvar contains = glob.doc.contains || glob.doc.compareDocumentPosition ?\n\t    function (a, b) {\n\t        var adown = a.nodeType == 9 ? a.documentElement : a,\n\t            bup = b && b.parentNode;\n\t            return a == bup || !!(bup && bup.nodeType == 1 && (\n\t                adown.contains ?\n\t                    adown.contains(bup) :\n\t                    a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16\n\t            ));\n\t    } :\n\t    function (a, b) {\n\t        if (b) {\n\t            while (b) {\n\t                b = b.parentNode;\n\t                if (b == a) {\n\t                    return true;\n\t                }\n\t            }\n\t        }\n\t        return false;\n\t    };\n\tfunction getSomeDefs(el) {\n\t    var p = (el.node.ownerSVGElement && wrap(el.node.ownerSVGElement)) ||\n\t            (el.node.parentNode && wrap(el.node.parentNode)) ||\n\t            Snap.select(\"svg\") ||\n\t            Snap(0, 0),\n\t        pdefs = p.select(\"defs\"),\n\t        defs  = pdefs == null ? false : pdefs.node;\n\t    if (!defs) {\n\t        defs = make(\"defs\", p.node).node;\n\t    }\n\t    return defs;\n\t}\n\tfunction getSomeSVG(el) {\n\t    return el.node.ownerSVGElement && wrap(el.node.ownerSVGElement) || Snap.select(\"svg\");\n\t}\n\tSnap._.getSomeDefs = getSomeDefs;\n\tSnap._.getSomeSVG = getSomeSVG;\n\tfunction unit2px(el, name, value) {\n\t    var svg = getSomeSVG(el).node,\n\t        out = {},\n\t        mgr = svg.querySelector(\".svg---mgr\");\n\t    if (!mgr) {\n\t        mgr = $(\"rect\");\n\t        $(mgr, {x: -9e9, y: -9e9, width: 10, height: 10, \"class\": \"svg---mgr\", fill: \"none\"});\n\t        svg.appendChild(mgr);\n\t    }\n\t    function getW(val) {\n\t        if (val == null) {\n\t            return E;\n\t        }\n\t        if (val == +val) {\n\t            return val;\n\t        }\n\t        $(mgr, {width: val});\n\t        try {\n\t            return mgr.getBBox().width;\n\t        } catch (e) {\n\t            return 0;\n\t        }\n\t    }\n\t    function getH(val) {\n\t        if (val == null) {\n\t            return E;\n\t        }\n\t        if (val == +val) {\n\t            return val;\n\t        }\n\t        $(mgr, {height: val});\n\t        try {\n\t            return mgr.getBBox().height;\n\t        } catch (e) {\n\t            return 0;\n\t        }\n\t    }\n\t    function set(nam, f) {\n\t        if (name == null) {\n\t            out[nam] = f(el.attr(nam) || 0);\n\t        } else if (nam == name) {\n\t            out = f(value == null ? el.attr(nam) || 0 : value);\n\t        }\n\t    }\n\t    switch (el.type) {\n\t        case \"rect\":\n\t            set(\"rx\", getW);\n\t            set(\"ry\", getH);\n\t        case \"image\":\n\t            set(\"width\", getW);\n\t            set(\"height\", getH);\n\t        case \"text\":\n\t            set(\"x\", getW);\n\t            set(\"y\", getH);\n\t        break;\n\t        case \"circle\":\n\t            set(\"cx\", getW);\n\t            set(\"cy\", getH);\n\t            set(\"r\", getW);\n\t        break;\n\t        case \"ellipse\":\n\t            set(\"cx\", getW);\n\t            set(\"cy\", getH);\n\t            set(\"rx\", getW);\n\t            set(\"ry\", getH);\n\t        break;\n\t        case \"line\":\n\t            set(\"x1\", getW);\n\t            set(\"x2\", getW);\n\t            set(\"y1\", getH);\n\t            set(\"y2\", getH);\n\t        break;\n\t        case \"marker\":\n\t            set(\"refX\", getW);\n\t            set(\"markerWidth\", getW);\n\t            set(\"refY\", getH);\n\t            set(\"markerHeight\", getH);\n\t        break;\n\t        case \"radialGradient\":\n\t            set(\"fx\", getW);\n\t            set(\"fy\", getH);\n\t        break;\n\t        case \"tspan\":\n\t            set(\"dx\", getW);\n\t            set(\"dy\", getH);\n\t        break;\n\t        default:\n\t            set(name, getW);\n\t    }\n\t    svg.removeChild(mgr);\n\t    return out;\n\t}\n\t/*\\\n\t * Snap.select\n\t [ method ]\n\t **\n\t * Wraps a DOM element specified by CSS selector as @Element\n\t - query (string) CSS selector of the element\n\t = (Element) the current element\n\t\\*/\n\tSnap.select = function (query) {\n\t    query = Str(query).replace(/([^\\\\]):/g, \"$1\\\\:\");\n\t    return wrap(glob.doc.querySelector(query));\n\t};\n\t/*\\\n\t * Snap.selectAll\n\t [ method ]\n\t **\n\t * Wraps DOM elements specified by CSS selector as set or array of @Element\n\t - query (string) CSS selector of the element\n\t = (Element) the current element\n\t\\*/\n\tSnap.selectAll = function (query) {\n\t    var nodelist = glob.doc.querySelectorAll(query),\n\t        set = (Snap.set || Array)();\n\t    for (var i = 0; i < nodelist.length; i++) {\n\t        set.push(wrap(nodelist[i]));\n\t    }\n\t    return set;\n\t};\n\t\n\tfunction add2group(list) {\n\t    if (!is(list, \"array\")) {\n\t        list = Array.prototype.slice.call(arguments, 0);\n\t    }\n\t    var i = 0,\n\t        j = 0,\n\t        node = this.node;\n\t    while (this[i]) delete this[i++];\n\t    for (i = 0; i < list.length; i++) {\n\t        if (list[i].type == \"set\") {\n\t            list[i].forEach(function (el) {\n\t                node.appendChild(el.node);\n\t            });\n\t        } else {\n\t            node.appendChild(list[i].node);\n\t        }\n\t    }\n\t    var children = node.childNodes;\n\t    for (i = 0; i < children.length; i++) {\n\t        this[j++] = wrap(children[i]);\n\t    }\n\t    return this;\n\t}\n\t// Hub garbage collector every 10s\n\tsetInterval(function () {\n\t    for (var key in hub) if (hub[has](key)) {\n\t        var el = hub[key],\n\t            node = el.node;\n\t        if (el.type != \"svg\" && !node.ownerSVGElement || el.type == \"svg\" && (!node.parentNode || \"ownerSVGElement\" in node.parentNode && !node.ownerSVGElement)) {\n\t            delete hub[key];\n\t        }\n\t    }\n\t}, 1e4);\n\tfunction Element(el) {\n\t    if (el.snap in hub) {\n\t        return hub[el.snap];\n\t    }\n\t    var svg;\n\t    try {\n\t        svg = el.ownerSVGElement;\n\t    } catch(e) {}\n\t    /*\\\n\t     * Element.node\n\t     [ property (object) ]\n\t     **\n\t     * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.\n\t     > Usage\n\t     | // draw a circle at coordinate 10,10 with radius of 10\n\t     | var c = paper.circle(10, 10, 10);\n\t     | c.node.onclick = function () {\n\t     |     c.attr(\"fill\", \"red\");\n\t     | };\n\t    \\*/\n\t    this.node = el;\n\t    if (svg) {\n\t        this.paper = new Paper(svg);\n\t    }\n\t    /*\\\n\t     * Element.type\n\t     [ property (string) ]\n\t     **\n\t     * SVG tag name of the given element.\n\t    \\*/\n\t    this.type = el.tagName || el.nodeName;\n\t    var id = this.id = ID(this);\n\t    this.anims = {};\n\t    this._ = {\n\t        transform: []\n\t    };\n\t    el.snap = id;\n\t    hub[id] = this;\n\t    if (this.type == \"g\") {\n\t        this.add = add2group;\n\t    }\n\t    if (this.type in {g: 1, mask: 1, pattern: 1, symbol: 1}) {\n\t        for (var method in Paper.prototype) if (Paper.prototype[has](method)) {\n\t            this[method] = Paper.prototype[method];\n\t        }\n\t    }\n\t}\n\t   /*\\\n\t     * Element.attr\n\t     [ method ]\n\t     **\n\t     * Gets or sets given attributes of the element.\n\t     **\n\t     - params (object) contains key-value pairs of attributes you want to set\n\t     * or\n\t     - param (string) name of the attribute\n\t     = (Element) the current element\n\t     * or\n\t     = (string) value of attribute\n\t     > Usage\n\t     | el.attr({\n\t     |     fill: \"#fc0\",\n\t     |     stroke: \"#000\",\n\t     |     strokeWidth: 2, // CamelCase...\n\t     |     \"fill-opacity\": 0.5, // or dash-separated names\n\t     |     width: \"*=2\" // prefixed values\n\t     | });\n\t     | console.log(el.attr(\"fill\")); // #fc0\n\t     * Prefixed values in format `\"+=10\"` supported. All four operations\n\t     * (`+`, `-`, `*` and `/`) could be used. Optionally you can use units for `+`\n\t     * and `-`: `\"+=2em\"`.\n\t    \\*/\n\t    Element.prototype.attr = function (params, value) {\n\t        var el = this,\n\t            node = el.node;\n\t        if (!params) {\n\t            if (node.nodeType != 1) {\n\t                return {\n\t                    text: node.nodeValue\n\t                };\n\t            }\n\t            var attr = node.attributes,\n\t                out = {};\n\t            for (var i = 0, ii = attr.length; i < ii; i++) {\n\t                out[attr[i].nodeName] = attr[i].nodeValue;\n\t            }\n\t            return out;\n\t        }\n\t        if (is(params, \"string\")) {\n\t            if (arguments.length > 1) {\n\t                var json = {};\n\t                json[params] = value;\n\t                params = json;\n\t            } else {\n\t                return eve(\"snap.util.getattr.\" + params, el).firstDefined();\n\t            }\n\t        }\n\t        for (var att in params) {\n\t            if (params[has](att)) {\n\t                eve(\"snap.util.attr.\" + att, el, params[att]);\n\t            }\n\t        }\n\t        return el;\n\t    };\n\t/*\\\n\t * Snap.parse\n\t [ method ]\n\t **\n\t * Parses SVG fragment and converts it into a @Fragment\n\t **\n\t - svg (string) SVG string\n\t = (Fragment) the @Fragment\n\t\\*/\n\tSnap.parse = function (svg) {\n\t    var f = glob.doc.createDocumentFragment(),\n\t        full = true,\n\t        div = glob.doc.createElement(\"div\");\n\t    svg = Str(svg);\n\t    if (!svg.match(/^\\s*<\\s*svg(?:\\s|>)/)) {\n\t        svg = \"<svg>\" + svg + \"</svg>\";\n\t        full = false;\n\t    }\n\t    div.innerHTML = svg;\n\t    svg = div.getElementsByTagName(\"svg\")[0];\n\t    if (svg) {\n\t        if (full) {\n\t            f = svg;\n\t        } else {\n\t            while (svg.firstChild) {\n\t                f.appendChild(svg.firstChild);\n\t            }\n\t        }\n\t    }\n\t    return new Fragment(f);\n\t};\n\tfunction Fragment(frag) {\n\t    this.node = frag;\n\t}\n\t/*\\\n\t * Snap.fragment\n\t [ method ]\n\t **\n\t * Creates a DOM fragment from a given list of elements or strings\n\t **\n\t - varargs (…) SVG string\n\t = (Fragment) the @Fragment\n\t\\*/\n\tSnap.fragment = function () {\n\t    var args = Array.prototype.slice.call(arguments, 0),\n\t        f = glob.doc.createDocumentFragment();\n\t    for (var i = 0, ii = args.length; i < ii; i++) {\n\t        var item = args[i];\n\t        if (item.node && item.node.nodeType) {\n\t            f.appendChild(item.node);\n\t        }\n\t        if (item.nodeType) {\n\t            f.appendChild(item);\n\t        }\n\t        if (typeof item == \"string\") {\n\t            f.appendChild(Snap.parse(item).node);\n\t        }\n\t    }\n\t    return new Fragment(f);\n\t};\n\t\n\tfunction make(name, parent) {\n\t    var res = $(name);\n\t    parent.appendChild(res);\n\t    var el = wrap(res);\n\t    return el;\n\t}\n\tfunction Paper(w, h) {\n\t    var res,\n\t        desc,\n\t        defs,\n\t        proto = Paper.prototype;\n\t    if (w && w.tagName == \"svg\") {\n\t        if (w.snap in hub) {\n\t            return hub[w.snap];\n\t        }\n\t        var doc = w.ownerDocument;\n\t        res = new Element(w);\n\t        desc = w.getElementsByTagName(\"desc\")[0];\n\t        defs = w.getElementsByTagName(\"defs\")[0];\n\t        if (!desc) {\n\t            desc = $(\"desc\");\n\t            desc.appendChild(doc.createTextNode(\"Created with Snap\"));\n\t            res.node.appendChild(desc);\n\t        }\n\t        if (!defs) {\n\t            defs = $(\"defs\");\n\t            res.node.appendChild(defs);\n\t        }\n\t        res.defs = defs;\n\t        for (var key in proto) if (proto[has](key)) {\n\t            res[key] = proto[key];\n\t        }\n\t        res.paper = res.root = res;\n\t    } else {\n\t        res = make(\"svg\", glob.doc.body);\n\t        $(res.node, {\n\t            height: h,\n\t            version: 1.1,\n\t            width: w,\n\t            xmlns: xmlns\n\t        });\n\t    }\n\t    return res;\n\t}\n\tfunction wrap(dom) {\n\t    if (!dom) {\n\t        return dom;\n\t    }\n\t    if (dom instanceof Element || dom instanceof Fragment) {\n\t        return dom;\n\t    }\n\t    if (dom.tagName && dom.tagName.toLowerCase() == \"svg\") {\n\t        return new Paper(dom);\n\t    }\n\t    if (dom.tagName && dom.tagName.toLowerCase() == \"object\" && dom.type == \"image/svg+xml\") {\n\t        return new Paper(dom.contentDocument.getElementsByTagName(\"svg\")[0]);\n\t    }\n\t    return new Element(dom);\n\t}\n\t\n\tSnap._.make = make;\n\tSnap._.wrap = wrap;\n\t/*\\\n\t * Paper.el\n\t [ method ]\n\t **\n\t * Creates an element on paper with a given name and no attributes\n\t **\n\t - name (string) tag name\n\t - attr (object) attributes\n\t = (Element) the current element\n\t > Usage\n\t | var c = paper.circle(10, 10, 10); // is the same as...\n\t | var c = paper.el(\"circle\").attr({\n\t |     cx: 10,\n\t |     cy: 10,\n\t |     r: 10\n\t | });\n\t | // and the same as\n\t | var c = paper.el(\"circle\", {\n\t |     cx: 10,\n\t |     cy: 10,\n\t |     r: 10\n\t | });\n\t\\*/\n\tPaper.prototype.el = function (name, attr) {\n\t    var el = make(name, this.node);\n\t    attr && el.attr(attr);\n\t    return el;\n\t};\n\t/*\\\n\t * Element.children\n\t [ method ]\n\t **\n\t * Returns array of all the children of the element.\n\t = (array) array of Elements\n\t\\*/\n\tElement.prototype.children = function () {\n\t    var out = [],\n\t        ch = this.node.childNodes;\n\t    for (var i = 0, ii = ch.length; i < ii; i++) {\n\t        out[i] = Snap(ch[i]);\n\t    }\n\t    return out;\n\t};\n\tfunction jsonFiller(root, o) {\n\t    for (var i = 0, ii = root.length; i < ii; i++) {\n\t        var item = {\n\t                type: root[i].type,\n\t                attr: root[i].attr()\n\t            },\n\t            children = root[i].children();\n\t        o.push(item);\n\t        if (children.length) {\n\t            jsonFiller(children, item.childNodes = []);\n\t        }\n\t    }\n\t}\n\t/*\\\n\t * Element.toJSON\n\t [ method ]\n\t **\n\t * Returns object representation of the given element and all its children.\n\t = (object) in format\n\t o {\n\t o     type (string) this.type,\n\t o     attr (object) attributes map,\n\t o     childNodes (array) optional array of children in the same format\n\t o }\n\t\\*/\n\tElement.prototype.toJSON = function () {\n\t    var out = [];\n\t    jsonFiller([this], out);\n\t    return out[0];\n\t};\n\t// default\n\teve.on(\"snap.util.getattr\", function () {\n\t    var att = eve.nt();\n\t    att = att.substring(att.lastIndexOf(\".\") + 1);\n\t    var css = att.replace(/[A-Z]/g, function (letter) {\n\t        return \"-\" + letter.toLowerCase();\n\t    });\n\t    if (cssAttr[has](css)) {\n\t        return this.node.ownerDocument.defaultView.getComputedStyle(this.node, null).getPropertyValue(css);\n\t    } else {\n\t        return $(this.node, att);\n\t    }\n\t});\n\tvar cssAttr = {\n\t    \"alignment-baseline\": 0,\n\t    \"baseline-shift\": 0,\n\t    \"clip\": 0,\n\t    \"clip-path\": 0,\n\t    \"clip-rule\": 0,\n\t    \"color\": 0,\n\t    \"color-interpolation\": 0,\n\t    \"color-interpolation-filters\": 0,\n\t    \"color-profile\": 0,\n\t    \"color-rendering\": 0,\n\t    \"cursor\": 0,\n\t    \"direction\": 0,\n\t    \"display\": 0,\n\t    \"dominant-baseline\": 0,\n\t    \"enable-background\": 0,\n\t    \"fill\": 0,\n\t    \"fill-opacity\": 0,\n\t    \"fill-rule\": 0,\n\t    \"filter\": 0,\n\t    \"flood-color\": 0,\n\t    \"flood-opacity\": 0,\n\t    \"font\": 0,\n\t    \"font-family\": 0,\n\t    \"font-size\": 0,\n\t    \"font-size-adjust\": 0,\n\t    \"font-stretch\": 0,\n\t    \"font-style\": 0,\n\t    \"font-variant\": 0,\n\t    \"font-weight\": 0,\n\t    \"glyph-orientation-horizontal\": 0,\n\t    \"glyph-orientation-vertical\": 0,\n\t    \"image-rendering\": 0,\n\t    \"kerning\": 0,\n\t    \"letter-spacing\": 0,\n\t    \"lighting-color\": 0,\n\t    \"marker\": 0,\n\t    \"marker-end\": 0,\n\t    \"marker-mid\": 0,\n\t    \"marker-start\": 0,\n\t    \"mask\": 0,\n\t    \"opacity\": 0,\n\t    \"overflow\": 0,\n\t    \"pointer-events\": 0,\n\t    \"shape-rendering\": 0,\n\t    \"stop-color\": 0,\n\t    \"stop-opacity\": 0,\n\t    \"stroke\": 0,\n\t    \"stroke-dasharray\": 0,\n\t    \"stroke-dashoffset\": 0,\n\t    \"stroke-linecap\": 0,\n\t    \"stroke-linejoin\": 0,\n\t    \"stroke-miterlimit\": 0,\n\t    \"stroke-opacity\": 0,\n\t    \"stroke-width\": 0,\n\t    \"text-anchor\": 0,\n\t    \"text-decoration\": 0,\n\t    \"text-rendering\": 0,\n\t    \"unicode-bidi\": 0,\n\t    \"visibility\": 0,\n\t    \"word-spacing\": 0,\n\t    \"writing-mode\": 0\n\t};\n\t\n\teve.on(\"snap.util.attr\", function (value) {\n\t    var att = eve.nt(),\n\t        attr = {};\n\t    att = att.substring(att.lastIndexOf(\".\") + 1);\n\t    attr[att] = value;\n\t    var style = att.replace(/-(\\w)/gi, function (all, letter) {\n\t            return letter.toUpperCase();\n\t        }),\n\t        css = att.replace(/[A-Z]/g, function (letter) {\n\t            return \"-\" + letter.toLowerCase();\n\t        });\n\t    if (cssAttr[has](css)) {\n\t        this.node.style[style] = value == null ? E : value;\n\t    } else {\n\t        $(this.node, attr);\n\t    }\n\t});\n\t(function (proto) {}(Paper.prototype));\n\t\n\t// simple ajax\n\t/*\\\n\t * Snap.ajax\n\t [ method ]\n\t **\n\t * Simple implementation of Ajax\n\t **\n\t - url (string) URL\n\t - postData (object|string) data for post request\n\t - callback (function) callback\n\t - scope (object) #optional scope of callback\n\t * or\n\t - url (string) URL\n\t - callback (function) callback\n\t - scope (object) #optional scope of callback\n\t = (XMLHttpRequest) the XMLHttpRequest object, just in case\n\t\\*/\n\tSnap.ajax = function (url, postData, callback, scope){\n\t    var req = new XMLHttpRequest,\n\t        id = ID();\n\t    if (req) {\n\t        if (is(postData, \"function\")) {\n\t            scope = callback;\n\t            callback = postData;\n\t            postData = null;\n\t        } else if (is(postData, \"object\")) {\n\t            var pd = [];\n\t            for (var key in postData) if (postData.hasOwnProperty(key)) {\n\t                pd.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(postData[key]));\n\t            }\n\t            postData = pd.join(\"&\");\n\t        }\n\t        req.open((postData ? \"POST\" : \"GET\"), url, true);\n\t        if (postData) {\n\t            req.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n\t            req.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");\n\t        }\n\t        if (callback) {\n\t            eve.once(\"snap.ajax.\" + id + \".0\", callback);\n\t            eve.once(\"snap.ajax.\" + id + \".200\", callback);\n\t            eve.once(\"snap.ajax.\" + id + \".304\", callback);\n\t        }\n\t        req.onreadystatechange = function() {\n\t            if (req.readyState != 4) return;\n\t            eve(\"snap.ajax.\" + id + \".\" + req.status, scope, req);\n\t        };\n\t        if (req.readyState == 4) {\n\t            return req;\n\t        }\n\t        req.send(postData);\n\t        return req;\n\t    }\n\t};\n\t/*\\\n\t * Snap.load\n\t [ method ]\n\t **\n\t * Loads external SVG file as a @Fragment (see @Snap.ajax for more advanced AJAX)\n\t **\n\t - url (string) URL\n\t - callback (function) callback\n\t - scope (object) #optional scope of callback\n\t\\*/\n\tSnap.load = function (url, callback, scope) {\n\t    Snap.ajax(url, function (req) {\n\t        var f = Snap.parse(req.responseText);\n\t        scope ? callback.call(scope, f) : callback(f);\n\t    });\n\t};\n\tvar getOffset = function (elem) {\n\t    var box = elem.getBoundingClientRect(),\n\t        doc = elem.ownerDocument,\n\t        body = doc.body,\n\t        docElem = doc.documentElement,\n\t        clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,\n\t        top  = box.top  + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop ) - clientTop,\n\t        left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;\n\t    return {\n\t        y: top,\n\t        x: left\n\t    };\n\t};\n\t/*\\\n\t * Snap.getElementByPoint\n\t [ method ]\n\t **\n\t * Returns you topmost element under given point.\n\t **\n\t = (object) Snap element object\n\t - x (number) x coordinate from the top left corner of the window\n\t - y (number) y coordinate from the top left corner of the window\n\t > Usage\n\t | Snap.getElementByPoint(mouseX, mouseY).attr({stroke: \"#f00\"});\n\t\\*/\n\tSnap.getElementByPoint = function (x, y) {\n\t    var paper = this,\n\t        svg = paper.canvas,\n\t        target = glob.doc.elementFromPoint(x, y);\n\t    if (glob.win.opera && target.tagName == \"svg\") {\n\t        var so = getOffset(target),\n\t            sr = target.createSVGRect();\n\t        sr.x = x - so.x;\n\t        sr.y = y - so.y;\n\t        sr.width = sr.height = 1;\n\t        var hits = target.getIntersectionList(sr, null);\n\t        if (hits.length) {\n\t            target = hits[hits.length - 1];\n\t        }\n\t    }\n\t    if (!target) {\n\t        return null;\n\t    }\n\t    return wrap(target);\n\t};\n\t/*\\\n\t * Snap.plugin\n\t [ method ]\n\t **\n\t * Let you write plugins. You pass in a function with five arguments, like this:\n\t | Snap.plugin(function (Snap, Element, Paper, global, Fragment) {\n\t |     Snap.newmethod = function () {};\n\t |     Element.prototype.newmethod = function () {};\n\t |     Paper.prototype.newmethod = function () {};\n\t | });\n\t * Inside the function you have access to all main objects (and their\n\t * prototypes). This allow you to extend anything you want.\n\t **\n\t - f (function) your plugin body\n\t\\*/\n\tSnap.plugin = function (f) {\n\t    f(Snap, Element, Paper, glob, Fragment);\n\t};\n\tglob.win.Snap = Snap;\n\treturn Snap;\n\t}(window || this));\n\t\n\t// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t//\n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t//\n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t//\n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n\t    var elproto = Element.prototype,\n\t        is = Snap.is,\n\t        Str = String,\n\t        unit2px = Snap._unit2px,\n\t        $ = Snap._.$,\n\t        make = Snap._.make,\n\t        getSomeDefs = Snap._.getSomeDefs,\n\t        has = \"hasOwnProperty\",\n\t        wrap = Snap._.wrap;\n\t    /*\\\n\t     * Element.getBBox\n\t     [ method ]\n\t     **\n\t     * Returns the bounding box descriptor for the given element\n\t     **\n\t     = (object) bounding box descriptor:\n\t     o {\n\t     o     cx: (number) x of the center,\n\t     o     cy: (number) x of the center,\n\t     o     h: (number) height,\n\t     o     height: (number) height,\n\t     o     path: (string) path command for the box,\n\t     o     r0: (number) radius of a circle that fully encloses the box,\n\t     o     r1: (number) radius of the smallest circle that can be enclosed,\n\t     o     r2: (number) radius of the largest circle that can be enclosed,\n\t     o     vb: (string) box as a viewbox command,\n\t     o     w: (number) width,\n\t     o     width: (number) width,\n\t     o     x2: (number) x of the right side,\n\t     o     x: (number) x of the left side,\n\t     o     y2: (number) y of the bottom edge,\n\t     o     y: (number) y of the top edge\n\t     o }\n\t    \\*/\n\t    elproto.getBBox = function (isWithoutTransform) {\n\t        if (!Snap.Matrix || !Snap.path) {\n\t            return this.node.getBBox();\n\t        }\n\t        var el = this,\n\t            m = new Snap.Matrix;\n\t        if (el.removed) {\n\t            return Snap._.box();\n\t        }\n\t        while (el.type == \"use\") {\n\t            if (!isWithoutTransform) {\n\t                m = m.add(el.transform().localMatrix.translate(el.attr(\"x\") || 0, el.attr(\"y\") || 0));\n\t            }\n\t            if (el.original) {\n\t                el = el.original;\n\t            } else {\n\t                var href = el.attr(\"xlink:href\");\n\t                el = el.original = el.node.ownerDocument.getElementById(href.substring(href.indexOf(\"#\") + 1));\n\t            }\n\t        }\n\t        var _ = el._,\n\t            pathfinder = Snap.path.get[el.type] || Snap.path.get.deflt;\n\t        try {\n\t            if (isWithoutTransform) {\n\t                _.bboxwt = pathfinder ? Snap.path.getBBox(el.realPath = pathfinder(el)) : Snap._.box(el.node.getBBox());\n\t                return Snap._.box(_.bboxwt);\n\t            } else {\n\t                el.realPath = pathfinder(el);\n\t                el.matrix = el.transform().localMatrix;\n\t                _.bbox = Snap.path.getBBox(Snap.path.map(el.realPath, m.add(el.matrix)));\n\t                return Snap._.box(_.bbox);\n\t            }\n\t        } catch (e) {\n\t            // Firefox doesn’t give you bbox of hidden element\n\t            return Snap._.box();\n\t        }\n\t    };\n\t    var propString = function () {\n\t        return this.string;\n\t    };\n\t    function extractTransform(el, tstr) {\n\t        if (tstr == null) {\n\t            var doReturn = true;\n\t            if (el.type == \"linearGradient\" || el.type == \"radialGradient\") {\n\t                tstr = el.node.getAttribute(\"gradientTransform\");\n\t            } else if (el.type == \"pattern\") {\n\t                tstr = el.node.getAttribute(\"patternTransform\");\n\t            } else {\n\t                tstr = el.node.getAttribute(\"transform\");\n\t            }\n\t            if (!tstr) {\n\t                return new Snap.Matrix;\n\t            }\n\t            tstr = Snap._.svgTransform2string(tstr);\n\t        } else {\n\t            if (!Snap._.rgTransform.test(tstr)) {\n\t                tstr = Snap._.svgTransform2string(tstr);\n\t            } else {\n\t                tstr = Str(tstr).replace(/\\.{3}|\\u2026/g, el._.transform || E);\n\t            }\n\t            if (is(tstr, \"array\")) {\n\t                tstr = Snap.path ? Snap.path.toString.call(tstr) : Str(tstr);\n\t            }\n\t            el._.transform = tstr;\n\t        }\n\t        var m = Snap._.transform2matrix(tstr, el.getBBox(1));\n\t        if (doReturn) {\n\t            return m;\n\t        } else {\n\t            el.matrix = m;\n\t        }\n\t    }\n\t    /*\\\n\t     * Element.transform\n\t     [ method ]\n\t     **\n\t     * Gets or sets transformation of the element\n\t     **\n\t     - tstr (string) transform string in Snap or SVG format\n\t     = (Element) the current element\n\t     * or\n\t     = (object) transformation descriptor:\n\t     o {\n\t     o     string (string) transform string,\n\t     o     globalMatrix (Matrix) matrix of all transformations applied to element or its parents,\n\t     o     localMatrix (Matrix) matrix of transformations applied only to the element,\n\t     o     diffMatrix (Matrix) matrix of difference between global and local transformations,\n\t     o     global (string) global transformation as string,\n\t     o     local (string) local transformation as string,\n\t     o     toString (function) returns `string` property\n\t     o }\n\t    \\*/\n\t    elproto.transform = function (tstr) {\n\t        var _ = this._;\n\t        if (tstr == null) {\n\t            var papa = this,\n\t                global = new Snap.Matrix(this.node.getCTM()),\n\t                local = extractTransform(this),\n\t                ms = [local],\n\t                m = new Snap.Matrix,\n\t                i,\n\t                localString = local.toTransformString(),\n\t                string = Str(local) == Str(this.matrix) ?\n\t                            Str(_.transform) : localString;\n\t            while (papa.type != \"svg\" && (papa = papa.parent())) {\n\t                ms.push(extractTransform(papa));\n\t            }\n\t            i = ms.length;\n\t            while (i--) {\n\t                m.add(ms[i]);\n\t            }\n\t            return {\n\t                string: string,\n\t                globalMatrix: global,\n\t                totalMatrix: m,\n\t                localMatrix: local,\n\t                diffMatrix: global.clone().add(local.invert()),\n\t                global: global.toTransformString(),\n\t                total: m.toTransformString(),\n\t                local: localString,\n\t                toString: propString\n\t            };\n\t        }\n\t        if (tstr instanceof Snap.Matrix) {\n\t            this.matrix = tstr;\n\t            this._.transform = tstr.toTransformString();\n\t        } else {\n\t            extractTransform(this, tstr);\n\t        }\n\t\n\t        if (this.node) {\n\t            if (this.type == \"linearGradient\" || this.type == \"radialGradient\") {\n\t                $(this.node, {gradientTransform: this.matrix});\n\t            } else if (this.type == \"pattern\") {\n\t                $(this.node, {patternTransform: this.matrix});\n\t            } else {\n\t                $(this.node, {transform: this.matrix});\n\t            }\n\t        }\n\t\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.parent\n\t     [ method ]\n\t     **\n\t     * Returns the element's parent\n\t     **\n\t     = (Element) the parent element\n\t    \\*/\n\t    elproto.parent = function () {\n\t        return wrap(this.node.parentNode);\n\t    };\n\t    /*\\\n\t     * Element.append\n\t     [ method ]\n\t     **\n\t     * Appends the given element to current one\n\t     **\n\t     - el (Element|Set) element to append\n\t     = (Element) the parent element\n\t    \\*/\n\t    /*\\\n\t     * Element.add\n\t     [ method ]\n\t     **\n\t     * See @Element.append\n\t    \\*/\n\t    elproto.append = elproto.add = function (el) {\n\t        if (el) {\n\t            if (el.type == \"set\") {\n\t                var it = this;\n\t                el.forEach(function (el) {\n\t                    it.add(el);\n\t                });\n\t                return this;\n\t            }\n\t            el = wrap(el);\n\t            this.node.appendChild(el.node);\n\t            el.paper = this.paper;\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.appendTo\n\t     [ method ]\n\t     **\n\t     * Appends the current element to the given one\n\t     **\n\t     - el (Element) parent element to append to\n\t     = (Element) the child element\n\t    \\*/\n\t    elproto.appendTo = function (el) {\n\t        if (el) {\n\t            el = wrap(el);\n\t            el.append(this);\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.prepend\n\t     [ method ]\n\t     **\n\t     * Prepends the given element to the current one\n\t     **\n\t     - el (Element) element to prepend\n\t     = (Element) the parent element\n\t    \\*/\n\t    elproto.prepend = function (el) {\n\t        if (el) {\n\t            if (el.type == \"set\") {\n\t                var it = this,\n\t                    first;\n\t                el.forEach(function (el) {\n\t                    if (first) {\n\t                        first.after(el);\n\t                    } else {\n\t                        it.prepend(el);\n\t                    }\n\t                    first = el;\n\t                });\n\t                return this;\n\t            }\n\t            el = wrap(el);\n\t            var parent = el.parent();\n\t            this.node.insertBefore(el.node, this.node.firstChild);\n\t            this.add && this.add();\n\t            el.paper = this.paper;\n\t            this.parent() && this.parent().add();\n\t            parent && parent.add();\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.prependTo\n\t     [ method ]\n\t     **\n\t     * Prepends the current element to the given one\n\t     **\n\t     - el (Element) parent element to prepend to\n\t     = (Element) the child element\n\t    \\*/\n\t    elproto.prependTo = function (el) {\n\t        el = wrap(el);\n\t        el.prepend(this);\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.before\n\t     [ method ]\n\t     **\n\t     * Inserts given element before the current one\n\t     **\n\t     - el (Element) element to insert\n\t     = (Element) the parent element\n\t    \\*/\n\t    elproto.before = function (el) {\n\t        if (el.type == \"set\") {\n\t            var it = this;\n\t            el.forEach(function (el) {\n\t                var parent = el.parent();\n\t                it.node.parentNode.insertBefore(el.node, it.node);\n\t                parent && parent.add();\n\t            });\n\t            this.parent().add();\n\t            return this;\n\t        }\n\t        el = wrap(el);\n\t        var parent = el.parent();\n\t        this.node.parentNode.insertBefore(el.node, this.node);\n\t        this.parent() && this.parent().add();\n\t        parent && parent.add();\n\t        el.paper = this.paper;\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.after\n\t     [ method ]\n\t     **\n\t     * Inserts given element after the current one\n\t     **\n\t     - el (Element) element to insert\n\t     = (Element) the parent element\n\t    \\*/\n\t    elproto.after = function (el) {\n\t        el = wrap(el);\n\t        var parent = el.parent();\n\t        if (this.node.nextSibling) {\n\t            this.node.parentNode.insertBefore(el.node, this.node.nextSibling);\n\t        } else {\n\t            this.node.parentNode.appendChild(el.node);\n\t        }\n\t        this.parent() && this.parent().add();\n\t        parent && parent.add();\n\t        el.paper = this.paper;\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.insertBefore\n\t     [ method ]\n\t     **\n\t     * Inserts the element after the given one\n\t     **\n\t     - el (Element) element next to whom insert to\n\t     = (Element) the parent element\n\t    \\*/\n\t    elproto.insertBefore = function (el) {\n\t        el = wrap(el);\n\t        var parent = this.parent();\n\t        el.node.parentNode.insertBefore(this.node, el.node);\n\t        this.paper = el.paper;\n\t        parent && parent.add();\n\t        el.parent() && el.parent().add();\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.insertAfter\n\t     [ method ]\n\t     **\n\t     * Inserts the element after the given one\n\t     **\n\t     - el (Element) element next to whom insert to\n\t     = (Element) the parent element\n\t    \\*/\n\t    elproto.insertAfter = function (el) {\n\t        el = wrap(el);\n\t        var parent = this.parent();\n\t        el.node.parentNode.insertBefore(this.node, el.node.nextSibling);\n\t        this.paper = el.paper;\n\t        parent && parent.add();\n\t        el.parent() && el.parent().add();\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.remove\n\t     [ method ]\n\t     **\n\t     * Removes element from the DOM\n\t     = (Element) the detached element\n\t    \\*/\n\t    elproto.remove = function () {\n\t        var parent = this.parent();\n\t        this.node.parentNode && this.node.parentNode.removeChild(this.node);\n\t        delete this.paper;\n\t        this.removed = true;\n\t        parent && parent.add();\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.select\n\t     [ method ]\n\t     **\n\t     * Gathers the nested @Element matching the given set of CSS selectors\n\t     **\n\t     - query (string) CSS selector\n\t     = (Element) result of query selection\n\t    \\*/\n\t    elproto.select = function (query) {\n\t        query = Str(query).replace(/([^\\\\]):/g, \"$1\\\\:\");\n\t        return wrap(this.node.querySelector(query));\n\t    };\n\t    /*\\\n\t     * Element.selectAll\n\t     [ method ]\n\t     **\n\t     * Gathers nested @Element objects matching the given set of CSS selectors\n\t     **\n\t     - query (string) CSS selector\n\t     = (Set|array) result of query selection\n\t    \\*/\n\t    elproto.selectAll = function (query) {\n\t        var nodelist = this.node.querySelectorAll(query),\n\t            set = (Snap.set || Array)();\n\t        for (var i = 0; i < nodelist.length; i++) {\n\t            set.push(wrap(nodelist[i]));\n\t        }\n\t        return set;\n\t    };\n\t    /*\\\n\t     * Element.asPX\n\t     [ method ]\n\t     **\n\t     * Returns given attribute of the element as a `px` value (not %, em, etc.)\n\t     **\n\t     - attr (string) attribute name\n\t     - value (string) #optional attribute value\n\t     = (Element) result of query selection\n\t    \\*/\n\t    elproto.asPX = function (attr, value) {\n\t        if (value == null) {\n\t            value = this.attr(attr);\n\t        }\n\t        return +unit2px(this, attr, value);\n\t    };\n\t    // SIERRA Element.use(): I suggest adding a note about how to access the original element the returned <use> instantiates. It's a part of SVG with which ordinary web developers may be least familiar.\n\t    /*\\\n\t     * Element.use\n\t     [ method ]\n\t     **\n\t     * Creates a `<use>` element linked to the current element\n\t     **\n\t     = (Element) the `<use>` element\n\t    \\*/\n\t    elproto.use = function () {\n\t        var use,\n\t            id = this.node.id;\n\t        if (!id) {\n\t            id = this.id;\n\t            $(this.node, {\n\t                id: id\n\t            });\n\t        }\n\t        if (this.type == \"linearGradient\" || this.type == \"radialGradient\" ||\n\t            this.type == \"pattern\") {\n\t            use = make(this.type, this.node.parentNode);\n\t        } else {\n\t            use = make(\"use\", this.node.parentNode);\n\t        }\n\t        $(use.node, {\n\t            \"xlink:href\": \"#\" + id\n\t        });\n\t        use.original = this;\n\t        return use;\n\t    };\n\t    function fixids(el) {\n\t        var els = el.selectAll(\"*\"),\n\t            it,\n\t            url = /^\\s*url\\((\"|'|)(.*)\\1\\)\\s*$/,\n\t            ids = [],\n\t            uses = {};\n\t        function urltest(it, name) {\n\t            var val = $(it.node, name);\n\t            val = val && val.match(url);\n\t            val = val && val[2];\n\t            if (val && val.charAt() == \"#\") {\n\t                val = val.substring(1);\n\t            } else {\n\t                return;\n\t            }\n\t            if (val) {\n\t                uses[val] = (uses[val] || []).concat(function (id) {\n\t                    var attr = {};\n\t                    attr[name] = URL(id);\n\t                    $(it.node, attr);\n\t                });\n\t            }\n\t        }\n\t        function linktest(it) {\n\t            var val = $(it.node, \"xlink:href\");\n\t            if (val && val.charAt() == \"#\") {\n\t                val = val.substring(1);\n\t            } else {\n\t                return;\n\t            }\n\t            if (val) {\n\t                uses[val] = (uses[val] || []).concat(function (id) {\n\t                    it.attr(\"xlink:href\", \"#\" + id);\n\t                });\n\t            }\n\t        }\n\t        for (var i = 0, ii = els.length; i < ii; i++) {\n\t            it = els[i];\n\t            urltest(it, \"fill\");\n\t            urltest(it, \"stroke\");\n\t            urltest(it, \"filter\");\n\t            urltest(it, \"mask\");\n\t            urltest(it, \"clip-path\");\n\t            linktest(it);\n\t            var oldid = $(it.node, \"id\");\n\t            if (oldid) {\n\t                $(it.node, {id: it.id});\n\t                ids.push({\n\t                    old: oldid,\n\t                    id: it.id\n\t                });\n\t            }\n\t        }\n\t        for (i = 0, ii = ids.length; i < ii; i++) {\n\t            var fs = uses[ids[i].old];\n\t            if (fs) {\n\t                for (var j = 0, jj = fs.length; j < jj; j++) {\n\t                    fs[j](ids[i].id);\n\t                }\n\t            }\n\t        }\n\t    }\n\t    /*\\\n\t     * Element.clone\n\t     [ method ]\n\t     **\n\t     * Creates a clone of the element and inserts it after the element\n\t     **\n\t     = (Element) the clone\n\t    \\*/\n\t    elproto.clone = function () {\n\t        var clone = wrap(this.node.cloneNode(true));\n\t        if ($(clone.node, \"id\")) {\n\t            $(clone.node, {id: clone.id});\n\t        }\n\t        fixids(clone);\n\t        clone.insertAfter(this);\n\t        return clone;\n\t    };\n\t    /*\\\n\t     * Element.toDefs\n\t     [ method ]\n\t     **\n\t     * Moves element to the shared `<defs>` area\n\t     **\n\t     = (Element) the element\n\t    \\*/\n\t    elproto.toDefs = function () {\n\t        var defs = getSomeDefs(this);\n\t        defs.appendChild(this.node);\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.toPattern\n\t     [ method ]\n\t     **\n\t     * Creates a `<pattern>` element from the current element\n\t     **\n\t     * To create a pattern you have to specify the pattern rect:\n\t     - x (string|number)\n\t     - y (string|number)\n\t     - width (string|number)\n\t     - height (string|number)\n\t     = (Element) the `<pattern>` element\n\t     * You can use pattern later on as an argument for `fill` attribute:\n\t     | var p = paper.path(\"M10-5-10,15M15,0,0,15M0-5-20,15\").attr({\n\t     |         fill: \"none\",\n\t     |         stroke: \"#bada55\",\n\t     |         strokeWidth: 5\n\t     |     }).pattern(0, 0, 10, 10),\n\t     |     c = paper.circle(200, 200, 100);\n\t     | c.attr({\n\t     |     fill: p\n\t     | });\n\t    \\*/\n\t    elproto.pattern = elproto.toPattern = function (x, y, width, height) {\n\t        var p = make(\"pattern\", getSomeDefs(this));\n\t        if (x == null) {\n\t            x = this.getBBox();\n\t        }\n\t        if (is(x, \"object\") && \"x\" in x) {\n\t            y = x.y;\n\t            width = x.width;\n\t            height = x.height;\n\t            x = x.x;\n\t        }\n\t        $(p.node, {\n\t            x: x,\n\t            y: y,\n\t            width: width,\n\t            height: height,\n\t            patternUnits: \"userSpaceOnUse\",\n\t            id: p.id,\n\t            viewBox: [x, y, width, height].join(\" \")\n\t        });\n\t        p.node.appendChild(this.node);\n\t        return p;\n\t    };\n\t// SIERRA Element.marker(): clarify what a reference point is. E.g., helps you offset the object from its edge such as when centering it over a path.\n\t// SIERRA Element.marker(): I suggest the method should accept default reference point values.  Perhaps centered with (refX = width/2) and (refY = height/2)? Also, couldn't it assume the element's current _width_ and _height_? And please specify what _x_ and _y_ mean: offsets? If so, from where?  Couldn't they also be assigned default values?\n\t    /*\\\n\t     * Element.marker\n\t     [ method ]\n\t     **\n\t     * Creates a `<marker>` element from the current element\n\t     **\n\t     * To create a marker you have to specify the bounding rect and reference point:\n\t     - x (number)\n\t     - y (number)\n\t     - width (number)\n\t     - height (number)\n\t     - refX (number)\n\t     - refY (number)\n\t     = (Element) the `<marker>` element\n\t     * You can specify the marker later as an argument for `marker-start`, `marker-end`, `marker-mid`, and `marker` attributes. The `marker` attribute places the marker at every point along the path, and `marker-mid` places them at every point except the start and end.\n\t    \\*/\n\t    // TODO add usage for markers\n\t    elproto.marker = function (x, y, width, height, refX, refY) {\n\t        var p = make(\"marker\", getSomeDefs(this));\n\t        if (x == null) {\n\t            x = this.getBBox();\n\t        }\n\t        if (is(x, \"object\") && \"x\" in x) {\n\t            y = x.y;\n\t            width = x.width;\n\t            height = x.height;\n\t            refX = x.refX || x.cx;\n\t            refY = x.refY || x.cy;\n\t            x = x.x;\n\t        }\n\t        $(p.node, {\n\t            viewBox: [x, y, width, height].join(\" \"),\n\t            markerWidth: width,\n\t            markerHeight: height,\n\t            orient: \"auto\",\n\t            refX: refX || 0,\n\t            refY: refY || 0,\n\t            id: p.id\n\t        });\n\t        p.node.appendChild(this.node);\n\t        return p;\n\t    };\n\t    // animation\n\t    function slice(from, to, f) {\n\t        return function (arr) {\n\t            var res = arr.slice(from, to);\n\t            if (res.length == 1) {\n\t                res = res[0];\n\t            }\n\t            return f ? f(res) : res;\n\t        };\n\t    }\n\t    var Animation = function (attr, ms, easing, callback) {\n\t        if (typeof easing == \"function\" && !easing.length) {\n\t            callback = easing;\n\t            easing = mina.linear;\n\t        }\n\t        this.attr = attr;\n\t        this.dur = ms;\n\t        easing && (this.easing = easing);\n\t        callback && (this.callback = callback);\n\t    };\n\t    Snap._.Animation = Animation;\n\t    /*\\\n\t     * Snap.animation\n\t     [ method ]\n\t     **\n\t     * Creates an animation object\n\t     **\n\t     - attr (object) attributes of final destination\n\t     - duration (number) duration of the animation, in milliseconds\n\t     - easing (function) #optional one of easing functions of @mina or custom one\n\t     - callback (function) #optional callback function that fires when animation ends\n\t     = (object) animation object\n\t    \\*/\n\t    Snap.animation = function (attr, ms, easing, callback) {\n\t        return new Animation(attr, ms, easing, callback);\n\t    };\n\t    /*\\\n\t     * Element.inAnim\n\t     [ method ]\n\t     **\n\t     * Returns a set of animations that may be able to manipulate the current element\n\t     **\n\t     = (object) in format:\n\t     o {\n\t     o     anim (object) animation object,\n\t     o     mina (object) @mina object,\n\t     o     curStatus (number) 0..1 — status of the animation: 0 — just started, 1 — just finished,\n\t     o     status (function) gets or sets the status of the animation,\n\t     o     stop (function) stops the animation\n\t     o }\n\t    \\*/\n\t    elproto.inAnim = function () {\n\t        var el = this,\n\t            res = [];\n\t        for (var id in el.anims) if (el.anims[has](id)) {\n\t            (function (a) {\n\t                res.push({\n\t                    anim: new Animation(a._attrs, a.dur, a.easing, a._callback),\n\t                    mina: a,\n\t                    curStatus: a.status(),\n\t                    status: function (val) {\n\t                        return a.status(val);\n\t                    },\n\t                    stop: function () {\n\t                        a.stop();\n\t                    }\n\t                });\n\t            }(el.anims[id]));\n\t        }\n\t        return res;\n\t    };\n\t    /*\\\n\t     * Snap.animate\n\t     [ method ]\n\t     **\n\t     * Runs generic animation of one number into another with a caring function\n\t     **\n\t     - from (number|array) number or array of numbers\n\t     - to (number|array) number or array of numbers\n\t     - setter (function) caring function that accepts one number argument\n\t     - duration (number) duration, in milliseconds\n\t     - easing (function) #optional easing function from @mina or custom\n\t     - callback (function) #optional callback function to execute when animation ends\n\t     = (object) animation object in @mina format\n\t     o {\n\t     o     id (string) animation id, consider it read-only,\n\t     o     duration (function) gets or sets the duration of the animation,\n\t     o     easing (function) easing,\n\t     o     speed (function) gets or sets the speed of the animation,\n\t     o     status (function) gets or sets the status of the animation,\n\t     o     stop (function) stops the animation\n\t     o }\n\t     | var rect = Snap().rect(0, 0, 10, 10);\n\t     | Snap.animate(0, 10, function (val) {\n\t     |     rect.attr({\n\t     |         x: val\n\t     |     });\n\t     | }, 1000);\n\t     | // in given context is equivalent to\n\t     | rect.animate({x: 10}, 1000);\n\t    \\*/\n\t    Snap.animate = function (from, to, setter, ms, easing, callback) {\n\t        if (typeof easing == \"function\" && !easing.length) {\n\t            callback = easing;\n\t            easing = mina.linear;\n\t        }\n\t        var now = mina.time(),\n\t            anim = mina(from, to, now, now + ms, mina.time, setter, easing);\n\t        callback && eve.once(\"mina.finish.\" + anim.id, callback);\n\t        return anim;\n\t    };\n\t    /*\\\n\t     * Element.stop\n\t     [ method ]\n\t     **\n\t     * Stops all the animations for the current element\n\t     **\n\t     = (Element) the current element\n\t    \\*/\n\t    elproto.stop = function () {\n\t        var anims = this.inAnim();\n\t        for (var i = 0, ii = anims.length; i < ii; i++) {\n\t            anims[i].stop();\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.animate\n\t     [ method ]\n\t     **\n\t     * Animates the given attributes of the element\n\t     **\n\t     - attrs (object) key-value pairs of destination attributes\n\t     - duration (number) duration of the animation in milliseconds\n\t     - easing (function) #optional easing function from @mina or custom\n\t     - callback (function) #optional callback function that executes when the animation ends\n\t     = (Element) the current element\n\t    \\*/\n\t    elproto.animate = function (attrs, ms, easing, callback) {\n\t        if (typeof easing == \"function\" && !easing.length) {\n\t            callback = easing;\n\t            easing = mina.linear;\n\t        }\n\t        if (attrs instanceof Animation) {\n\t            callback = attrs.callback;\n\t            easing = attrs.easing;\n\t            ms = easing.dur;\n\t            attrs = attrs.attr;\n\t        }\n\t        var fkeys = [], tkeys = [], keys = {}, from, to, f, eq,\n\t            el = this;\n\t        for (var key in attrs) if (attrs[has](key)) {\n\t            if (el.equal) {\n\t                eq = el.equal(key, Str(attrs[key]));\n\t                from = eq.from;\n\t                to = eq.to;\n\t                f = eq.f;\n\t            } else {\n\t                from = +el.attr(key);\n\t                to = +attrs[key];\n\t            }\n\t            var len = is(from, \"array\") ? from.length : 1;\n\t            keys[key] = slice(fkeys.length, fkeys.length + len, f);\n\t            fkeys = fkeys.concat(from);\n\t            tkeys = tkeys.concat(to);\n\t        }\n\t        var now = mina.time(),\n\t            anim = mina(fkeys, tkeys, now, now + ms, mina.time, function (val) {\n\t                var attr = {};\n\t                for (var key in keys) if (keys[has](key)) {\n\t                    attr[key] = keys[key](val);\n\t                }\n\t                el.attr(attr);\n\t            }, easing);\n\t        el.anims[anim.id] = anim;\n\t        anim._attrs = attrs;\n\t        anim._callback = callback;\n\t        eve(\"snap.animcreated.\" + el.id, anim);\n\t        eve.once(\"mina.finish.\" + anim.id, function () {\n\t            delete el.anims[anim.id];\n\t            callback && callback.call(el);\n\t        });\n\t        eve.once(\"mina.stop.\" + anim.id, function () {\n\t            delete el.anims[anim.id];\n\t        });\n\t        return el;\n\t    };\n\t    var eldata = {};\n\t    /*\\\n\t     * Element.data\n\t     [ method ]\n\t     **\n\t     * Adds or retrieves given value associated with given key. (Don’t confuse\n\t     * with `data-` attributes)\n\t     *\n\t     * See also @Element.removeData\n\t     - key (string) key to store data\n\t     - value (any) #optional value to store\n\t     = (object) @Element\n\t     * or, if value is not specified:\n\t     = (any) value\n\t     > Usage\n\t     | for (var i = 0, i < 5, i++) {\n\t     |     paper.circle(10 + 15 * i, 10, 10)\n\t     |          .attr({fill: \"#000\"})\n\t     |          .data(\"i\", i)\n\t     |          .click(function () {\n\t     |             alert(this.data(\"i\"));\n\t     |          });\n\t     | }\n\t    \\*/\n\t    elproto.data = function (key, value) {\n\t        var data = eldata[this.id] = eldata[this.id] || {};\n\t        if (arguments.length == 0){\n\t            eve(\"snap.data.get.\" + this.id, this, data, null);\n\t            return data;\n\t        }\n\t        if (arguments.length == 1) {\n\t            if (Snap.is(key, \"object\")) {\n\t                for (var i in key) if (key[has](i)) {\n\t                    this.data(i, key[i]);\n\t                }\n\t                return this;\n\t            }\n\t            eve(\"snap.data.get.\" + this.id, this, data[key], key);\n\t            return data[key];\n\t        }\n\t        data[key] = value;\n\t        eve(\"snap.data.set.\" + this.id, this, value, key);\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.removeData\n\t     [ method ]\n\t     **\n\t     * Removes value associated with an element by given key.\n\t     * If key is not provided, removes all the data of the element.\n\t     - key (string) #optional key\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.removeData = function (key) {\n\t        if (key == null) {\n\t            eldata[this.id] = {};\n\t        } else {\n\t            eldata[this.id] && delete eldata[this.id][key];\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.outerSVG\n\t     [ method ]\n\t     **\n\t     * Returns SVG code for the element, equivalent to HTML's `outerHTML`.\n\t     *\n\t     * See also @Element.innerSVG\n\t     = (string) SVG code for the element\n\t    \\*/\n\t    /*\\\n\t     * Element.toString\n\t     [ method ]\n\t     **\n\t     * See @Element.outerSVG\n\t    \\*/\n\t    elproto.outerSVG = elproto.toString = toString(1);\n\t    /*\\\n\t     * Element.innerSVG\n\t     [ method ]\n\t     **\n\t     * Returns SVG code for the element's contents, equivalent to HTML's `innerHTML`\n\t     = (string) SVG code for the element\n\t    \\*/\n\t    elproto.innerSVG = toString();\n\t    function toString(type) {\n\t        return function () {\n\t            var res = type ? \"<\" + this.type : \"\",\n\t                attr = this.node.attributes,\n\t                chld = this.node.childNodes;\n\t            if (type) {\n\t                for (var i = 0, ii = attr.length; i < ii; i++) {\n\t                    res += \" \" + attr[i].name + '=\"' +\n\t                            attr[i].value.replace(/\"/g, '\\\\\"') + '\"';\n\t                }\n\t            }\n\t            if (chld.length) {\n\t                type && (res += \">\");\n\t                for (i = 0, ii = chld.length; i < ii; i++) {\n\t                    if (chld[i].nodeType == 3) {\n\t                        res += chld[i].nodeValue;\n\t                    } else if (chld[i].nodeType == 1) {\n\t                        res += wrap(chld[i]).toString();\n\t                    }\n\t                }\n\t                type && (res += \"</\" + this.type + \">\");\n\t            } else {\n\t                type && (res += \"/>\");\n\t            }\n\t            return res;\n\t        };\n\t    }\n\t    elproto.toDataURL = function () {\n\t        if (window && window.btoa) {\n\t            var bb = this.getBBox(),\n\t                svg = Snap.format('<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"{width}\" height=\"{height}\" viewBox=\"{x} {y} {width} {height}\">{contents}</svg>', {\n\t                x: +bb.x.toFixed(3),\n\t                y: +bb.y.toFixed(3),\n\t                width: +bb.width.toFixed(3),\n\t                height: +bb.height.toFixed(3),\n\t                contents: this.outerSVG()\n\t            });\n\t            return \"data:image/svg+xml;base64,\" + btoa(unescape(encodeURIComponent(svg)));\n\t        }\n\t    };\n\t    /*\\\n\t     * Fragment.select\n\t     [ method ]\n\t     **\n\t     * See @Element.select\n\t    \\*/\n\t    Fragment.prototype.select = elproto.select;\n\t    /*\\\n\t     * Fragment.selectAll\n\t     [ method ]\n\t     **\n\t     * See @Element.selectAll\n\t    \\*/\n\t    Fragment.prototype.selectAll = elproto.selectAll;\n\t});\n\t\n\t// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t// \n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t// \n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t// \n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n\t    var objectToString = Object.prototype.toString,\n\t        Str = String,\n\t        math = Math,\n\t        E = \"\";\n\t    function Matrix(a, b, c, d, e, f) {\n\t        if (b == null && objectToString.call(a) == \"[object SVGMatrix]\") {\n\t            this.a = a.a;\n\t            this.b = a.b;\n\t            this.c = a.c;\n\t            this.d = a.d;\n\t            this.e = a.e;\n\t            this.f = a.f;\n\t            return;\n\t        }\n\t        if (a != null) {\n\t            this.a = +a;\n\t            this.b = +b;\n\t            this.c = +c;\n\t            this.d = +d;\n\t            this.e = +e;\n\t            this.f = +f;\n\t        } else {\n\t            this.a = 1;\n\t            this.b = 0;\n\t            this.c = 0;\n\t            this.d = 1;\n\t            this.e = 0;\n\t            this.f = 0;\n\t        }\n\t    }\n\t    (function (matrixproto) {\n\t        /*\\\n\t         * Matrix.add\n\t         [ method ]\n\t         **\n\t         * Adds the given matrix to existing one\n\t         - a (number)\n\t         - b (number)\n\t         - c (number)\n\t         - d (number)\n\t         - e (number)\n\t         - f (number)\n\t         * or\n\t         - matrix (object) @Matrix\n\t        \\*/\n\t        matrixproto.add = function (a, b, c, d, e, f) {\n\t            var out = [[], [], []],\n\t                m = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]],\n\t                matrix = [[a, c, e], [b, d, f], [0, 0, 1]],\n\t                x, y, z, res;\n\t\n\t            if (a && a instanceof Matrix) {\n\t                matrix = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]];\n\t            }\n\t\n\t            for (x = 0; x < 3; x++) {\n\t                for (y = 0; y < 3; y++) {\n\t                    res = 0;\n\t                    for (z = 0; z < 3; z++) {\n\t                        res += m[x][z] * matrix[z][y];\n\t                    }\n\t                    out[x][y] = res;\n\t                }\n\t            }\n\t            this.a = out[0][0];\n\t            this.b = out[1][0];\n\t            this.c = out[0][1];\n\t            this.d = out[1][1];\n\t            this.e = out[0][2];\n\t            this.f = out[1][2];\n\t            return this;\n\t        };\n\t        /*\\\n\t         * Matrix.invert\n\t         [ method ]\n\t         **\n\t         * Returns an inverted version of the matrix\n\t         = (object) @Matrix\n\t        \\*/\n\t        matrixproto.invert = function () {\n\t            var me = this,\n\t                x = me.a * me.d - me.b * me.c;\n\t            return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);\n\t        };\n\t        /*\\\n\t         * Matrix.clone\n\t         [ method ]\n\t         **\n\t         * Returns a copy of the matrix\n\t         = (object) @Matrix\n\t        \\*/\n\t        matrixproto.clone = function () {\n\t            return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);\n\t        };\n\t        /*\\\n\t         * Matrix.translate\n\t         [ method ]\n\t         **\n\t         * Translate the matrix\n\t         - x (number) horizontal offset distance\n\t         - y (number) vertical offset distance\n\t        \\*/\n\t        matrixproto.translate = function (x, y) {\n\t            return this.add(1, 0, 0, 1, x, y);\n\t        };\n\t        /*\\\n\t         * Matrix.scale\n\t         [ method ]\n\t         **\n\t         * Scales the matrix\n\t         - x (number) amount to be scaled, with `1` resulting in no change\n\t         - y (number) #optional amount to scale along the vertical axis. (Otherwise `x` applies to both axes.)\n\t         - cx (number) #optional horizontal origin point from which to scale\n\t         - cy (number) #optional vertical origin point from which to scale\n\t         * Default cx, cy is the middle point of the element.\n\t        \\*/\n\t        matrixproto.scale = function (x, y, cx, cy) {\n\t            y == null && (y = x);\n\t            (cx || cy) && this.add(1, 0, 0, 1, cx, cy);\n\t            this.add(x, 0, 0, y, 0, 0);\n\t            (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);\n\t            return this;\n\t        };\n\t        /*\\\n\t         * Matrix.rotate\n\t         [ method ]\n\t         **\n\t         * Rotates the matrix\n\t         - a (number) angle of rotation, in degrees\n\t         - x (number) horizontal origin point from which to rotate\n\t         - y (number) vertical origin point from which to rotate\n\t        \\*/\n\t        matrixproto.rotate = function (a, x, y) {\n\t            a = Snap.rad(a);\n\t            x = x || 0;\n\t            y = y || 0;\n\t            var cos = +math.cos(a).toFixed(9),\n\t                sin = +math.sin(a).toFixed(9);\n\t            this.add(cos, sin, -sin, cos, x, y);\n\t            return this.add(1, 0, 0, 1, -x, -y);\n\t        };\n\t        /*\\\n\t         * Matrix.x\n\t         [ method ]\n\t         **\n\t         * Returns x coordinate for given point after transformation described by the matrix. See also @Matrix.y\n\t         - x (number)\n\t         - y (number)\n\t         = (number) x\n\t        \\*/\n\t        matrixproto.x = function (x, y) {\n\t            return x * this.a + y * this.c + this.e;\n\t        };\n\t        /*\\\n\t         * Matrix.y\n\t         [ method ]\n\t         **\n\t         * Returns y coordinate for given point after transformation described by the matrix. See also @Matrix.x\n\t         - x (number)\n\t         - y (number)\n\t         = (number) y\n\t        \\*/\n\t        matrixproto.y = function (x, y) {\n\t            return x * this.b + y * this.d + this.f;\n\t        };\n\t        matrixproto.get = function (i) {\n\t            return +this[Str.fromCharCode(97 + i)].toFixed(4);\n\t        };\n\t        matrixproto.toString = function () {\n\t            return \"matrix(\" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + \")\";\n\t        };\n\t        matrixproto.offset = function () {\n\t            return [this.e.toFixed(4), this.f.toFixed(4)];\n\t        };\n\t        function norm(a) {\n\t            return a[0] * a[0] + a[1] * a[1];\n\t        }\n\t        function normalize(a) {\n\t            var mag = math.sqrt(norm(a));\n\t            a[0] && (a[0] /= mag);\n\t            a[1] && (a[1] /= mag);\n\t        }\n\t        /*\\\n\t         * Matrix.determinant\n\t         [ method ]\n\t         **\n\t         * Finds determinant of the given matrix.\n\t         = (number) determinant\n\t        \\*/\n\t        matrixproto.determinant = function () {\n\t            return this.a * this.d - this.b * this.c;\n\t        };\n\t        /*\\\n\t         * Matrix.split\n\t         [ method ]\n\t         **\n\t         * Splits matrix into primitive transformations\n\t         = (object) in format:\n\t         o dx (number) translation by x\n\t         o dy (number) translation by y\n\t         o scalex (number) scale by x\n\t         o scaley (number) scale by y\n\t         o shear (number) shear\n\t         o rotate (number) rotation in deg\n\t         o isSimple (boolean) could it be represented via simple transformations\n\t        \\*/\n\t        matrixproto.split = function () {\n\t            var out = {};\n\t            // translation\n\t            out.dx = this.e;\n\t            out.dy = this.f;\n\t\n\t            // scale and shear\n\t            var row = [[this.a, this.c], [this.b, this.d]];\n\t            out.scalex = math.sqrt(norm(row[0]));\n\t            normalize(row[0]);\n\t\n\t            out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];\n\t            row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];\n\t\n\t            out.scaley = math.sqrt(norm(row[1]));\n\t            normalize(row[1]);\n\t            out.shear /= out.scaley;\n\t\n\t            if (this.determinant() < 0) {\n\t                out.scalex = -out.scalex;\n\t            }\n\t\n\t            // rotation\n\t            var sin = -row[0][1],\n\t                cos = row[1][1];\n\t            if (cos < 0) {\n\t                out.rotate = Snap.deg(math.acos(cos));\n\t                if (sin < 0) {\n\t                    out.rotate = 360 - out.rotate;\n\t                }\n\t            } else {\n\t                out.rotate = Snap.deg(math.asin(sin));\n\t            }\n\t\n\t            out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);\n\t            out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;\n\t            out.noRotation = !+out.shear.toFixed(9) && !out.rotate;\n\t            return out;\n\t        };\n\t        /*\\\n\t         * Matrix.toTransformString\n\t         [ method ]\n\t         **\n\t         * Returns transform string that represents given matrix\n\t         = (string) transform string\n\t        \\*/\n\t        matrixproto.toTransformString = function (shorter) {\n\t            var s = shorter || this.split();\n\t            if (!+s.shear.toFixed(9)) {\n\t                s.scalex = +s.scalex.toFixed(4);\n\t                s.scaley = +s.scaley.toFixed(4);\n\t                s.rotate = +s.rotate.toFixed(4);\n\t                return  (s.dx || s.dy ? \"t\" + [+s.dx.toFixed(4), +s.dy.toFixed(4)] : E) + \n\t                        (s.scalex != 1 || s.scaley != 1 ? \"s\" + [s.scalex, s.scaley, 0, 0] : E) +\n\t                        (s.rotate ? \"r\" + [+s.rotate.toFixed(4), 0, 0] : E);\n\t            } else {\n\t                return \"m\" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];\n\t            }\n\t        };\n\t    })(Matrix.prototype);\n\t    /*\\\n\t     * Snap.Matrix\n\t     [ method ]\n\t     **\n\t     * Matrix constructor, extend on your own risk.\n\t     * To create matrices use @Snap.matrix.\n\t    \\*/\n\t    Snap.Matrix = Matrix;\n\t    /*\\\n\t     * Snap.matrix\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Returns a matrix based on the given parameters\n\t     - a (number)\n\t     - b (number)\n\t     - c (number)\n\t     - d (number)\n\t     - e (number)\n\t     - f (number)\n\t     * or\n\t     - svgMatrix (SVGMatrix)\n\t     = (object) @Matrix\n\t    \\*/\n\t    Snap.matrix = function (a, b, c, d, e, f) {\n\t        return new Matrix(a, b, c, d, e, f);\n\t    };\n\t});\n\t// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t// \n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t// \n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t// \n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n\t    var has = \"hasOwnProperty\",\n\t        make = Snap._.make,\n\t        wrap = Snap._.wrap,\n\t        is = Snap.is,\n\t        getSomeDefs = Snap._.getSomeDefs,\n\t        reURLValue = /^url\\(#?([^)]+)\\)$/,\n\t        $ = Snap._.$,\n\t        URL = Snap.url,\n\t        Str = String,\n\t        separator = Snap._.separator,\n\t        E = \"\";\n\t    // Attributes event handlers\n\t    eve.on(\"snap.util.attr.mask\", function (value) {\n\t        if (value instanceof Element || value instanceof Fragment) {\n\t            eve.stop();\n\t            if (value instanceof Fragment && value.node.childNodes.length == 1) {\n\t                value = value.node.firstChild;\n\t                getSomeDefs(this).appendChild(value);\n\t                value = wrap(value);\n\t            }\n\t            if (value.type == \"mask\") {\n\t                var mask = value;\n\t            } else {\n\t                mask = make(\"mask\", getSomeDefs(this));\n\t                mask.node.appendChild(value.node);\n\t            }\n\t            !mask.node.id && $(mask.node, {\n\t                id: mask.id\n\t            });\n\t            $(this.node, {\n\t                mask: URL(mask.id)\n\t            });\n\t        }\n\t    });\n\t    (function (clipIt) {\n\t        eve.on(\"snap.util.attr.clip\", clipIt);\n\t        eve.on(\"snap.util.attr.clip-path\", clipIt);\n\t        eve.on(\"snap.util.attr.clipPath\", clipIt);\n\t    }(function (value) {\n\t        if (value instanceof Element || value instanceof Fragment) {\n\t            eve.stop();\n\t            if (value.type == \"clipPath\") {\n\t                var clip = value;\n\t            } else {\n\t                clip = make(\"clipPath\", getSomeDefs(this));\n\t                clip.node.appendChild(value.node);\n\t                !clip.node.id && $(clip.node, {\n\t                    id: clip.id\n\t                });\n\t            }\n\t            $(this.node, {\n\t                \"clip-path\": URL(clip.node.id || clip.id)\n\t            });\n\t        }\n\t    }));\n\t    function fillStroke(name) {\n\t        return function (value) {\n\t            eve.stop();\n\t            if (value instanceof Fragment && value.node.childNodes.length == 1 &&\n\t                (value.node.firstChild.tagName == \"radialGradient\" ||\n\t                value.node.firstChild.tagName == \"linearGradient\" ||\n\t                value.node.firstChild.tagName == \"pattern\")) {\n\t                value = value.node.firstChild;\n\t                getSomeDefs(this).appendChild(value);\n\t                value = wrap(value);\n\t            }\n\t            if (value instanceof Element) {\n\t                if (value.type == \"radialGradient\" || value.type == \"linearGradient\"\n\t                   || value.type == \"pattern\") {\n\t                    if (!value.node.id) {\n\t                        $(value.node, {\n\t                            id: value.id\n\t                        });\n\t                    }\n\t                    var fill = URL(value.node.id);\n\t                } else {\n\t                    fill = value.attr(name);\n\t                }\n\t            } else {\n\t                fill = Snap.color(value);\n\t                if (fill.error) {\n\t                    var grad = Snap(getSomeDefs(this).ownerSVGElement).gradient(value);\n\t                    if (grad) {\n\t                        if (!grad.node.id) {\n\t                            $(grad.node, {\n\t                                id: grad.id\n\t                            });\n\t                        }\n\t                        fill = URL(grad.node.id);\n\t                    } else {\n\t                        fill = value;\n\t                    }\n\t                } else {\n\t                    fill = Str(fill);\n\t                }\n\t            }\n\t            var attrs = {};\n\t            attrs[name] = fill;\n\t            $(this.node, attrs);\n\t            this.node.style[name] = E;\n\t        };\n\t    }\n\t    eve.on(\"snap.util.attr.fill\", fillStroke(\"fill\"));\n\t    eve.on(\"snap.util.attr.stroke\", fillStroke(\"stroke\"));\n\t    var gradrg = /^([lr])(?:\\(([^)]*)\\))?(.*)$/i;\n\t    eve.on(\"snap.util.grad.parse\", function parseGrad(string) {\n\t        string = Str(string);\n\t        var tokens = string.match(gradrg);\n\t        if (!tokens) {\n\t            return null;\n\t        }\n\t        var type = tokens[1],\n\t            params = tokens[2],\n\t            stops = tokens[3];\n\t        params = params.split(/\\s*,\\s*/).map(function (el) {\n\t            return +el == el ? +el : el;\n\t        });\n\t        if (params.length == 1 && params[0] == 0) {\n\t            params = [];\n\t        }\n\t        stops = stops.split(\"-\");\n\t        stops = stops.map(function (el) {\n\t            el = el.split(\":\");\n\t            var out = {\n\t                color: el[0]\n\t            };\n\t            if (el[1]) {\n\t                out.offset = parseFloat(el[1]);\n\t            }\n\t            return out;\n\t        });\n\t        return {\n\t            type: type,\n\t            params: params,\n\t            stops: stops\n\t        };\n\t    });\n\t\n\t    eve.on(\"snap.util.attr.d\", function (value) {\n\t        eve.stop();\n\t        if (is(value, \"array\") && is(value[0], \"array\")) {\n\t            value = Snap.path.toString.call(value);\n\t        }\n\t        value = Str(value);\n\t        if (value.match(/[ruo]/i)) {\n\t            value = Snap.path.toAbsolute(value);\n\t        }\n\t        $(this.node, {d: value});\n\t    })(-1);\n\t    eve.on(\"snap.util.attr.#text\", function (value) {\n\t        eve.stop();\n\t        value = Str(value);\n\t        var txt = glob.doc.createTextNode(value);\n\t        while (this.node.firstChild) {\n\t            this.node.removeChild(this.node.firstChild);\n\t        }\n\t        this.node.appendChild(txt);\n\t    })(-1);\n\t    eve.on(\"snap.util.attr.path\", function (value) {\n\t        eve.stop();\n\t        this.attr({d: value});\n\t    })(-1);\n\t    eve.on(\"snap.util.attr.class\", function (value) {\n\t        eve.stop();\n\t        this.node.className.baseVal = value;\n\t    })(-1);\n\t    eve.on(\"snap.util.attr.viewBox\", function (value) {\n\t        var vb;\n\t        if (is(value, \"object\") && \"x\" in value) {\n\t            vb = [value.x, value.y, value.width, value.height].join(\" \");\n\t        } else if (is(value, \"array\")) {\n\t            vb = value.join(\" \");\n\t        } else {\n\t            vb = value;\n\t        }\n\t        $(this.node, {\n\t            viewBox: vb\n\t        });\n\t        eve.stop();\n\t    })(-1);\n\t    eve.on(\"snap.util.attr.transform\", function (value) {\n\t        this.transform(value);\n\t        eve.stop();\n\t    })(-1);\n\t    eve.on(\"snap.util.attr.r\", function (value) {\n\t        if (this.type == \"rect\") {\n\t            eve.stop();\n\t            $(this.node, {\n\t                rx: value,\n\t                ry: value\n\t            });\n\t        }\n\t    })(-1);\n\t    eve.on(\"snap.util.attr.textpath\", function (value) {\n\t        eve.stop();\n\t        if (this.type == \"text\") {\n\t            var id, tp, node;\n\t            if (!value && this.textPath) {\n\t                tp = this.textPath;\n\t                while (tp.node.firstChild) {\n\t                    this.node.appendChild(tp.node.firstChild);\n\t                }\n\t                tp.remove();\n\t                delete this.textPath;\n\t                return;\n\t            }\n\t            if (is(value, \"string\")) {\n\t                var defs = getSomeDefs(this),\n\t                    path = wrap(defs.parentNode).path(value);\n\t                defs.appendChild(path.node);\n\t                id = path.id;\n\t                path.attr({id: id});\n\t            } else {\n\t                value = wrap(value);\n\t                if (value instanceof Element) {\n\t                    id = value.attr(\"id\");\n\t                    if (!id) {\n\t                        id = value.id;\n\t                        value.attr({id: id});\n\t                    }\n\t                }\n\t            }\n\t            if (id) {\n\t                tp = this.textPath;\n\t                node = this.node;\n\t                if (tp) {\n\t                    tp.attr({\"xlink:href\": \"#\" + id});\n\t                } else {\n\t                    tp = $(\"textPath\", {\n\t                        \"xlink:href\": \"#\" + id\n\t                    });\n\t                    while (node.firstChild) {\n\t                        tp.appendChild(node.firstChild);\n\t                    }\n\t                    node.appendChild(tp);\n\t                    this.textPath = wrap(tp);\n\t                }\n\t            }\n\t        }\n\t    })(-1);\n\t    eve.on(\"snap.util.attr.text\", function (value) {\n\t        if (this.type == \"text\") {\n\t            var i = 0,\n\t                node = this.node,\n\t                tuner = function (chunk) {\n\t                    var out = $(\"tspan\");\n\t                    if (is(chunk, \"array\")) {\n\t                        for (var i = 0; i < chunk.length; i++) {\n\t                            out.appendChild(tuner(chunk[i]));\n\t                        }\n\t                    } else {\n\t                        out.appendChild(glob.doc.createTextNode(chunk));\n\t                    }\n\t                    out.normalize && out.normalize();\n\t                    return out;\n\t                };\n\t            while (node.firstChild) {\n\t                node.removeChild(node.firstChild);\n\t            }\n\t            var tuned = tuner(value);\n\t            while (tuned.firstChild) {\n\t                node.appendChild(tuned.firstChild);\n\t            }\n\t        }\n\t        eve.stop();\n\t    })(-1);\n\t    function setFontSize(value) {\n\t        eve.stop();\n\t        if (value == +value) {\n\t            value += \"px\";\n\t        }\n\t        this.node.style.fontSize = value;\n\t    }\n\t    eve.on(\"snap.util.attr.fontSize\", setFontSize)(-1);\n\t    eve.on(\"snap.util.attr.font-size\", setFontSize)(-1);\n\t\n\t\n\t    eve.on(\"snap.util.getattr.transform\", function () {\n\t        eve.stop();\n\t        return this.transform();\n\t    })(-1);\n\t    eve.on(\"snap.util.getattr.textpath\", function () {\n\t        eve.stop();\n\t        return this.textPath;\n\t    })(-1);\n\t    // Markers\n\t    (function () {\n\t        function getter(end) {\n\t            return function () {\n\t                eve.stop();\n\t                var style = glob.doc.defaultView.getComputedStyle(this.node, null).getPropertyValue(\"marker-\" + end);\n\t                if (style == \"none\") {\n\t                    return style;\n\t                } else {\n\t                    return Snap(glob.doc.getElementById(style.match(reURLValue)[1]));\n\t                }\n\t            };\n\t        }\n\t        function setter(end) {\n\t            return function (value) {\n\t                eve.stop();\n\t                var name = \"marker\" + end.charAt(0).toUpperCase() + end.substring(1);\n\t                if (value == \"\" || !value) {\n\t                    this.node.style[name] = \"none\";\n\t                    return;\n\t                }\n\t                if (value.type == \"marker\") {\n\t                    var id = value.node.id;\n\t                    if (!id) {\n\t                        $(value.node, {id: value.id});\n\t                    }\n\t                    this.node.style[name] = URL(id);\n\t                    return;\n\t                }\n\t            };\n\t        }\n\t        eve.on(\"snap.util.getattr.marker-end\", getter(\"end\"))(-1);\n\t        eve.on(\"snap.util.getattr.markerEnd\", getter(\"end\"))(-1);\n\t        eve.on(\"snap.util.getattr.marker-start\", getter(\"start\"))(-1);\n\t        eve.on(\"snap.util.getattr.markerStart\", getter(\"start\"))(-1);\n\t        eve.on(\"snap.util.getattr.marker-mid\", getter(\"mid\"))(-1);\n\t        eve.on(\"snap.util.getattr.markerMid\", getter(\"mid\"))(-1);\n\t        eve.on(\"snap.util.attr.marker-end\", setter(\"end\"))(-1);\n\t        eve.on(\"snap.util.attr.markerEnd\", setter(\"end\"))(-1);\n\t        eve.on(\"snap.util.attr.marker-start\", setter(\"start\"))(-1);\n\t        eve.on(\"snap.util.attr.markerStart\", setter(\"start\"))(-1);\n\t        eve.on(\"snap.util.attr.marker-mid\", setter(\"mid\"))(-1);\n\t        eve.on(\"snap.util.attr.markerMid\", setter(\"mid\"))(-1);\n\t    }());\n\t    eve.on(\"snap.util.getattr.r\", function () {\n\t        if (this.type == \"rect\" && $(this.node, \"rx\") == $(this.node, \"ry\")) {\n\t            eve.stop();\n\t            return $(this.node, \"rx\");\n\t        }\n\t    })(-1);\n\t    function textExtract(node) {\n\t        var out = [];\n\t        var children = node.childNodes;\n\t        for (var i = 0, ii = children.length; i < ii; i++) {\n\t            var chi = children[i];\n\t            if (chi.nodeType == 3) {\n\t                out.push(chi.nodeValue);\n\t            }\n\t            if (chi.tagName == \"tspan\") {\n\t                if (chi.childNodes.length == 1 && chi.firstChild.nodeType == 3) {\n\t                    out.push(chi.firstChild.nodeValue);\n\t                } else {\n\t                    out.push(textExtract(chi));\n\t                }\n\t            }\n\t        }\n\t        return out;\n\t    }\n\t    eve.on(\"snap.util.getattr.text\", function () {\n\t        if (this.type == \"text\" || this.type == \"tspan\") {\n\t            eve.stop();\n\t            var out = textExtract(this.node);\n\t            return out.length == 1 ? out[0] : out;\n\t        }\n\t    })(-1);\n\t    eve.on(\"snap.util.getattr.#text\", function () {\n\t        return this.node.textContent;\n\t    })(-1);\n\t    eve.on(\"snap.util.getattr.viewBox\", function () {\n\t        eve.stop();\n\t        var vb = $(this.node, \"viewBox\");\n\t        if (vb) {\n\t            vb = vb.split(separator);\n\t            return Snap._.box(+vb[0], +vb[1], +vb[2], +vb[3]);\n\t        } else {\n\t            return;\n\t        }\n\t    })(-1);\n\t    eve.on(\"snap.util.getattr.points\", function () {\n\t        var p = $(this.node, \"points\");\n\t        eve.stop();\n\t        if (p) {\n\t            return p.split(separator);\n\t        } else {\n\t            return;\n\t        }\n\t    })(-1);\n\t    eve.on(\"snap.util.getattr.path\", function () {\n\t        var p = $(this.node, \"d\");\n\t        eve.stop();\n\t        return p;\n\t    })(-1);\n\t    eve.on(\"snap.util.getattr.class\", function () {\n\t        return this.node.className.baseVal;\n\t    })(-1);\n\t    function getFontSize() {\n\t        eve.stop();\n\t        return this.node.style.fontSize;\n\t    }\n\t    eve.on(\"snap.util.getattr.fontSize\", getFontSize)(-1);\n\t    eve.on(\"snap.util.getattr.font-size\", getFontSize)(-1);\n\t});\n\t\n\t// Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\n\t//\n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t//\n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t//\n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n\t    var rgNotSpace = /\\S+/g,\n\t        rgBadSpace = /[\\t\\r\\n\\f]/g,\n\t        rgTrim = /(^\\s+|\\s+$)/g,\n\t        Str = String,\n\t        elproto = Element.prototype;\n\t    /*\\\n\t     * Element.addClass\n\t     [ method ]\n\t     **\n\t     * Adds given class name or list of class names to the element.\n\t     - value (string) class name or space separated list of class names\n\t     **\n\t     = (Element) original element.\n\t    \\*/\n\t    elproto.addClass = function (value) {\n\t        var classes = Str(value || \"\").match(rgNotSpace) || [],\n\t            elem = this.node,\n\t            className = elem.className.baseVal,\n\t            curClasses = className.match(rgNotSpace) || [],\n\t            j,\n\t            pos,\n\t            clazz,\n\t            finalValue;\n\t\n\t        if (classes.length) {\n\t            j = 0;\n\t            while ((clazz = classes[j++])) {\n\t                pos = curClasses.indexOf(clazz);\n\t                if (!~pos) {\n\t                    curClasses.push(clazz);\n\t                }\n\t            }\n\t\n\t            finalValue = curClasses.join(\" \");\n\t            if (className != finalValue) {\n\t                elem.className.baseVal = finalValue;\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.removeClass\n\t     [ method ]\n\t     **\n\t     * Removes given class name or list of class names from the element.\n\t     - value (string) class name or space separated list of class names\n\t     **\n\t     = (Element) original element.\n\t    \\*/\n\t    elproto.removeClass = function (value) {\n\t        var classes = Str(value || \"\").match(rgNotSpace) || [],\n\t            elem = this.node,\n\t            className = elem.className.baseVal,\n\t            curClasses = className.match(rgNotSpace) || [],\n\t            j,\n\t            pos,\n\t            clazz,\n\t            finalValue;\n\t        if (curClasses.length) {\n\t            j = 0;\n\t            while ((clazz = classes[j++])) {\n\t                pos = curClasses.indexOf(clazz);\n\t                if (~pos) {\n\t                    curClasses.splice(pos, 1);\n\t                }\n\t            }\n\t\n\t            finalValue = curClasses.join(\" \");\n\t            if (className != finalValue) {\n\t                elem.className.baseVal = finalValue;\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.hasClass\n\t     [ method ]\n\t     **\n\t     * Checks if the element has a given class name in the list of class names applied to it.\n\t     - value (string) class name\n\t     **\n\t     = (boolean) `true` if the element has given class\n\t    \\*/\n\t    elproto.hasClass = function (value) {\n\t        var elem = this.node,\n\t            className = elem.className.baseVal,\n\t            curClasses = className.match(rgNotSpace) || [];\n\t        return !!~curClasses.indexOf(value);\n\t    };\n\t    /*\\\n\t     * Element.toggleClass\n\t     [ method ]\n\t     **\n\t     * Add or remove one or more classes from the element, depending on either\n\t     * the class’s presence or the value of the `flag` argument.\n\t     - value (string) class name or space separated list of class names\n\t     - flag (boolean) value to determine whether the class should be added or removed\n\t     **\n\t     = (Element) original element.\n\t    \\*/\n\t    elproto.toggleClass = function (value, flag) {\n\t        if (flag != null) {\n\t            if (flag) {\n\t                return this.addClass(value);\n\t            } else {\n\t                return this.removeClass(value);\n\t            }\n\t        }\n\t        var classes = (value || \"\").match(rgNotSpace) || [],\n\t            elem = this.node,\n\t            className = elem.className.baseVal,\n\t            curClasses = className.match(rgNotSpace) || [],\n\t            j,\n\t            pos,\n\t            clazz,\n\t            finalValue;\n\t        j = 0;\n\t        while ((clazz = classes[j++])) {\n\t            pos = curClasses.indexOf(clazz);\n\t            if (~pos) {\n\t                curClasses.splice(pos, 1);\n\t            } else {\n\t                curClasses.push(clazz);\n\t            }\n\t        }\n\t\n\t        finalValue = curClasses.join(\" \");\n\t        if (className != finalValue) {\n\t            elem.className.baseVal = finalValue;\n\t        }\n\t        return this;\n\t    };\n\t});\n\t\n\t// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t// \n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t// \n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t// \n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n\t    var operators = {\n\t            \"+\": function (x, y) {\n\t                    return x + y;\n\t                },\n\t            \"-\": function (x, y) {\n\t                    return x - y;\n\t                },\n\t            \"/\": function (x, y) {\n\t                    return x / y;\n\t                },\n\t            \"*\": function (x, y) {\n\t                    return x * y;\n\t                }\n\t        },\n\t        Str = String,\n\t        reUnit = /[a-z]+$/i,\n\t        reAddon = /^\\s*([+\\-\\/*])\\s*=\\s*([\\d.eE+\\-]+)\\s*([^\\d\\s]+)?\\s*$/;\n\t    function getNumber(val) {\n\t        return val;\n\t    }\n\t    function getUnit(unit) {\n\t        return function (val) {\n\t            return +val.toFixed(3) + unit;\n\t        };\n\t    }\n\t    eve.on(\"snap.util.attr\", function (val) {\n\t        var plus = Str(val).match(reAddon);\n\t        if (plus) {\n\t            var evnt = eve.nt(),\n\t                name = evnt.substring(evnt.lastIndexOf(\".\") + 1),\n\t                a = this.attr(name),\n\t                atr = {};\n\t            eve.stop();\n\t            var unit = plus[3] || \"\",\n\t                aUnit = a.match(reUnit),\n\t                op = operators[plus[1]];\n\t            if (aUnit && aUnit == unit) {\n\t                val = op(parseFloat(a), +plus[2]);\n\t            } else {\n\t                a = this.asPX(name);\n\t                val = op(this.asPX(name), this.asPX(name, plus[2] + unit));\n\t            }\n\t            if (isNaN(a) || isNaN(val)) {\n\t                return;\n\t            }\n\t            atr[name] = val;\n\t            this.attr(atr);\n\t        }\n\t    })(-10);\n\t    eve.on(\"snap.util.equal\", function (name, b) {\n\t        var A, B, a = Str(this.attr(name) || \"\"),\n\t            el = this,\n\t            bplus = Str(b).match(reAddon);\n\t        if (bplus) {\n\t            eve.stop();\n\t            var unit = bplus[3] || \"\",\n\t                aUnit = a.match(reUnit),\n\t                op = operators[bplus[1]];\n\t            if (aUnit && aUnit == unit) {\n\t                return {\n\t                    from: parseFloat(a),\n\t                    to: op(parseFloat(a), +bplus[2]),\n\t                    f: getUnit(aUnit)\n\t                };\n\t            } else {\n\t                a = this.asPX(name);\n\t                return {\n\t                    from: a,\n\t                    to: op(a, this.asPX(name, bplus[2] + unit)),\n\t                    f: getNumber\n\t                };\n\t            }\n\t        }\n\t    })(-10);\n\t});\n\t// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t// \n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t// \n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t// \n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n\t    var proto = Paper.prototype,\n\t        is = Snap.is;\n\t    /*\\\n\t     * Paper.rect\n\t     [ method ]\n\t     *\n\t     * Draws a rectangle\n\t     **\n\t     - x (number) x coordinate of the top left corner\n\t     - y (number) y coordinate of the top left corner\n\t     - width (number) width\n\t     - height (number) height\n\t     - rx (number) #optional horizontal radius for rounded corners, default is 0\n\t     - ry (number) #optional vertical radius for rounded corners, default is rx or 0\n\t     = (object) the `rect` element\n\t     **\n\t     > Usage\n\t     | // regular rectangle\n\t     | var c = paper.rect(10, 10, 50, 50);\n\t     | // rectangle with rounded corners\n\t     | var c = paper.rect(40, 40, 50, 50, 10);\n\t    \\*/\n\t    proto.rect = function (x, y, w, h, rx, ry) {\n\t        var attr;\n\t        if (ry == null) {\n\t            ry = rx;\n\t        }\n\t        if (is(x, \"object\") && x == \"[object Object]\") {\n\t            attr = x;\n\t        } else if (x != null) {\n\t            attr = {\n\t                x: x,\n\t                y: y,\n\t                width: w,\n\t                height: h\n\t            };\n\t            if (rx != null) {\n\t                attr.rx = rx;\n\t                attr.ry = ry;\n\t            }\n\t        }\n\t        return this.el(\"rect\", attr);\n\t    };\n\t    /*\\\n\t     * Paper.circle\n\t     [ method ]\n\t     **\n\t     * Draws a circle\n\t     **\n\t     - x (number) x coordinate of the centre\n\t     - y (number) y coordinate of the centre\n\t     - r (number) radius\n\t     = (object) the `circle` element\n\t     **\n\t     > Usage\n\t     | var c = paper.circle(50, 50, 40);\n\t    \\*/\n\t    proto.circle = function (cx, cy, r) {\n\t        var attr;\n\t        if (is(cx, \"object\") && cx == \"[object Object]\") {\n\t            attr = cx;\n\t        } else if (cx != null) {\n\t            attr = {\n\t                cx: cx,\n\t                cy: cy,\n\t                r: r\n\t            };\n\t        }\n\t        return this.el(\"circle\", attr);\n\t    };\n\t\n\t    var preload = (function () {\n\t        function onerror() {\n\t            this.parentNode.removeChild(this);\n\t        }\n\t        return function (src, f) {\n\t            var img = glob.doc.createElement(\"img\"),\n\t                body = glob.doc.body;\n\t            img.style.cssText = \"position:absolute;left:-9999em;top:-9999em\";\n\t            img.onload = function () {\n\t                f.call(img);\n\t                img.onload = img.onerror = null;\n\t                body.removeChild(img);\n\t            };\n\t            img.onerror = onerror;\n\t            body.appendChild(img);\n\t            img.src = src;\n\t        };\n\t    }());\n\t\n\t    /*\\\n\t     * Paper.image\n\t     [ method ]\n\t     **\n\t     * Places an image on the surface\n\t     **\n\t     - src (string) URI of the source image\n\t     - x (number) x offset position\n\t     - y (number) y offset position\n\t     - width (number) width of the image\n\t     - height (number) height of the image\n\t     = (object) the `image` element\n\t     * or\n\t     = (object) Snap element object with type `image`\n\t     **\n\t     > Usage\n\t     | var c = paper.image(\"apple.png\", 10, 10, 80, 80);\n\t    \\*/\n\t    proto.image = function (src, x, y, width, height) {\n\t        var el = this.el(\"image\");\n\t        if (is(src, \"object\") && \"src\" in src) {\n\t            el.attr(src);\n\t        } else if (src != null) {\n\t            var set = {\n\t                \"xlink:href\": src,\n\t                preserveAspectRatio: \"none\"\n\t            };\n\t            if (x != null && y != null) {\n\t                set.x = x;\n\t                set.y = y;\n\t            }\n\t            if (width != null && height != null) {\n\t                set.width = width;\n\t                set.height = height;\n\t            } else {\n\t                preload(src, function () {\n\t                    Snap._.$(el.node, {\n\t                        width: this.offsetWidth,\n\t                        height: this.offsetHeight\n\t                    });\n\t                });\n\t            }\n\t            Snap._.$(el.node, set);\n\t        }\n\t        return el;\n\t    };\n\t    /*\\\n\t     * Paper.ellipse\n\t     [ method ]\n\t     **\n\t     * Draws an ellipse\n\t     **\n\t     - x (number) x coordinate of the centre\n\t     - y (number) y coordinate of the centre\n\t     - rx (number) horizontal radius\n\t     - ry (number) vertical radius\n\t     = (object) the `ellipse` element\n\t     **\n\t     > Usage\n\t     | var c = paper.ellipse(50, 50, 40, 20);\n\t    \\*/\n\t    proto.ellipse = function (cx, cy, rx, ry) {\n\t        var attr;\n\t        if (is(cx, \"object\") && cx == \"[object Object]\") {\n\t            attr = cx;\n\t        } else if (cx != null) {\n\t            attr ={\n\t                cx: cx,\n\t                cy: cy,\n\t                rx: rx,\n\t                ry: ry\n\t            };\n\t        }\n\t        return this.el(\"ellipse\", attr);\n\t    };\n\t    // SIERRA Paper.path(): Unclear from the link what a Catmull-Rom curveto is, and why it would make life any easier.\n\t    /*\\\n\t     * Paper.path\n\t     [ method ]\n\t     **\n\t     * Creates a `<path>` element using the given string as the path's definition\n\t     - pathString (string) #optional path string in SVG format\n\t     * Path string consists of one-letter commands, followed by comma seprarated arguments in numerical form. Example:\n\t     | \"M10,20L30,40\"\n\t     * This example features two commands: `M`, with arguments `(10, 20)` and `L` with arguments `(30, 40)`. Uppercase letter commands express coordinates in absolute terms, while lowercase commands express them in relative terms from the most recently declared coordinates.\n\t     *\n\t     # <p>Here is short list of commands available, for more details see <a href=\"http://www.w3.org/TR/SVG/paths.html#PathData\" title=\"Details of a path's data attribute's format are described in the SVG specification.\">SVG path string format</a> or <a href=\"https://developer.mozilla.org/en/SVG/Tutorial/Paths\">article about path strings at MDN</a>.</p>\n\t     # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>\n\t     # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>\n\t     # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>\n\t     # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>\n\t     # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>\n\t     # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>\n\t     # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>\n\t     # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>\n\t     # <tr><td>Q</td><td>quadratic Bézier curveto</td><td>(x1 y1 x y)+</td></tr>\n\t     # <tr><td>T</td><td>smooth quadratic Bézier curveto</td><td>(x y)+</td></tr>\n\t     # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>\n\t     # <tr><td>R</td><td><a href=\"http://en.wikipedia.org/wiki/Catmull–Rom_spline#Catmull.E2.80.93Rom_spline\">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>\n\t     * * _Catmull-Rom curveto_ is a not standard SVG command and added to make life easier.\n\t     * Note: there is a special case when a path consists of only three commands: `M10,10R…z`. In this case the path connects back to its starting point.\n\t     > Usage\n\t     | var c = paper.path(\"M10 10L90 90\");\n\t     | // draw a diagonal line:\n\t     | // move to 10,10, line to 90,90\n\t    \\*/\n\t    proto.path = function (d) {\n\t        var attr;\n\t        if (is(d, \"object\") && !is(d, \"array\")) {\n\t            attr = d;\n\t        } else if (d) {\n\t            attr = {d: d};\n\t        }\n\t        return this.el(\"path\", attr);\n\t    };\n\t    /*\\\n\t     * Paper.g\n\t     [ method ]\n\t     **\n\t     * Creates a group element\n\t     **\n\t     - varargs (…) #optional elements to nest within the group\n\t     = (object) the `g` element\n\t     **\n\t     > Usage\n\t     | var c1 = paper.circle(),\n\t     |     c2 = paper.rect(),\n\t     |     g = paper.g(c2, c1); // note that the order of elements is different\n\t     * or\n\t     | var c1 = paper.circle(),\n\t     |     c2 = paper.rect(),\n\t     |     g = paper.g();\n\t     | g.add(c2, c1);\n\t    \\*/\n\t    /*\\\n\t     * Paper.group\n\t     [ method ]\n\t     **\n\t     * See @Paper.g\n\t    \\*/\n\t    proto.group = proto.g = function (first) {\n\t        var attr,\n\t            el = this.el(\"g\");\n\t        if (arguments.length == 1 && first && !first.type) {\n\t            el.attr(first);\n\t        } else if (arguments.length) {\n\t            el.add(Array.prototype.slice.call(arguments, 0));\n\t        }\n\t        return el;\n\t    };\n\t    /*\\\n\t     * Paper.svg\n\t     [ method ]\n\t     **\n\t     * Creates a nested SVG element.\n\t     - x (number) @optional X of the element\n\t     - y (number) @optional Y of the element\n\t     - width (number) @optional width of the element\n\t     - height (number) @optional height of the element\n\t     - vbx (number) @optional viewbox X\n\t     - vby (number) @optional viewbox Y\n\t     - vbw (number) @optional viewbox width\n\t     - vbh (number) @optional viewbox height\n\t     **\n\t     = (object) the `svg` element\n\t     **\n\t    \\*/\n\t    proto.svg = function (x, y, width, height, vbx, vby, vbw, vbh) {\n\t        var attrs = {};\n\t        if (is(x, \"object\") && y == null) {\n\t            attrs = x;\n\t        } else {\n\t            if (x != null) {\n\t                attrs.x = x;\n\t            }\n\t            if (y != null) {\n\t                attrs.y = y;\n\t            }\n\t            if (width != null) {\n\t                attrs.width = width;\n\t            }\n\t            if (height != null) {\n\t                attrs.height = height;\n\t            }\n\t            if (vbx != null && vby != null && vbw != null && vbh != null) {\n\t                attrs.viewBox = [vbx, vby, vbw, vbh];\n\t            }\n\t        }\n\t        return this.el(\"svg\", attrs);\n\t    };\n\t    /*\\\n\t     * Paper.mask\n\t     [ method ]\n\t     **\n\t     * Equivalent in behaviour to @Paper.g, except it’s a mask.\n\t     **\n\t     = (object) the `mask` element\n\t     **\n\t    \\*/\n\t    proto.mask = function (first) {\n\t        var attr,\n\t            el = this.el(\"mask\");\n\t        if (arguments.length == 1 && first && !first.type) {\n\t            el.attr(first);\n\t        } else if (arguments.length) {\n\t            el.add(Array.prototype.slice.call(arguments, 0));\n\t        }\n\t        return el;\n\t    };\n\t    /*\\\n\t     * Paper.ptrn\n\t     [ method ]\n\t     **\n\t     * Equivalent in behaviour to @Paper.g, except it’s a pattern.\n\t     - x (number) @optional X of the element\n\t     - y (number) @optional Y of the element\n\t     - width (number) @optional width of the element\n\t     - height (number) @optional height of the element\n\t     - vbx (number) @optional viewbox X\n\t     - vby (number) @optional viewbox Y\n\t     - vbw (number) @optional viewbox width\n\t     - vbh (number) @optional viewbox height\n\t     **\n\t     = (object) the `pattern` element\n\t     **\n\t    \\*/\n\t    proto.ptrn = function (x, y, width, height, vx, vy, vw, vh) {\n\t        if (is(x, \"object\")) {\n\t            var attr = x;\n\t        } else {\n\t            attr = {patternUnits: \"userSpaceOnUse\"};\n\t            if (x) {\n\t                attr.x = x;\n\t            }\n\t            if (y) {\n\t                attr.y = y;\n\t            }\n\t            if (width != null) {\n\t                attr.width = width;\n\t            }\n\t            if (height != null) {\n\t                attr.height = height;\n\t            }\n\t            if (vx != null && vy != null && vw != null && vh != null) {\n\t                attr.viewBox = [vx, vy, vw, vh];\n\t            } else {\n\t                attr.viewBox = [x || 0, y || 0, width || 0, height || 0];\n\t            }\n\t        }\n\t        return this.el(\"pattern\", attr);\n\t    };\n\t    /*\\\n\t     * Paper.use\n\t     [ method ]\n\t     **\n\t     * Creates a <use> element.\n\t     - id (string) @optional id of element to link\n\t     * or\n\t     - id (Element) @optional element to link\n\t     **\n\t     = (object) the `use` element\n\t     **\n\t    \\*/\n\t    proto.use = function (id) {\n\t        if (id != null) {\n\t            if (id instanceof Element) {\n\t                if (!id.attr(\"id\")) {\n\t                    id.attr({id: Snap._.id(id)});\n\t                }\n\t                id = id.attr(\"id\");\n\t            }\n\t            if (String(id).charAt() == \"#\") {\n\t                id = id.substring(1);\n\t            }\n\t            return this.el(\"use\", {\"xlink:href\": \"#\" + id});\n\t        } else {\n\t            return Element.prototype.use.call(this);\n\t        }\n\t    };\n\t    /*\\\n\t     * Paper.symbol\n\t     [ method ]\n\t     **\n\t     * Creates a <symbol> element.\n\t     - vbx (number) @optional viewbox X\n\t     - vby (number) @optional viewbox Y\n\t     - vbw (number) @optional viewbox width\n\t     - vbh (number) @optional viewbox height\n\t     = (object) the `symbol` element\n\t     **\n\t    \\*/\n\t    proto.symbol = function (vx, vy, vw, vh) {\n\t        var attr = {};\n\t        if (vx != null && vy != null && vw != null && vh != null) {\n\t            attr.viewBox = [vx, vy, vw, vh];\n\t        }\n\t\n\t        return this.el(\"symbol\", attr);\n\t    };\n\t    /*\\\n\t     * Paper.text\n\t     [ method ]\n\t     **\n\t     * Draws a text string\n\t     **\n\t     - x (number) x coordinate position\n\t     - y (number) y coordinate position\n\t     - text (string|array) The text string to draw or array of strings to nest within separate `<tspan>` elements\n\t     = (object) the `text` element\n\t     **\n\t     > Usage\n\t     | var t1 = paper.text(50, 50, \"Snap\");\n\t     | var t2 = paper.text(50, 50, [\"S\",\"n\",\"a\",\"p\"]);\n\t     | // Text path usage\n\t     | t1.attr({textpath: \"M10,10L100,100\"});\n\t     | // or\n\t     | var pth = paper.path(\"M10,10L100,100\");\n\t     | t1.attr({textpath: pth});\n\t    \\*/\n\t    proto.text = function (x, y, text) {\n\t        var attr = {};\n\t        if (is(x, \"object\")) {\n\t            attr = x;\n\t        } else if (x != null) {\n\t            attr = {\n\t                x: x,\n\t                y: y,\n\t                text: text || \"\"\n\t            };\n\t        }\n\t        return this.el(\"text\", attr);\n\t    };\n\t    /*\\\n\t     * Paper.line\n\t     [ method ]\n\t     **\n\t     * Draws a line\n\t     **\n\t     - x1 (number) x coordinate position of the start\n\t     - y1 (number) y coordinate position of the start\n\t     - x2 (number) x coordinate position of the end\n\t     - y2 (number) y coordinate position of the end\n\t     = (object) the `line` element\n\t     **\n\t     > Usage\n\t     | var t1 = paper.line(50, 50, 100, 100);\n\t    \\*/\n\t    proto.line = function (x1, y1, x2, y2) {\n\t        var attr = {};\n\t        if (is(x1, \"object\")) {\n\t            attr = x1;\n\t        } else if (x1 != null) {\n\t            attr = {\n\t                x1: x1,\n\t                x2: x2,\n\t                y1: y1,\n\t                y2: y2\n\t            };\n\t        }\n\t        return this.el(\"line\", attr);\n\t    };\n\t    /*\\\n\t     * Paper.polyline\n\t     [ method ]\n\t     **\n\t     * Draws a polyline\n\t     **\n\t     - points (array) array of points\n\t     * or\n\t     - varargs (…) points\n\t     = (object) the `polyline` element\n\t     **\n\t     > Usage\n\t     | var p1 = paper.polyline([10, 10, 100, 100]);\n\t     | var p2 = paper.polyline(10, 10, 100, 100);\n\t    \\*/\n\t    proto.polyline = function (points) {\n\t        if (arguments.length > 1) {\n\t            points = Array.prototype.slice.call(arguments, 0);\n\t        }\n\t        var attr = {};\n\t        if (is(points, \"object\") && !is(points, \"array\")) {\n\t            attr = points;\n\t        } else if (points != null) {\n\t            attr = {points: points};\n\t        }\n\t        return this.el(\"polyline\", attr);\n\t    };\n\t    /*\\\n\t     * Paper.polygon\n\t     [ method ]\n\t     **\n\t     * Draws a polygon. See @Paper.polyline\n\t    \\*/\n\t    proto.polygon = function (points) {\n\t        if (arguments.length > 1) {\n\t            points = Array.prototype.slice.call(arguments, 0);\n\t        }\n\t        var attr = {};\n\t        if (is(points, \"object\") && !is(points, \"array\")) {\n\t            attr = points;\n\t        } else if (points != null) {\n\t            attr = {points: points};\n\t        }\n\t        return this.el(\"polygon\", attr);\n\t    };\n\t    // gradients\n\t    (function () {\n\t        var $ = Snap._.$;\n\t        // gradients' helpers\n\t        function Gstops() {\n\t            return this.selectAll(\"stop\");\n\t        }\n\t        function GaddStop(color, offset) {\n\t            var stop = $(\"stop\"),\n\t                attr = {\n\t                    offset: +offset + \"%\"\n\t                };\n\t            color = Snap.color(color);\n\t            attr[\"stop-color\"] = color.hex;\n\t            if (color.opacity < 1) {\n\t                attr[\"stop-opacity\"] = color.opacity;\n\t            }\n\t            $(stop, attr);\n\t            this.node.appendChild(stop);\n\t            return this;\n\t        }\n\t        function GgetBBox() {\n\t            if (this.type == \"linearGradient\") {\n\t                var x1 = $(this.node, \"x1\") || 0,\n\t                    x2 = $(this.node, \"x2\") || 1,\n\t                    y1 = $(this.node, \"y1\") || 0,\n\t                    y2 = $(this.node, \"y2\") || 0;\n\t                return Snap._.box(x1, y1, math.abs(x2 - x1), math.abs(y2 - y1));\n\t            } else {\n\t                var cx = this.node.cx || .5,\n\t                    cy = this.node.cy || .5,\n\t                    r = this.node.r || 0;\n\t                return Snap._.box(cx - r, cy - r, r * 2, r * 2);\n\t            }\n\t        }\n\t        function gradient(defs, str) {\n\t            var grad = eve(\"snap.util.grad.parse\", null, str).firstDefined(),\n\t                el;\n\t            if (!grad) {\n\t                return null;\n\t            }\n\t            grad.params.unshift(defs);\n\t            if (grad.type.toLowerCase() == \"l\") {\n\t                el = gradientLinear.apply(0, grad.params);\n\t            } else {\n\t                el = gradientRadial.apply(0, grad.params);\n\t            }\n\t            if (grad.type != grad.type.toLowerCase()) {\n\t                $(el.node, {\n\t                    gradientUnits: \"userSpaceOnUse\"\n\t                });\n\t            }\n\t            var stops = grad.stops,\n\t                len = stops.length,\n\t                start = 0,\n\t                j = 0;\n\t            function seed(i, end) {\n\t                var step = (end - start) / (i - j);\n\t                for (var k = j; k < i; k++) {\n\t                    stops[k].offset = +(+start + step * (k - j)).toFixed(2);\n\t                }\n\t                j = i;\n\t                start = end;\n\t            }\n\t            len--;\n\t            for (var i = 0; i < len; i++) if (\"offset\" in stops[i]) {\n\t                seed(i, stops[i].offset);\n\t            }\n\t            stops[len].offset = stops[len].offset || 100;\n\t            seed(len, stops[len].offset);\n\t            for (i = 0; i <= len; i++) {\n\t                var stop = stops[i];\n\t                el.addStop(stop.color, stop.offset);\n\t            }\n\t            return el;\n\t        }\n\t        function gradientLinear(defs, x1, y1, x2, y2) {\n\t            var el = Snap._.make(\"linearGradient\", defs);\n\t            el.stops = Gstops;\n\t            el.addStop = GaddStop;\n\t            el.getBBox = GgetBBox;\n\t            if (x1 != null) {\n\t                $(el.node, {\n\t                    x1: x1,\n\t                    y1: y1,\n\t                    x2: x2,\n\t                    y2: y2\n\t                });\n\t            }\n\t            return el;\n\t        }\n\t        function gradientRadial(defs, cx, cy, r, fx, fy) {\n\t            var el = Snap._.make(\"radialGradient\", defs);\n\t            el.stops = Gstops;\n\t            el.addStop = GaddStop;\n\t            el.getBBox = GgetBBox;\n\t            if (cx != null) {\n\t                $(el.node, {\n\t                    cx: cx,\n\t                    cy: cy,\n\t                    r: r\n\t                });\n\t            }\n\t            if (fx != null && fy != null) {\n\t                $(el.node, {\n\t                    fx: fx,\n\t                    fy: fy\n\t                });\n\t            }\n\t            return el;\n\t        }\n\t        /*\\\n\t         * Paper.gradient\n\t         [ method ]\n\t         **\n\t         * Creates a gradient element\n\t         **\n\t         - gradient (string) gradient descriptor\n\t         > Gradient Descriptor\n\t         * The gradient descriptor is an expression formatted as\n\t         * follows: `<type>(<coords>)<colors>`.  The `<type>` can be\n\t         * either linear or radial.  The uppercase `L` or `R` letters\n\t         * indicate absolute coordinates offset from the SVG surface.\n\t         * Lowercase `l` or `r` letters indicate coordinates\n\t         * calculated relative to the element to which the gradient is\n\t         * applied.  Coordinates specify a linear gradient vector as\n\t         * `x1`, `y1`, `x2`, `y2`, or a radial gradient as `cx`, `cy`,\n\t         * `r` and optional `fx`, `fy` specifying a focal point away\n\t         * from the center of the circle. Specify `<colors>` as a list\n\t         * of dash-separated CSS color values.  Each color may be\n\t         * followed by a custom offset value, separated with a colon\n\t         * character.\n\t         > Examples\n\t         * Linear gradient, relative from top-left corner to bottom-right\n\t         * corner, from black through red to white:\n\t         | var g = paper.gradient(\"l(0, 0, 1, 1)#000-#f00-#fff\");\n\t         * Linear gradient, absolute from (0, 0) to (100, 100), from black\n\t         * through red at 25% to white:\n\t         | var g = paper.gradient(\"L(0, 0, 100, 100)#000-#f00:25-#fff\");\n\t         * Radial gradient, relative from the center of the element with radius\n\t         * half the width, from black to white:\n\t         | var g = paper.gradient(\"r(0.5, 0.5, 0.5)#000-#fff\");\n\t         * To apply the gradient:\n\t         | paper.circle(50, 50, 40).attr({\n\t         |     fill: g\n\t         | });\n\t         = (object) the `gradient` element\n\t        \\*/\n\t        proto.gradient = function (str) {\n\t            return gradient(this.defs, str);\n\t        };\n\t        proto.gradientLinear = function (x1, y1, x2, y2) {\n\t            return gradientLinear(this.defs, x1, y1, x2, y2);\n\t        };\n\t        proto.gradientRadial = function (cx, cy, r, fx, fy) {\n\t            return gradientRadial(this.defs, cx, cy, r, fx, fy);\n\t        };\n\t        /*\\\n\t         * Paper.toString\n\t         [ method ]\n\t         **\n\t         * Returns SVG code for the @Paper\n\t         = (string) SVG code for the @Paper\n\t        \\*/\n\t        proto.toString = function () {\n\t            var doc = this.node.ownerDocument,\n\t                f = doc.createDocumentFragment(),\n\t                d = doc.createElement(\"div\"),\n\t                svg = this.node.cloneNode(true),\n\t                res;\n\t            f.appendChild(d);\n\t            d.appendChild(svg);\n\t            Snap._.$(svg, {xmlns: \"http://www.w3.org/2000/svg\"});\n\t            res = d.innerHTML;\n\t            f.removeChild(f.firstChild);\n\t            return res;\n\t        };\n\t        /*\\\n\t         * Paper.toDataURL\n\t         [ method ]\n\t         **\n\t         * Returns SVG code for the @Paper as Data URI string.\n\t         = (string) Data URI string\n\t        \\*/\n\t        proto.toDataURL = function () {\n\t            if (window && window.btoa) {\n\t                return \"data:image/svg+xml;base64,\" + btoa(unescape(encodeURIComponent(this)));\n\t            }\n\t        };\n\t        /*\\\n\t         * Paper.clear\n\t         [ method ]\n\t         **\n\t         * Removes all child nodes of the paper, except <defs>.\n\t        \\*/\n\t        proto.clear = function () {\n\t            var node = this.node.firstChild,\n\t                next;\n\t            while (node) {\n\t                next = node.nextSibling;\n\t                if (node.tagName != \"defs\") {\n\t                    node.parentNode.removeChild(node);\n\t                } else {\n\t                    proto.clear.call({node: node});\n\t                }\n\t                node = next;\n\t            }\n\t        };\n\t    }());\n\t});\n\t\n\t// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t// \n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t// \n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t// \n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tSnap.plugin(function (Snap, Element, Paper, glob) {\n\t    var elproto = Element.prototype,\n\t        is = Snap.is,\n\t        clone = Snap._.clone,\n\t        has = \"hasOwnProperty\",\n\t        p2s = /,?([a-z]),?/gi,\n\t        toFloat = parseFloat,\n\t        math = Math,\n\t        PI = math.PI,\n\t        mmin = math.min,\n\t        mmax = math.max,\n\t        pow = math.pow,\n\t        abs = math.abs;\n\t    function paths(ps) {\n\t        var p = paths.ps = paths.ps || {};\n\t        if (p[ps]) {\n\t            p[ps].sleep = 100;\n\t        } else {\n\t            p[ps] = {\n\t                sleep: 100\n\t            };\n\t        }\n\t        setTimeout(function () {\n\t            for (var key in p) if (p[has](key) && key != ps) {\n\t                p[key].sleep--;\n\t                !p[key].sleep && delete p[key];\n\t            }\n\t        });\n\t        return p[ps];\n\t    }\n\t    function box(x, y, width, height) {\n\t        if (x == null) {\n\t            x = y = width = height = 0;\n\t        }\n\t        if (y == null) {\n\t            y = x.y;\n\t            width = x.width;\n\t            height = x.height;\n\t            x = x.x;\n\t        }\n\t        return {\n\t            x: x,\n\t            y: y,\n\t            width: width,\n\t            w: width,\n\t            height: height,\n\t            h: height,\n\t            x2: x + width,\n\t            y2: y + height,\n\t            cx: x + width / 2,\n\t            cy: y + height / 2,\n\t            r1: math.min(width, height) / 2,\n\t            r2: math.max(width, height) / 2,\n\t            r0: math.sqrt(width * width + height * height) / 2,\n\t            path: rectPath(x, y, width, height),\n\t            vb: [x, y, width, height].join(\" \")\n\t        };\n\t    }\n\t    function toString() {\n\t        return this.join(\",\").replace(p2s, \"$1\");\n\t    }\n\t    function pathClone(pathArray) {\n\t        var res = clone(pathArray);\n\t        res.toString = toString;\n\t        return res;\n\t    }\n\t    function getPointAtSegmentLength(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {\n\t        if (length == null) {\n\t            return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);\n\t        } else {\n\t            return findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y,\n\t                getTotLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));\n\t        }\n\t    }\n\t    function getLengthFactory(istotal, subpath) {\n\t        function O(val) {\n\t            return +(+val).toFixed(3);\n\t        }\n\t        return Snap._.cacher(function (path, length, onlystart) {\n\t            if (path instanceof Element) {\n\t                path = path.attr(\"d\");\n\t            }\n\t            path = path2curve(path);\n\t            var x, y, p, l, sp = \"\", subpaths = {}, point,\n\t                len = 0;\n\t            for (var i = 0, ii = path.length; i < ii; i++) {\n\t                p = path[i];\n\t                if (p[0] == \"M\") {\n\t                    x = +p[1];\n\t                    y = +p[2];\n\t                } else {\n\t                    l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);\n\t                    if (len + l > length) {\n\t                        if (subpath && !subpaths.start) {\n\t                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);\n\t                            sp += [\n\t                                \"C\" + O(point.start.x),\n\t                                O(point.start.y),\n\t                                O(point.m.x),\n\t                                O(point.m.y),\n\t                                O(point.x),\n\t                                O(point.y)\n\t                            ];\n\t                            if (onlystart) {return sp;}\n\t                            subpaths.start = sp;\n\t                            sp = [\n\t                                \"M\" + O(point.x),\n\t                                O(point.y) + \"C\" + O(point.n.x),\n\t                                O(point.n.y),\n\t                                O(point.end.x),\n\t                                O(point.end.y),\n\t                                O(p[5]),\n\t                                O(p[6])\n\t                            ].join();\n\t                            len += l;\n\t                            x = +p[5];\n\t                            y = +p[6];\n\t                            continue;\n\t                        }\n\t                        if (!istotal && !subpath) {\n\t                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);\n\t                            return point;\n\t                        }\n\t                    }\n\t                    len += l;\n\t                    x = +p[5];\n\t                    y = +p[6];\n\t                }\n\t                sp += p.shift() + p;\n\t            }\n\t            subpaths.end = sp;\n\t            point = istotal ? len : subpath ? subpaths : findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);\n\t            return point;\n\t        }, null, Snap._.clone);\n\t    }\n\t    var getTotalLength = getLengthFactory(1),\n\t        getPointAtLength = getLengthFactory(),\n\t        getSubpathsAtLength = getLengthFactory(0, 1);\n\t    function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {\n\t        var t1 = 1 - t,\n\t            t13 = pow(t1, 3),\n\t            t12 = pow(t1, 2),\n\t            t2 = t * t,\n\t            t3 = t2 * t,\n\t            x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,\n\t            y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,\n\t            mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),\n\t            my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),\n\t            nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),\n\t            ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),\n\t            ax = t1 * p1x + t * c1x,\n\t            ay = t1 * p1y + t * c1y,\n\t            cx = t1 * c2x + t * p2x,\n\t            cy = t1 * c2y + t * p2y,\n\t            alpha = (90 - math.atan2(mx - nx, my - ny) * 180 / PI);\n\t        // (mx > nx || my < ny) && (alpha += 180);\n\t        return {\n\t            x: x,\n\t            y: y,\n\t            m: {x: mx, y: my},\n\t            n: {x: nx, y: ny},\n\t            start: {x: ax, y: ay},\n\t            end: {x: cx, y: cy},\n\t            alpha: alpha\n\t        };\n\t    }\n\t    function bezierBBox(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {\n\t        if (!Snap.is(p1x, \"array\")) {\n\t            p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];\n\t        }\n\t        var bbox = curveDim.apply(null, p1x);\n\t        return box(\n\t            bbox.min.x,\n\t            bbox.min.y,\n\t            bbox.max.x - bbox.min.x,\n\t            bbox.max.y - bbox.min.y\n\t        );\n\t    }\n\t    function isPointInsideBBox(bbox, x, y) {\n\t        return  x >= bbox.x &&\n\t                x <= bbox.x + bbox.width &&\n\t                y >= bbox.y &&\n\t                y <= bbox.y + bbox.height;\n\t    }\n\t    function isBBoxIntersect(bbox1, bbox2) {\n\t        bbox1 = box(bbox1);\n\t        bbox2 = box(bbox2);\n\t        return isPointInsideBBox(bbox2, bbox1.x, bbox1.y)\n\t            || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y)\n\t            || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2)\n\t            || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2)\n\t            || isPointInsideBBox(bbox1, bbox2.x, bbox2.y)\n\t            || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y)\n\t            || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2)\n\t            || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2)\n\t            || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x\n\t                || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)\n\t            && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y\n\t                || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);\n\t    }\n\t    function base3(t, p1, p2, p3, p4) {\n\t        var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,\n\t            t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;\n\t        return t * t2 - 3 * p1 + 3 * p2;\n\t    }\n\t    function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {\n\t        if (z == null) {\n\t            z = 1;\n\t        }\n\t        z = z > 1 ? 1 : z < 0 ? 0 : z;\n\t        var z2 = z / 2,\n\t            n = 12,\n\t            Tvalues = [-.1252,.1252,-.3678,.3678,-.5873,.5873,-.7699,.7699,-.9041,.9041,-.9816,.9816],\n\t            Cvalues = [0.2491,0.2491,0.2335,0.2335,0.2032,0.2032,0.1601,0.1601,0.1069,0.1069,0.0472,0.0472],\n\t            sum = 0;\n\t        for (var i = 0; i < n; i++) {\n\t            var ct = z2 * Tvalues[i] + z2,\n\t                xbase = base3(ct, x1, x2, x3, x4),\n\t                ybase = base3(ct, y1, y2, y3, y4),\n\t                comb = xbase * xbase + ybase * ybase;\n\t            sum += Cvalues[i] * math.sqrt(comb);\n\t        }\n\t        return z2 * sum;\n\t    }\n\t    function getTotLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {\n\t        if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {\n\t            return;\n\t        }\n\t        var t = 1,\n\t            step = t / 2,\n\t            t2 = t - step,\n\t            l,\n\t            e = .01;\n\t        l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);\n\t        while (abs(l - ll) > e) {\n\t            step /= 2;\n\t            t2 += (l < ll ? 1 : -1) * step;\n\t            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);\n\t        }\n\t        return t2;\n\t    }\n\t    function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {\n\t        if (\n\t            mmax(x1, x2) < mmin(x3, x4) ||\n\t            mmin(x1, x2) > mmax(x3, x4) ||\n\t            mmax(y1, y2) < mmin(y3, y4) ||\n\t            mmin(y1, y2) > mmax(y3, y4)\n\t        ) {\n\t            return;\n\t        }\n\t        var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n\t            ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n\t            denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n\t\n\t        if (!denominator) {\n\t            return;\n\t        }\n\t        var px = nx / denominator,\n\t            py = ny / denominator,\n\t            px2 = +px.toFixed(2),\n\t            py2 = +py.toFixed(2);\n\t        if (\n\t            px2 < +mmin(x1, x2).toFixed(2) ||\n\t            px2 > +mmax(x1, x2).toFixed(2) ||\n\t            px2 < +mmin(x3, x4).toFixed(2) ||\n\t            px2 > +mmax(x3, x4).toFixed(2) ||\n\t            py2 < +mmin(y1, y2).toFixed(2) ||\n\t            py2 > +mmax(y1, y2).toFixed(2) ||\n\t            py2 < +mmin(y3, y4).toFixed(2) ||\n\t            py2 > +mmax(y3, y4).toFixed(2)\n\t        ) {\n\t            return;\n\t        }\n\t        return {x: px, y: py};\n\t    }\n\t    function inter(bez1, bez2) {\n\t        return interHelper(bez1, bez2);\n\t    }\n\t    function interCount(bez1, bez2) {\n\t        return interHelper(bez1, bez2, 1);\n\t    }\n\t    function interHelper(bez1, bez2, justCount) {\n\t        var bbox1 = bezierBBox(bez1),\n\t            bbox2 = bezierBBox(bez2);\n\t        if (!isBBoxIntersect(bbox1, bbox2)) {\n\t            return justCount ? 0 : [];\n\t        }\n\t        var l1 = bezlen.apply(0, bez1),\n\t            l2 = bezlen.apply(0, bez2),\n\t            n1 = ~~(l1 / 8),\n\t            n2 = ~~(l2 / 8),\n\t            dots1 = [],\n\t            dots2 = [],\n\t            xy = {},\n\t            res = justCount ? 0 : [];\n\t        for (var i = 0; i < n1 + 1; i++) {\n\t            var p = findDotsAtSegment.apply(0, bez1.concat(i / n1));\n\t            dots1.push({x: p.x, y: p.y, t: i / n1});\n\t        }\n\t        for (i = 0; i < n2 + 1; i++) {\n\t            p = findDotsAtSegment.apply(0, bez2.concat(i / n2));\n\t            dots2.push({x: p.x, y: p.y, t: i / n2});\n\t        }\n\t        for (i = 0; i < n1; i++) {\n\t            for (var j = 0; j < n2; j++) {\n\t                var di = dots1[i],\n\t                    di1 = dots1[i + 1],\n\t                    dj = dots2[j],\n\t                    dj1 = dots2[j + 1],\n\t                    ci = abs(di1.x - di.x) < .001 ? \"y\" : \"x\",\n\t                    cj = abs(dj1.x - dj.x) < .001 ? \"y\" : \"x\",\n\t                    is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);\n\t                if (is) {\n\t                    if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {\n\t                        continue;\n\t                    }\n\t                    xy[is.x.toFixed(4)] = is.y.toFixed(4);\n\t                    var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),\n\t                        t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);\n\t                    if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {\n\t                        if (justCount) {\n\t                            res++;\n\t                        } else {\n\t                            res.push({\n\t                                x: is.x,\n\t                                y: is.y,\n\t                                t1: t1,\n\t                                t2: t2\n\t                            });\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return res;\n\t    }\n\t    function pathIntersection(path1, path2) {\n\t        return interPathHelper(path1, path2);\n\t    }\n\t    function pathIntersectionNumber(path1, path2) {\n\t        return interPathHelper(path1, path2, 1);\n\t    }\n\t    function interPathHelper(path1, path2, justCount) {\n\t        path1 = path2curve(path1);\n\t        path2 = path2curve(path2);\n\t        var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,\n\t            res = justCount ? 0 : [];\n\t        for (var i = 0, ii = path1.length; i < ii; i++) {\n\t            var pi = path1[i];\n\t            if (pi[0] == \"M\") {\n\t                x1 = x1m = pi[1];\n\t                y1 = y1m = pi[2];\n\t            } else {\n\t                if (pi[0] == \"C\") {\n\t                    bez1 = [x1, y1].concat(pi.slice(1));\n\t                    x1 = bez1[6];\n\t                    y1 = bez1[7];\n\t                } else {\n\t                    bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];\n\t                    x1 = x1m;\n\t                    y1 = y1m;\n\t                }\n\t                for (var j = 0, jj = path2.length; j < jj; j++) {\n\t                    var pj = path2[j];\n\t                    if (pj[0] == \"M\") {\n\t                        x2 = x2m = pj[1];\n\t                        y2 = y2m = pj[2];\n\t                    } else {\n\t                        if (pj[0] == \"C\") {\n\t                            bez2 = [x2, y2].concat(pj.slice(1));\n\t                            x2 = bez2[6];\n\t                            y2 = bez2[7];\n\t                        } else {\n\t                            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];\n\t                            x2 = x2m;\n\t                            y2 = y2m;\n\t                        }\n\t                        var intr = interHelper(bez1, bez2, justCount);\n\t                        if (justCount) {\n\t                            res += intr;\n\t                        } else {\n\t                            for (var k = 0, kk = intr.length; k < kk; k++) {\n\t                                intr[k].segment1 = i;\n\t                                intr[k].segment2 = j;\n\t                                intr[k].bez1 = bez1;\n\t                                intr[k].bez2 = bez2;\n\t                            }\n\t                            res = res.concat(intr);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return res;\n\t    }\n\t    function isPointInsidePath(path, x, y) {\n\t        var bbox = pathBBox(path);\n\t        return isPointInsideBBox(bbox, x, y) &&\n\t               interPathHelper(path, [[\"M\", x, y], [\"H\", bbox.x2 + 10]], 1) % 2 == 1;\n\t    }\n\t    function pathBBox(path) {\n\t        var pth = paths(path);\n\t        if (pth.bbox) {\n\t            return clone(pth.bbox);\n\t        }\n\t        if (!path) {\n\t            return box();\n\t        }\n\t        path = path2curve(path);\n\t        var x = 0, \n\t            y = 0,\n\t            X = [],\n\t            Y = [],\n\t            p;\n\t        for (var i = 0, ii = path.length; i < ii; i++) {\n\t            p = path[i];\n\t            if (p[0] == \"M\") {\n\t                x = p[1];\n\t                y = p[2];\n\t                X.push(x);\n\t                Y.push(y);\n\t            } else {\n\t                var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);\n\t                X = X.concat(dim.min.x, dim.max.x);\n\t                Y = Y.concat(dim.min.y, dim.max.y);\n\t                x = p[5];\n\t                y = p[6];\n\t            }\n\t        }\n\t        var xmin = mmin.apply(0, X),\n\t            ymin = mmin.apply(0, Y),\n\t            xmax = mmax.apply(0, X),\n\t            ymax = mmax.apply(0, Y),\n\t            bb = box(xmin, ymin, xmax - xmin, ymax - ymin);\n\t        pth.bbox = clone(bb);\n\t        return bb;\n\t    }\n\t    function rectPath(x, y, w, h, r) {\n\t        if (r) {\n\t            return [\n\t                [\"M\", +x + (+r), y],\n\t                [\"l\", w - r * 2, 0],\n\t                [\"a\", r, r, 0, 0, 1, r, r],\n\t                [\"l\", 0, h - r * 2],\n\t                [\"a\", r, r, 0, 0, 1, -r, r],\n\t                [\"l\", r * 2 - w, 0],\n\t                [\"a\", r, r, 0, 0, 1, -r, -r],\n\t                [\"l\", 0, r * 2 - h],\n\t                [\"a\", r, r, 0, 0, 1, r, -r],\n\t                [\"z\"]\n\t            ];\n\t        }\n\t        var res = [[\"M\", x, y], [\"l\", w, 0], [\"l\", 0, h], [\"l\", -w, 0], [\"z\"]];\n\t        res.toString = toString;\n\t        return res;\n\t    }\n\t    function ellipsePath(x, y, rx, ry, a) {\n\t        if (a == null && ry == null) {\n\t            ry = rx;\n\t        }\n\t        x = +x;\n\t        y = +y;\n\t        rx = +rx;\n\t        ry = +ry;\n\t        if (a != null) {\n\t            var rad = Math.PI / 180,\n\t                x1 = x + rx * Math.cos(-ry * rad),\n\t                x2 = x + rx * Math.cos(-a * rad),\n\t                y1 = y + rx * Math.sin(-ry * rad),\n\t                y2 = y + rx * Math.sin(-a * rad),\n\t                res = [[\"M\", x1, y1], [\"A\", rx, rx, 0, +(a - ry > 180), 0, x2, y2]];\n\t        } else {\n\t            res = [\n\t                [\"M\", x, y],\n\t                [\"m\", 0, -ry],\n\t                [\"a\", rx, ry, 0, 1, 1, 0, 2 * ry],\n\t                [\"a\", rx, ry, 0, 1, 1, 0, -2 * ry],\n\t                [\"z\"]\n\t            ];\n\t        }\n\t        res.toString = toString;\n\t        return res;\n\t    }\n\t    var unit2px = Snap._unit2px,\n\t        getPath = {\n\t        path: function (el) {\n\t            return el.attr(\"path\");\n\t        },\n\t        circle: function (el) {\n\t            var attr = unit2px(el);\n\t            return ellipsePath(attr.cx, attr.cy, attr.r);\n\t        },\n\t        ellipse: function (el) {\n\t            var attr = unit2px(el);\n\t            return ellipsePath(attr.cx || 0, attr.cy || 0, attr.rx, attr.ry);\n\t        },\n\t        rect: function (el) {\n\t            var attr = unit2px(el);\n\t            return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height, attr.rx, attr.ry);\n\t        },\n\t        image: function (el) {\n\t            var attr = unit2px(el);\n\t            return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height);\n\t        },\n\t        line: function (el) {\n\t            return \"M\" + [el.attr(\"x1\") || 0, el.attr(\"y1\") || 0, el.attr(\"x2\"), el.attr(\"y2\")];\n\t        },\n\t        polyline: function (el) {\n\t            return \"M\" + el.attr(\"points\");\n\t        },\n\t        polygon: function (el) {\n\t            return \"M\" + el.attr(\"points\") + \"z\";\n\t        },\n\t        deflt: function (el) {\n\t            var bbox = el.node.getBBox();\n\t            return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);\n\t        }\n\t    };\n\t    function pathToRelative(pathArray) {\n\t        var pth = paths(pathArray),\n\t            lowerCase = String.prototype.toLowerCase;\n\t        if (pth.rel) {\n\t            return pathClone(pth.rel);\n\t        }\n\t        if (!Snap.is(pathArray, \"array\") || !Snap.is(pathArray && pathArray[0], \"array\")) {\n\t            pathArray = Snap.parsePathString(pathArray);\n\t        }\n\t        var res = [],\n\t            x = 0,\n\t            y = 0,\n\t            mx = 0,\n\t            my = 0,\n\t            start = 0;\n\t        if (pathArray[0][0] == \"M\") {\n\t            x = pathArray[0][1];\n\t            y = pathArray[0][2];\n\t            mx = x;\n\t            my = y;\n\t            start++;\n\t            res.push([\"M\", x, y]);\n\t        }\n\t        for (var i = start, ii = pathArray.length; i < ii; i++) {\n\t            var r = res[i] = [],\n\t                pa = pathArray[i];\n\t            if (pa[0] != lowerCase.call(pa[0])) {\n\t                r[0] = lowerCase.call(pa[0]);\n\t                switch (r[0]) {\n\t                    case \"a\":\n\t                        r[1] = pa[1];\n\t                        r[2] = pa[2];\n\t                        r[3] = pa[3];\n\t                        r[4] = pa[4];\n\t                        r[5] = pa[5];\n\t                        r[6] = +(pa[6] - x).toFixed(3);\n\t                        r[7] = +(pa[7] - y).toFixed(3);\n\t                        break;\n\t                    case \"v\":\n\t                        r[1] = +(pa[1] - y).toFixed(3);\n\t                        break;\n\t                    case \"m\":\n\t                        mx = pa[1];\n\t                        my = pa[2];\n\t                    default:\n\t                        for (var j = 1, jj = pa.length; j < jj; j++) {\n\t                            r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);\n\t                        }\n\t                }\n\t            } else {\n\t                r = res[i] = [];\n\t                if (pa[0] == \"m\") {\n\t                    mx = pa[1] + x;\n\t                    my = pa[2] + y;\n\t                }\n\t                for (var k = 0, kk = pa.length; k < kk; k++) {\n\t                    res[i][k] = pa[k];\n\t                }\n\t            }\n\t            var len = res[i].length;\n\t            switch (res[i][0]) {\n\t                case \"z\":\n\t                    x = mx;\n\t                    y = my;\n\t                    break;\n\t                case \"h\":\n\t                    x += +res[i][len - 1];\n\t                    break;\n\t                case \"v\":\n\t                    y += +res[i][len - 1];\n\t                    break;\n\t                default:\n\t                    x += +res[i][len - 2];\n\t                    y += +res[i][len - 1];\n\t            }\n\t        }\n\t        res.toString = toString;\n\t        pth.rel = pathClone(res);\n\t        return res;\n\t    }\n\t    function pathToAbsolute(pathArray) {\n\t        var pth = paths(pathArray);\n\t        if (pth.abs) {\n\t            return pathClone(pth.abs);\n\t        }\n\t        if (!is(pathArray, \"array\") || !is(pathArray && pathArray[0], \"array\")) { // rough assumption\n\t            pathArray = Snap.parsePathString(pathArray);\n\t        }\n\t        if (!pathArray || !pathArray.length) {\n\t            return [[\"M\", 0, 0]];\n\t        }\n\t        var res = [],\n\t            x = 0,\n\t            y = 0,\n\t            mx = 0,\n\t            my = 0,\n\t            start = 0,\n\t            pa0;\n\t        if (pathArray[0][0] == \"M\") {\n\t            x = +pathArray[0][1];\n\t            y = +pathArray[0][2];\n\t            mx = x;\n\t            my = y;\n\t            start++;\n\t            res[0] = [\"M\", x, y];\n\t        }\n\t        var crz = pathArray.length == 3 &&\n\t            pathArray[0][0] == \"M\" &&\n\t            pathArray[1][0].toUpperCase() == \"R\" &&\n\t            pathArray[2][0].toUpperCase() == \"Z\";\n\t        for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {\n\t            res.push(r = []);\n\t            pa = pathArray[i];\n\t            pa0 = pa[0];\n\t            if (pa0 != pa0.toUpperCase()) {\n\t                r[0] = pa0.toUpperCase();\n\t                switch (r[0]) {\n\t                    case \"A\":\n\t                        r[1] = pa[1];\n\t                        r[2] = pa[2];\n\t                        r[3] = pa[3];\n\t                        r[4] = pa[4];\n\t                        r[5] = pa[5];\n\t                        r[6] = +pa[6] + x;\n\t                        r[7] = +pa[7] + y;\n\t                        break;\n\t                    case \"V\":\n\t                        r[1] = +pa[1] + y;\n\t                        break;\n\t                    case \"H\":\n\t                        r[1] = +pa[1] + x;\n\t                        break;\n\t                    case \"R\":\n\t                        var dots = [x, y].concat(pa.slice(1));\n\t                        for (var j = 2, jj = dots.length; j < jj; j++) {\n\t                            dots[j] = +dots[j] + x;\n\t                            dots[++j] = +dots[j] + y;\n\t                        }\n\t                        res.pop();\n\t                        res = res.concat(catmullRom2bezier(dots, crz));\n\t                        break;\n\t                    case \"O\":\n\t                        res.pop();\n\t                        dots = ellipsePath(x, y, pa[1], pa[2]);\n\t                        dots.push(dots[0]);\n\t                        res = res.concat(dots);\n\t                        break;\n\t                    case \"U\":\n\t                        res.pop();\n\t                        res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));\n\t                        r = [\"U\"].concat(res[res.length - 1].slice(-2));\n\t                        break;\n\t                    case \"M\":\n\t                        mx = +pa[1] + x;\n\t                        my = +pa[2] + y;\n\t                    default:\n\t                        for (j = 1, jj = pa.length; j < jj; j++) {\n\t                            r[j] = +pa[j] + ((j % 2) ? x : y);\n\t                        }\n\t                }\n\t            } else if (pa0 == \"R\") {\n\t                dots = [x, y].concat(pa.slice(1));\n\t                res.pop();\n\t                res = res.concat(catmullRom2bezier(dots, crz));\n\t                r = [\"R\"].concat(pa.slice(-2));\n\t            } else if (pa0 == \"O\") {\n\t                res.pop();\n\t                dots = ellipsePath(x, y, pa[1], pa[2]);\n\t                dots.push(dots[0]);\n\t                res = res.concat(dots);\n\t            } else if (pa0 == \"U\") {\n\t                res.pop();\n\t                res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));\n\t                r = [\"U\"].concat(res[res.length - 1].slice(-2));\n\t            } else {\n\t                for (var k = 0, kk = pa.length; k < kk; k++) {\n\t                    r[k] = pa[k];\n\t                }\n\t            }\n\t            pa0 = pa0.toUpperCase();\n\t            if (pa0 != \"O\") {\n\t                switch (r[0]) {\n\t                    case \"Z\":\n\t                        x = +mx;\n\t                        y = +my;\n\t                        break;\n\t                    case \"H\":\n\t                        x = r[1];\n\t                        break;\n\t                    case \"V\":\n\t                        y = r[1];\n\t                        break;\n\t                    case \"M\":\n\t                        mx = r[r.length - 2];\n\t                        my = r[r.length - 1];\n\t                    default:\n\t                        x = r[r.length - 2];\n\t                        y = r[r.length - 1];\n\t                }\n\t            }\n\t        }\n\t        res.toString = toString;\n\t        pth.abs = pathClone(res);\n\t        return res;\n\t    }\n\t    function l2c(x1, y1, x2, y2) {\n\t        return [x1, y1, x2, y2, x2, y2];\n\t    }\n\t    function q2c(x1, y1, ax, ay, x2, y2) {\n\t        var _13 = 1 / 3,\n\t            _23 = 2 / 3;\n\t        return [\n\t                _13 * x1 + _23 * ax,\n\t                _13 * y1 + _23 * ay,\n\t                _13 * x2 + _23 * ax,\n\t                _13 * y2 + _23 * ay,\n\t                x2,\n\t                y2\n\t            ];\n\t    }\n\t    function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n\t        // for more information of where this math came from visit:\n\t        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n\t        var _120 = PI * 120 / 180,\n\t            rad = PI / 180 * (+angle || 0),\n\t            res = [],\n\t            xy,\n\t            rotate = Snap._.cacher(function (x, y, rad) {\n\t                var X = x * math.cos(rad) - y * math.sin(rad),\n\t                    Y = x * math.sin(rad) + y * math.cos(rad);\n\t                return {x: X, y: Y};\n\t            });\n\t        if (!recursive) {\n\t            xy = rotate(x1, y1, -rad);\n\t            x1 = xy.x;\n\t            y1 = xy.y;\n\t            xy = rotate(x2, y2, -rad);\n\t            x2 = xy.x;\n\t            y2 = xy.y;\n\t            var cos = math.cos(PI / 180 * angle),\n\t                sin = math.sin(PI / 180 * angle),\n\t                x = (x1 - x2) / 2,\n\t                y = (y1 - y2) / 2;\n\t            var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);\n\t            if (h > 1) {\n\t                h = math.sqrt(h);\n\t                rx = h * rx;\n\t                ry = h * ry;\n\t            }\n\t            var rx2 = rx * rx,\n\t                ry2 = ry * ry,\n\t                k = (large_arc_flag == sweep_flag ? -1 : 1) *\n\t                    math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),\n\t                cx = k * rx * y / ry + (x1 + x2) / 2,\n\t                cy = k * -ry * x / rx + (y1 + y2) / 2,\n\t                f1 = math.asin(((y1 - cy) / ry).toFixed(9)),\n\t                f2 = math.asin(((y2 - cy) / ry).toFixed(9));\n\t\n\t            f1 = x1 < cx ? PI - f1 : f1;\n\t            f2 = x2 < cx ? PI - f2 : f2;\n\t            f1 < 0 && (f1 = PI * 2 + f1);\n\t            f2 < 0 && (f2 = PI * 2 + f2);\n\t            if (sweep_flag && f1 > f2) {\n\t                f1 = f1 - PI * 2;\n\t            }\n\t            if (!sweep_flag && f2 > f1) {\n\t                f2 = f2 - PI * 2;\n\t            }\n\t        } else {\n\t            f1 = recursive[0];\n\t            f2 = recursive[1];\n\t            cx = recursive[2];\n\t            cy = recursive[3];\n\t        }\n\t        var df = f2 - f1;\n\t        if (abs(df) > _120) {\n\t            var f2old = f2,\n\t                x2old = x2,\n\t                y2old = y2;\n\t            f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n\t            x2 = cx + rx * math.cos(f2);\n\t            y2 = cy + ry * math.sin(f2);\n\t            res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n\t        }\n\t        df = f2 - f1;\n\t        var c1 = math.cos(f1),\n\t            s1 = math.sin(f1),\n\t            c2 = math.cos(f2),\n\t            s2 = math.sin(f2),\n\t            t = math.tan(df / 4),\n\t            hx = 4 / 3 * rx * t,\n\t            hy = 4 / 3 * ry * t,\n\t            m1 = [x1, y1],\n\t            m2 = [x1 + hx * s1, y1 - hy * c1],\n\t            m3 = [x2 + hx * s2, y2 - hy * c2],\n\t            m4 = [x2, y2];\n\t        m2[0] = 2 * m1[0] - m2[0];\n\t        m2[1] = 2 * m1[1] - m2[1];\n\t        if (recursive) {\n\t            return [m2, m3, m4].concat(res);\n\t        } else {\n\t            res = [m2, m3, m4].concat(res).join().split(\",\");\n\t            var newres = [];\n\t            for (var i = 0, ii = res.length; i < ii; i++) {\n\t                newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;\n\t            }\n\t            return newres;\n\t        }\n\t    }\n\t    function findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {\n\t        var t1 = 1 - t;\n\t        return {\n\t            x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,\n\t            y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y\n\t        };\n\t    }\n\t    \n\t    // Returns bounding box of cubic bezier curve.\n\t    // Source: http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html\n\t    // Original version: NISHIO Hirokazu\n\t    // Modifications: https://github.com/timo22345\n\t    function curveDim(x0, y0, x1, y1, x2, y2, x3, y3) {\n\t        var tvalues = [],\n\t            bounds = [[], []],\n\t            a, b, c, t, t1, t2, b2ac, sqrtb2ac;\n\t        for (var i = 0; i < 2; ++i) {\n\t            if (i == 0) {\n\t                b = 6 * x0 - 12 * x1 + 6 * x2;\n\t                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n\t                c = 3 * x1 - 3 * x0;\n\t            } else {\n\t                b = 6 * y0 - 12 * y1 + 6 * y2;\n\t                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n\t                c = 3 * y1 - 3 * y0;\n\t            }\n\t            if (abs(a) < 1e-12) {\n\t                if (abs(b) < 1e-12) {\n\t                    continue;\n\t                }\n\t                t = -c / b;\n\t                if (0 < t && t < 1) {\n\t                    tvalues.push(t);\n\t                }\n\t                continue;\n\t            }\n\t            b2ac = b * b - 4 * c * a;\n\t            sqrtb2ac = math.sqrt(b2ac);\n\t            if (b2ac < 0) {\n\t                continue;\n\t            }\n\t            t1 = (-b + sqrtb2ac) / (2 * a);\n\t            if (0 < t1 && t1 < 1) {\n\t                tvalues.push(t1);\n\t            }\n\t            t2 = (-b - sqrtb2ac) / (2 * a);\n\t            if (0 < t2 && t2 < 1) {\n\t                tvalues.push(t2);\n\t            }\n\t        }\n\t\n\t        var x, y, j = tvalues.length,\n\t            jlen = j,\n\t            mt;\n\t        while (j--) {\n\t            t = tvalues[j];\n\t            mt = 1 - t;\n\t            bounds[0][j] = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);\n\t            bounds[1][j] = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);\n\t        }\n\t\n\t        bounds[0][jlen] = x0;\n\t        bounds[1][jlen] = y0;\n\t        bounds[0][jlen + 1] = x3;\n\t        bounds[1][jlen + 1] = y3;\n\t        bounds[0].length = bounds[1].length = jlen + 2;\n\t\n\t\n\t        return {\n\t          min: {x: mmin.apply(0, bounds[0]), y: mmin.apply(0, bounds[1])},\n\t          max: {x: mmax.apply(0, bounds[0]), y: mmax.apply(0, bounds[1])}\n\t        };\n\t    }\n\t\n\t    function path2curve(path, path2) {\n\t        var pth = !path2 && paths(path);\n\t        if (!path2 && pth.curve) {\n\t            return pathClone(pth.curve);\n\t        }\n\t        var p = pathToAbsolute(path),\n\t            p2 = path2 && pathToAbsolute(path2),\n\t            attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},\n\t            attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},\n\t            processPath = function (path, d, pcom) {\n\t                var nx, ny;\n\t                if (!path) {\n\t                    return [\"C\", d.x, d.y, d.x, d.y, d.x, d.y];\n\t                }\n\t                !(path[0] in {T: 1, Q: 1}) && (d.qx = d.qy = null);\n\t                switch (path[0]) {\n\t                    case \"M\":\n\t                        d.X = path[1];\n\t                        d.Y = path[2];\n\t                        break;\n\t                    case \"A\":\n\t                        path = [\"C\"].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));\n\t                        break;\n\t                    case \"S\":\n\t                        if (pcom == \"C\" || pcom == \"S\") { // In \"S\" case we have to take into account, if the previous command is C/S.\n\t                            nx = d.x * 2 - d.bx;          // And reflect the previous\n\t                            ny = d.y * 2 - d.by;          // command's control point relative to the current point.\n\t                        }\n\t                        else {                            // or some else or nothing\n\t                            nx = d.x;\n\t                            ny = d.y;\n\t                        }\n\t                        path = [\"C\", nx, ny].concat(path.slice(1));\n\t                        break;\n\t                    case \"T\":\n\t                        if (pcom == \"Q\" || pcom == \"T\") { // In \"T\" case we have to take into account, if the previous command is Q/T.\n\t                            d.qx = d.x * 2 - d.qx;        // And make a reflection similar\n\t                            d.qy = d.y * 2 - d.qy;        // to case \"S\".\n\t                        }\n\t                        else {                            // or something else or nothing\n\t                            d.qx = d.x;\n\t                            d.qy = d.y;\n\t                        }\n\t                        path = [\"C\"].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));\n\t                        break;\n\t                    case \"Q\":\n\t                        d.qx = path[1];\n\t                        d.qy = path[2];\n\t                        path = [\"C\"].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));\n\t                        break;\n\t                    case \"L\":\n\t                        path = [\"C\"].concat(l2c(d.x, d.y, path[1], path[2]));\n\t                        break;\n\t                    case \"H\":\n\t                        path = [\"C\"].concat(l2c(d.x, d.y, path[1], d.y));\n\t                        break;\n\t                    case \"V\":\n\t                        path = [\"C\"].concat(l2c(d.x, d.y, d.x, path[1]));\n\t                        break;\n\t                    case \"Z\":\n\t                        path = [\"C\"].concat(l2c(d.x, d.y, d.X, d.Y));\n\t                        break;\n\t                }\n\t                return path;\n\t            },\n\t            fixArc = function (pp, i) {\n\t                if (pp[i].length > 7) {\n\t                    pp[i].shift();\n\t                    var pi = pp[i];\n\t                    while (pi.length) {\n\t                        pcoms1[i] = \"A\"; // if created multiple C:s, their original seg is saved\n\t                        p2 && (pcoms2[i] = \"A\"); // the same as above\n\t                        pp.splice(i++, 0, [\"C\"].concat(pi.splice(0, 6)));\n\t                    }\n\t                    pp.splice(i, 1);\n\t                    ii = mmax(p.length, p2 && p2.length || 0);\n\t                }\n\t            },\n\t            fixM = function (path1, path2, a1, a2, i) {\n\t                if (path1 && path2 && path1[i][0] == \"M\" && path2[i][0] != \"M\") {\n\t                    path2.splice(i, 0, [\"M\", a2.x, a2.y]);\n\t                    a1.bx = 0;\n\t                    a1.by = 0;\n\t                    a1.x = path1[i][1];\n\t                    a1.y = path1[i][2];\n\t                    ii = mmax(p.length, p2 && p2.length || 0);\n\t                }\n\t            },\n\t            pcoms1 = [], // path commands of original path p\n\t            pcoms2 = [], // path commands of original path p2\n\t            pfirst = \"\", // temporary holder for original path command\n\t            pcom = \"\"; // holder for previous path command of original path\n\t        for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {\n\t            p[i] && (pfirst = p[i][0]); // save current path command\n\t\n\t            if (pfirst != \"C\") // C is not saved yet, because it may be result of conversion\n\t            {\n\t                pcoms1[i] = pfirst; // Save current path command\n\t                i && ( pcom = pcoms1[i - 1]); // Get previous path command pcom\n\t            }\n\t            p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\n\t\n\t            if (pcoms1[i] != \"A\" && pfirst == \"C\") pcoms1[i] = \"C\"; // A is the only command\n\t            // which may produce multiple C:s\n\t            // so we have to make sure that C is also C in original path\n\t\n\t            fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1\n\t\n\t            if (p2) { // the same procedures is done to p2\n\t                p2[i] && (pfirst = p2[i][0]);\n\t                if (pfirst != \"C\") {\n\t                    pcoms2[i] = pfirst;\n\t                    i && (pcom = pcoms2[i - 1]);\n\t                }\n\t                p2[i] = processPath(p2[i], attrs2, pcom);\n\t\n\t                if (pcoms2[i] != \"A\" && pfirst == \"C\") {\n\t                    pcoms2[i] = \"C\";\n\t                }\n\t\n\t                fixArc(p2, i);\n\t            }\n\t            fixM(p, p2, attrs, attrs2, i);\n\t            fixM(p2, p, attrs2, attrs, i);\n\t            var seg = p[i],\n\t                seg2 = p2 && p2[i],\n\t                seglen = seg.length,\n\t                seg2len = p2 && seg2.length;\n\t            attrs.x = seg[seglen - 2];\n\t            attrs.y = seg[seglen - 1];\n\t            attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;\n\t            attrs.by = toFloat(seg[seglen - 3]) || attrs.y;\n\t            attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);\n\t            attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);\n\t            attrs2.x = p2 && seg2[seg2len - 2];\n\t            attrs2.y = p2 && seg2[seg2len - 1];\n\t        }\n\t        if (!p2) {\n\t            pth.curve = pathClone(p);\n\t        }\n\t        return p2 ? [p, p2] : p;\n\t    }\n\t    function mapPath(path, matrix) {\n\t        if (!matrix) {\n\t            return path;\n\t        }\n\t        var x, y, i, j, ii, jj, pathi;\n\t        path = path2curve(path);\n\t        for (i = 0, ii = path.length; i < ii; i++) {\n\t            pathi = path[i];\n\t            for (j = 1, jj = pathi.length; j < jj; j += 2) {\n\t                x = matrix.x(pathi[j], pathi[j + 1]);\n\t                y = matrix.y(pathi[j], pathi[j + 1]);\n\t                pathi[j] = x;\n\t                pathi[j + 1] = y;\n\t            }\n\t        }\n\t        return path;\n\t    }\n\t\n\t    // http://schepers.cc/getting-to-the-point\n\t    function catmullRom2bezier(crp, z) {\n\t        var d = [];\n\t        for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {\n\t            var p = [\n\t                        {x: +crp[i - 2], y: +crp[i - 1]},\n\t                        {x: +crp[i],     y: +crp[i + 1]},\n\t                        {x: +crp[i + 2], y: +crp[i + 3]},\n\t                        {x: +crp[i + 4], y: +crp[i + 5]}\n\t                    ];\n\t            if (z) {\n\t                if (!i) {\n\t                    p[0] = {x: +crp[iLen - 2], y: +crp[iLen - 1]};\n\t                } else if (iLen - 4 == i) {\n\t                    p[3] = {x: +crp[0], y: +crp[1]};\n\t                } else if (iLen - 2 == i) {\n\t                    p[2] = {x: +crp[0], y: +crp[1]};\n\t                    p[3] = {x: +crp[2], y: +crp[3]};\n\t                }\n\t            } else {\n\t                if (iLen - 4 == i) {\n\t                    p[3] = p[2];\n\t                } else if (!i) {\n\t                    p[0] = {x: +crp[i], y: +crp[i + 1]};\n\t                }\n\t            }\n\t            d.push([\"C\",\n\t                  (-p[0].x + 6 * p[1].x + p[2].x) / 6,\n\t                  (-p[0].y + 6 * p[1].y + p[2].y) / 6,\n\t                  (p[1].x + 6 * p[2].x - p[3].x) / 6,\n\t                  (p[1].y + 6*p[2].y - p[3].y) / 6,\n\t                  p[2].x,\n\t                  p[2].y\n\t            ]);\n\t        }\n\t\n\t        return d;\n\t    }\n\t\n\t    // export\n\t    Snap.path = paths;\n\t\n\t    /*\\\n\t     * Snap.path.getTotalLength\n\t     [ method ]\n\t     **\n\t     * Returns the length of the given path in pixels\n\t     **\n\t     - path (string) SVG path string\n\t     **\n\t     = (number) length\n\t    \\*/\n\t    Snap.path.getTotalLength = getTotalLength;\n\t    /*\\\n\t     * Snap.path.getPointAtLength\n\t     [ method ]\n\t     **\n\t     * Returns the coordinates of the point located at the given length along the given path\n\t     **\n\t     - path (string) SVG path string\n\t     - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps\n\t     **\n\t     = (object) representation of the point:\n\t     o {\n\t     o     x: (number) x coordinate,\n\t     o     y: (number) y coordinate,\n\t     o     alpha: (number) angle of derivative\n\t     o }\n\t    \\*/\n\t    Snap.path.getPointAtLength = getPointAtLength;\n\t    /*\\\n\t     * Snap.path.getSubpath\n\t     [ method ]\n\t     **\n\t     * Returns the subpath of a given path between given start and end lengths\n\t     **\n\t     - path (string) SVG path string\n\t     - from (number) length, in pixels, from the start of the path to the start of the segment\n\t     - to (number) length, in pixels, from the start of the path to the end of the segment\n\t     **\n\t     = (string) path string definition for the segment\n\t    \\*/\n\t    Snap.path.getSubpath = function (path, from, to) {\n\t        if (this.getTotalLength(path) - to < 1e-6) {\n\t            return getSubpathsAtLength(path, from).end;\n\t        }\n\t        var a = getSubpathsAtLength(path, to, 1);\n\t        return from ? getSubpathsAtLength(a, from).end : a;\n\t    };\n\t    /*\\\n\t     * Element.getTotalLength\n\t     [ method ]\n\t     **\n\t     * Returns the length of the path in pixels (only works for `path` elements)\n\t     = (number) length\n\t    \\*/\n\t    elproto.getTotalLength = function () {\n\t        if (this.node.getTotalLength) {\n\t            return this.node.getTotalLength();\n\t        }\n\t    };\n\t    // SIERRA Element.getPointAtLength()/Element.getTotalLength(): If a <path> is broken into different segments, is the jump distance to the new coordinates set by the _M_ or _m_ commands calculated as part of the path's total length?\n\t    /*\\\n\t     * Element.getPointAtLength\n\t     [ method ]\n\t     **\n\t     * Returns coordinates of the point located at the given length on the given path (only works for `path` elements)\n\t     **\n\t     - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps\n\t     **\n\t     = (object) representation of the point:\n\t     o {\n\t     o     x: (number) x coordinate,\n\t     o     y: (number) y coordinate,\n\t     o     alpha: (number) angle of derivative\n\t     o }\n\t    \\*/\n\t    elproto.getPointAtLength = function (length) {\n\t        return getPointAtLength(this.attr(\"d\"), length);\n\t    };\n\t    // SIERRA Element.getSubpath(): Similar to the problem for Element.getPointAtLength(). Unclear how this would work for a segmented path. Overall, the concept of _subpath_ and what I'm calling a _segment_ (series of non-_M_ or _Z_ commands) is unclear.\n\t    /*\\\n\t     * Element.getSubpath\n\t     [ method ]\n\t     **\n\t     * Returns subpath of a given element from given start and end lengths (only works for `path` elements)\n\t     **\n\t     - from (number) length, in pixels, from the start of the path to the start of the segment\n\t     - to (number) length, in pixels, from the start of the path to the end of the segment\n\t     **\n\t     = (string) path string definition for the segment\n\t    \\*/\n\t    elproto.getSubpath = function (from, to) {\n\t        return Snap.path.getSubpath(this.attr(\"d\"), from, to);\n\t    };\n\t    Snap._.box = box;\n\t    /*\\\n\t     * Snap.path.findDotsAtSegment\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Finds dot coordinates on the given cubic beziér curve at the given t\n\t     - p1x (number) x of the first point of the curve\n\t     - p1y (number) y of the first point of the curve\n\t     - c1x (number) x of the first anchor of the curve\n\t     - c1y (number) y of the first anchor of the curve\n\t     - c2x (number) x of the second anchor of the curve\n\t     - c2y (number) y of the second anchor of the curve\n\t     - p2x (number) x of the second point of the curve\n\t     - p2y (number) y of the second point of the curve\n\t     - t (number) position on the curve (0..1)\n\t     = (object) point information in format:\n\t     o {\n\t     o     x: (number) x coordinate of the point,\n\t     o     y: (number) y coordinate of the point,\n\t     o     m: {\n\t     o         x: (number) x coordinate of the left anchor,\n\t     o         y: (number) y coordinate of the left anchor\n\t     o     },\n\t     o     n: {\n\t     o         x: (number) x coordinate of the right anchor,\n\t     o         y: (number) y coordinate of the right anchor\n\t     o     },\n\t     o     start: {\n\t     o         x: (number) x coordinate of the start of the curve,\n\t     o         y: (number) y coordinate of the start of the curve\n\t     o     },\n\t     o     end: {\n\t     o         x: (number) x coordinate of the end of the curve,\n\t     o         y: (number) y coordinate of the end of the curve\n\t     o     },\n\t     o     alpha: (number) angle of the curve derivative at the point\n\t     o }\n\t    \\*/\n\t    Snap.path.findDotsAtSegment = findDotsAtSegment;\n\t    /*\\\n\t     * Snap.path.bezierBBox\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Returns the bounding box of a given cubic beziér curve\n\t     - p1x (number) x of the first point of the curve\n\t     - p1y (number) y of the first point of the curve\n\t     - c1x (number) x of the first anchor of the curve\n\t     - c1y (number) y of the first anchor of the curve\n\t     - c2x (number) x of the second anchor of the curve\n\t     - c2y (number) y of the second anchor of the curve\n\t     - p2x (number) x of the second point of the curve\n\t     - p2y (number) y of the second point of the curve\n\t     * or\n\t     - bez (array) array of six points for beziér curve\n\t     = (object) bounding box\n\t     o {\n\t     o     x: (number) x coordinate of the left top point of the box,\n\t     o     y: (number) y coordinate of the left top point of the box,\n\t     o     x2: (number) x coordinate of the right bottom point of the box,\n\t     o     y2: (number) y coordinate of the right bottom point of the box,\n\t     o     width: (number) width of the box,\n\t     o     height: (number) height of the box\n\t     o }\n\t    \\*/\n\t    Snap.path.bezierBBox = bezierBBox;\n\t    /*\\\n\t     * Snap.path.isPointInsideBBox\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Returns `true` if given point is inside bounding box\n\t     - bbox (string) bounding box\n\t     - x (string) x coordinate of the point\n\t     - y (string) y coordinate of the point\n\t     = (boolean) `true` if point is inside\n\t    \\*/\n\t    Snap.path.isPointInsideBBox = isPointInsideBBox;\n\t    Snap.closest = function (x, y, X, Y) {\n\t        var r = 100,\n\t            b = box(x - r / 2, y - r / 2, r, r),\n\t            inside = [],\n\t            getter = X[0].hasOwnProperty(\"x\") ? function (i) {\n\t                return {\n\t                    x: X[i].x,\n\t                    y: X[i].y\n\t                };\n\t            } : function (i) {\n\t                return {\n\t                    x: X[i],\n\t                    y: Y[i]\n\t                };\n\t            },\n\t            found = 0;\n\t        while (r <= 1e6 && !found) {\n\t            for (var i = 0, ii = X.length; i < ii; i++) {\n\t                var xy = getter(i);\n\t                if (isPointInsideBBox(b, xy.x, xy.y)) {\n\t                    found++;\n\t                    inside.push(xy);\n\t                    break;\n\t                }\n\t            }\n\t            if (!found) {\n\t                r *= 2;\n\t                b = box(x - r / 2, y - r / 2, r, r)\n\t            }\n\t        }\n\t        if (r == 1e6) {\n\t            return;\n\t        }\n\t        var len = Infinity,\n\t            res;\n\t        for (i = 0, ii = inside.length; i < ii; i++) {\n\t            var l = Snap.len(x, y, inside[i].x, inside[i].y);\n\t            if (len > l) {\n\t                len = l;\n\t                inside[i].len = l;\n\t                res = inside[i];\n\t            }\n\t        }\n\t        return res;\n\t    };\n\t    /*\\\n\t     * Snap.path.isBBoxIntersect\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Returns `true` if two bounding boxes intersect\n\t     - bbox1 (string) first bounding box\n\t     - bbox2 (string) second bounding box\n\t     = (boolean) `true` if bounding boxes intersect\n\t    \\*/\n\t    Snap.path.isBBoxIntersect = isBBoxIntersect;\n\t    /*\\\n\t     * Snap.path.intersection\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Finds intersections of two paths\n\t     - path1 (string) path string\n\t     - path2 (string) path string\n\t     = (array) dots of intersection\n\t     o [\n\t     o     {\n\t     o         x: (number) x coordinate of the point,\n\t     o         y: (number) y coordinate of the point,\n\t     o         t1: (number) t value for segment of path1,\n\t     o         t2: (number) t value for segment of path2,\n\t     o         segment1: (number) order number for segment of path1,\n\t     o         segment2: (number) order number for segment of path2,\n\t     o         bez1: (array) eight coordinates representing beziér curve for the segment of path1,\n\t     o         bez2: (array) eight coordinates representing beziér curve for the segment of path2\n\t     o     }\n\t     o ]\n\t    \\*/\n\t    Snap.path.intersection = pathIntersection;\n\t    Snap.path.intersectionNumber = pathIntersectionNumber;\n\t    /*\\\n\t     * Snap.path.isPointInside\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Returns `true` if given point is inside a given closed path.\n\t     *\n\t     * Note: fill mode doesn’t affect the result of this method.\n\t     - path (string) path string\n\t     - x (number) x of the point\n\t     - y (number) y of the point\n\t     = (boolean) `true` if point is inside the path\n\t    \\*/\n\t    Snap.path.isPointInside = isPointInsidePath;\n\t    /*\\\n\t     * Snap.path.getBBox\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Returns the bounding box of a given path\n\t     - path (string) path string\n\t     = (object) bounding box\n\t     o {\n\t     o     x: (number) x coordinate of the left top point of the box,\n\t     o     y: (number) y coordinate of the left top point of the box,\n\t     o     x2: (number) x coordinate of the right bottom point of the box,\n\t     o     y2: (number) y coordinate of the right bottom point of the box,\n\t     o     width: (number) width of the box,\n\t     o     height: (number) height of the box\n\t     o }\n\t    \\*/\n\t    Snap.path.getBBox = pathBBox;\n\t    Snap.path.get = getPath;\n\t    /*\\\n\t     * Snap.path.toRelative\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Converts path coordinates into relative values\n\t     - path (string) path string\n\t     = (array) path string\n\t    \\*/\n\t    Snap.path.toRelative = pathToRelative;\n\t    /*\\\n\t     * Snap.path.toAbsolute\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Converts path coordinates into absolute values\n\t     - path (string) path string\n\t     = (array) path string\n\t    \\*/\n\t    Snap.path.toAbsolute = pathToAbsolute;\n\t    /*\\\n\t     * Snap.path.toCubic\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Converts path to a new path where all segments are cubic beziér curves\n\t     - pathString (string|array) path string or array of segments\n\t     = (array) array of segments\n\t    \\*/\n\t    Snap.path.toCubic = path2curve;\n\t    /*\\\n\t     * Snap.path.map\n\t     [ method ]\n\t     **\n\t     * Transform the path string with the given matrix\n\t     - path (string) path string\n\t     - matrix (object) see @Matrix\n\t     = (string) transformed path string\n\t    \\*/\n\t    Snap.path.map = mapPath;\n\t    Snap.path.toString = toString;\n\t    Snap.path.clone = pathClone;\n\t});\n\t\n\t// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t// \n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t// \n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t// \n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tSnap.plugin(function (Snap, Element, Paper, glob) {\n\t    var mmax = Math.max,\n\t        mmin = Math.min;\n\t\n\t    // Set\n\t    var Set = function (items) {\n\t        this.items = [];\n\t\tthis.bindings = {};\n\t        this.length = 0;\n\t        this.type = \"set\";\n\t        if (items) {\n\t            for (var i = 0, ii = items.length; i < ii; i++) {\n\t                if (items[i]) {\n\t                    this[this.items.length] = this.items[this.items.length] = items[i];\n\t                    this.length++;\n\t                }\n\t            }\n\t        }\n\t    },\n\t    setproto = Set.prototype;\n\t    /*\\\n\t     * Set.push\n\t     [ method ]\n\t     **\n\t     * Adds each argument to the current set\n\t     = (object) original element\n\t    \\*/\n\t    setproto.push = function () {\n\t        var item,\n\t            len;\n\t        for (var i = 0, ii = arguments.length; i < ii; i++) {\n\t            item = arguments[i];\n\t            if (item) {\n\t                len = this.items.length;\n\t                this[len] = this.items[len] = item;\n\t                this.length++;\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Set.pop\n\t     [ method ]\n\t     **\n\t     * Removes last element and returns it\n\t     = (object) element\n\t    \\*/\n\t    setproto.pop = function () {\n\t        this.length && delete this[this.length--];\n\t        return this.items.pop();\n\t    };\n\t    /*\\\n\t     * Set.forEach\n\t     [ method ]\n\t     **\n\t     * Executes given function for each element in the set\n\t     *\n\t     * If the function returns `false`, the loop stops running.\n\t     **\n\t     - callback (function) function to run\n\t     - thisArg (object) context object for the callback\n\t     = (object) Set object\n\t    \\*/\n\t    setproto.forEach = function (callback, thisArg) {\n\t        for (var i = 0, ii = this.items.length; i < ii; i++) {\n\t            if (callback.call(thisArg, this.items[i], i) === false) {\n\t                return this;\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Set.animate\n\t     [ method ]\n\t     **\n\t     * Animates each element in set in sync.\n\t     *\n\t     **\n\t     - attrs (object) key-value pairs of destination attributes\n\t     - duration (number) duration of the animation in milliseconds\n\t     - easing (function) #optional easing function from @mina or custom\n\t     - callback (function) #optional callback function that executes when the animation ends\n\t     * or\n\t     - animation (array) array of animation parameter for each element in set in format `[attrs, duration, easing, callback]`\n\t     > Usage\n\t     | // animate all elements in set to radius 10\n\t     | set.animate({r: 10}, 500, mina.easein);\n\t     | // or\n\t     | // animate first element to radius 10, but second to radius 20 and in different time\n\t     | set.animate([{r: 10}, 500, mina.easein], [{r: 20}, 1500, mina.easein]);\n\t     = (Element) the current element\n\t    \\*/\n\t    setproto.animate = function (attrs, ms, easing, callback) {\n\t        if (typeof easing == \"function\" && !easing.length) {\n\t            callback = easing;\n\t            easing = mina.linear;\n\t        }\n\t        if (attrs instanceof Snap._.Animation) {\n\t            callback = attrs.callback;\n\t            easing = attrs.easing;\n\t            ms = easing.dur;\n\t            attrs = attrs.attr;\n\t        }\n\t        var args = arguments;\n\t        if (Snap.is(attrs, \"array\") && Snap.is(args[args.length - 1], \"array\")) {\n\t            var each = true;\n\t        }\n\t        var begin,\n\t            handler = function () {\n\t                if (begin) {\n\t                    this.b = begin;\n\t                } else {\n\t                    begin = this.b;\n\t                }\n\t            },\n\t            cb = 0,\n\t            set = this,\n\t            callbacker = callback && function () {\n\t                if (++cb == set.length) {\n\t                    callback.call(this);\n\t                }\n\t            };\n\t        return this.forEach(function (el, i) {\n\t            eve.once(\"snap.animcreated.\" + el.id, handler);\n\t            if (each) {\n\t                args[i] && el.animate.apply(el, args[i]);\n\t            } else {\n\t                el.animate(attrs, ms, easing, callbacker);\n\t            }\n\t        });\n\t    };\n\t    setproto.remove = function () {\n\t        while (this.length) {\n\t            this.pop().remove();\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Set.bind\n\t     [ method ]\n\t     **\n\t     * Specifies how to handle a specific attribute when applied\n\t     * to a set.\n\t     *\n\t     **\n\t     - attr (string) attribute name\n\t     - callback (function) function to run\n\t     * or\n\t     - attr (string) attribute name\n\t     - element (Element) specific element in the set to apply the attribute to\n\t     * or\n\t     - attr (string) attribute name\n\t     - element (Element) specific element in the set to apply the attribute to\n\t     - eattr (string) attribute on the element to bind the attribute to\n\t     = (object) Set object\n\t    \\*/\n\t    setproto.bind = function (attr, a, b) {\n\t        var data = {};\n\t        if (typeof a == \"function\") {\n\t            this.bindings[attr] = a;\n\t        } else {\n\t            var aname = b || attr;\n\t            this.bindings[attr] = function (v) {\n\t                data[aname] = v;\n\t                a.attr(data);\n\t            };\n\t        }\n\t        return this;\n\t    };\n\t    setproto.attr = function (value) {\n\t        var unbound = {};\n\t        for (var k in value) {\n\t            if (this.bindings[k]) {\n\t                this.bindings[k](value[k]);\n\t            } else {\n\t                unbound[k] = value[k];\n\t            }\n\t        }\n\t        for (var i = 0, ii = this.items.length; i < ii; i++) {\n\t            this.items[i].attr(unbound);\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Set.clear\n\t     [ method ]\n\t     **\n\t     * Removes all elements from the set\n\t    \\*/\n\t    setproto.clear = function () {\n\t        while (this.length) {\n\t            this.pop();\n\t        }\n\t    };\n\t    /*\\\n\t     * Set.splice\n\t     [ method ]\n\t     **\n\t     * Removes range of elements from the set\n\t     **\n\t     - index (number) position of the deletion\n\t     - count (number) number of element to remove\n\t     - insertion… (object) #optional elements to insert\n\t     = (object) set elements that were deleted\n\t    \\*/\n\t    setproto.splice = function (index, count, insertion) {\n\t        index = index < 0 ? mmax(this.length + index, 0) : index;\n\t        count = mmax(0, mmin(this.length - index, count));\n\t        var tail = [],\n\t            todel = [],\n\t            args = [],\n\t            i;\n\t        for (i = 2; i < arguments.length; i++) {\n\t            args.push(arguments[i]);\n\t        }\n\t        for (i = 0; i < count; i++) {\n\t            todel.push(this[index + i]);\n\t        }\n\t        for (; i < this.length - index; i++) {\n\t            tail.push(this[index + i]);\n\t        }\n\t        var arglen = args.length;\n\t        for (i = 0; i < arglen + tail.length; i++) {\n\t            this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];\n\t        }\n\t        i = this.items.length = this.length -= count - arglen;\n\t        while (this[i]) {\n\t            delete this[i++];\n\t        }\n\t        return new Set(todel);\n\t    };\n\t    /*\\\n\t     * Set.exclude\n\t     [ method ]\n\t     **\n\t     * Removes given element from the set\n\t     **\n\t     - element (object) element to remove\n\t     = (boolean) `true` if object was found and removed from the set\n\t    \\*/\n\t    setproto.exclude = function (el) {\n\t        for (var i = 0, ii = this.length; i < ii; i++) if (this[i] == el) {\n\t            this.splice(i, 1);\n\t            return true;\n\t        }\n\t        return false;\n\t    };\n\t    setproto.insertAfter = function (el) {\n\t        var i = this.items.length;\n\t        while (i--) {\n\t            this.items[i].insertAfter(el);\n\t        }\n\t        return this;\n\t    };\n\t    setproto.getBBox = function () {\n\t        var x = [],\n\t            y = [],\n\t            x2 = [],\n\t            y2 = [];\n\t        for (var i = this.items.length; i--;) if (!this.items[i].removed) {\n\t            var box = this.items[i].getBBox();\n\t            x.push(box.x);\n\t            y.push(box.y);\n\t            x2.push(box.x + box.width);\n\t            y2.push(box.y + box.height);\n\t        }\n\t        x = mmin.apply(0, x);\n\t        y = mmin.apply(0, y);\n\t        x2 = mmax.apply(0, x2);\n\t        y2 = mmax.apply(0, y2);\n\t        return {\n\t            x: x,\n\t            y: y,\n\t            x2: x2,\n\t            y2: y2,\n\t            width: x2 - x,\n\t            height: y2 - y,\n\t            cx: x + (x2 - x) / 2,\n\t            cy: y + (y2 - y) / 2\n\t        };\n\t    };\n\t    setproto.clone = function (s) {\n\t        s = new Set;\n\t        for (var i = 0, ii = this.items.length; i < ii; i++) {\n\t            s.push(this.items[i].clone());\n\t        }\n\t        return s;\n\t    };\n\t    setproto.toString = function () {\n\t        return \"Snap\\u2018s set\";\n\t    };\n\t    setproto.type = \"set\";\n\t    // export\n\t    Snap.Set = Set;\n\t    Snap.set = function () {\n\t        var set = new Set;\n\t        if (arguments.length) {\n\t            set.push.apply(set, Array.prototype.slice.call(arguments, 0));\n\t        }\n\t        return set;\n\t    };\n\t});\n\t\n\t// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t// \n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t// \n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t// \n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tSnap.plugin(function (Snap, Element, Paper, glob) {\n\t    var names = {},\n\t        reUnit = /[a-z]+$/i,\n\t        Str = String;\n\t    names.stroke = names.fill = \"colour\";\n\t    function getEmpty(item) {\n\t        var l = item[0];\n\t        switch (l.toLowerCase()) {\n\t            case \"t\": return [l, 0, 0];\n\t            case \"m\": return [l, 1, 0, 0, 1, 0, 0];\n\t            case \"r\": if (item.length == 4) {\n\t                return [l, 0, item[2], item[3]];\n\t            } else {\n\t                return [l, 0];\n\t            }\n\t            case \"s\": if (item.length == 5) {\n\t                return [l, 1, 1, item[3], item[4]];\n\t            } else if (item.length == 3) {\n\t                return [l, 1, 1];\n\t            } else {\n\t                return [l, 1];\n\t            }\n\t        }\n\t    }\n\t    function equaliseTransform(t1, t2, getBBox) {\n\t        t2 = Str(t2).replace(/\\.{3}|\\u2026/g, t1);\n\t        t1 = Snap.parseTransformString(t1) || [];\n\t        t2 = Snap.parseTransformString(t2) || [];\n\t        var maxlength = Math.max(t1.length, t2.length),\n\t            from = [],\n\t            to = [],\n\t            i = 0, j, jj,\n\t            tt1, tt2;\n\t        for (; i < maxlength; i++) {\n\t            tt1 = t1[i] || getEmpty(t2[i]);\n\t            tt2 = t2[i] || getEmpty(tt1);\n\t            if ((tt1[0] != tt2[0]) ||\n\t                (tt1[0].toLowerCase() == \"r\" && (tt1[2] != tt2[2] || tt1[3] != tt2[3])) ||\n\t                (tt1[0].toLowerCase() == \"s\" && (tt1[3] != tt2[3] || tt1[4] != tt2[4]))\n\t                ) {\n\t                    t1 = Snap._.transform2matrix(t1, getBBox());\n\t                    t2 = Snap._.transform2matrix(t2, getBBox());\n\t                    from = [[\"m\", t1.a, t1.b, t1.c, t1.d, t1.e, t1.f]];\n\t                    to = [[\"m\", t2.a, t2.b, t2.c, t2.d, t2.e, t2.f]];\n\t                    break;\n\t            }\n\t            from[i] = [];\n\t            to[i] = [];\n\t            for (j = 0, jj = Math.max(tt1.length, tt2.length); j < jj; j++) {\n\t                j in tt1 && (from[i][j] = tt1[j]);\n\t                j in tt2 && (to[i][j] = tt2[j]);\n\t            }\n\t        }\n\t        return {\n\t            from: path2array(from),\n\t            to: path2array(to),\n\t            f: getPath(from)\n\t        };\n\t    }\n\t    function getNumber(val) {\n\t        return val;\n\t    }\n\t    function getUnit(unit) {\n\t        return function (val) {\n\t            return +val.toFixed(3) + unit;\n\t        };\n\t    }\n\t    function getViewBox(val) {\n\t        return val.join(\" \");\n\t    }\n\t    function getColour(clr) {\n\t        return Snap.rgb(clr[0], clr[1], clr[2]);\n\t    }\n\t    function getPath(path) {\n\t        var k = 0, i, ii, j, jj, out, a, b = [];\n\t        for (i = 0, ii = path.length; i < ii; i++) {\n\t            out = \"[\";\n\t            a = ['\"' + path[i][0] + '\"'];\n\t            for (j = 1, jj = path[i].length; j < jj; j++) {\n\t                a[j] = \"val[\" + (k++) + \"]\";\n\t            }\n\t            out += a + \"]\";\n\t            b[i] = out;\n\t        }\n\t        return Function(\"val\", \"return Snap.path.toString.call([\" + b + \"])\");\n\t    }\n\t    function path2array(path) {\n\t        var out = [];\n\t        for (var i = 0, ii = path.length; i < ii; i++) {\n\t            for (var j = 1, jj = path[i].length; j < jj; j++) {\n\t                out.push(path[i][j]);\n\t            }\n\t        }\n\t        return out;\n\t    }\n\t    function isNumeric(obj) {\n\t        return isFinite(parseFloat(obj));\n\t    }\n\t    function arrayEqual(arr1, arr2) {\n\t        if (!Snap.is(arr1, \"array\") || !Snap.is(arr2, \"array\")) {\n\t            return false;\n\t        }\n\t        return arr1.toString() == arr2.toString();\n\t    }\n\t    Element.prototype.equal = function (name, b) {\n\t        return eve(\"snap.util.equal\", this, name, b).firstDefined();\n\t    };\n\t    eve.on(\"snap.util.equal\", function (name, b) {\n\t        var A, B, a = Str(this.attr(name) || \"\"),\n\t            el = this;\n\t        if (isNumeric(a) && isNumeric(b)) {\n\t            return {\n\t                from: parseFloat(a),\n\t                to: parseFloat(b),\n\t                f: getNumber\n\t            };\n\t        }\n\t        if (names[name] == \"colour\") {\n\t            A = Snap.color(a);\n\t            B = Snap.color(b);\n\t            return {\n\t                from: [A.r, A.g, A.b, A.opacity],\n\t                to: [B.r, B.g, B.b, B.opacity],\n\t                f: getColour\n\t            };\n\t        }\n\t        if (name == \"viewBox\") {\n\t            A = this.attr(name).vb.split(\" \").map(Number);\n\t            B = b.split(\" \").map(Number);\n\t            return {\n\t                from: A,\n\t                to: B,\n\t                f: getViewBox\n\t            };\n\t        }\n\t        if (name == \"transform\" || name == \"gradientTransform\" || name == \"patternTransform\") {\n\t            if (b instanceof Snap.Matrix) {\n\t                b = b.toTransformString();\n\t            }\n\t            if (!Snap._.rgTransform.test(b)) {\n\t                b = Snap._.svgTransform2string(b);\n\t            }\n\t            return equaliseTransform(a, b, function () {\n\t                return el.getBBox(1);\n\t            });\n\t        }\n\t        if (name == \"d\" || name == \"path\") {\n\t            A = Snap.path.toCubic(a, b);\n\t            return {\n\t                from: path2array(A[0]),\n\t                to: path2array(A[1]),\n\t                f: getPath(A[0])\n\t            };\n\t        }\n\t        if (name == \"points\") {\n\t            A = Str(a).split(Snap._.separator);\n\t            B = Str(b).split(Snap._.separator);\n\t            return {\n\t                from: A,\n\t                to: B,\n\t                f: function (val) { return val; }\n\t            };\n\t        }\n\t        var aUnit = a.match(reUnit),\n\t            bUnit = Str(b).match(reUnit);\n\t        if (aUnit && arrayEqual(aUnit, bUnit)) {\n\t            return {\n\t                from: parseFloat(a),\n\t                to: parseFloat(b),\n\t                f: getUnit(aUnit)\n\t            };\n\t        } else {\n\t            return {\n\t                from: this.asPX(name),\n\t                to: this.asPX(name, b),\n\t                f: getNumber\n\t            };\n\t        }\n\t    });\n\t});\n\t\n\t// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t// \n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t// \n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t// \n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tSnap.plugin(function (Snap, Element, Paper, glob) {\n\t    var elproto = Element.prototype,\n\t    has = \"hasOwnProperty\",\n\t    supportsTouch = \"createTouch\" in glob.doc,\n\t    events = [\n\t        \"click\", \"dblclick\", \"mousedown\", \"mousemove\", \"mouseout\",\n\t        \"mouseover\", \"mouseup\", \"touchstart\", \"touchmove\", \"touchend\",\n\t        \"touchcancel\"\n\t    ],\n\t    touchMap = {\n\t        mousedown: \"touchstart\",\n\t        mousemove: \"touchmove\",\n\t        mouseup: \"touchend\"\n\t    },\n\t    getScroll = function (xy, el) {\n\t        var name = xy == \"y\" ? \"scrollTop\" : \"scrollLeft\",\n\t            doc = el && el.node ? el.node.ownerDocument : glob.doc;\n\t        return doc[name in doc.documentElement ? \"documentElement\" : \"body\"][name];\n\t    },\n\t    preventDefault = function () {\n\t        this.returnValue = false;\n\t    },\n\t    preventTouch = function () {\n\t        return this.originalEvent.preventDefault();\n\t    },\n\t    stopPropagation = function () {\n\t        this.cancelBubble = true;\n\t    },\n\t    stopTouch = function () {\n\t        return this.originalEvent.stopPropagation();\n\t    },\n\t    addEvent = function (obj, type, fn, element) {\n\t        var realName = supportsTouch && touchMap[type] ? touchMap[type] : type,\n\t            f = function (e) {\n\t                var scrollY = getScroll(\"y\", element),\n\t                    scrollX = getScroll(\"x\", element);\n\t                if (supportsTouch && touchMap[has](type)) {\n\t                    for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {\n\t                        if (e.targetTouches[i].target == obj || obj.contains(e.targetTouches[i].target)) {\n\t                            var olde = e;\n\t                            e = e.targetTouches[i];\n\t                            e.originalEvent = olde;\n\t                            e.preventDefault = preventTouch;\n\t                            e.stopPropagation = stopTouch;\n\t                            break;\n\t                        }\n\t                    }\n\t                }\n\t                var x = e.clientX + scrollX,\n\t                    y = e.clientY + scrollY;\n\t                return fn.call(element, e, x, y);\n\t            };\n\t\n\t        if (type !== realName) {\n\t            obj.addEventListener(type, f, false);\n\t        }\n\t\n\t        obj.addEventListener(realName, f, false);\n\t\n\t        return function () {\n\t            if (type !== realName) {\n\t                obj.removeEventListener(type, f, false);\n\t            }\n\t\n\t            obj.removeEventListener(realName, f, false);\n\t            return true;\n\t        };\n\t    },\n\t    drag = [],\n\t    dragMove = function (e) {\n\t        var x = e.clientX,\n\t            y = e.clientY,\n\t            scrollY = getScroll(\"y\"),\n\t            scrollX = getScroll(\"x\"),\n\t            dragi,\n\t            j = drag.length;\n\t        while (j--) {\n\t            dragi = drag[j];\n\t            if (supportsTouch) {\n\t                var i = e.touches && e.touches.length,\n\t                    touch;\n\t                while (i--) {\n\t                    touch = e.touches[i];\n\t                    if (touch.identifier == dragi.el._drag.id || dragi.el.node.contains(touch.target)) {\n\t                        x = touch.clientX;\n\t                        y = touch.clientY;\n\t                        (e.originalEvent ? e.originalEvent : e).preventDefault();\n\t                        break;\n\t                    }\n\t                }\n\t            } else {\n\t                e.preventDefault();\n\t            }\n\t            var node = dragi.el.node,\n\t                o,\n\t                next = node.nextSibling,\n\t                parent = node.parentNode,\n\t                display = node.style.display;\n\t            // glob.win.opera && parent.removeChild(node);\n\t            // node.style.display = \"none\";\n\t            // o = dragi.el.paper.getElementByPoint(x, y);\n\t            // node.style.display = display;\n\t            // glob.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));\n\t            // o && eve(\"snap.drag.over.\" + dragi.el.id, dragi.el, o);\n\t            x += scrollX;\n\t            y += scrollY;\n\t            eve(\"snap.drag.move.\" + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);\n\t        }\n\t    },\n\t    dragUp = function (e) {\n\t        Snap.unmousemove(dragMove).unmouseup(dragUp);\n\t        var i = drag.length,\n\t            dragi;\n\t        while (i--) {\n\t            dragi = drag[i];\n\t            dragi.el._drag = {};\n\t            eve(\"snap.drag.end.\" + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);\n\t            eve.off(\"snap.drag.*.\" + dragi.el.id);\n\t        }\n\t        drag = [];\n\t    };\n\t    /*\\\n\t     * Element.click\n\t     [ method ]\n\t     **\n\t     * Adds a click event handler to the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.unclick\n\t     [ method ]\n\t     **\n\t     * Removes a click event handler from the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    \n\t    /*\\\n\t     * Element.dblclick\n\t     [ method ]\n\t     **\n\t     * Adds a double click event handler to the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.undblclick\n\t     [ method ]\n\t     **\n\t     * Removes a double click event handler from the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    \n\t    /*\\\n\t     * Element.mousedown\n\t     [ method ]\n\t     **\n\t     * Adds a mousedown event handler to the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.unmousedown\n\t     [ method ]\n\t     **\n\t     * Removes a mousedown event handler from the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    \n\t    /*\\\n\t     * Element.mousemove\n\t     [ method ]\n\t     **\n\t     * Adds a mousemove event handler to the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.unmousemove\n\t     [ method ]\n\t     **\n\t     * Removes a mousemove event handler from the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    \n\t    /*\\\n\t     * Element.mouseout\n\t     [ method ]\n\t     **\n\t     * Adds a mouseout event handler to the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.unmouseout\n\t     [ method ]\n\t     **\n\t     * Removes a mouseout event handler from the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    \n\t    /*\\\n\t     * Element.mouseover\n\t     [ method ]\n\t     **\n\t     * Adds a mouseover event handler to the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.unmouseover\n\t     [ method ]\n\t     **\n\t     * Removes a mouseover event handler from the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    \n\t    /*\\\n\t     * Element.mouseup\n\t     [ method ]\n\t     **\n\t     * Adds a mouseup event handler to the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.unmouseup\n\t     [ method ]\n\t     **\n\t     * Removes a mouseup event handler from the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    \n\t    /*\\\n\t     * Element.touchstart\n\t     [ method ]\n\t     **\n\t     * Adds a touchstart event handler to the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.untouchstart\n\t     [ method ]\n\t     **\n\t     * Removes a touchstart event handler from the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    \n\t    /*\\\n\t     * Element.touchmove\n\t     [ method ]\n\t     **\n\t     * Adds a touchmove event handler to the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.untouchmove\n\t     [ method ]\n\t     **\n\t     * Removes a touchmove event handler from the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    \n\t    /*\\\n\t     * Element.touchend\n\t     [ method ]\n\t     **\n\t     * Adds a touchend event handler to the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.untouchend\n\t     [ method ]\n\t     **\n\t     * Removes a touchend event handler from the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    \n\t    /*\\\n\t     * Element.touchcancel\n\t     [ method ]\n\t     **\n\t     * Adds a touchcancel event handler to the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.untouchcancel\n\t     [ method ]\n\t     **\n\t     * Removes a touchcancel event handler from the element\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    for (var i = events.length; i--;) {\n\t        (function (eventName) {\n\t            Snap[eventName] = elproto[eventName] = function (fn, scope) {\n\t                if (Snap.is(fn, \"function\")) {\n\t                    this.events = this.events || [];\n\t                    this.events.push({\n\t                        name: eventName,\n\t                        f: fn,\n\t                        unbind: addEvent(this.node || document, eventName, fn, scope || this)\n\t                    });\n\t                } else {\n\t                    for (var i = 0, ii = this.events.length; i < ii; i++) if (this.events[i].name == eventName) {\n\t                        try {\n\t                            this.events[i].f.call(this);\n\t                        } catch (e) {}\n\t                    }\n\t                }\n\t                return this;\n\t            };\n\t            Snap[\"un\" + eventName] =\n\t            elproto[\"un\" + eventName] = function (fn) {\n\t                var events = this.events || [],\n\t                    l = events.length;\n\t                while (l--) if (events[l].name == eventName &&\n\t                               (events[l].f == fn || !fn)) {\n\t                    events[l].unbind();\n\t                    events.splice(l, 1);\n\t                    !events.length && delete this.events;\n\t                    return this;\n\t                }\n\t                return this;\n\t            };\n\t        })(events[i]);\n\t    }\n\t    /*\\\n\t     * Element.hover\n\t     [ method ]\n\t     **\n\t     * Adds hover event handlers to the element\n\t     - f_in (function) handler for hover in\n\t     - f_out (function) handler for hover out\n\t     - icontext (object) #optional context for hover in handler\n\t     - ocontext (object) #optional context for hover out handler\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.hover = function (f_in, f_out, scope_in, scope_out) {\n\t        return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);\n\t    };\n\t    /*\\\n\t     * Element.unhover\n\t     [ method ]\n\t     **\n\t     * Removes hover event handlers from the element\n\t     - f_in (function) handler for hover in\n\t     - f_out (function) handler for hover out\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.unhover = function (f_in, f_out) {\n\t        return this.unmouseover(f_in).unmouseout(f_out);\n\t    };\n\t    var draggable = [];\n\t    // SIERRA unclear what _context_ refers to for starting, ending, moving the drag gesture.\n\t    // SIERRA Element.drag(): _x position of the mouse_: Where are the x/y values offset from?\n\t    // SIERRA Element.drag(): much of this member's doc appears to be duplicated for some reason.\n\t    // SIERRA Unclear about this sentence: _Additionally following drag events will be triggered: drag.start.<id> on start, drag.end.<id> on end and drag.move.<id> on every move._ Is there a global _drag_ object to which you can assign handlers keyed by an element's ID?\n\t    /*\\\n\t     * Element.drag\n\t     [ method ]\n\t     **\n\t     * Adds event handlers for an element's drag gesture\n\t     **\n\t     - onmove (function) handler for moving\n\t     - onstart (function) handler for drag start\n\t     - onend (function) handler for drag end\n\t     - mcontext (object) #optional context for moving handler\n\t     - scontext (object) #optional context for drag start handler\n\t     - econtext (object) #optional context for drag end handler\n\t     * Additionaly following `drag` events are triggered: `drag.start.<id>` on start, \n\t     * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element is dragged over another element \n\t     * `drag.over.<id>` fires as well.\n\t     *\n\t     * Start event and start handler are called in specified context or in context of the element with following parameters:\n\t     o x (number) x position of the mouse\n\t     o y (number) y position of the mouse\n\t     o event (object) DOM event object\n\t     * Move event and move handler are called in specified context or in context of the element with following parameters:\n\t     o dx (number) shift by x from the start point\n\t     o dy (number) shift by y from the start point\n\t     o x (number) x position of the mouse\n\t     o y (number) y position of the mouse\n\t     o event (object) DOM event object\n\t     * End event and end handler are called in specified context or in context of the element with following parameters:\n\t     o event (object) DOM event object\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {\n\t        var el = this;\n\t        if (!arguments.length) {\n\t            var origTransform;\n\t            return el.drag(function (dx, dy) {\n\t                this.attr({\n\t                    transform: origTransform + (origTransform ? \"T\" : \"t\") + [dx, dy]\n\t                });\n\t            }, function () {\n\t                origTransform = this.transform().local;\n\t            });\n\t        }\n\t        function start(e, x, y) {\n\t            (e.originalEvent || e).preventDefault();\n\t            el._drag.x = x;\n\t            el._drag.y = y;\n\t            el._drag.id = e.identifier;\n\t            !drag.length && Snap.mousemove(dragMove).mouseup(dragUp);\n\t            drag.push({el: el, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope});\n\t            onstart && eve.on(\"snap.drag.start.\" + el.id, onstart);\n\t            onmove && eve.on(\"snap.drag.move.\" + el.id, onmove);\n\t            onend && eve.on(\"snap.drag.end.\" + el.id, onend);\n\t            eve(\"snap.drag.start.\" + el.id, start_scope || move_scope || el, x, y, e);\n\t        }\n\t        function init(e, x, y) {\n\t            eve(\"snap.draginit.\" + el.id, el, e, x, y);\n\t        }\n\t        eve.on(\"snap.draginit.\" + el.id, start);\n\t        el._drag = {};\n\t        draggable.push({el: el, start: start, init: init});\n\t        el.mousedown(init);\n\t        return el;\n\t    };\n\t    /*\n\t     * Element.onDragOver\n\t     [ method ]\n\t     **\n\t     * Shortcut to assign event handler for `drag.over.<id>` event, where `id` is the element's `id` (see @Element.id)\n\t     - f (function) handler for event, first argument would be the element you are dragging over\n\t    \\*/\n\t    // elproto.onDragOver = function (f) {\n\t    //     f ? eve.on(\"snap.drag.over.\" + this.id, f) : eve.unbind(\"snap.drag.over.\" + this.id);\n\t    // };\n\t    /*\\\n\t     * Element.undrag\n\t     [ method ]\n\t     **\n\t     * Removes all drag event handlers from the given element\n\t    \\*/\n\t    elproto.undrag = function () {\n\t        var i = draggable.length;\n\t        while (i--) if (draggable[i].el == this) {\n\t            this.unmousedown(draggable[i].init);\n\t            draggable.splice(i, 1);\n\t            eve.unbind(\"snap.drag.*.\" + this.id);\n\t            eve.unbind(\"snap.draginit.\" + this.id);\n\t        }\n\t        !draggable.length && Snap.unmousemove(dragMove).unmouseup(dragUp);\n\t        return this;\n\t    };\n\t});\n\t\n\t// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t// \n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t// \n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t// \n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tSnap.plugin(function (Snap, Element, Paper, glob) {\n\t    var elproto = Element.prototype,\n\t        pproto = Paper.prototype,\n\t        rgurl = /^\\s*url\\((.+)\\)/,\n\t        Str = String,\n\t        $ = Snap._.$;\n\t    Snap.filter = {};\n\t    /*\\\n\t     * Paper.filter\n\t     [ method ]\n\t     **\n\t     * Creates a `<filter>` element\n\t     **\n\t     - filstr (string) SVG fragment of filter provided as a string\n\t     = (object) @Element\n\t     * Note: It is recommended to use filters embedded into the page inside an empty SVG element.\n\t     > Usage\n\t     | var f = paper.filter('<feGaussianBlur stdDeviation=\"2\"/>'),\n\t     |     c = paper.circle(10, 10, 10).attr({\n\t     |         filter: f\n\t     |     });\n\t    \\*/\n\t    pproto.filter = function (filstr) {\n\t        var paper = this;\n\t        if (paper.type != \"svg\") {\n\t            paper = paper.paper;\n\t        }\n\t        var f = Snap.parse(Str(filstr)),\n\t            id = Snap._.id(),\n\t            width = paper.node.offsetWidth,\n\t            height = paper.node.offsetHeight,\n\t            filter = $(\"filter\");\n\t        $(filter, {\n\t            id: id,\n\t            filterUnits: \"userSpaceOnUse\"\n\t        });\n\t        filter.appendChild(f.node);\n\t        paper.defs.appendChild(filter);\n\t        return new Element(filter);\n\t    };\n\t    \n\t    eve.on(\"snap.util.getattr.filter\", function () {\n\t        eve.stop();\n\t        var p = $(this.node, \"filter\");\n\t        if (p) {\n\t            var match = Str(p).match(rgurl);\n\t            return match && Snap.select(match[1]);\n\t        }\n\t    });\n\t    eve.on(\"snap.util.attr.filter\", function (value) {\n\t        if (value instanceof Element && value.type == \"filter\") {\n\t            eve.stop();\n\t            var id = value.node.id;\n\t            if (!id) {\n\t                $(value.node, {id: value.id});\n\t                id = value.id;\n\t            }\n\t            $(this.node, {\n\t                filter: Snap.url(id)\n\t            });\n\t        }\n\t        if (!value || value == \"none\") {\n\t            eve.stop();\n\t            this.node.removeAttribute(\"filter\");\n\t        }\n\t    });\n\t    /*\\\n\t     * Snap.filter.blur\n\t     [ method ]\n\t     **\n\t     * Returns an SVG markup string for the blur filter\n\t     **\n\t     - x (number) amount of horizontal blur, in pixels\n\t     - y (number) #optional amount of vertical blur, in pixels\n\t     = (string) filter representation\n\t     > Usage\n\t     | var f = paper.filter(Snap.filter.blur(5, 10)),\n\t     |     c = paper.circle(10, 10, 10).attr({\n\t     |         filter: f\n\t     |     });\n\t    \\*/\n\t    Snap.filter.blur = function (x, y) {\n\t        if (x == null) {\n\t            x = 2;\n\t        }\n\t        var def = y == null ? x : [x, y];\n\t        return Snap.format('\\<feGaussianBlur stdDeviation=\"{def}\"/>', {\n\t            def: def\n\t        });\n\t    };\n\t    Snap.filter.blur.toString = function () {\n\t        return this();\n\t    };\n\t    /*\\\n\t     * Snap.filter.shadow\n\t     [ method ]\n\t     **\n\t     * Returns an SVG markup string for the shadow filter\n\t     **\n\t     - dx (number) #optional horizontal shift of the shadow, in pixels\n\t     - dy (number) #optional vertical shift of the shadow, in pixels\n\t     - blur (number) #optional amount of blur\n\t     - color (string) #optional color of the shadow\n\t     - opacity (number) #optional `0..1` opacity of the shadow\n\t     * or\n\t     - dx (number) #optional horizontal shift of the shadow, in pixels\n\t     - dy (number) #optional vertical shift of the shadow, in pixels\n\t     - color (string) #optional color of the shadow\n\t     - opacity (number) #optional `0..1` opacity of the shadow\n\t     * which makes blur default to `4`. Or\n\t     - dx (number) #optional horizontal shift of the shadow, in pixels\n\t     - dy (number) #optional vertical shift of the shadow, in pixels\n\t     - opacity (number) #optional `0..1` opacity of the shadow\n\t     = (string) filter representation\n\t     > Usage\n\t     | var f = paper.filter(Snap.filter.shadow(0, 2, 3)),\n\t     |     c = paper.circle(10, 10, 10).attr({\n\t     |         filter: f\n\t     |     });\n\t    \\*/\n\t    Snap.filter.shadow = function (dx, dy, blur, color, opacity) {\n\t        if (typeof blur == \"string\") {\n\t            color = blur;\n\t            opacity = color;\n\t            blur = 4;\n\t        }\n\t        if (typeof color != \"string\") {\n\t            opacity = color;\n\t            color = \"#000\";\n\t        }\n\t        color = color || \"#000\";\n\t        if (blur == null) {\n\t            blur = 4;\n\t        }\n\t        if (opacity == null) {\n\t            opacity = 1;\n\t        }\n\t        if (dx == null) {\n\t            dx = 0;\n\t            dy = 2;\n\t        }\n\t        if (dy == null) {\n\t            dy = dx;\n\t        }\n\t        color = Snap.color(color);\n\t        return Snap.format('<feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"{blur}\"/><feOffset dx=\"{dx}\" dy=\"{dy}\" result=\"offsetblur\"/><feFlood flood-color=\"{color}\"/><feComposite in2=\"offsetblur\" operator=\"in\"/><feComponentTransfer><feFuncA type=\"linear\" slope=\"{opacity}\"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in=\"SourceGraphic\"/></feMerge>', {\n\t            color: color,\n\t            dx: dx,\n\t            dy: dy,\n\t            blur: blur,\n\t            opacity: opacity\n\t        });\n\t    };\n\t    Snap.filter.shadow.toString = function () {\n\t        return this();\n\t    };\n\t    /*\\\n\t     * Snap.filter.grayscale\n\t     [ method ]\n\t     **\n\t     * Returns an SVG markup string for the grayscale filter\n\t     **\n\t     - amount (number) amount of filter (`0..1`)\n\t     = (string) filter representation\n\t    \\*/\n\t    Snap.filter.grayscale = function (amount) {\n\t        if (amount == null) {\n\t            amount = 1;\n\t        }\n\t        return Snap.format('<feColorMatrix type=\"matrix\" values=\"{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {b} {h} 0 0 0 0 0 1 0\"/>', {\n\t            a: 0.2126 + 0.7874 * (1 - amount),\n\t            b: 0.7152 - 0.7152 * (1 - amount),\n\t            c: 0.0722 - 0.0722 * (1 - amount),\n\t            d: 0.2126 - 0.2126 * (1 - amount),\n\t            e: 0.7152 + 0.2848 * (1 - amount),\n\t            f: 0.0722 - 0.0722 * (1 - amount),\n\t            g: 0.2126 - 0.2126 * (1 - amount),\n\t            h: 0.0722 + 0.9278 * (1 - amount)\n\t        });\n\t    };\n\t    Snap.filter.grayscale.toString = function () {\n\t        return this();\n\t    };\n\t    /*\\\n\t     * Snap.filter.sepia\n\t     [ method ]\n\t     **\n\t     * Returns an SVG markup string for the sepia filter\n\t     **\n\t     - amount (number) amount of filter (`0..1`)\n\t     = (string) filter representation\n\t    \\*/\n\t    Snap.filter.sepia = function (amount) {\n\t        if (amount == null) {\n\t            amount = 1;\n\t        }\n\t        return Snap.format('<feColorMatrix type=\"matrix\" values=\"{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {h} {i} 0 0 0 0 0 1 0\"/>', {\n\t            a: 0.393 + 0.607 * (1 - amount),\n\t            b: 0.769 - 0.769 * (1 - amount),\n\t            c: 0.189 - 0.189 * (1 - amount),\n\t            d: 0.349 - 0.349 * (1 - amount),\n\t            e: 0.686 + 0.314 * (1 - amount),\n\t            f: 0.168 - 0.168 * (1 - amount),\n\t            g: 0.272 - 0.272 * (1 - amount),\n\t            h: 0.534 - 0.534 * (1 - amount),\n\t            i: 0.131 + 0.869 * (1 - amount)\n\t        });\n\t    };\n\t    Snap.filter.sepia.toString = function () {\n\t        return this();\n\t    };\n\t    /*\\\n\t     * Snap.filter.saturate\n\t     [ method ]\n\t     **\n\t     * Returns an SVG markup string for the saturate filter\n\t     **\n\t     - amount (number) amount of filter (`0..1`)\n\t     = (string) filter representation\n\t    \\*/\n\t    Snap.filter.saturate = function (amount) {\n\t        if (amount == null) {\n\t            amount = 1;\n\t        }\n\t        return Snap.format('<feColorMatrix type=\"saturate\" values=\"{amount}\"/>', {\n\t            amount: 1 - amount\n\t        });\n\t    };\n\t    Snap.filter.saturate.toString = function () {\n\t        return this();\n\t    };\n\t    /*\\\n\t     * Snap.filter.hueRotate\n\t     [ method ]\n\t     **\n\t     * Returns an SVG markup string for the hue-rotate filter\n\t     **\n\t     - angle (number) angle of rotation\n\t     = (string) filter representation\n\t    \\*/\n\t    Snap.filter.hueRotate = function (angle) {\n\t        angle = angle || 0;\n\t        return Snap.format('<feColorMatrix type=\"hueRotate\" values=\"{angle}\"/>', {\n\t            angle: angle\n\t        });\n\t    };\n\t    Snap.filter.hueRotate.toString = function () {\n\t        return this();\n\t    };\n\t    /*\\\n\t     * Snap.filter.invert\n\t     [ method ]\n\t     **\n\t     * Returns an SVG markup string for the invert filter\n\t     **\n\t     - amount (number) amount of filter (`0..1`)\n\t     = (string) filter representation\n\t    \\*/\n\t    Snap.filter.invert = function (amount) {\n\t        if (amount == null) {\n\t            amount = 1;\n\t        }\n\t//        <feColorMatrix type=\"matrix\" values=\"-1 0 0 0 1  0 -1 0 0 1  0 0 -1 0 1  0 0 0 1 0\" color-interpolation-filters=\"sRGB\"/>\n\t        return Snap.format('<feComponentTransfer><feFuncR type=\"table\" tableValues=\"{amount} {amount2}\"/><feFuncG type=\"table\" tableValues=\"{amount} {amount2}\"/><feFuncB type=\"table\" tableValues=\"{amount} {amount2}\"/></feComponentTransfer>', {\n\t            amount: amount,\n\t            amount2: 1 - amount\n\t        });\n\t    };\n\t    Snap.filter.invert.toString = function () {\n\t        return this();\n\t    };\n\t    /*\\\n\t     * Snap.filter.brightness\n\t     [ method ]\n\t     **\n\t     * Returns an SVG markup string for the brightness filter\n\t     **\n\t     - amount (number) amount of filter (`0..1`)\n\t     = (string) filter representation\n\t    \\*/\n\t    Snap.filter.brightness = function (amount) {\n\t        if (amount == null) {\n\t            amount = 1;\n\t        }\n\t        return Snap.format('<feComponentTransfer><feFuncR type=\"linear\" slope=\"{amount}\"/><feFuncG type=\"linear\" slope=\"{amount}\"/><feFuncB type=\"linear\" slope=\"{amount}\"/></feComponentTransfer>', {\n\t            amount: amount\n\t        });\n\t    };\n\t    Snap.filter.brightness.toString = function () {\n\t        return this();\n\t    };\n\t    /*\\\n\t     * Snap.filter.contrast\n\t     [ method ]\n\t     **\n\t     * Returns an SVG markup string for the contrast filter\n\t     **\n\t     - amount (number) amount of filter (`0..1`)\n\t     = (string) filter representation\n\t    \\*/\n\t    Snap.filter.contrast = function (amount) {\n\t        if (amount == null) {\n\t            amount = 1;\n\t        }\n\t        return Snap.format('<feComponentTransfer><feFuncR type=\"linear\" slope=\"{amount}\" intercept=\"{amount2}\"/><feFuncG type=\"linear\" slope=\"{amount}\" intercept=\"{amount2}\"/><feFuncB type=\"linear\" slope=\"{amount}\" intercept=\"{amount2}\"/></feComponentTransfer>', {\n\t            amount: amount,\n\t            amount2: .5 - amount / 2\n\t        });\n\t    };\n\t    Snap.filter.contrast.toString = function () {\n\t        return this();\n\t    };\n\t});\n\t\n\t// Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\n\t//\n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t//\n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t//\n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\tSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n\t    var box = Snap._.box,\n\t        is = Snap.is,\n\t        firstLetter = /^[^a-z]*([tbmlrc])/i,\n\t        toString = function () {\n\t            return \"T\" + this.dx + \",\" + this.dy;\n\t        };\n\t    /*\\\n\t     * Element.getAlign\n\t     [ method ]\n\t     **\n\t     * Returns shift needed to align the element relatively to given element.\n\t     * If no elements specified, parent `<svg>` container will be used.\n\t     - el (object) @optional alignment element\n\t     - way (string) one of six values: `\"top\"`, `\"middle\"`, `\"bottom\"`, `\"left\"`, `\"center\"`, `\"right\"`\n\t     = (object|string) Object in format `{dx: , dy: }` also has a string representation as a transformation string\n\t     > Usage\n\t     | el.transform(el.getAlign(el2, \"top\"));\n\t     * or\n\t     | var dy = el.getAlign(el2, \"top\").dy;\n\t    \\*/\n\t    Element.prototype.getAlign = function (el, way) {\n\t        if (way == null && is(el, \"string\")) {\n\t            way = el;\n\t            el = null;\n\t        }\n\t        el = el || this.paper;\n\t        var bx = el.getBBox ? el.getBBox() : box(el),\n\t            bb = this.getBBox(),\n\t            out = {};\n\t        way = way && way.match(firstLetter);\n\t        way = way ? way[1].toLowerCase() : \"c\";\n\t        switch (way) {\n\t            case \"t\":\n\t                out.dx = 0;\n\t                out.dy = bx.y - bb.y;\n\t            break;\n\t            case \"b\":\n\t                out.dx = 0;\n\t                out.dy = bx.y2 - bb.y2;\n\t            break;\n\t            case \"m\":\n\t                out.dx = 0;\n\t                out.dy = bx.cy - bb.cy;\n\t            break;\n\t            case \"l\":\n\t                out.dx = bx.x - bb.x;\n\t                out.dy = 0;\n\t            break;\n\t            case \"r\":\n\t                out.dx = bx.x2 - bb.x2;\n\t                out.dy = 0;\n\t            break;\n\t            default:\n\t                out.dx = bx.cx - bb.cx;\n\t                out.dy = 0;\n\t            break;\n\t        }\n\t        out.toString = toString;\n\t        return out;\n\t    };\n\t    /*\\\n\t     * Element.align\n\t     [ method ]\n\t     **\n\t     * Aligns the element relatively to given one via transformation.\n\t     * If no elements specified, parent `<svg>` container will be used.\n\t     - el (object) @optional alignment element\n\t     - way (string) one of six values: `\"top\"`, `\"middle\"`, `\"bottom\"`, `\"left\"`, `\"center\"`, `\"right\"`\n\t     = (object) this element\n\t     > Usage\n\t     | el.align(el2, \"top\");\n\t     * or\n\t     | el.align(\"middle\");\n\t    \\*/\n\t    Element.prototype.align = function (el, way) {\n\t        return this.transform(\"...\" + this.getAlign(el, way));\n\t    };\n\t});\n\t\n\treturn Snap;\n\t}));\n\t}.call(window));\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _grammar = __webpack_require__(8);\n\t\n\tvar _grammar2 = _interopRequireDefault(_grammar);\n\t\n\tvar _node = __webpack_require__(9);\n\t\n\tvar _node2 = _interopRequireDefault(_node);\n\t\n\tvar _root = __webpack_require__(10);\n\t\n\tvar _root2 = _interopRequireDefault(_root);\n\t\n\tvar _regexp = __webpack_require__(11);\n\t\n\tvar _regexp2 = _interopRequireDefault(_regexp);\n\t\n\tvar _match = __webpack_require__(12);\n\t\n\tvar _match2 = _interopRequireDefault(_match);\n\t\n\tvar _match_fragment = __webpack_require__(13);\n\t\n\tvar _match_fragment2 = _interopRequireDefault(_match_fragment);\n\t\n\tvar _anchor = __webpack_require__(14);\n\t\n\tvar _anchor2 = _interopRequireDefault(_anchor);\n\t\n\tvar _subexp = __webpack_require__(15);\n\t\n\tvar _subexp2 = _interopRequireDefault(_subexp);\n\t\n\tvar _charset = __webpack_require__(16);\n\t\n\tvar _charset2 = _interopRequireDefault(_charset);\n\t\n\tvar _charset_escape = __webpack_require__(17);\n\t\n\tvar _charset_escape2 = _interopRequireDefault(_charset_escape);\n\t\n\tvar _charset_range = __webpack_require__(19);\n\t\n\tvar _charset_range2 = _interopRequireDefault(_charset_range);\n\t\n\tvar _literal = __webpack_require__(20);\n\t\n\tvar _literal2 = _interopRequireDefault(_literal);\n\t\n\tvar _escape = __webpack_require__(18);\n\t\n\tvar _escape2 = _interopRequireDefault(_escape);\n\t\n\tvar _any_character = __webpack_require__(21);\n\t\n\tvar _any_character2 = _interopRequireDefault(_any_character);\n\t\n\tvar _repeat = __webpack_require__(22);\n\t\n\tvar _repeat2 = _interopRequireDefault(_repeat);\n\t\n\tvar _repeat_any = __webpack_require__(23);\n\t\n\tvar _repeat_any2 = _interopRequireDefault(_repeat_any);\n\t\n\tvar _repeat_optional = __webpack_require__(24);\n\t\n\tvar _repeat_optional2 = _interopRequireDefault(_repeat_optional);\n\t\n\tvar _repeat_required = __webpack_require__(25);\n\t\n\tvar _repeat_required2 = _interopRequireDefault(_repeat_required);\n\t\n\tvar _repeat_spec = __webpack_require__(26);\n\t\n\tvar _repeat_spec2 = _interopRequireDefault(_repeat_spec);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// Canopy creates an instance of SyntaxNode for each element in the tree, then\n\t// adds any necessary fields to that instance. In this case, we're replacing\n\t// the default class with the Node class.\n\t_grammar2.default.Parser.SyntaxNode = _node2.default;\n\t\n\t// Once the SyntaxNode instance is created, the specific node type object is\n\t// overlayed onto it. This causes the module attribute on the Node to be set,\n\t// which updates the Node instance into the more specific \"subclass\" that is\n\t// used for rendering.\n\t// Sets up the parser generated by canopy to use the\n\t// [Node](./javascript/node.html) subclasses in the generated tree. This is all\n\t// a bit of a hack that is dependent on how canopy creates nodes in its parse\n\t// tree.\n\t_grammar2.default.Parser.Root = { module: _root2.default };\n\t_grammar2.default.Parser.Regexp = { module: _regexp2.default };\n\t_grammar2.default.Parser.Match = { module: _match2.default };\n\t_grammar2.default.Parser.MatchFragment = { module: _match_fragment2.default };\n\t_grammar2.default.Parser.Anchor = { module: _anchor2.default };\n\t_grammar2.default.Parser.Subexp = { module: _subexp2.default };\n\t_grammar2.default.Parser.Charset = { module: _charset2.default };\n\t_grammar2.default.Parser.CharsetEscape = { module: _charset_escape2.default };\n\t_grammar2.default.Parser.CharsetRange = { module: _charset_range2.default };\n\t_grammar2.default.Parser.Literal = { module: _literal2.default };\n\t_grammar2.default.Parser.Escape = { module: _escape2.default };\n\t_grammar2.default.Parser.AnyCharacter = { module: _any_character2.default };\n\t_grammar2.default.Parser.Repeat = { module: _repeat2.default };\n\t_grammar2.default.Parser.RepeatAny = { module: _repeat_any2.default };\n\t_grammar2.default.Parser.RepeatOptional = { module: _repeat_optional2.default };\n\t_grammar2.default.Parser.RepeatRequired = { module: _repeat_required2.default };\n\t_grammar2.default.Parser.RepeatSpec = { module: _repeat_spec2.default };\n\t\n\texports.default = _grammar2.default;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function() {\n\t  var extend = function (destination, source) {\n\t    if (!destination || !source) return destination;\n\t    for (var key in source) {\n\t      if (destination[key] !== source[key])\n\t        destination[key] = source[key];\n\t    }\n\t    return destination;\n\t  };\n\t  \n\t  var find = function (root, objectName) {\n\t    var parts = objectName.split('.'),\n\t        part;\n\t    \n\t    while (part = parts.shift()) {\n\t      root = root[part];\n\t      if (root === undefined)\n\t        throw new Error('Cannot find object named ' + objectName);\n\t    }\n\t    return root;\n\t  };\n\t  \n\t  var formatError = function (error) {\n\t    var lines  = error.input.split(/\\n/g),\n\t        lineNo = 0,\n\t        offset = 0;\n\t    \n\t    while (offset < error.offset + 1) {\n\t      offset += lines[lineNo].length + 1;\n\t      lineNo += 1;\n\t    }\n\t    var message = 'Line ' + lineNo + ': expected ' + error.expected + '\\n',\n\t        line    = lines[lineNo - 1];\n\t    \n\t    message += line + '\\n';\n\t    offset  -= line.length + 1;\n\t    \n\t    while (offset < error.offset) {\n\t      message += ' ';\n\t      offset  += 1;\n\t    }\n\t    return message + '^';\n\t  };\n\t  \n\t  var Grammar = {\n\t    __consume__root: function(input) {\n\t      var address0 = null, index0 = this._offset;\n\t      this._nodeCache[\"root\"] = this._nodeCache[\"root\"] || {};\n\t      var cached = this._nodeCache[\"root\"][index0];\n\t      if (cached) {\n\t        this._offset += cached.textValue.length;\n\t        return cached;\n\t      }\n\t      var index1 = this._offset;\n\t      var index2 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n\t      var address1 = null;\n\t      var slice0 = null;\n\t      if (this._input.length > this._offset) {\n\t        slice0 = this._input.substring(this._offset, this._offset + 1);\n\t      } else {\n\t        slice0 = null;\n\t      }\n\t      if (slice0 === \"/\") {\n\t        var klass0 = this.constructor.SyntaxNode;\n\t        var type0 = null;\n\t        address1 = new klass0(\"/\", this._offset, []);\n\t        if (typeof type0 === \"object\") {\n\t          extend(address1, type0);\n\t        }\n\t        this._offset += 1;\n\t      } else {\n\t        address1 = null;\n\t        var slice1 = null;\n\t        if (this._input.length > this._offset) {\n\t          slice1 = this._input.substring(this._offset, this._offset + 1);\n\t        } else {\n\t          slice1 = null;\n\t        }\n\t        if (!this.error || this.error.offset <= this._offset) {\n\t          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"/\\\"\"};\n\t        }\n\t      }\n\t      if (address1) {\n\t        elements0.push(address1);\n\t        text0 += address1.textValue;\n\t        var address2 = null;\n\t        address2 = this.__consume__regexp();\n\t        if (address2) {\n\t          elements0.push(address2);\n\t          text0 += address2.textValue;\n\t          labelled0.regexp = address2;\n\t          var address3 = null;\n\t          var slice2 = null;\n\t          if (this._input.length > this._offset) {\n\t            slice2 = this._input.substring(this._offset, this._offset + 1);\n\t          } else {\n\t            slice2 = null;\n\t          }\n\t          if (slice2 === \"/\") {\n\t            var klass1 = this.constructor.SyntaxNode;\n\t            var type1 = null;\n\t            address3 = new klass1(\"/\", this._offset, []);\n\t            if (typeof type1 === \"object\") {\n\t              extend(address3, type1);\n\t            }\n\t            this._offset += 1;\n\t          } else {\n\t            address3 = null;\n\t            var slice3 = null;\n\t            if (this._input.length > this._offset) {\n\t              slice3 = this._input.substring(this._offset, this._offset + 1);\n\t            } else {\n\t              slice3 = null;\n\t            }\n\t            if (!this.error || this.error.offset <= this._offset) {\n\t              this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"/\\\"\"};\n\t            }\n\t          }\n\t          if (address3) {\n\t            elements0.push(address3);\n\t            text0 += address3.textValue;\n\t            var address4 = null;\n\t            var remaining0 = 0, index3 = this._offset, elements1 = [], text1 = \"\", address5 = true;\n\t            while (address5) {\n\t              var slice4 = null;\n\t              if (this._input.length > this._offset) {\n\t                slice4 = this._input.substring(this._offset, this._offset + 1);\n\t              } else {\n\t                slice4 = null;\n\t              }\n\t              if (slice4 && /^[igm]/.test(slice4)) {\n\t                var klass2 = this.constructor.SyntaxNode;\n\t                var type2 = null;\n\t                address5 = new klass2(slice4, this._offset, []);\n\t                if (typeof type2 === \"object\") {\n\t                  extend(address5, type2);\n\t                }\n\t                this._offset += 1;\n\t              } else {\n\t                address5 = null;\n\t                var slice5 = null;\n\t                if (this._input.length > this._offset) {\n\t                  slice5 = this._input.substring(this._offset, this._offset + 1);\n\t                } else {\n\t                  slice5 = null;\n\t                }\n\t                if (!this.error || this.error.offset <= this._offset) {\n\t                  this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[igm]\"};\n\t                }\n\t              }\n\t              if (address5) {\n\t                elements1.push(address5);\n\t                text1 += address5.textValue;\n\t                remaining0 -= 1;\n\t              }\n\t            }\n\t            if (remaining0 <= 0) {\n\t              this._offset = index3;\n\t              var klass3 = this.constructor.SyntaxNode;\n\t              var type3 = null;\n\t              address4 = new klass3(text1, this._offset, elements1);\n\t              if (typeof type3 === \"object\") {\n\t                extend(address4, type3);\n\t              }\n\t              this._offset += text1.length;\n\t            } else {\n\t              address4 = null;\n\t            }\n\t            if (address4) {\n\t              elements0.push(address4);\n\t              text0 += address4.textValue;\n\t              labelled0.flags = address4;\n\t            } else {\n\t              elements0 = null;\n\t              this._offset = index2;\n\t            }\n\t          } else {\n\t            elements0 = null;\n\t            this._offset = index2;\n\t          }\n\t        } else {\n\t          elements0 = null;\n\t          this._offset = index2;\n\t        }\n\t      } else {\n\t        elements0 = null;\n\t        this._offset = index2;\n\t      }\n\t      if (elements0) {\n\t        this._offset = index2;\n\t        var klass4 = this.constructor.SyntaxNode;\n\t        var type4 = null;\n\t        address0 = new klass4(text0, this._offset, elements0, labelled0);\n\t        if (typeof type4 === \"object\") {\n\t          extend(address0, type4);\n\t        }\n\t        this._offset += text0.length;\n\t      } else {\n\t        address0 = null;\n\t      }\n\t      if (address0) {\n\t        var type5 = find(this.constructor, \"Root\");\n\t        if (typeof type5 === \"object\") {\n\t          extend(address0, type5);\n\t        }\n\t      } else {\n\t        this._offset = index1;\n\t        var index4 = this._offset, elements2 = [], labelled1 = {}, text2 = \"\";\n\t        var address6 = null;\n\t        address6 = this.__consume__regexp();\n\t        if (address6) {\n\t          elements2.push(address6);\n\t          text2 += address6.textValue;\n\t          labelled1.regexp = address6;\n\t          var address7 = null;\n\t          var index5 = this._offset;\n\t          var slice6 = null;\n\t          if (this._input.length > this._offset) {\n\t            slice6 = this._input.substring(this._offset, this._offset + 0);\n\t          } else {\n\t            slice6 = null;\n\t          }\n\t          if (slice6 === \"\") {\n\t            var klass5 = this.constructor.SyntaxNode;\n\t            var type6 = null;\n\t            address7 = new klass5(\"\", this._offset, []);\n\t            if (typeof type6 === \"object\") {\n\t              extend(address7, type6);\n\t            }\n\t            this._offset += 0;\n\t          } else {\n\t            address7 = null;\n\t            var slice7 = null;\n\t            if (this._input.length > this._offset) {\n\t              slice7 = this._input.substring(this._offset, this._offset + 1);\n\t            } else {\n\t              slice7 = null;\n\t            }\n\t            if (!this.error || this.error.offset <= this._offset) {\n\t              this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"\\\"\"};\n\t            }\n\t          }\n\t          if (address7) {\n\t          } else {\n\t            this._offset = index5;\n\t            var klass6 = this.constructor.SyntaxNode;\n\t            var type7 = null;\n\t            address7 = new klass6(\"\", this._offset, []);\n\t            if (typeof type7 === \"object\") {\n\t              extend(address7, type7);\n\t            }\n\t            this._offset += 0;\n\t          }\n\t          if (address7) {\n\t            elements2.push(address7);\n\t            text2 += address7.textValue;\n\t            labelled1.flags = address7;\n\t          } else {\n\t            elements2 = null;\n\t            this._offset = index4;\n\t          }\n\t        } else {\n\t          elements2 = null;\n\t          this._offset = index4;\n\t        }\n\t        if (elements2) {\n\t          this._offset = index4;\n\t          var klass7 = this.constructor.SyntaxNode;\n\t          var type8 = null;\n\t          address0 = new klass7(text2, this._offset, elements2, labelled1);\n\t          if (typeof type8 === \"object\") {\n\t            extend(address0, type8);\n\t          }\n\t          this._offset += text2.length;\n\t        } else {\n\t          address0 = null;\n\t        }\n\t        if (address0) {\n\t          var type9 = find(this.constructor, \"Root\");\n\t          if (typeof type9 === \"object\") {\n\t            extend(address0, type9);\n\t          }\n\t        } else {\n\t          this._offset = index1;\n\t        }\n\t      }\n\t      return this._nodeCache[\"root\"][index0] = address0;\n\t    },\n\t    __consume__regexp: function(input) {\n\t      var address0 = null, index0 = this._offset;\n\t      this._nodeCache[\"regexp\"] = this._nodeCache[\"regexp\"] || {};\n\t      var cached = this._nodeCache[\"regexp\"][index0];\n\t      if (cached) {\n\t        this._offset += cached.textValue.length;\n\t        return cached;\n\t      }\n\t      var index1 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n\t      var address1 = null;\n\t      address1 = this.__consume__match();\n\t      if (address1) {\n\t        elements0.push(address1);\n\t        text0 += address1.textValue;\n\t        labelled0.match = address1;\n\t        var address2 = null;\n\t        var remaining0 = 0, index2 = this._offset, elements1 = [], text1 = \"\", address3 = true;\n\t        while (address3) {\n\t          var index3 = this._offset, elements2 = [], labelled1 = {}, text2 = \"\";\n\t          var address4 = null;\n\t          var slice0 = null;\n\t          if (this._input.length > this._offset) {\n\t            slice0 = this._input.substring(this._offset, this._offset + 1);\n\t          } else {\n\t            slice0 = null;\n\t          }\n\t          if (slice0 === \"|\") {\n\t            var klass0 = this.constructor.SyntaxNode;\n\t            var type0 = null;\n\t            address4 = new klass0(\"|\", this._offset, []);\n\t            if (typeof type0 === \"object\") {\n\t              extend(address4, type0);\n\t            }\n\t            this._offset += 1;\n\t          } else {\n\t            address4 = null;\n\t            var slice1 = null;\n\t            if (this._input.length > this._offset) {\n\t              slice1 = this._input.substring(this._offset, this._offset + 1);\n\t            } else {\n\t              slice1 = null;\n\t            }\n\t            if (!this.error || this.error.offset <= this._offset) {\n\t              this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"|\\\"\"};\n\t            }\n\t          }\n\t          if (address4) {\n\t            elements2.push(address4);\n\t            text2 += address4.textValue;\n\t            var address5 = null;\n\t            address5 = this.__consume__match();\n\t            if (address5) {\n\t              elements2.push(address5);\n\t              text2 += address5.textValue;\n\t              labelled1.match = address5;\n\t            } else {\n\t              elements2 = null;\n\t              this._offset = index3;\n\t            }\n\t          } else {\n\t            elements2 = null;\n\t            this._offset = index3;\n\t          }\n\t          if (elements2) {\n\t            this._offset = index3;\n\t            var klass1 = this.constructor.SyntaxNode;\n\t            var type1 = null;\n\t            address3 = new klass1(text2, this._offset, elements2, labelled1);\n\t            if (typeof type1 === \"object\") {\n\t              extend(address3, type1);\n\t            }\n\t            this._offset += text2.length;\n\t          } else {\n\t            address3 = null;\n\t          }\n\t          if (address3) {\n\t            elements1.push(address3);\n\t            text1 += address3.textValue;\n\t            remaining0 -= 1;\n\t          }\n\t        }\n\t        if (remaining0 <= 0) {\n\t          this._offset = index2;\n\t          var klass2 = this.constructor.SyntaxNode;\n\t          var type2 = null;\n\t          address2 = new klass2(text1, this._offset, elements1);\n\t          if (typeof type2 === \"object\") {\n\t            extend(address2, type2);\n\t          }\n\t          this._offset += text1.length;\n\t        } else {\n\t          address2 = null;\n\t        }\n\t        if (address2) {\n\t          elements0.push(address2);\n\t          text0 += address2.textValue;\n\t          labelled0.alternates = address2;\n\t        } else {\n\t          elements0 = null;\n\t          this._offset = index1;\n\t        }\n\t      } else {\n\t        elements0 = null;\n\t        this._offset = index1;\n\t      }\n\t      if (elements0) {\n\t        this._offset = index1;\n\t        var klass3 = this.constructor.SyntaxNode;\n\t        var type3 = find(this.constructor, \"Regexp\");\n\t        address0 = new klass3(text0, this._offset, elements0, labelled0);\n\t        if (typeof type3 === \"object\") {\n\t          extend(address0, type3);\n\t        }\n\t        this._offset += text0.length;\n\t      } else {\n\t        address0 = null;\n\t      }\n\t      return this._nodeCache[\"regexp\"][index0] = address0;\n\t    },\n\t    __consume__match: function(input) {\n\t      var address0 = null, index0 = this._offset;\n\t      this._nodeCache[\"match\"] = this._nodeCache[\"match\"] || {};\n\t      var cached = this._nodeCache[\"match\"][index0];\n\t      if (cached) {\n\t        this._offset += cached.textValue.length;\n\t        return cached;\n\t      }\n\t      var index1 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n\t      var address1 = null;\n\t      var index2 = this._offset;\n\t      address1 = this.__consume__repeat();\n\t      this._offset = index2;\n\t      if (!(address1)) {\n\t        var klass0 = this.constructor.SyntaxNode;\n\t        var type0 = null;\n\t        address1 = new klass0(\"\", this._offset, []);\n\t        if (typeof type0 === \"object\") {\n\t          extend(address1, type0);\n\t        }\n\t        this._offset += 0;\n\t      } else {\n\t        address1 = null;\n\t      }\n\t      if (address1) {\n\t        elements0.push(address1);\n\t        text0 += address1.textValue;\n\t        var address2 = null;\n\t        var remaining0 = 0, index3 = this._offset, elements1 = [], text1 = \"\", address3 = true;\n\t        while (address3) {\n\t          address3 = this.__consume__match_fragment();\n\t          if (address3) {\n\t            elements1.push(address3);\n\t            text1 += address3.textValue;\n\t            remaining0 -= 1;\n\t          }\n\t        }\n\t        if (remaining0 <= 0) {\n\t          this._offset = index3;\n\t          var klass1 = this.constructor.SyntaxNode;\n\t          var type1 = null;\n\t          address2 = new klass1(text1, this._offset, elements1);\n\t          if (typeof type1 === \"object\") {\n\t            extend(address2, type1);\n\t          }\n\t          this._offset += text1.length;\n\t        } else {\n\t          address2 = null;\n\t        }\n\t        if (address2) {\n\t          elements0.push(address2);\n\t          text0 += address2.textValue;\n\t          labelled0.parts = address2;\n\t        } else {\n\t          elements0 = null;\n\t          this._offset = index1;\n\t        }\n\t      } else {\n\t        elements0 = null;\n\t        this._offset = index1;\n\t      }\n\t      if (elements0) {\n\t        this._offset = index1;\n\t        var klass2 = this.constructor.SyntaxNode;\n\t        var type2 = find(this.constructor, \"Match\");\n\t        address0 = new klass2(text0, this._offset, elements0, labelled0);\n\t        if (typeof type2 === \"object\") {\n\t          extend(address0, type2);\n\t        }\n\t        this._offset += text0.length;\n\t      } else {\n\t        address0 = null;\n\t      }\n\t      return this._nodeCache[\"match\"][index0] = address0;\n\t    },\n\t    __consume__anchor: function(input) {\n\t      var address0 = null, index0 = this._offset;\n\t      this._nodeCache[\"anchor\"] = this._nodeCache[\"anchor\"] || {};\n\t      var cached = this._nodeCache[\"anchor\"][index0];\n\t      if (cached) {\n\t        this._offset += cached.textValue.length;\n\t        return cached;\n\t      }\n\t      var index1 = this._offset;\n\t      var slice0 = null;\n\t      if (this._input.length > this._offset) {\n\t        slice0 = this._input.substring(this._offset, this._offset + 1);\n\t      } else {\n\t        slice0 = null;\n\t      }\n\t      if (slice0 === \"^\") {\n\t        var klass0 = this.constructor.SyntaxNode;\n\t        var type0 = null;\n\t        address0 = new klass0(\"^\", this._offset, []);\n\t        if (typeof type0 === \"object\") {\n\t          extend(address0, type0);\n\t        }\n\t        this._offset += 1;\n\t      } else {\n\t        address0 = null;\n\t        var slice1 = null;\n\t        if (this._input.length > this._offset) {\n\t          slice1 = this._input.substring(this._offset, this._offset + 1);\n\t        } else {\n\t          slice1 = null;\n\t        }\n\t        if (!this.error || this.error.offset <= this._offset) {\n\t          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"^\\\"\"};\n\t        }\n\t      }\n\t      if (address0) {\n\t        var type1 = find(this.constructor, \"Anchor\");\n\t        if (typeof type1 === \"object\") {\n\t          extend(address0, type1);\n\t        }\n\t      } else {\n\t        this._offset = index1;\n\t        var slice2 = null;\n\t        if (this._input.length > this._offset) {\n\t          slice2 = this._input.substring(this._offset, this._offset + 1);\n\t        } else {\n\t          slice2 = null;\n\t        }\n\t        if (slice2 === \"$\") {\n\t          var klass1 = this.constructor.SyntaxNode;\n\t          var type2 = null;\n\t          address0 = new klass1(\"$\", this._offset, []);\n\t          if (typeof type2 === \"object\") {\n\t            extend(address0, type2);\n\t          }\n\t          this._offset += 1;\n\t        } else {\n\t          address0 = null;\n\t          var slice3 = null;\n\t          if (this._input.length > this._offset) {\n\t            slice3 = this._input.substring(this._offset, this._offset + 1);\n\t          } else {\n\t            slice3 = null;\n\t          }\n\t          if (!this.error || this.error.offset <= this._offset) {\n\t            this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"$\\\"\"};\n\t          }\n\t        }\n\t        if (address0) {\n\t          var type3 = find(this.constructor, \"Anchor\");\n\t          if (typeof type3 === \"object\") {\n\t            extend(address0, type3);\n\t          }\n\t        } else {\n\t          this._offset = index1;\n\t        }\n\t      }\n\t      return this._nodeCache[\"anchor\"][index0] = address0;\n\t    },\n\t    __consume__match_fragment: function(input) {\n\t      var address0 = null, index0 = this._offset;\n\t      this._nodeCache[\"match_fragment\"] = this._nodeCache[\"match_fragment\"] || {};\n\t      var cached = this._nodeCache[\"match_fragment\"][index0];\n\t      if (cached) {\n\t        this._offset += cached.textValue.length;\n\t        return cached;\n\t      }\n\t      var index1 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n\t      var address1 = null;\n\t      var index2 = this._offset;\n\t      address1 = this.__consume__anchor();\n\t      if (address1) {\n\t      } else {\n\t        this._offset = index2;\n\t        address1 = this.__consume__subexp();\n\t        if (address1) {\n\t        } else {\n\t          this._offset = index2;\n\t          address1 = this.__consume__charset();\n\t          if (address1) {\n\t          } else {\n\t            this._offset = index2;\n\t            address1 = this.__consume__terminal();\n\t            if (address1) {\n\t            } else {\n\t              this._offset = index2;\n\t            }\n\t          }\n\t        }\n\t      }\n\t      if (address1) {\n\t        elements0.push(address1);\n\t        text0 += address1.textValue;\n\t        labelled0.content = address1;\n\t        var address2 = null;\n\t        var index3 = this._offset;\n\t        address2 = this.__consume__repeat();\n\t        if (address2) {\n\t        } else {\n\t          this._offset = index3;\n\t          var klass0 = this.constructor.SyntaxNode;\n\t          var type0 = null;\n\t          address2 = new klass0(\"\", this._offset, []);\n\t          if (typeof type0 === \"object\") {\n\t            extend(address2, type0);\n\t          }\n\t          this._offset += 0;\n\t        }\n\t        if (address2) {\n\t          elements0.push(address2);\n\t          text0 += address2.textValue;\n\t          labelled0.repeat = address2;\n\t        } else {\n\t          elements0 = null;\n\t          this._offset = index1;\n\t        }\n\t      } else {\n\t        elements0 = null;\n\t        this._offset = index1;\n\t      }\n\t      if (elements0) {\n\t        this._offset = index1;\n\t        var klass1 = this.constructor.SyntaxNode;\n\t        var type1 = find(this.constructor, \"MatchFragment\");\n\t        address0 = new klass1(text0, this._offset, elements0, labelled0);\n\t        if (typeof type1 === \"object\") {\n\t          extend(address0, type1);\n\t        }\n\t        this._offset += text0.length;\n\t      } else {\n\t        address0 = null;\n\t      }\n\t      return this._nodeCache[\"match_fragment\"][index0] = address0;\n\t    },\n\t    __consume__repeat: function(input) {\n\t      var address0 = null, index0 = this._offset;\n\t      this._nodeCache[\"repeat\"] = this._nodeCache[\"repeat\"] || {};\n\t      var cached = this._nodeCache[\"repeat\"][index0];\n\t      if (cached) {\n\t        this._offset += cached.textValue.length;\n\t        return cached;\n\t      }\n\t      var index1 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n\t      var address1 = null;\n\t      var index2 = this._offset;\n\t      address1 = this.__consume__repeat_any();\n\t      if (address1) {\n\t      } else {\n\t        this._offset = index2;\n\t        address1 = this.__consume__repeat_required();\n\t        if (address1) {\n\t        } else {\n\t          this._offset = index2;\n\t          address1 = this.__consume__repeat_optional();\n\t          if (address1) {\n\t          } else {\n\t            this._offset = index2;\n\t            address1 = this.__consume__repeat_spec();\n\t            if (address1) {\n\t            } else {\n\t              this._offset = index2;\n\t            }\n\t          }\n\t        }\n\t      }\n\t      if (address1) {\n\t        elements0.push(address1);\n\t        text0 += address1.textValue;\n\t        labelled0.spec = address1;\n\t        var address2 = null;\n\t        var index3 = this._offset;\n\t        var slice0 = null;\n\t        if (this._input.length > this._offset) {\n\t          slice0 = this._input.substring(this._offset, this._offset + 1);\n\t        } else {\n\t          slice0 = null;\n\t        }\n\t        if (slice0 === \"?\") {\n\t          var klass0 = this.constructor.SyntaxNode;\n\t          var type0 = null;\n\t          address2 = new klass0(\"?\", this._offset, []);\n\t          if (typeof type0 === \"object\") {\n\t            extend(address2, type0);\n\t          }\n\t          this._offset += 1;\n\t        } else {\n\t          address2 = null;\n\t          var slice1 = null;\n\t          if (this._input.length > this._offset) {\n\t            slice1 = this._input.substring(this._offset, this._offset + 1);\n\t          } else {\n\t            slice1 = null;\n\t          }\n\t          if (!this.error || this.error.offset <= this._offset) {\n\t            this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"?\\\"\"};\n\t          }\n\t        }\n\t        if (address2) {\n\t        } else {\n\t          this._offset = index3;\n\t          var klass1 = this.constructor.SyntaxNode;\n\t          var type1 = null;\n\t          address2 = new klass1(\"\", this._offset, []);\n\t          if (typeof type1 === \"object\") {\n\t            extend(address2, type1);\n\t          }\n\t          this._offset += 0;\n\t        }\n\t        if (address2) {\n\t          elements0.push(address2);\n\t          text0 += address2.textValue;\n\t          labelled0.greedy = address2;\n\t        } else {\n\t          elements0 = null;\n\t          this._offset = index1;\n\t        }\n\t      } else {\n\t        elements0 = null;\n\t        this._offset = index1;\n\t      }\n\t      if (elements0) {\n\t        this._offset = index1;\n\t        var klass2 = this.constructor.SyntaxNode;\n\t        var type2 = find(this.constructor, \"Repeat\");\n\t        address0 = new klass2(text0, this._offset, elements0, labelled0);\n\t        if (typeof type2 === \"object\") {\n\t          extend(address0, type2);\n\t        }\n\t        this._offset += text0.length;\n\t      } else {\n\t        address0 = null;\n\t      }\n\t      return this._nodeCache[\"repeat\"][index0] = address0;\n\t    },\n\t    __consume__repeat_any: function(input) {\n\t      var address0 = null, index0 = this._offset;\n\t      this._nodeCache[\"repeat_any\"] = this._nodeCache[\"repeat_any\"] || {};\n\t      var cached = this._nodeCache[\"repeat_any\"][index0];\n\t      if (cached) {\n\t        this._offset += cached.textValue.length;\n\t        return cached;\n\t      }\n\t      var slice0 = null;\n\t      if (this._input.length > this._offset) {\n\t        slice0 = this._input.substring(this._offset, this._offset + 1);\n\t      } else {\n\t        slice0 = null;\n\t      }\n\t      if (slice0 === \"*\") {\n\t        var klass0 = this.constructor.SyntaxNode;\n\t        var type0 = find(this.constructor, \"RepeatAny\");\n\t        address0 = new klass0(\"*\", this._offset, []);\n\t        if (typeof type0 === \"object\") {\n\t          extend(address0, type0);\n\t        }\n\t        this._offset += 1;\n\t      } else {\n\t        address0 = null;\n\t        var slice1 = null;\n\t        if (this._input.length > this._offset) {\n\t          slice1 = this._input.substring(this._offset, this._offset + 1);\n\t        } else {\n\t          slice1 = null;\n\t        }\n\t        if (!this.error || this.error.offset <= this._offset) {\n\t          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"*\\\"\"};\n\t        }\n\t      }\n\t      return this._nodeCache[\"repeat_any\"][index0] = address0;\n\t    },\n\t    __consume__repeat_required: function(input) {\n\t      var address0 = null, index0 = this._offset;\n\t      this._nodeCache[\"repeat_required\"] = this._nodeCache[\"repeat_required\"] || {};\n\t      var cached = this._nodeCache[\"repeat_required\"][index0];\n\t      if (cached) {\n\t        this._offset += cached.textValue.length;\n\t        return cached;\n\t      }\n\t      var slice0 = null;\n\t      if (this._input.length > this._offset) {\n\t        slice0 = this._input.substring(this._offset, this._offset + 1);\n\t      } else {\n\t        slice0 = null;\n\t      }\n\t      if (slice0 === \"+\") {\n\t        var klass0 = this.constructor.SyntaxNode;\n\t        var type0 = find(this.constructor, \"RepeatRequired\");\n\t        address0 = new klass0(\"+\", this._offset, []);\n\t        if (typeof type0 === \"object\") {\n\t          extend(address0, type0);\n\t        }\n\t        this._offset += 1;\n\t      } else {\n\t        address0 = null;\n\t        var slice1 = null;\n\t        if (this._input.length > this._offset) {\n\t          slice1 = this._input.substring(this._offset, this._offset + 1);\n\t        } else {\n\t          slice1 = null;\n\t        }\n\t        if (!this.error || this.error.offset <= this._offset) {\n\t          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"+\\\"\"};\n\t        }\n\t      }\n\t      return this._nodeCache[\"repeat_required\"][index0] = address0;\n\t    },\n\t    __consume__repeat_optional: function(input) {\n\t      var address0 = null, index0 = this._offset;\n\t      this._nodeCache[\"repeat_optional\"] = this._nodeCache[\"repeat_optional\"] || {};\n\t      var cached = this._nodeCache[\"repeat_optional\"][index0];\n\t      if (cached) {\n\t        this._offset += cached.textValue.length;\n\t        return cached;\n\t      }\n\t      var slice0 = null;\n\t      if (this._input.length > this._offset) {\n\t        slice0 = this._input.substring(this._offset, this._offset + 1);\n\t      } else {\n\t        slice0 = null;\n\t      }\n\t      if (slice0 === \"?\") {\n\t        var klass0 = this.constructor.SyntaxNode;\n\t        var type0 = find(this.constructor, \"RepeatOptional\");\n\t        address0 = new klass0(\"?\", this._offset, []);\n\t        if (typeof type0 === \"object\") {\n\t          extend(address0, type0);\n\t        }\n\t        this._offset += 1;\n\t      } else {\n\t        address0 = null;\n\t        var slice1 = null;\n\t        if (this._input.length > this._offset) {\n\t          slice1 = this._input.substring(this._offset, this._offset + 1);\n\t        } else {\n\t          slice1 = null;\n\t        }\n\t        if (!this.error || this.error.offset <= this._offset) {\n\t          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"?\\\"\"};\n\t        }\n\t      }\n\t      return this._nodeCache[\"repeat_optional\"][index0] = address0;\n\t    },\n\t    __consume__repeat_spec: function(input) {\n\t      var address0 = null, index0 = this._offset;\n\t      this._nodeCache[\"repeat_spec\"] = this._nodeCache[\"repeat_spec\"] || {};\n\t      var cached = this._nodeCache[\"repeat_spec\"][index0];\n\t      if (cached) {\n\t        this._offset += cached.textValue.length;\n\t        return cached;\n\t      }\n\t      var index1 = this._offset;\n\t      var index2 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n\t      var address1 = null;\n\t      var slice0 = null;\n\t      if (this._input.length > this._offset) {\n\t        slice0 = this._input.substring(this._offset, this._offset + 1);\n\t      } else {\n\t        slice0 = null;\n\t      }\n\t      if (slice0 === \"{\") {\n\t        var klass0 = this.constructor.SyntaxNode;\n\t        var type0 = null;\n\t        address1 = new klass0(\"{\", this._offset, []);\n\t        if (typeof type0 === \"object\") {\n\t          extend(address1, type0);\n\t        }\n\t        this._offset += 1;\n\t      } else {\n\t        address1 = null;\n\t        var slice1 = null;\n\t        if (this._input.length > this._offset) {\n\t          slice1 = this._input.substring(this._offset, this._offset + 1);\n\t        } else {\n\t          slice1 = null;\n\t        }\n\t        if (!this.error || this.error.offset <= this._offset) {\n\t          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"{\\\"\"};\n\t        }\n\t      }\n\t      if (address1) {\n\t        elements0.push(address1);\n\t        text0 += address1.textValue;\n\t        var address2 = null;\n\t        var remaining0 = 1, index3 = this._offset, elements1 = [], text1 = \"\", address3 = true;\n\t        while (address3) {\n\t          var slice2 = null;\n\t          if (this._input.length > this._offset) {\n\t            slice2 = this._input.substring(this._offset, this._offset + 1);\n\t          } else {\n\t            slice2 = null;\n\t          }\n\t          if (slice2 && /^[0-9]/.test(slice2)) {\n\t            var klass1 = this.constructor.SyntaxNode;\n\t            var type1 = null;\n\t            address3 = new klass1(slice2, this._offset, []);\n\t            if (typeof type1 === \"object\") {\n\t              extend(address3, type1);\n\t            }\n\t            this._offset += 1;\n\t          } else {\n\t            address3 = null;\n\t            var slice3 = null;\n\t            if (this._input.length > this._offset) {\n\t              slice3 = this._input.substring(this._offset, this._offset + 1);\n\t            } else {\n\t              slice3 = null;\n\t            }\n\t            if (!this.error || this.error.offset <= this._offset) {\n\t              this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[0-9]\"};\n\t            }\n\t          }\n\t          if (address3) {\n\t            elements1.push(address3);\n\t            text1 += address3.textValue;\n\t            remaining0 -= 1;\n\t          }\n\t        }\n\t        if (remaining0 <= 0) {\n\t          this._offset = index3;\n\t          var klass2 = this.constructor.SyntaxNode;\n\t          var type2 = null;\n\t          address2 = new klass2(text1, this._offset, elements1);\n\t          if (typeof type2 === \"object\") {\n\t            extend(address2, type2);\n\t          }\n\t          this._offset += text1.length;\n\t        } else {\n\t          address2 = null;\n\t        }\n\t        if (address2) {\n\t          elements0.push(address2);\n\t          text0 += address2.textValue;\n\t          labelled0.min = address2;\n\t          var address4 = null;\n\t          var slice4 = null;\n\t          if (this._input.length > this._offset) {\n\t            slice4 = this._input.substring(this._offset, this._offset + 1);\n\t          } else {\n\t            slice4 = null;\n\t          }\n\t          if (slice4 === \",\") {\n\t            var klass3 = this.constructor.SyntaxNode;\n\t            var type3 = null;\n\t            address4 = new klass3(\",\", this._offset, []);\n\t            if (typeof type3 === \"object\") {\n\t              extend(address4, type3);\n\t            }\n\t            this._offset += 1;\n\t          } else {\n\t            address4 = null;\n\t            var slice5 = null;\n\t            if (this._input.length > this._offset) {\n\t              slice5 = this._input.substring(this._offset, this._offset + 1);\n\t            } else {\n\t              slice5 = null;\n\t            }\n\t            if (!this.error || this.error.offset <= this._offset) {\n\t              this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\",\\\"\"};\n\t            }\n\t          }\n\t          if (address4) {\n\t            elements0.push(address4);\n\t            text0 += address4.textValue;\n\t            var address5 = null;\n\t            var remaining1 = 1, index4 = this._offset, elements2 = [], text2 = \"\", address6 = true;\n\t            while (address6) {\n\t              var slice6 = null;\n\t              if (this._input.length > this._offset) {\n\t                slice6 = this._input.substring(this._offset, this._offset + 1);\n\t              } else {\n\t                slice6 = null;\n\t              }\n\t              if (slice6 && /^[0-9]/.test(slice6)) {\n\t                var klass4 = this.constructor.SyntaxNode;\n\t                var type4 = null;\n\t                address6 = new klass4(slice6, this._offset, []);\n\t                if (typeof type4 === \"object\") {\n\t                  extend(address6, type4);\n\t                }\n\t                this._offset += 1;\n\t              } else {\n\t                address6 = null;\n\t                var slice7 = null;\n\t                if (this._input.length > this._offset) {\n\t                  slice7 = this._input.substring(this._offset, this._offset + 1);\n\t                } else {\n\t                  slice7 = null;\n\t                }\n\t                if (!this.error || this.error.offset <= this._offset) {\n\t                  this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[0-9]\"};\n\t                }\n\t              }\n\t              if (address6) {\n\t                elements2.push(address6);\n\t                text2 += address6.textValue;\n\t                remaining1 -= 1;\n\t              }\n\t            }\n\t            if (remaining1 <= 0) {\n\t              this._offset = index4;\n\t              var klass5 = this.constructor.SyntaxNode;\n\t              var type5 = null;\n\t              address5 = new klass5(text2, this._offset, elements2);\n\t              if (typeof type5 === \"object\") {\n\t                extend(address5, type5);\n\t              }\n\t              this._offset += text2.length;\n\t            } else {\n\t              address5 = null;\n\t            }\n\t            if (address5) {\n\t              elements0.push(address5);\n\t              text0 += address5.textValue;\n\t              labelled0.max = address5;\n\t              var address7 = null;\n\t              var slice8 = null;\n\t              if (this._input.length > this._offset) {\n\t                slice8 = this._input.substring(this._offset, this._offset + 1);\n\t              } else {\n\t                slice8 = null;\n\t              }\n\t              if (slice8 === \"}\") {\n\t                var klass6 = this.constructor.SyntaxNode;\n\t                var type6 = null;\n\t                address7 = new klass6(\"}\", this._offset, []);\n\t                if (typeof type6 === \"object\") {\n\t                  extend(address7, type6);\n\t                }\n\t                this._offset += 1;\n\t              } else {\n\t                address7 = null;\n\t                var slice9 = null;\n\t                if (this._input.length > this._offset) {\n\t                  slice9 = this._input.substring(this._offset, this._offset + 1);\n\t                } else {\n\t                  slice9 = null;\n\t                }\n\t                if (!this.error || this.error.offset <= this._offset) {\n\t                  this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"}\\\"\"};\n\t                }\n\t              }\n\t              if (address7) {\n\t                elements0.push(address7);\n\t                text0 += address7.textValue;\n\t              } else {\n\t                elements0 = null;\n\t                this._offset = index2;\n\t              }\n\t            } else {\n\t              elements0 = null;\n\t              this._offset = index2;\n\t            }\n\t          } else {\n\t            elements0 = null;\n\t            this._offset = index2;\n\t          }\n\t        } else {\n\t          elements0 = null;\n\t          this._offset = index2;\n\t        }\n\t      } else {\n\t        elements0 = null;\n\t        this._offset = index2;\n\t      }\n\t      if (elements0) {\n\t        this._offset = index2;\n\t        var klass7 = this.constructor.SyntaxNode;\n\t        var type7 = null;\n\t        address0 = new klass7(text0, this._offset, elements0, labelled0);\n\t        if (typeof type7 === \"object\") {\n\t          extend(address0, type7);\n\t        }\n\t        this._offset += text0.length;\n\t      } else {\n\t        address0 = null;\n\t      }\n\t      if (address0) {\n\t        var type8 = find(this.constructor, \"RepeatSpec\");\n\t        if (typeof type8 === \"object\") {\n\t          extend(address0, type8);\n\t        }\n\t      } else {\n\t        this._offset = index1;\n\t        var index5 = this._offset, elements3 = [], labelled1 = {}, text3 = \"\";\n\t        var address8 = null;\n\t        var slice10 = null;\n\t        if (this._input.length > this._offset) {\n\t          slice10 = this._input.substring(this._offset, this._offset + 1);\n\t        } else {\n\t          slice10 = null;\n\t        }\n\t        if (slice10 === \"{\") {\n\t          var klass8 = this.constructor.SyntaxNode;\n\t          var type9 = null;\n\t          address8 = new klass8(\"{\", this._offset, []);\n\t          if (typeof type9 === \"object\") {\n\t            extend(address8, type9);\n\t          }\n\t          this._offset += 1;\n\t        } else {\n\t          address8 = null;\n\t          var slice11 = null;\n\t          if (this._input.length > this._offset) {\n\t            slice11 = this._input.substring(this._offset, this._offset + 1);\n\t          } else {\n\t            slice11 = null;\n\t          }\n\t          if (!this.error || this.error.offset <= this._offset) {\n\t            this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"{\\\"\"};\n\t          }\n\t        }\n\t        if (address8) {\n\t          elements3.push(address8);\n\t          text3 += address8.textValue;\n\t          var address9 = null;\n\t          var remaining2 = 1, index6 = this._offset, elements4 = [], text4 = \"\", address10 = true;\n\t          while (address10) {\n\t            var slice12 = null;\n\t            if (this._input.length > this._offset) {\n\t              slice12 = this._input.substring(this._offset, this._offset + 1);\n\t            } else {\n\t              slice12 = null;\n\t            }\n\t            if (slice12 && /^[0-9]/.test(slice12)) {\n\t              var klass9 = this.constructor.SyntaxNode;\n\t              var type10 = null;\n\t              address10 = new klass9(slice12, this._offset, []);\n\t              if (typeof type10 === \"object\") {\n\t                extend(address10, type10);\n\t              }\n\t              this._offset += 1;\n\t            } else {\n\t              address10 = null;\n\t              var slice13 = null;\n\t              if (this._input.length > this._offset) {\n\t                slice13 = this._input.substring(this._offset, this._offset + 1);\n\t              } else {\n\t                slice13 = null;\n\t              }\n\t              if (!this.error || this.error.offset <= this._offset) {\n\t                this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[0-9]\"};\n\t              }\n\t            }\n\t            if (address10) {\n\t              elements4.push(address10);\n\t              text4 += address10.textValue;\n\t              remaining2 -= 1;\n\t            }\n\t          }\n\t          if (remaining2 <= 0) {\n\t            this._offset = index6;\n\t            var klass10 = this.constructor.SyntaxNode;\n\t            var type11 = null;\n\t            address9 = new klass10(text4, this._offset, elements4);\n\t            if (typeof type11 === \"object\") {\n\t              extend(address9, type11);\n\t            }\n\t            this._offset += text4.length;\n\t          } else {\n\t            address9 = null;\n\t          }\n\t          if (address9) {\n\t            elements3.push(address9);\n\t            text3 += address9.textValue;\n\t            labelled1.min = address9;\n\t            var address11 = null;\n\t            var slice14 = null;\n\t            if (this._input.length > this._offset) {\n\t              slice14 = this._input.substring(this._offset, this._offset + 2);\n\t            } else {\n\t              slice14 = null;\n\t            }\n\t            if (slice14 === \",}\") {\n\t              var klass11 = this.constructor.SyntaxNode;\n\t              var type12 = null;\n\t              address11 = new klass11(\",}\", this._offset, []);\n\t              if (typeof type12 === \"object\") {\n\t                extend(address11, type12);\n\t              }\n\t              this._offset += 2;\n\t            } else {\n\t              address11 = null;\n\t              var slice15 = null;\n\t              if (this._input.length > this._offset) {\n\t                slice15 = this._input.substring(this._offset, this._offset + 1);\n\t              } else {\n\t                slice15 = null;\n\t              }\n\t              if (!this.error || this.error.offset <= this._offset) {\n\t                this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\",}\\\"\"};\n\t              }\n\t            }\n\t            if (address11) {\n\t              elements3.push(address11);\n\t              text3 += address11.textValue;\n\t            } else {\n\t              elements3 = null;\n\t              this._offset = index5;\n\t            }\n\t          } else {\n\t            elements3 = null;\n\t            this._offset = index5;\n\t          }\n\t        } else {\n\t          elements3 = null;\n\t          this._offset = index5;\n\t        }\n\t        if (elements3) {\n\t          this._offset = index5;\n\t          var klass12 = this.constructor.SyntaxNode;\n\t          var type13 = null;\n\t          address0 = new klass12(text3, this._offset, elements3, labelled1);\n\t          if (typeof type13 === \"object\") {\n\t            extend(address0, type13);\n\t          }\n\t          this._offset += text3.length;\n\t        } else {\n\t          address0 = null;\n\t        }\n\t        if (address0) {\n\t          var type14 = find(this.constructor, \"RepeatSpec\");\n\t          if (typeof type14 === \"object\") {\n\t            extend(address0, type14);\n\t          }\n\t        } else {\n\t          this._offset = index1;\n\t          var index7 = this._offset, elements5 = [], labelled2 = {}, text5 = \"\";\n\t          var address12 = null;\n\t          var slice16 = null;\n\t          if (this._input.length > this._offset) {\n\t            slice16 = this._input.substring(this._offset, this._offset + 1);\n\t          } else {\n\t            slice16 = null;\n\t          }\n\t          if (slice16 === \"{\") {\n\t            var klass13 = this.constructor.SyntaxNode;\n\t            var type15 = null;\n\t            address12 = new klass13(\"{\", this._offset, []);\n\t            if (typeof type15 === \"object\") {\n\t              extend(address12, type15);\n\t            }\n\t            this._offset += 1;\n\t          } else {\n\t            address12 = null;\n\t            var slice17 = null;\n\t            if (this._input.length > this._offset) {\n\t              slice17 = this._input.substring(this._offset, this._offset + 1);\n\t            } else {\n\t              slice17 = null;\n\t            }\n\t            if (!this.error || this.error.offset <= this._offset) {\n\t              this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"{\\\"\"};\n\t            }\n\t          }\n\t          if (address12) {\n\t            elements5.push(address12);\n\t            text5 += address12.textValue;\n\t            var address13 = null;\n\t            var remaining3 = 1, index8 = this._offset, elements6 = [], text6 = \"\", address14 = true;\n\t            while (address14) {\n\t              var slice18 = null;\n\t              if (this._input.length > this._offset) {\n\t                slice18 = this._input.substring(this._offset, this._offset + 1);\n\t              } else {\n\t                slice18 = null;\n\t              }\n\t              if (slice18 && /^[0-9]/.test(slice18)) {\n\t                var klass14 = this.constructor.SyntaxNode;\n\t                var type16 = null;\n\t                address14 = new klass14(slice18, this._offset, []);\n\t                if (typeof type16 === \"object\") {\n\t                  extend(address14, type16);\n\t                }\n\t                this._offset += 1;\n\t              } else {\n\t                address14 = null;\n\t                var slice19 = null;\n\t                if (this._input.length > this._offset) {\n\t                  slice19 = this._input.substring(this._offset, this._offset + 1);\n\t                } else {\n\t                  slice19 = null;\n\t                }\n\t                if (!this.error || this.error.offset <= this._offset) {\n\t                  this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[0-9]\"};\n\t                }\n\t              }\n\t              if (address14) {\n\t                elements6.push(address14);\n\t                text6 += address14.textValue;\n\t                remaining3 -= 1;\n\t              }\n\t            }\n\t            if (remaining3 <= 0) {\n\t              this._offset = index8;\n\t              var klass15 = this.constructor.SyntaxNode;\n\t              var type17 = null;\n\t              address13 = new klass15(text6, this._offset, elements6);\n\t              if (typeof type17 === \"object\") {\n\t                extend(address13, type17);\n\t              }\n\t              this._offset += text6.length;\n\t            } else {\n\t              address13 = null;\n\t            }\n\t            if (address13) {\n\t              elements5.push(address13);\n\t              text5 += address13.textValue;\n\t              labelled2.exact = address13;\n\t              var address15 = null;\n\t              var slice20 = null;\n\t              if (this._input.length > this._offset) {\n\t                slice20 = this._input.substring(this._offset, this._offset + 1);\n\t              } else {\n\t                slice20 = null;\n\t              }\n\t              if (slice20 === \"}\") {\n\t                var klass16 = this.constructor.SyntaxNode;\n\t                var type18 = null;\n\t                address15 = new klass16(\"}\", this._offset, []);\n\t                if (typeof type18 === \"object\") {\n\t                  extend(address15, type18);\n\t                }\n\t                this._offset += 1;\n\t              } else {\n\t                address15 = null;\n\t                var slice21 = null;\n\t                if (this._input.length > this._offset) {\n\t                  slice21 = this._input.substring(this._offset, this._offset + 1);\n\t                } else {\n\t                  slice21 = null;\n\t                }\n\t                if (!this.error || this.error.offset <= this._offset) {\n\t                  this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"}\\\"\"};\n\t                }\n\t              }\n\t              if (address15) {\n\t                elements5.push(address15);\n\t                text5 += address15.textValue;\n\t              } else {\n\t                elements5 = null;\n\t                this._offset = index7;\n\t              }\n\t            } else {\n\t              elements5 = null;\n\t              this._offset = index7;\n\t            }\n\t          } else {\n\t            elements5 = null;\n\t            this._offset = index7;\n\t          }\n\t          if (elements5) {\n\t            this._offset = index7;\n\t            var klass17 = this.constructor.SyntaxNode;\n\t            var type19 = null;\n\t            address0 = new klass17(text5, this._offset, elements5, labelled2);\n\t            if (typeof type19 === \"object\") {\n\t              extend(address0, type19);\n\t            }\n\t            this._offset += text5.length;\n\t          } else {\n\t            address0 = null;\n\t          }\n\t          if (address0) {\n\t            var type20 = find(this.constructor, \"RepeatSpec\");\n\t            if (typeof type20 === \"object\") {\n\t              extend(address0, type20);\n\t            }\n\t          } else {\n\t            this._offset = index1;\n\t          }\n\t        }\n\t      }\n\t      return this._nodeCache[\"repeat_spec\"][index0] = address0;\n\t    },\n\t    __consume__subexp: function(input) {\n\t      var address0 = null, index0 = this._offset;\n\t      this._nodeCache[\"subexp\"] = this._nodeCache[\"subexp\"] || {};\n\t      var cached = this._nodeCache[\"subexp\"][index0];\n\t      if (cached) {\n\t        this._offset += cached.textValue.length;\n\t        return cached;\n\t      }\n\t      var index1 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n\t      var address1 = null;\n\t      var slice0 = null;\n\t      if (this._input.length > this._offset) {\n\t        slice0 = this._input.substring(this._offset, this._offset + 1);\n\t      } else {\n\t        slice0 = null;\n\t      }\n\t      if (slice0 === \"(\") {\n\t        var klass0 = this.constructor.SyntaxNode;\n\t        var type0 = null;\n\t        address1 = new klass0(\"(\", this._offset, []);\n\t        if (typeof type0 === \"object\") {\n\t          extend(address1, type0);\n\t        }\n\t        this._offset += 1;\n\t      } else {\n\t        address1 = null;\n\t        var slice1 = null;\n\t        if (this._input.length > this._offset) {\n\t          slice1 = this._input.substring(this._offset, this._offset + 1);\n\t        } else {\n\t          slice1 = null;\n\t        }\n\t        if (!this.error || this.error.offset <= this._offset) {\n\t          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"(\\\"\"};\n\t        }\n\t      }\n\t      if (address1) {\n\t        elements0.push(address1);\n\t        text0 += address1.textValue;\n\t        var address2 = null;\n\t        var index2 = this._offset;\n\t        var index3 = this._offset;\n\t        var slice2 = null;\n\t        if (this._input.length > this._offset) {\n\t          slice2 = this._input.substring(this._offset, this._offset + 2);\n\t        } else {\n\t          slice2 = null;\n\t        }\n\t        if (slice2 === \"?:\") {\n\t          var klass1 = this.constructor.SyntaxNode;\n\t          var type1 = null;\n\t          address2 = new klass1(\"?:\", this._offset, []);\n\t          if (typeof type1 === \"object\") {\n\t            extend(address2, type1);\n\t          }\n\t          this._offset += 2;\n\t        } else {\n\t          address2 = null;\n\t          var slice3 = null;\n\t          if (this._input.length > this._offset) {\n\t            slice3 = this._input.substring(this._offset, this._offset + 1);\n\t          } else {\n\t            slice3 = null;\n\t          }\n\t          if (!this.error || this.error.offset <= this._offset) {\n\t            this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"?:\\\"\"};\n\t          }\n\t        }\n\t        if (address2) {\n\t        } else {\n\t          this._offset = index3;\n\t          var slice4 = null;\n\t          if (this._input.length > this._offset) {\n\t            slice4 = this._input.substring(this._offset, this._offset + 2);\n\t          } else {\n\t            slice4 = null;\n\t          }\n\t          if (slice4 === \"?=\") {\n\t            var klass2 = this.constructor.SyntaxNode;\n\t            var type2 = null;\n\t            address2 = new klass2(\"?=\", this._offset, []);\n\t            if (typeof type2 === \"object\") {\n\t              extend(address2, type2);\n\t            }\n\t            this._offset += 2;\n\t          } else {\n\t            address2 = null;\n\t            var slice5 = null;\n\t            if (this._input.length > this._offset) {\n\t              slice5 = this._input.substring(this._offset, this._offset + 1);\n\t            } else {\n\t              slice5 = null;\n\t            }\n\t            if (!this.error || this.error.offset <= this._offset) {\n\t              this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"?=\\\"\"};\n\t            }\n\t          }\n\t          if (address2) {\n\t          } else {\n\t            this._offset = index3;\n\t            var slice6 = null;\n\t            if (this._input.length > this._offset) {\n\t              slice6 = this._input.substring(this._offset, this._offset + 2);\n\t            } else {\n\t              slice6 = null;\n\t            }\n\t            if (slice6 === \"?!\") {\n\t              var klass3 = this.constructor.SyntaxNode;\n\t              var type3 = null;\n\t              address2 = new klass3(\"?!\", this._offset, []);\n\t              if (typeof type3 === \"object\") {\n\t                extend(address2, type3);\n\t              }\n\t              this._offset += 2;\n\t            } else {\n\t              address2 = null;\n\t              var slice7 = null;\n\t              if (this._input.length > this._offset) {\n\t                slice7 = this._input.substring(this._offset, this._offset + 1);\n\t              } else {\n\t                slice7 = null;\n\t              }\n\t              if (!this.error || this.error.offset <= this._offset) {\n\t                this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"?!\\\"\"};\n\t              }\n\t            }\n\t            if (address2) {\n\t            } else {\n\t              this._offset = index3;\n\t            }\n\t          }\n\t        }\n\t        if (address2) {\n\t        } else {\n\t          this._offset = index2;\n\t          var klass4 = this.constructor.SyntaxNode;\n\t          var type4 = null;\n\t          address2 = new klass4(\"\", this._offset, []);\n\t          if (typeof type4 === \"object\") {\n\t            extend(address2, type4);\n\t          }\n\t          this._offset += 0;\n\t        }\n\t        if (address2) {\n\t          elements0.push(address2);\n\t          text0 += address2.textValue;\n\t          labelled0.capture = address2;\n\t          var address3 = null;\n\t          address3 = this.__consume__regexp();\n\t          if (address3) {\n\t            elements0.push(address3);\n\t            text0 += address3.textValue;\n\t            labelled0.regexp = address3;\n\t            var address4 = null;\n\t            var slice8 = null;\n\t            if (this._input.length > this._offset) {\n\t              slice8 = this._input.substring(this._offset, this._offset + 1);\n\t            } else {\n\t              slice8 = null;\n\t            }\n\t            if (slice8 === \")\") {\n\t              var klass5 = this.constructor.SyntaxNode;\n\t              var type5 = null;\n\t              address4 = new klass5(\")\", this._offset, []);\n\t              if (typeof type5 === \"object\") {\n\t                extend(address4, type5);\n\t              }\n\t              this._offset += 1;\n\t            } else {\n\t              address4 = null;\n\t              var slice9 = null;\n\t              if (this._input.length > this._offset) {\n\t                slice9 = this._input.substring(this._offset, this._offset + 1);\n\t              } else {\n\t                slice9 = null;\n\t              }\n\t              if (!this.error || this.error.offset <= this._offset) {\n\t                this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\")\\\"\"};\n\t              }\n\t            }\n\t            if (address4) {\n\t              elements0.push(address4);\n\t              text0 += address4.textValue;\n\t            } else {\n\t              elements0 = null;\n\t              this._offset = index1;\n\t            }\n\t          } else {\n\t            elements0 = null;\n\t            this._offset = index1;\n\t          }\n\t        } else {\n\t          elements0 = null;\n\t          this._offset = index1;\n\t        }\n\t      } else {\n\t        elements0 = null;\n\t        this._offset = index1;\n\t      }\n\t      if (elements0) {\n\t        this._offset = index1;\n\t        var klass6 = this.constructor.SyntaxNode;\n\t        var type6 = find(this.constructor, \"Subexp\");\n\t        address0 = new klass6(text0, this._offset, elements0, labelled0);\n\t        if (typeof type6 === \"object\") {\n\t          extend(address0, type6);\n\t        }\n\t        this._offset += text0.length;\n\t      } else {\n\t        address0 = null;\n\t      }\n\t      return this._nodeCache[\"subexp\"][index0] = address0;\n\t    },\n\t    __consume__charset: function(input) {\n\t      var address0 = null, index0 = this._offset;\n\t      this._nodeCache[\"charset\"] = this._nodeCache[\"charset\"] || {};\n\t      var cached = this._nodeCache[\"charset\"][index0];\n\t      if (cached) {\n\t        this._offset += cached.textValue.length;\n\t        return cached;\n\t      }\n\t      var index1 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n\t      var address1 = null;\n\t      var slice0 = null;\n\t      if (this._input.length > this._offset) {\n\t        slice0 = this._input.substring(this._offset, this._offset + 1);\n\t      } else {\n\t        slice0 = null;\n\t      }\n\t      if (slice0 === \"[\") {\n\t        var klass0 = this.constructor.SyntaxNode;\n\t        var type0 = null;\n\t        address1 = new klass0(\"[\", this._offset, []);\n\t        if (typeof type0 === \"object\") {\n\t          extend(address1, type0);\n\t        }\n\t        this._offset += 1;\n\t      } else {\n\t        address1 = null;\n\t        var slice1 = null;\n\t        if (this._input.length > this._offset) {\n\t          slice1 = this._input.substring(this._offset, this._offset + 1);\n\t        } else {\n\t          slice1 = null;\n\t        }\n\t        if (!this.error || this.error.offset <= this._offset) {\n\t          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"[\\\"\"};\n\t        }\n\t      }\n\t      if (address1) {\n\t        elements0.push(address1);\n\t        text0 += address1.textValue;\n\t        var address2 = null;\n\t        var index2 = this._offset;\n\t        var slice2 = null;\n\t        if (this._input.length > this._offset) {\n\t          slice2 = this._input.substring(this._offset, this._offset + 1);\n\t        } else {\n\t          slice2 = null;\n\t        }\n\t        if (slice2 === \"^\") {\n\t          var klass1 = this.constructor.SyntaxNode;\n\t          var type1 = null;\n\t          address2 = new klass1(\"^\", this._offset, []);\n\t          if (typeof type1 === \"object\") {\n\t            extend(address2, type1);\n\t          }\n\t          this._offset += 1;\n\t        } else {\n\t          address2 = null;\n\t          var slice3 = null;\n\t          if (this._input.length > this._offset) {\n\t            slice3 = this._input.substring(this._offset, this._offset + 1);\n\t          } else {\n\t            slice3 = null;\n\t          }\n\t          if (!this.error || this.error.offset <= this._offset) {\n\t            this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"^\\\"\"};\n\t          }\n\t        }\n\t        if (address2) {\n\t        } else {\n\t          this._offset = index2;\n\t          var klass2 = this.constructor.SyntaxNode;\n\t          var type2 = null;\n\t          address2 = new klass2(\"\", this._offset, []);\n\t          if (typeof type2 === \"object\") {\n\t            extend(address2, type2);\n\t          }\n\t          this._offset += 0;\n\t        }\n\t        if (address2) {\n\t          elements0.push(address2);\n\t          text0 += address2.textValue;\n\t          labelled0.invert = address2;\n\t          var address3 = null;\n\t          var remaining0 = 0, index3 = this._offset, elements1 = [], text1 = \"\", address4 = true;\n\t          while (address4) {\n\t            var index4 = this._offset;\n\t            address4 = this.__consume__charset_range();\n\t            if (address4) {\n\t            } else {\n\t              this._offset = index4;\n\t              address4 = this.__consume__charset_terminal();\n\t              if (address4) {\n\t              } else {\n\t                this._offset = index4;\n\t              }\n\t            }\n\t            if (address4) {\n\t              elements1.push(address4);\n\t              text1 += address4.textValue;\n\t              remaining0 -= 1;\n\t            }\n\t          }\n\t          if (remaining0 <= 0) {\n\t            this._offset = index3;\n\t            var klass3 = this.constructor.SyntaxNode;\n\t            var type3 = null;\n\t            address3 = new klass3(text1, this._offset, elements1);\n\t            if (typeof type3 === \"object\") {\n\t              extend(address3, type3);\n\t            }\n\t            this._offset += text1.length;\n\t          } else {\n\t            address3 = null;\n\t          }\n\t          if (address3) {\n\t            elements0.push(address3);\n\t            text0 += address3.textValue;\n\t            labelled0.parts = address3;\n\t            var address5 = null;\n\t            var slice4 = null;\n\t            if (this._input.length > this._offset) {\n\t              slice4 = this._input.substring(this._offset, this._offset + 1);\n\t            } else {\n\t              slice4 = null;\n\t            }\n\t            if (slice4 === \"]\") {\n\t              var klass4 = this.constructor.SyntaxNode;\n\t              var type4 = null;\n\t              address5 = new klass4(\"]\", this._offset, []);\n\t              if (typeof type4 === \"object\") {\n\t                extend(address5, type4);\n\t              }\n\t              this._offset += 1;\n\t            } else {\n\t              address5 = null;\n\t              var slice5 = null;\n\t              if (this._input.length > this._offset) {\n\t                slice5 = this._input.substring(this._offset, this._offset + 1);\n\t              } else {\n\t                slice5 = null;\n\t              }\n\t              if (!this.error || this.error.offset <= this._offset) {\n\t                this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"]\\\"\"};\n\t              }\n\t            }\n\t            if (address5) {\n\t              elements0.push(address5);\n\t              text0 += address5.textValue;\n\t            } else {\n\t              elements0 = null;\n\t              this._offset = index1;\n\t            }\n\t          } else {\n\t            elements0 = null;\n\t            this._offset = index1;\n\t          }\n\t        } else {\n\t          elements0 = null;\n\t          this._offset = index1;\n\t        }\n\t      } else {\n\t        elements0 = null;\n\t        this._offset = index1;\n\t      }\n\t      if (elements0) {\n\t        this._offset = index1;\n\t        var klass5 = this.constructor.SyntaxNode;\n\t        var type5 = find(this.constructor, \"Charset\");\n\t        address0 = new klass5(text0, this._offset, elements0, labelled0);\n\t        if (typeof type5 === \"object\") {\n\t          extend(address0, type5);\n\t        }\n\t        this._offset += text0.length;\n\t      } else {\n\t        address0 = null;\n\t      }\n\t      return this._nodeCache[\"charset\"][index0] = address0;\n\t    },\n\t    __consume__charset_range: function(input) {\n\t      var address0 = null, index0 = this._offset;\n\t      this._nodeCache[\"charset_range\"] = this._nodeCache[\"charset_range\"] || {};\n\t      var cached = this._nodeCache[\"charset_range\"][index0];\n\t      if (cached) {\n\t        this._offset += cached.textValue.length;\n\t        return cached;\n\t      }\n\t      var index1 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n\t      var address1 = null;\n\t      address1 = this.__consume__charset_range_terminal();\n\t      if (address1) {\n\t        elements0.push(address1);\n\t        text0 += address1.textValue;\n\t        labelled0.first = address1;\n\t        var address2 = null;\n\t        var slice0 = null;\n\t        if (this._input.length > this._offset) {\n\t          slice0 = this._input.substring(this._offset, this._offset + 1);\n\t        } else {\n\t          slice0 = null;\n\t        }\n\t        if (slice0 === \"-\") {\n\t          var klass0 = this.constructor.SyntaxNode;\n\t          var type0 = null;\n\t          address2 = new klass0(\"-\", this._offset, []);\n\t          if (typeof type0 === \"object\") {\n\t            extend(address2, type0);\n\t          }\n\t          this._offset += 1;\n\t        } else {\n\t          address2 = null;\n\t          var slice1 = null;\n\t          if (this._input.length > this._offset) {\n\t            slice1 = this._input.substring(this._offset, this._offset + 1);\n\t          } else {\n\t            slice1 = null;\n\t          }\n\t          if (!this.error || this.error.offset <= this._offset) {\n\t            this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"-\\\"\"};\n\t          }\n\t        }\n\t        if (address2) {\n\t          elements0.push(address2);\n\t          text0 += address2.textValue;\n\t          var address3 = null;\n\t          address3 = this.__consume__charset_range_terminal();\n\t          if (address3) {\n\t            elements0.push(address3);\n\t            text0 += address3.textValue;\n\t            labelled0.last = address3;\n\t          } else {\n\t            elements0 = null;\n\t            this._offset = index1;\n\t          }\n\t        } else {\n\t          elements0 = null;\n\t          this._offset = index1;\n\t        }\n\t      } else {\n\t        elements0 = null;\n\t        this._offset = index1;\n\t      }\n\t      if (elements0) {\n\t        this._offset = index1;\n\t        var klass1 = this.constructor.SyntaxNode;\n\t        var type1 = find(this.constructor, \"CharsetRange\");\n\t        address0 = new klass1(text0, this._offset, elements0, labelled0);\n\t        if (typeof type1 === \"object\") {\n\t          extend(address0, type1);\n\t        }\n\t        this._offset += text0.length;\n\t      } else {\n\t        address0 = null;\n\t      }\n\t      return this._nodeCache[\"charset_range\"][index0] = address0;\n\t    },\n\t    __consume__charset_terminal: function(input) {\n\t      var address0 = null, index0 = this._offset;\n\t      this._nodeCache[\"charset_terminal\"] = this._nodeCache[\"charset_terminal\"] || {};\n\t      var cached = this._nodeCache[\"charset_terminal\"][index0];\n\t      if (cached) {\n\t        this._offset += cached.textValue.length;\n\t        return cached;\n\t      }\n\t      var index1 = this._offset;\n\t      address0 = this.__consume__charset_escape();\n\t      var type0 = find(this.constructor, \"CharsetEscape\");\n\t      if (typeof type0 === \"object\") {\n\t        extend(address0, type0);\n\t      }\n\t      if (address0) {\n\t      } else {\n\t        this._offset = index1;\n\t        address0 = this.__consume__charset_literal();\n\t        var type1 = find(this.constructor, \"Literal\");\n\t        if (typeof type1 === \"object\") {\n\t          extend(address0, type1);\n\t        }\n\t        if (address0) {\n\t        } else {\n\t          this._offset = index1;\n\t        }\n\t      }\n\t      return this._nodeCache[\"charset_terminal\"][index0] = address0;\n\t    },\n\t    __consume__charset_range_terminal: function(input) {\n\t      var address0 = null, index0 = this._offset;\n\t      this._nodeCache[\"charset_range_terminal\"] = this._nodeCache[\"charset_range_terminal\"] || {};\n\t      var cached = this._nodeCache[\"charset_range_terminal\"][index0];\n\t      if (cached) {\n\t        this._offset += cached.textValue.length;\n\t        return cached;\n\t      }\n\t      var index1 = this._offset;\n\t      address0 = this.__consume__charset_range_escape();\n\t      var type0 = find(this.constructor, \"CharsetEscape\");\n\t      if (typeof type0 === \"object\") {\n\t        extend(address0, type0);\n\t      }\n\t      if (address0) {\n\t      } else {\n\t        this._offset = index1;\n\t        address0 = this.__consume__charset_literal();\n\t        var type1 = find(this.constructor, \"Literal\");\n\t        if (typeof type1 === \"object\") {\n\t          extend(address0, type1);\n\t        }\n\t        if (address0) {\n\t        } else {\n\t          this._offset = index1;\n\t        }\n\t      }\n\t      return this._nodeCache[\"charset_range_terminal\"][index0] = address0;\n\t    },\n\t    __consume__charset_escape: function(input) {\n\t      var address0 = null, index0 = this._offset;\n\t      this._nodeCache[\"charset_escape\"] = this._nodeCache[\"charset_escape\"] || {};\n\t      var cached = this._nodeCache[\"charset_escape\"][index0];\n\t      if (cached) {\n\t        this._offset += cached.textValue.length;\n\t        return cached;\n\t      }\n\t      var index1 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n\t      var address1 = null;\n\t      var slice0 = null;\n\t      if (this._input.length > this._offset) {\n\t        slice0 = this._input.substring(this._offset, this._offset + 1);\n\t      } else {\n\t        slice0 = null;\n\t      }\n\t      if (slice0 === \"\\\\\") {\n\t        var klass0 = this.constructor.SyntaxNode;\n\t        var type0 = null;\n\t        address1 = new klass0(\"\\\\\", this._offset, []);\n\t        if (typeof type0 === \"object\") {\n\t          extend(address1, type0);\n\t        }\n\t        this._offset += 1;\n\t      } else {\n\t        address1 = null;\n\t        var slice1 = null;\n\t        if (this._input.length > this._offset) {\n\t          slice1 = this._input.substring(this._offset, this._offset + 1);\n\t        } else {\n\t          slice1 = null;\n\t        }\n\t        if (!this.error || this.error.offset <= this._offset) {\n\t          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"\\\\\\\\\\\"\"};\n\t        }\n\t      }\n\t      if (address1) {\n\t        elements0.push(address1);\n\t        text0 += address1.textValue;\n\t        var address2 = null;\n\t        var index2 = this._offset;\n\t        var index3 = this._offset, elements1 = [], labelled1 = {}, text1 = \"\";\n\t        var address3 = null;\n\t        var slice2 = null;\n\t        if (this._input.length > this._offset) {\n\t          slice2 = this._input.substring(this._offset, this._offset + 1);\n\t        } else {\n\t          slice2 = null;\n\t        }\n\t        if (slice2 && /^[bdDfnrsStvwW]/.test(slice2)) {\n\t          var klass1 = this.constructor.SyntaxNode;\n\t          var type1 = null;\n\t          address3 = new klass1(slice2, this._offset, []);\n\t          if (typeof type1 === \"object\") {\n\t            extend(address3, type1);\n\t          }\n\t          this._offset += 1;\n\t        } else {\n\t          address3 = null;\n\t          var slice3 = null;\n\t          if (this._input.length > this._offset) {\n\t            slice3 = this._input.substring(this._offset, this._offset + 1);\n\t          } else {\n\t            slice3 = null;\n\t          }\n\t          if (!this.error || this.error.offset <= this._offset) {\n\t            this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[bdDfnrsStvwW]\"};\n\t          }\n\t        }\n\t        if (address3) {\n\t          elements1.push(address3);\n\t          text1 += address3.textValue;\n\t          labelled1.code = address3;\n\t          var address4 = null;\n\t          var index4 = this._offset;\n\t          var slice4 = null;\n\t          if (this._input.length > this._offset) {\n\t            slice4 = this._input.substring(this._offset, this._offset + 0);\n\t          } else {\n\t            slice4 = null;\n\t          }\n\t          if (slice4 === \"\") {\n\t            var klass2 = this.constructor.SyntaxNode;\n\t            var type2 = null;\n\t            address4 = new klass2(\"\", this._offset, []);\n\t            if (typeof type2 === \"object\") {\n\t              extend(address4, type2);\n\t            }\n\t            this._offset += 0;\n\t          } else {\n\t            address4 = null;\n\t            var slice5 = null;\n\t            if (this._input.length > this._offset) {\n\t              slice5 = this._input.substring(this._offset, this._offset + 1);\n\t            } else {\n\t              slice5 = null;\n\t            }\n\t            if (!this.error || this.error.offset <= this._offset) {\n\t              this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"\\\"\"};\n\t            }\n\t          }\n\t          if (address4) {\n\t          } else {\n\t            this._offset = index4;\n\t            var klass3 = this.constructor.SyntaxNode;\n\t            var type3 = null;\n\t            address4 = new klass3(\"\", this._offset, []);\n\t            if (typeof type3 === \"object\") {\n\t              extend(address4, type3);\n\t            }\n\t            this._offset += 0;\n\t          }\n\t          if (address4) {\n\t            elements1.push(address4);\n\t            text1 += address4.textValue;\n\t            labelled1.arg = address4;\n\t          } else {\n\t            elements1 = null;\n\t            this._offset = index3;\n\t          }\n\t        } else {\n\t          elements1 = null;\n\t          this._offset = index3;\n\t        }\n\t        if (elements1) {\n\t          this._offset = index3;\n\t          var klass4 = this.constructor.SyntaxNode;\n\t          var type4 = null;\n\t          address2 = new klass4(text1, this._offset, elements1, labelled1);\n\t          if (typeof type4 === \"object\") {\n\t            extend(address2, type4);\n\t          }\n\t          this._offset += text1.length;\n\t        } else {\n\t          address2 = null;\n\t        }\n\t        if (address2) {\n\t        } else {\n\t          this._offset = index2;\n\t          address2 = this.__consume__control_escape();\n\t          if (address2) {\n\t          } else {\n\t            this._offset = index2;\n\t            address2 = this.__consume__octal_escape();\n\t            if (address2) {\n\t            } else {\n\t              this._offset = index2;\n\t              address2 = this.__consume__hex_escape();\n\t              if (address2) {\n\t              } else {\n\t                this._offset = index2;\n\t                address2 = this.__consume__unicode_escape();\n\t                if (address2) {\n\t                } else {\n\t                  this._offset = index2;\n\t                  address2 = this.__consume__null_escape();\n\t                  if (address2) {\n\t                  } else {\n\t                    this._offset = index2;\n\t                  }\n\t                }\n\t              }\n\t            }\n\t          }\n\t        }\n\t        if (address2) {\n\t          elements0.push(address2);\n\t          text0 += address2.textValue;\n\t          labelled0.esc = address2;\n\t        } else {\n\t          elements0 = null;\n\t          this._offset = index1;\n\t        }\n\t      } else {\n\t        elements0 = null;\n\t        this._offset = index1;\n\t      }\n\t      if (elements0) {\n\t        this._offset = index1;\n\t        var klass5 = this.constructor.SyntaxNode;\n\t        var type5 = null;\n\t        address0 = new klass5(text0, this._offset, elements0, labelled0);\n\t        if (typeof type5 === \"object\") {\n\t          extend(address0, type5);\n\t        }\n\t        this._offset += text0.length;\n\t      } else {\n\t        address0 = null;\n\t      }\n\t      return this._nodeCache[\"charset_escape\"][index0] = address0;\n\t    },\n\t    __consume__charset_range_escape: function(input) {\n\t      var address0 = null, index0 = this._offset;\n\t      this._nodeCache[\"charset_range_escape\"] = this._nodeCache[\"charset_range_escape\"] || {};\n\t      var cached = this._nodeCache[\"charset_range_escape\"][index0];\n\t      if (cached) {\n\t        this._offset += cached.textValue.length;\n\t        return cached;\n\t      }\n\t      var index1 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n\t      var address1 = null;\n\t      var slice0 = null;\n\t      if (this._input.length > this._offset) {\n\t        slice0 = this._input.substring(this._offset, this._offset + 1);\n\t      } else {\n\t        slice0 = null;\n\t      }\n\t      if (slice0 === \"\\\\\") {\n\t        var klass0 = this.constructor.SyntaxNode;\n\t        var type0 = null;\n\t        address1 = new klass0(\"\\\\\", this._offset, []);\n\t        if (typeof type0 === \"object\") {\n\t          extend(address1, type0);\n\t        }\n\t        this._offset += 1;\n\t      } else {\n\t        address1 = null;\n\t        var slice1 = null;\n\t        if (this._input.length > this._offset) {\n\t          slice1 = this._input.substring(this._offset, this._offset + 1);\n\t        } else {\n\t          slice1 = null;\n\t        }\n\t        if (!this.error || this.error.offset <= this._offset) {\n\t          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"\\\\\\\\\\\"\"};\n\t        }\n\t      }\n\t      if (address1) {\n\t        elements0.push(address1);\n\t        text0 += address1.textValue;\n\t        var address2 = null;\n\t        var index2 = this._offset;\n\t        var index3 = this._offset, elements1 = [], labelled1 = {}, text1 = \"\";\n\t        var address3 = null;\n\t        var slice2 = null;\n\t        if (this._input.length > this._offset) {\n\t          slice2 = this._input.substring(this._offset, this._offset + 1);\n\t        } else {\n\t          slice2 = null;\n\t        }\n\t        if (slice2 && /^[bfnrtv]/.test(slice2)) {\n\t          var klass1 = this.constructor.SyntaxNode;\n\t          var type1 = null;\n\t          address3 = new klass1(slice2, this._offset, []);\n\t          if (typeof type1 === \"object\") {\n\t            extend(address3, type1);\n\t          }\n\t          this._offset += 1;\n\t        } else {\n\t          address3 = null;\n\t          var slice3 = null;\n\t          if (this._input.length > this._offset) {\n\t            slice3 = this._input.substring(this._offset, this._offset + 1);\n\t          } else {\n\t            slice3 = null;\n\t          }\n\t          if (!this.error || this.error.offset <= this._offset) {\n\t            this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[bfnrtv]\"};\n\t          }\n\t        }\n\t        if (address3) {\n\t          elements1.push(address3);\n\t          text1 += address3.textValue;\n\t          labelled1.code = address3;\n\t          var address4 = null;\n\t          var index4 = this._offset;\n\t          var slice4 = null;\n\t          if (this._input.length > this._offset) {\n\t            slice4 = this._input.substring(this._offset, this._offset + 0);\n\t          } else {\n\t            slice4 = null;\n\t          }\n\t          if (slice4 === \"\") {\n\t            var klass2 = this.constructor.SyntaxNode;\n\t            var type2 = null;\n\t            address4 = new klass2(\"\", this._offset, []);\n\t            if (typeof type2 === \"object\") {\n\t              extend(address4, type2);\n\t            }\n\t            this._offset += 0;\n\t          } else {\n\t            address4 = null;\n\t            var slice5 = null;\n\t            if (this._input.length > this._offset) {\n\t              slice5 = this._input.substring(this._offset, this._offset + 1);\n\t            } else {\n\t              slice5 = null;\n\t            }\n\t            if (!this.error || this.error.offset <= this._offset) {\n\t              this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"\\\"\"};\n\t            }\n\t          }\n\t          if (address4) {\n\t          } else {\n\t            this._offset = index4;\n\t            var klass3 = this.constructor.SyntaxNode;\n\t            var type3 = null;\n\t            address4 = new klass3(\"\", this._offset, []);\n\t            if (typeof type3 === \"object\") {\n\t              extend(address4, type3);\n\t            }\n\t            this._offset += 0;\n\t          }\n\t          if (address4) {\n\t            elements1.push(address4);\n\t            text1 += address4.textValue;\n\t            labelled1.arg = address4;\n\t          } else {\n\t            elements1 = null;\n\t            this._offset = index3;\n\t          }\n\t        } else {\n\t          elements1 = null;\n\t          this._offset = index3;\n\t        }\n\t        if (elements1) {\n\t          this._offset = index3;\n\t          var klass4 = this.constructor.SyntaxNode;\n\t          var type4 = null;\n\t          address2 = new klass4(text1, this._offset, elements1, labelled1);\n\t          if (typeof type4 === \"object\") {\n\t            extend(address2, type4);\n\t          }\n\t          this._offset += text1.length;\n\t        } else {\n\t          address2 = null;\n\t        }\n\t        if (address2) {\n\t        } else {\n\t          this._offset = index2;\n\t          address2 = this.__consume__control_escape();\n\t          if (address2) {\n\t          } else {\n\t            this._offset = index2;\n\t            address2 = this.__consume__octal_escape();\n\t            if (address2) {\n\t            } else {\n\t              this._offset = index2;\n\t              address2 = this.__consume__hex_escape();\n\t              if (address2) {\n\t              } else {\n\t                this._offset = index2;\n\t                address2 = this.__consume__unicode_escape();\n\t                if (address2) {\n\t                } else {\n\t                  this._offset = index2;\n\t                  address2 = this.__consume__null_escape();\n\t                  if (address2) {\n\t                  } else {\n\t                    this._offset = index2;\n\t                  }\n\t                }\n\t              }\n\t            }\n\t          }\n\t        }\n\t        if (address2) {\n\t          elements0.push(address2);\n\t          text0 += address2.textValue;\n\t          labelled0.esc = address2;\n\t        } else {\n\t          elements0 = null;\n\t          this._offset = index1;\n\t        }\n\t      } else {\n\t        elements0 = null;\n\t        this._offset = index1;\n\t      }\n\t      if (elements0) {\n\t        this._offset = index1;\n\t        var klass5 = this.constructor.SyntaxNode;\n\t        var type5 = null;\n\t        address0 = new klass5(text0, this._offset, elements0, labelled0);\n\t        if (typeof type5 === \"object\") {\n\t          extend(address0, type5);\n\t        }\n\t        this._offset += text0.length;\n\t      } else {\n\t        address0 = null;\n\t      }\n\t      return this._nodeCache[\"charset_range_escape\"][index0] = address0;\n\t    },\n\t    __consume__charset_literal: function(input) {\n\t      var address0 = null, index0 = this._offset;\n\t      this._nodeCache[\"charset_literal\"] = this._nodeCache[\"charset_literal\"] || {};\n\t      var cached = this._nodeCache[\"charset_literal\"][index0];\n\t      if (cached) {\n\t        this._offset += cached.textValue.length;\n\t        return cached;\n\t      }\n\t      var index1 = this._offset;\n\t      var index2 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n\t      var address1 = null;\n\t      var index3 = this._offset;\n\t      var slice0 = null;\n\t      if (this._input.length > this._offset) {\n\t        slice0 = this._input.substring(this._offset, this._offset + 0);\n\t      } else {\n\t        slice0 = null;\n\t      }\n\t      if (slice0 === \"\") {\n\t        var klass0 = this.constructor.SyntaxNode;\n\t        var type0 = null;\n\t        address1 = new klass0(\"\", this._offset, []);\n\t        if (typeof type0 === \"object\") {\n\t          extend(address1, type0);\n\t        }\n\t        this._offset += 0;\n\t      } else {\n\t        address1 = null;\n\t        var slice1 = null;\n\t        if (this._input.length > this._offset) {\n\t          slice1 = this._input.substring(this._offset, this._offset + 1);\n\t        } else {\n\t          slice1 = null;\n\t        }\n\t        if (!this.error || this.error.offset <= this._offset) {\n\t          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"\\\"\"};\n\t        }\n\t      }\n\t      if (address1) {\n\t      } else {\n\t        this._offset = index3;\n\t        var klass1 = this.constructor.SyntaxNode;\n\t        var type1 = null;\n\t        address1 = new klass1(\"\", this._offset, []);\n\t        if (typeof type1 === \"object\") {\n\t          extend(address1, type1);\n\t        }\n\t        this._offset += 0;\n\t      }\n\t      if (address1) {\n\t        elements0.push(address1);\n\t        text0 += address1.textValue;\n\t        var address2 = null;\n\t        var slice2 = null;\n\t        if (this._input.length > this._offset) {\n\t          slice2 = this._input.substring(this._offset, this._offset + 1);\n\t        } else {\n\t          slice2 = null;\n\t        }\n\t        if (slice2 && /^[^\\\\\\]]/.test(slice2)) {\n\t          var klass2 = this.constructor.SyntaxNode;\n\t          var type2 = null;\n\t          address2 = new klass2(slice2, this._offset, []);\n\t          if (typeof type2 === \"object\") {\n\t            extend(address2, type2);\n\t          }\n\t          this._offset += 1;\n\t        } else {\n\t          address2 = null;\n\t          var slice3 = null;\n\t          if (this._input.length > this._offset) {\n\t            slice3 = this._input.substring(this._offset, this._offset + 1);\n\t          } else {\n\t            slice3 = null;\n\t          }\n\t          if (!this.error || this.error.offset <= this._offset) {\n\t            this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[^\\\\\\\\\\\\]]\"};\n\t          }\n\t        }\n\t        if (address2) {\n\t          elements0.push(address2);\n\t          text0 += address2.textValue;\n\t          labelled0.literal = address2;\n\t        } else {\n\t          elements0 = null;\n\t          this._offset = index2;\n\t        }\n\t      } else {\n\t        elements0 = null;\n\t        this._offset = index2;\n\t      }\n\t      if (elements0) {\n\t        this._offset = index2;\n\t        var klass3 = this.constructor.SyntaxNode;\n\t        var type3 = null;\n\t        address0 = new klass3(text0, this._offset, elements0, labelled0);\n\t        if (typeof type3 === \"object\") {\n\t          extend(address0, type3);\n\t        }\n\t        this._offset += text0.length;\n\t      } else {\n\t        address0 = null;\n\t      }\n\t      if (address0) {\n\t      } else {\n\t        this._offset = index1;\n\t        var index4 = this._offset, elements1 = [], labelled1 = {}, text1 = \"\";\n\t        var address3 = null;\n\t        var slice4 = null;\n\t        if (this._input.length > this._offset) {\n\t          slice4 = this._input.substring(this._offset, this._offset + 1);\n\t        } else {\n\t          slice4 = null;\n\t        }\n\t        if (slice4 === \"\\\\\") {\n\t          var klass4 = this.constructor.SyntaxNode;\n\t          var type4 = null;\n\t          address3 = new klass4(\"\\\\\", this._offset, []);\n\t          if (typeof type4 === \"object\") {\n\t            extend(address3, type4);\n\t          }\n\t          this._offset += 1;\n\t        } else {\n\t          address3 = null;\n\t          var slice5 = null;\n\t          if (this._input.length > this._offset) {\n\t            slice5 = this._input.substring(this._offset, this._offset + 1);\n\t          } else {\n\t            slice5 = null;\n\t          }\n\t          if (!this.error || this.error.offset <= this._offset) {\n\t            this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"\\\\\\\\\\\"\"};\n\t          }\n\t        }\n\t        if (address3) {\n\t          elements1.push(address3);\n\t          text1 += address3.textValue;\n\t          labelled1.literal = address3;\n\t          var address4 = null;\n\t          var index5 = this._offset;\n\t          var slice6 = null;\n\t          if (this._input.length > this._offset) {\n\t            slice6 = this._input.substring(this._offset, this._offset + 1);\n\t          } else {\n\t            slice6 = null;\n\t          }\n\t          if (slice6 === \"c\") {\n\t            var klass5 = this.constructor.SyntaxNode;\n\t            var type5 = null;\n\t            address4 = new klass5(\"c\", this._offset, []);\n\t            if (typeof type5 === \"object\") {\n\t              extend(address4, type5);\n\t            }\n\t            this._offset += 1;\n\t          } else {\n\t            address4 = null;\n\t            var slice7 = null;\n\t            if (this._input.length > this._offset) {\n\t              slice7 = this._input.substring(this._offset, this._offset + 1);\n\t            } else {\n\t              slice7 = null;\n\t            }\n\t            if (!this.error || this.error.offset <= this._offset) {\n\t              this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"c\\\"\"};\n\t            }\n\t          }\n\t          this._offset = index5;\n\t          if (address4) {\n\t            var klass6 = this.constructor.SyntaxNode;\n\t            var type6 = null;\n\t            address4 = new klass6(\"\", this._offset, []);\n\t            if (typeof type6 === \"object\") {\n\t              extend(address4, type6);\n\t            }\n\t            this._offset += 0;\n\t          } else {\n\t            address4 = null;\n\t          }\n\t          if (address4) {\n\t            elements1.push(address4);\n\t            text1 += address4.textValue;\n\t          } else {\n\t            elements1 = null;\n\t            this._offset = index4;\n\t          }\n\t        } else {\n\t          elements1 = null;\n\t          this._offset = index4;\n\t        }\n\t        if (elements1) {\n\t          this._offset = index4;\n\t          var klass7 = this.constructor.SyntaxNode;\n\t          var type7 = null;\n\t          address0 = new klass7(text1, this._offset, elements1, labelled1);\n\t          if (typeof type7 === \"object\") {\n\t            extend(address0, type7);\n\t          }\n\t          this._offset += text1.length;\n\t        } else {\n\t          address0 = null;\n\t        }\n\t        if (address0) {\n\t        } else {\n\t          this._offset = index1;\n\t          var index6 = this._offset, elements2 = [], labelled2 = {}, text2 = \"\";\n\t          var address5 = null;\n\t          var slice8 = null;\n\t          if (this._input.length > this._offset) {\n\t            slice8 = this._input.substring(this._offset, this._offset + 1);\n\t          } else {\n\t            slice8 = null;\n\t          }\n\t          if (slice8 === \"\\\\\") {\n\t            var klass8 = this.constructor.SyntaxNode;\n\t            var type8 = null;\n\t            address5 = new klass8(\"\\\\\", this._offset, []);\n\t            if (typeof type8 === \"object\") {\n\t              extend(address5, type8);\n\t            }\n\t            this._offset += 1;\n\t          } else {\n\t            address5 = null;\n\t            var slice9 = null;\n\t            if (this._input.length > this._offset) {\n\t              slice9 = this._input.substring(this._offset, this._offset + 1);\n\t            } else {\n\t              slice9 = null;\n\t            }\n\t            if (!this.error || this.error.offset <= this._offset) {\n\t              this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"\\\\\\\\\\\"\"};\n\t            }\n\t          }\n\t          if (address5) {\n\t            elements2.push(address5);\n\t            text2 += address5.textValue;\n\t            var address6 = null;\n\t            var slice10 = null;\n\t            if (this._input.length > this._offset) {\n\t              slice10 = this._input.substring(this._offset, this._offset + 1);\n\t            } else {\n\t              slice10 = null;\n\t            }\n\t            if (slice10 && /^[^bdDfnrsStvwW]/.test(slice10)) {\n\t              var klass9 = this.constructor.SyntaxNode;\n\t              var type9 = null;\n\t              address6 = new klass9(slice10, this._offset, []);\n\t              if (typeof type9 === \"object\") {\n\t                extend(address6, type9);\n\t              }\n\t              this._offset += 1;\n\t            } else {\n\t              address6 = null;\n\t              var slice11 = null;\n\t              if (this._input.length > this._offset) {\n\t                slice11 = this._input.substring(this._offset, this._offset + 1);\n\t              } else {\n\t                slice11 = null;\n\t              }\n\t              if (!this.error || this.error.offset <= this._offset) {\n\t                this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[^bdDfnrsStvwW]\"};\n\t              }\n\t            }\n\t            if (address6) {\n\t              elements2.push(address6);\n\t              text2 += address6.textValue;\n\t              labelled2.literal = address6;\n\t            } else {\n\t              elements2 = null;\n\t              this._offset = index6;\n\t            }\n\t          } else {\n\t            elements2 = null;\n\t            this._offset = index6;\n\t          }\n\t          if (elements2) {\n\t            this._offset = index6;\n\t            var klass10 = this.constructor.SyntaxNode;\n\t            var type10 = null;\n\t            address0 = new klass10(text2, this._offset, elements2, labelled2);\n\t            if (typeof type10 === \"object\") {\n\t              extend(address0, type10);\n\t            }\n\t            this._offset += text2.length;\n\t          } else {\n\t            address0 = null;\n\t          }\n\t          if (address0) {\n\t          } else {\n\t            this._offset = index1;\n\t          }\n\t        }\n\t      }\n\t      return this._nodeCache[\"charset_literal\"][index0] = address0;\n\t    },\n\t    __consume__terminal: function(input) {\n\t      var address0 = null, index0 = this._offset;\n\t      this._nodeCache[\"terminal\"] = this._nodeCache[\"terminal\"] || {};\n\t      var cached = this._nodeCache[\"terminal\"][index0];\n\t      if (cached) {\n\t        this._offset += cached.textValue.length;\n\t        return cached;\n\t      }\n\t      var index1 = this._offset;\n\t      var slice0 = null;\n\t      if (this._input.length > this._offset) {\n\t        slice0 = this._input.substring(this._offset, this._offset + 1);\n\t      } else {\n\t        slice0 = null;\n\t      }\n\t      if (slice0 === \".\") {\n\t        var klass0 = this.constructor.SyntaxNode;\n\t        var type0 = find(this.constructor, \"AnyCharacter\");\n\t        address0 = new klass0(\".\", this._offset, []);\n\t        if (typeof type0 === \"object\") {\n\t          extend(address0, type0);\n\t        }\n\t        this._offset += 1;\n\t      } else {\n\t        address0 = null;\n\t        var slice1 = null;\n\t        if (this._input.length > this._offset) {\n\t          slice1 = this._input.substring(this._offset, this._offset + 1);\n\t        } else {\n\t          slice1 = null;\n\t        }\n\t        if (!this.error || this.error.offset <= this._offset) {\n\t          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\".\\\"\"};\n\t        }\n\t      }\n\t      if (address0) {\n\t      } else {\n\t        this._offset = index1;\n\t        address0 = this.__consume__escape();\n\t        var type1 = find(this.constructor, \"Escape\");\n\t        if (typeof type1 === \"object\") {\n\t          extend(address0, type1);\n\t        }\n\t        if (address0) {\n\t        } else {\n\t          this._offset = index1;\n\t          address0 = this.__consume__literal();\n\t          var type2 = find(this.constructor, \"Literal\");\n\t          if (typeof type2 === \"object\") {\n\t            extend(address0, type2);\n\t          }\n\t          if (address0) {\n\t          } else {\n\t            this._offset = index1;\n\t          }\n\t        }\n\t      }\n\t      return this._nodeCache[\"terminal\"][index0] = address0;\n\t    },\n\t    __consume__escape: function(input) {\n\t      var address0 = null, index0 = this._offset;\n\t      this._nodeCache[\"escape\"] = this._nodeCache[\"escape\"] || {};\n\t      var cached = this._nodeCache[\"escape\"][index0];\n\t      if (cached) {\n\t        this._offset += cached.textValue.length;\n\t        return cached;\n\t      }\n\t      var index1 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n\t      var address1 = null;\n\t      var slice0 = null;\n\t      if (this._input.length > this._offset) {\n\t        slice0 = this._input.substring(this._offset, this._offset + 1);\n\t      } else {\n\t        slice0 = null;\n\t      }\n\t      if (slice0 === \"\\\\\") {\n\t        var klass0 = this.constructor.SyntaxNode;\n\t        var type0 = null;\n\t        address1 = new klass0(\"\\\\\", this._offset, []);\n\t        if (typeof type0 === \"object\") {\n\t          extend(address1, type0);\n\t        }\n\t        this._offset += 1;\n\t      } else {\n\t        address1 = null;\n\t        var slice1 = null;\n\t        if (this._input.length > this._offset) {\n\t          slice1 = this._input.substring(this._offset, this._offset + 1);\n\t        } else {\n\t          slice1 = null;\n\t        }\n\t        if (!this.error || this.error.offset <= this._offset) {\n\t          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"\\\\\\\\\\\"\"};\n\t        }\n\t      }\n\t      if (address1) {\n\t        elements0.push(address1);\n\t        text0 += address1.textValue;\n\t        var address2 = null;\n\t        var index2 = this._offset;\n\t        var index3 = this._offset, elements1 = [], labelled1 = {}, text1 = \"\";\n\t        var address3 = null;\n\t        var slice2 = null;\n\t        if (this._input.length > this._offset) {\n\t          slice2 = this._input.substring(this._offset, this._offset + 1);\n\t        } else {\n\t          slice2 = null;\n\t        }\n\t        if (slice2 && /^[bBdDfnrsStvwW1-9]/.test(slice2)) {\n\t          var klass1 = this.constructor.SyntaxNode;\n\t          var type1 = null;\n\t          address3 = new klass1(slice2, this._offset, []);\n\t          if (typeof type1 === \"object\") {\n\t            extend(address3, type1);\n\t          }\n\t          this._offset += 1;\n\t        } else {\n\t          address3 = null;\n\t          var slice3 = null;\n\t          if (this._input.length > this._offset) {\n\t            slice3 = this._input.substring(this._offset, this._offset + 1);\n\t          } else {\n\t            slice3 = null;\n\t          }\n\t          if (!this.error || this.error.offset <= this._offset) {\n\t            this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[bBdDfnrsStvwW1-9]\"};\n\t          }\n\t        }\n\t        if (address3) {\n\t          elements1.push(address3);\n\t          text1 += address3.textValue;\n\t          labelled1.code = address3;\n\t          var address4 = null;\n\t          var index4 = this._offset;\n\t          var slice4 = null;\n\t          if (this._input.length > this._offset) {\n\t            slice4 = this._input.substring(this._offset, this._offset + 0);\n\t          } else {\n\t            slice4 = null;\n\t          }\n\t          if (slice4 === \"\") {\n\t            var klass2 = this.constructor.SyntaxNode;\n\t            var type2 = null;\n\t            address4 = new klass2(\"\", this._offset, []);\n\t            if (typeof type2 === \"object\") {\n\t              extend(address4, type2);\n\t            }\n\t            this._offset += 0;\n\t          } else {\n\t            address4 = null;\n\t            var slice5 = null;\n\t            if (this._input.length > this._offset) {\n\t              slice5 = this._input.substring(this._offset, this._offset + 1);\n\t            } else {\n\t              slice5 = null;\n\t            }\n\t            if (!this.error || this.error.offset <= this._offset) {\n\t              this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"\\\"\"};\n\t            }\n\t          }\n\t          if (address4) {\n\t          } else {\n\t            this._offset = index4;\n\t            var klass3 = this.constructor.SyntaxNode;\n\t            var type3 = null;\n\t            address4 = new klass3(\"\", this._offset, []);\n\t            if (typeof type3 === \"object\") {\n\t              extend(address4, type3);\n\t            }\n\t            this._offset += 0;\n\t          }\n\t          if (address4) {\n\t            elements1.push(address4);\n\t            text1 += address4.textValue;\n\t            labelled1.arg = address4;\n\t          } else {\n\t            elements1 = null;\n\t            this._offset = index3;\n\t          }\n\t        } else {\n\t          elements1 = null;\n\t          this._offset = index3;\n\t        }\n\t        if (elements1) {\n\t          this._offset = index3;\n\t          var klass4 = this.constructor.SyntaxNode;\n\t          var type4 = null;\n\t          address2 = new klass4(text1, this._offset, elements1, labelled1);\n\t          if (typeof type4 === \"object\") {\n\t            extend(address2, type4);\n\t          }\n\t          this._offset += text1.length;\n\t        } else {\n\t          address2 = null;\n\t        }\n\t        if (address2) {\n\t        } else {\n\t          this._offset = index2;\n\t          address2 = this.__consume__control_escape();\n\t          if (address2) {\n\t          } else {\n\t            this._offset = index2;\n\t            address2 = this.__consume__octal_escape();\n\t            if (address2) {\n\t            } else {\n\t              this._offset = index2;\n\t              address2 = this.__consume__hex_escape();\n\t              if (address2) {\n\t              } else {\n\t                this._offset = index2;\n\t                address2 = this.__consume__unicode_escape();\n\t                if (address2) {\n\t                } else {\n\t                  this._offset = index2;\n\t                  address2 = this.__consume__null_escape();\n\t                  if (address2) {\n\t                  } else {\n\t                    this._offset = index2;\n\t                  }\n\t                }\n\t              }\n\t            }\n\t          }\n\t        }\n\t        if (address2) {\n\t          elements0.push(address2);\n\t          text0 += address2.textValue;\n\t          labelled0.esc = address2;\n\t        } else {\n\t          elements0 = null;\n\t          this._offset = index1;\n\t        }\n\t      } else {\n\t        elements0 = null;\n\t        this._offset = index1;\n\t      }\n\t      if (elements0) {\n\t        this._offset = index1;\n\t        var klass5 = this.constructor.SyntaxNode;\n\t        var type5 = null;\n\t        address0 = new klass5(text0, this._offset, elements0, labelled0);\n\t        if (typeof type5 === \"object\") {\n\t          extend(address0, type5);\n\t        }\n\t        this._offset += text0.length;\n\t      } else {\n\t        address0 = null;\n\t      }\n\t      return this._nodeCache[\"escape\"][index0] = address0;\n\t    },\n\t    __consume__literal: function(input) {\n\t      var address0 = null, index0 = this._offset;\n\t      this._nodeCache[\"literal\"] = this._nodeCache[\"literal\"] || {};\n\t      var cached = this._nodeCache[\"literal\"][index0];\n\t      if (cached) {\n\t        this._offset += cached.textValue.length;\n\t        return cached;\n\t      }\n\t      var index1 = this._offset;\n\t      var index2 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n\t      var address1 = null;\n\t      var index3 = this._offset;\n\t      var slice0 = null;\n\t      if (this._input.length > this._offset) {\n\t        slice0 = this._input.substring(this._offset, this._offset + 0);\n\t      } else {\n\t        slice0 = null;\n\t      }\n\t      if (slice0 === \"\") {\n\t        var klass0 = this.constructor.SyntaxNode;\n\t        var type0 = null;\n\t        address1 = new klass0(\"\", this._offset, []);\n\t        if (typeof type0 === \"object\") {\n\t          extend(address1, type0);\n\t        }\n\t        this._offset += 0;\n\t      } else {\n\t        address1 = null;\n\t        var slice1 = null;\n\t        if (this._input.length > this._offset) {\n\t          slice1 = this._input.substring(this._offset, this._offset + 1);\n\t        } else {\n\t          slice1 = null;\n\t        }\n\t        if (!this.error || this.error.offset <= this._offset) {\n\t          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"\\\"\"};\n\t        }\n\t      }\n\t      if (address1) {\n\t      } else {\n\t        this._offset = index3;\n\t        var klass1 = this.constructor.SyntaxNode;\n\t        var type1 = null;\n\t        address1 = new klass1(\"\", this._offset, []);\n\t        if (typeof type1 === \"object\") {\n\t          extend(address1, type1);\n\t        }\n\t        this._offset += 0;\n\t      }\n\t      if (address1) {\n\t        elements0.push(address1);\n\t        text0 += address1.textValue;\n\t        var address2 = null;\n\t        var slice2 = null;\n\t        if (this._input.length > this._offset) {\n\t          slice2 = this._input.substring(this._offset, this._offset + 1);\n\t        } else {\n\t          slice2 = null;\n\t        }\n\t        if (slice2 && /^[^|\\\\/.\\[\\(\\)?+*$^]/.test(slice2)) {\n\t          var klass2 = this.constructor.SyntaxNode;\n\t          var type2 = null;\n\t          address2 = new klass2(slice2, this._offset, []);\n\t          if (typeof type2 === \"object\") {\n\t            extend(address2, type2);\n\t          }\n\t          this._offset += 1;\n\t        } else {\n\t          address2 = null;\n\t          var slice3 = null;\n\t          if (this._input.length > this._offset) {\n\t            slice3 = this._input.substring(this._offset, this._offset + 1);\n\t          } else {\n\t            slice3 = null;\n\t          }\n\t          if (!this.error || this.error.offset <= this._offset) {\n\t            this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[^|\\\\\\\\/.\\\\[\\\\(\\\\)?+*$^]\"};\n\t          }\n\t        }\n\t        if (address2) {\n\t          elements0.push(address2);\n\t          text0 += address2.textValue;\n\t          labelled0.literal = address2;\n\t        } else {\n\t          elements0 = null;\n\t          this._offset = index2;\n\t        }\n\t      } else {\n\t        elements0 = null;\n\t        this._offset = index2;\n\t      }\n\t      if (elements0) {\n\t        this._offset = index2;\n\t        var klass3 = this.constructor.SyntaxNode;\n\t        var type3 = null;\n\t        address0 = new klass3(text0, this._offset, elements0, labelled0);\n\t        if (typeof type3 === \"object\") {\n\t          extend(address0, type3);\n\t        }\n\t        this._offset += text0.length;\n\t      } else {\n\t        address0 = null;\n\t      }\n\t      if (address0) {\n\t      } else {\n\t        this._offset = index1;\n\t        var index4 = this._offset, elements1 = [], labelled1 = {}, text1 = \"\";\n\t        var address3 = null;\n\t        var slice4 = null;\n\t        if (this._input.length > this._offset) {\n\t          slice4 = this._input.substring(this._offset, this._offset + 1);\n\t        } else {\n\t          slice4 = null;\n\t        }\n\t        if (slice4 === \"\\\\\") {\n\t          var klass4 = this.constructor.SyntaxNode;\n\t          var type4 = null;\n\t          address3 = new klass4(\"\\\\\", this._offset, []);\n\t          if (typeof type4 === \"object\") {\n\t            extend(address3, type4);\n\t          }\n\t          this._offset += 1;\n\t        } else {\n\t          address3 = null;\n\t          var slice5 = null;\n\t          if (this._input.length > this._offset) {\n\t            slice5 = this._input.substring(this._offset, this._offset + 1);\n\t          } else {\n\t            slice5 = null;\n\t          }\n\t          if (!this.error || this.error.offset <= this._offset) {\n\t            this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"\\\\\\\\\\\"\"};\n\t          }\n\t        }\n\t        if (address3) {\n\t          elements1.push(address3);\n\t          text1 += address3.textValue;\n\t          labelled1.literal = address3;\n\t          var address4 = null;\n\t          var index5 = this._offset;\n\t          var slice6 = null;\n\t          if (this._input.length > this._offset) {\n\t            slice6 = this._input.substring(this._offset, this._offset + 1);\n\t          } else {\n\t            slice6 = null;\n\t          }\n\t          if (slice6 === \"c\") {\n\t            var klass5 = this.constructor.SyntaxNode;\n\t            var type5 = null;\n\t            address4 = new klass5(\"c\", this._offset, []);\n\t            if (typeof type5 === \"object\") {\n\t              extend(address4, type5);\n\t            }\n\t            this._offset += 1;\n\t          } else {\n\t            address4 = null;\n\t            var slice7 = null;\n\t            if (this._input.length > this._offset) {\n\t              slice7 = this._input.substring(this._offset, this._offset + 1);\n\t            } else {\n\t              slice7 = null;\n\t            }\n\t            if (!this.error || this.error.offset <= this._offset) {\n\t              this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"c\\\"\"};\n\t            }\n\t          }\n\t          this._offset = index5;\n\t          if (address4) {\n\t            var klass6 = this.constructor.SyntaxNode;\n\t            var type6 = null;\n\t            address4 = new klass6(\"\", this._offset, []);\n\t            if (typeof type6 === \"object\") {\n\t              extend(address4, type6);\n\t            }\n\t            this._offset += 0;\n\t          } else {\n\t            address4 = null;\n\t          }\n\t          if (address4) {\n\t            elements1.push(address4);\n\t            text1 += address4.textValue;\n\t          } else {\n\t            elements1 = null;\n\t            this._offset = index4;\n\t          }\n\t        } else {\n\t          elements1 = null;\n\t          this._offset = index4;\n\t        }\n\t        if (elements1) {\n\t          this._offset = index4;\n\t          var klass7 = this.constructor.SyntaxNode;\n\t          var type7 = null;\n\t          address0 = new klass7(text1, this._offset, elements1, labelled1);\n\t          if (typeof type7 === \"object\") {\n\t            extend(address0, type7);\n\t          }\n\t          this._offset += text1.length;\n\t        } else {\n\t          address0 = null;\n\t        }\n\t        if (address0) {\n\t        } else {\n\t          this._offset = index1;\n\t          var index6 = this._offset, elements2 = [], labelled2 = {}, text2 = \"\";\n\t          var address5 = null;\n\t          var slice8 = null;\n\t          if (this._input.length > this._offset) {\n\t            slice8 = this._input.substring(this._offset, this._offset + 1);\n\t          } else {\n\t            slice8 = null;\n\t          }\n\t          if (slice8 === \"\\\\\") {\n\t            var klass8 = this.constructor.SyntaxNode;\n\t            var type8 = null;\n\t            address5 = new klass8(\"\\\\\", this._offset, []);\n\t            if (typeof type8 === \"object\") {\n\t              extend(address5, type8);\n\t            }\n\t            this._offset += 1;\n\t          } else {\n\t            address5 = null;\n\t            var slice9 = null;\n\t            if (this._input.length > this._offset) {\n\t              slice9 = this._input.substring(this._offset, this._offset + 1);\n\t            } else {\n\t              slice9 = null;\n\t            }\n\t            if (!this.error || this.error.offset <= this._offset) {\n\t              this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"\\\\\\\\\\\"\"};\n\t            }\n\t          }\n\t          if (address5) {\n\t            elements2.push(address5);\n\t            text2 += address5.textValue;\n\t            var address6 = null;\n\t            var slice10 = null;\n\t            if (this._input.length > this._offset) {\n\t              slice10 = this._input.substring(this._offset, this._offset + 1);\n\t            } else {\n\t              slice10 = null;\n\t            }\n\t            var temp0 = slice10;\n\t            if (temp0 === null) {\n\t              address6 = null;\n\t              var slice11 = null;\n\t              if (this._input.length > this._offset) {\n\t                slice11 = this._input.substring(this._offset, this._offset + 1);\n\t              } else {\n\t                slice11 = null;\n\t              }\n\t              if (!this.error || this.error.offset <= this._offset) {\n\t                this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"<any char>\"};\n\t              }\n\t            } else {\n\t              var klass9 = this.constructor.SyntaxNode;\n\t              var type9 = null;\n\t              address6 = new klass9(temp0, this._offset, []);\n\t              if (typeof type9 === \"object\") {\n\t                extend(address6, type9);\n\t              }\n\t              this._offset += 1;\n\t            }\n\t            if (address6) {\n\t              elements2.push(address6);\n\t              text2 += address6.textValue;\n\t              labelled2.literal = address6;\n\t            } else {\n\t              elements2 = null;\n\t              this._offset = index6;\n\t            }\n\t          } else {\n\t            elements2 = null;\n\t            this._offset = index6;\n\t          }\n\t          if (elements2) {\n\t            this._offset = index6;\n\t            var klass10 = this.constructor.SyntaxNode;\n\t            var type10 = null;\n\t            address0 = new klass10(text2, this._offset, elements2, labelled2);\n\t            if (typeof type10 === \"object\") {\n\t              extend(address0, type10);\n\t            }\n\t            this._offset += text2.length;\n\t          } else {\n\t            address0 = null;\n\t          }\n\t          if (address0) {\n\t          } else {\n\t            this._offset = index1;\n\t          }\n\t        }\n\t      }\n\t      return this._nodeCache[\"literal\"][index0] = address0;\n\t    },\n\t    __consume__control_escape: function(input) {\n\t      var address0 = null, index0 = this._offset;\n\t      this._nodeCache[\"control_escape\"] = this._nodeCache[\"control_escape\"] || {};\n\t      var cached = this._nodeCache[\"control_escape\"][index0];\n\t      if (cached) {\n\t        this._offset += cached.textValue.length;\n\t        return cached;\n\t      }\n\t      var index1 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n\t      var address1 = null;\n\t      var slice0 = null;\n\t      if (this._input.length > this._offset) {\n\t        slice0 = this._input.substring(this._offset, this._offset + 1);\n\t      } else {\n\t        slice0 = null;\n\t      }\n\t      if (slice0 === \"c\") {\n\t        var klass0 = this.constructor.SyntaxNode;\n\t        var type0 = null;\n\t        address1 = new klass0(\"c\", this._offset, []);\n\t        if (typeof type0 === \"object\") {\n\t          extend(address1, type0);\n\t        }\n\t        this._offset += 1;\n\t      } else {\n\t        address1 = null;\n\t        var slice1 = null;\n\t        if (this._input.length > this._offset) {\n\t          slice1 = this._input.substring(this._offset, this._offset + 1);\n\t        } else {\n\t          slice1 = null;\n\t        }\n\t        if (!this.error || this.error.offset <= this._offset) {\n\t          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"c\\\"\"};\n\t        }\n\t      }\n\t      if (address1) {\n\t        elements0.push(address1);\n\t        text0 += address1.textValue;\n\t        labelled0.code = address1;\n\t        var address2 = null;\n\t        var slice2 = null;\n\t        if (this._input.length > this._offset) {\n\t          slice2 = this._input.substring(this._offset, this._offset + 1);\n\t        } else {\n\t          slice2 = null;\n\t        }\n\t        if (slice2 && /^[a-zA-Z]/.test(slice2)) {\n\t          var klass1 = this.constructor.SyntaxNode;\n\t          var type1 = null;\n\t          address2 = new klass1(slice2, this._offset, []);\n\t          if (typeof type1 === \"object\") {\n\t            extend(address2, type1);\n\t          }\n\t          this._offset += 1;\n\t        } else {\n\t          address2 = null;\n\t          var slice3 = null;\n\t          if (this._input.length > this._offset) {\n\t            slice3 = this._input.substring(this._offset, this._offset + 1);\n\t          } else {\n\t            slice3 = null;\n\t          }\n\t          if (!this.error || this.error.offset <= this._offset) {\n\t            this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[a-zA-Z]\"};\n\t          }\n\t        }\n\t        if (address2) {\n\t          elements0.push(address2);\n\t          text0 += address2.textValue;\n\t          labelled0.arg = address2;\n\t        } else {\n\t          elements0 = null;\n\t          this._offset = index1;\n\t        }\n\t      } else {\n\t        elements0 = null;\n\t        this._offset = index1;\n\t      }\n\t      if (elements0) {\n\t        this._offset = index1;\n\t        var klass2 = this.constructor.SyntaxNode;\n\t        var type2 = null;\n\t        address0 = new klass2(text0, this._offset, elements0, labelled0);\n\t        if (typeof type2 === \"object\") {\n\t          extend(address0, type2);\n\t        }\n\t        this._offset += text0.length;\n\t      } else {\n\t        address0 = null;\n\t      }\n\t      return this._nodeCache[\"control_escape\"][index0] = address0;\n\t    },\n\t    __consume__octal_escape: function(input) {\n\t      var address0 = null, index0 = this._offset;\n\t      this._nodeCache[\"octal_escape\"] = this._nodeCache[\"octal_escape\"] || {};\n\t      var cached = this._nodeCache[\"octal_escape\"][index0];\n\t      if (cached) {\n\t        this._offset += cached.textValue.length;\n\t        return cached;\n\t      }\n\t      var index1 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n\t      var address1 = null;\n\t      var slice0 = null;\n\t      if (this._input.length > this._offset) {\n\t        slice0 = this._input.substring(this._offset, this._offset + 1);\n\t      } else {\n\t        slice0 = null;\n\t      }\n\t      if (slice0 === \"0\") {\n\t        var klass0 = this.constructor.SyntaxNode;\n\t        var type0 = null;\n\t        address1 = new klass0(\"0\", this._offset, []);\n\t        if (typeof type0 === \"object\") {\n\t          extend(address1, type0);\n\t        }\n\t        this._offset += 1;\n\t      } else {\n\t        address1 = null;\n\t        var slice1 = null;\n\t        if (this._input.length > this._offset) {\n\t          slice1 = this._input.substring(this._offset, this._offset + 1);\n\t        } else {\n\t          slice1 = null;\n\t        }\n\t        if (!this.error || this.error.offset <= this._offset) {\n\t          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"0\\\"\"};\n\t        }\n\t      }\n\t      if (address1) {\n\t        elements0.push(address1);\n\t        text0 += address1.textValue;\n\t        labelled0.code = address1;\n\t        var address2 = null;\n\t        var remaining0 = 1, index2 = this._offset, elements1 = [], text1 = \"\", address3 = true;\n\t        while (address3) {\n\t          var slice2 = null;\n\t          if (this._input.length > this._offset) {\n\t            slice2 = this._input.substring(this._offset, this._offset + 1);\n\t          } else {\n\t            slice2 = null;\n\t          }\n\t          if (slice2 && /^[0-7]/.test(slice2)) {\n\t            var klass1 = this.constructor.SyntaxNode;\n\t            var type1 = null;\n\t            address3 = new klass1(slice2, this._offset, []);\n\t            if (typeof type1 === \"object\") {\n\t              extend(address3, type1);\n\t            }\n\t            this._offset += 1;\n\t          } else {\n\t            address3 = null;\n\t            var slice3 = null;\n\t            if (this._input.length > this._offset) {\n\t              slice3 = this._input.substring(this._offset, this._offset + 1);\n\t            } else {\n\t              slice3 = null;\n\t            }\n\t            if (!this.error || this.error.offset <= this._offset) {\n\t              this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[0-7]\"};\n\t            }\n\t          }\n\t          if (address3) {\n\t            elements1.push(address3);\n\t            text1 += address3.textValue;\n\t            remaining0 -= 1;\n\t          }\n\t        }\n\t        if (remaining0 <= 0) {\n\t          this._offset = index2;\n\t          var klass2 = this.constructor.SyntaxNode;\n\t          var type2 = null;\n\t          address2 = new klass2(text1, this._offset, elements1);\n\t          if (typeof type2 === \"object\") {\n\t            extend(address2, type2);\n\t          }\n\t          this._offset += text1.length;\n\t        } else {\n\t          address2 = null;\n\t        }\n\t        if (address2) {\n\t          elements0.push(address2);\n\t          text0 += address2.textValue;\n\t          labelled0.arg = address2;\n\t        } else {\n\t          elements0 = null;\n\t          this._offset = index1;\n\t        }\n\t      } else {\n\t        elements0 = null;\n\t        this._offset = index1;\n\t      }\n\t      if (elements0) {\n\t        this._offset = index1;\n\t        var klass3 = this.constructor.SyntaxNode;\n\t        var type3 = null;\n\t        address0 = new klass3(text0, this._offset, elements0, labelled0);\n\t        if (typeof type3 === \"object\") {\n\t          extend(address0, type3);\n\t        }\n\t        this._offset += text0.length;\n\t      } else {\n\t        address0 = null;\n\t      }\n\t      return this._nodeCache[\"octal_escape\"][index0] = address0;\n\t    },\n\t    __consume__hex_escape: function(input) {\n\t      var address0 = null, index0 = this._offset;\n\t      this._nodeCache[\"hex_escape\"] = this._nodeCache[\"hex_escape\"] || {};\n\t      var cached = this._nodeCache[\"hex_escape\"][index0];\n\t      if (cached) {\n\t        this._offset += cached.textValue.length;\n\t        return cached;\n\t      }\n\t      var index1 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n\t      var address1 = null;\n\t      var slice0 = null;\n\t      if (this._input.length > this._offset) {\n\t        slice0 = this._input.substring(this._offset, this._offset + 1);\n\t      } else {\n\t        slice0 = null;\n\t      }\n\t      if (slice0 === \"x\") {\n\t        var klass0 = this.constructor.SyntaxNode;\n\t        var type0 = null;\n\t        address1 = new klass0(\"x\", this._offset, []);\n\t        if (typeof type0 === \"object\") {\n\t          extend(address1, type0);\n\t        }\n\t        this._offset += 1;\n\t      } else {\n\t        address1 = null;\n\t        var slice1 = null;\n\t        if (this._input.length > this._offset) {\n\t          slice1 = this._input.substring(this._offset, this._offset + 1);\n\t        } else {\n\t          slice1 = null;\n\t        }\n\t        if (!this.error || this.error.offset <= this._offset) {\n\t          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"x\\\"\"};\n\t        }\n\t      }\n\t      if (address1) {\n\t        elements0.push(address1);\n\t        text0 += address1.textValue;\n\t        labelled0.code = address1;\n\t        var address2 = null;\n\t        var index2 = this._offset, elements1 = [], labelled1 = {}, text1 = \"\";\n\t        var address3 = null;\n\t        var slice2 = null;\n\t        if (this._input.length > this._offset) {\n\t          slice2 = this._input.substring(this._offset, this._offset + 1);\n\t        } else {\n\t          slice2 = null;\n\t        }\n\t        if (slice2 && /^[0-9a-fA-F]/.test(slice2)) {\n\t          var klass1 = this.constructor.SyntaxNode;\n\t          var type1 = null;\n\t          address3 = new klass1(slice2, this._offset, []);\n\t          if (typeof type1 === \"object\") {\n\t            extend(address3, type1);\n\t          }\n\t          this._offset += 1;\n\t        } else {\n\t          address3 = null;\n\t          var slice3 = null;\n\t          if (this._input.length > this._offset) {\n\t            slice3 = this._input.substring(this._offset, this._offset + 1);\n\t          } else {\n\t            slice3 = null;\n\t          }\n\t          if (!this.error || this.error.offset <= this._offset) {\n\t            this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[0-9a-fA-F]\"};\n\t          }\n\t        }\n\t        if (address3) {\n\t          elements1.push(address3);\n\t          text1 += address3.textValue;\n\t          var address4 = null;\n\t          var slice4 = null;\n\t          if (this._input.length > this._offset) {\n\t            slice4 = this._input.substring(this._offset, this._offset + 1);\n\t          } else {\n\t            slice4 = null;\n\t          }\n\t          if (slice4 && /^[0-9a-fA-F]/.test(slice4)) {\n\t            var klass2 = this.constructor.SyntaxNode;\n\t            var type2 = null;\n\t            address4 = new klass2(slice4, this._offset, []);\n\t            if (typeof type2 === \"object\") {\n\t              extend(address4, type2);\n\t            }\n\t            this._offset += 1;\n\t          } else {\n\t            address4 = null;\n\t            var slice5 = null;\n\t            if (this._input.length > this._offset) {\n\t              slice5 = this._input.substring(this._offset, this._offset + 1);\n\t            } else {\n\t              slice5 = null;\n\t            }\n\t            if (!this.error || this.error.offset <= this._offset) {\n\t              this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[0-9a-fA-F]\"};\n\t            }\n\t          }\n\t          if (address4) {\n\t            elements1.push(address4);\n\t            text1 += address4.textValue;\n\t          } else {\n\t            elements1 = null;\n\t            this._offset = index2;\n\t          }\n\t        } else {\n\t          elements1 = null;\n\t          this._offset = index2;\n\t        }\n\t        if (elements1) {\n\t          this._offset = index2;\n\t          var klass3 = this.constructor.SyntaxNode;\n\t          var type3 = null;\n\t          address2 = new klass3(text1, this._offset, elements1, labelled1);\n\t          if (typeof type3 === \"object\") {\n\t            extend(address2, type3);\n\t          }\n\t          this._offset += text1.length;\n\t        } else {\n\t          address2 = null;\n\t        }\n\t        if (address2) {\n\t          elements0.push(address2);\n\t          text0 += address2.textValue;\n\t          labelled0.arg = address2;\n\t        } else {\n\t          elements0 = null;\n\t          this._offset = index1;\n\t        }\n\t      } else {\n\t        elements0 = null;\n\t        this._offset = index1;\n\t      }\n\t      if (elements0) {\n\t        this._offset = index1;\n\t        var klass4 = this.constructor.SyntaxNode;\n\t        var type4 = null;\n\t        address0 = new klass4(text0, this._offset, elements0, labelled0);\n\t        if (typeof type4 === \"object\") {\n\t          extend(address0, type4);\n\t        }\n\t        this._offset += text0.length;\n\t      } else {\n\t        address0 = null;\n\t      }\n\t      return this._nodeCache[\"hex_escape\"][index0] = address0;\n\t    },\n\t    __consume__unicode_escape: function(input) {\n\t      var address0 = null, index0 = this._offset;\n\t      this._nodeCache[\"unicode_escape\"] = this._nodeCache[\"unicode_escape\"] || {};\n\t      var cached = this._nodeCache[\"unicode_escape\"][index0];\n\t      if (cached) {\n\t        this._offset += cached.textValue.length;\n\t        return cached;\n\t      }\n\t      var index1 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n\t      var address1 = null;\n\t      var slice0 = null;\n\t      if (this._input.length > this._offset) {\n\t        slice0 = this._input.substring(this._offset, this._offset + 1);\n\t      } else {\n\t        slice0 = null;\n\t      }\n\t      if (slice0 === \"u\") {\n\t        var klass0 = this.constructor.SyntaxNode;\n\t        var type0 = null;\n\t        address1 = new klass0(\"u\", this._offset, []);\n\t        if (typeof type0 === \"object\") {\n\t          extend(address1, type0);\n\t        }\n\t        this._offset += 1;\n\t      } else {\n\t        address1 = null;\n\t        var slice1 = null;\n\t        if (this._input.length > this._offset) {\n\t          slice1 = this._input.substring(this._offset, this._offset + 1);\n\t        } else {\n\t          slice1 = null;\n\t        }\n\t        if (!this.error || this.error.offset <= this._offset) {\n\t          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"u\\\"\"};\n\t        }\n\t      }\n\t      if (address1) {\n\t        elements0.push(address1);\n\t        text0 += address1.textValue;\n\t        labelled0.code = address1;\n\t        var address2 = null;\n\t        var index2 = this._offset, elements1 = [], labelled1 = {}, text1 = \"\";\n\t        var address3 = null;\n\t        var slice2 = null;\n\t        if (this._input.length > this._offset) {\n\t          slice2 = this._input.substring(this._offset, this._offset + 1);\n\t        } else {\n\t          slice2 = null;\n\t        }\n\t        if (slice2 && /^[0-9a-fA-F]/.test(slice2)) {\n\t          var klass1 = this.constructor.SyntaxNode;\n\t          var type1 = null;\n\t          address3 = new klass1(slice2, this._offset, []);\n\t          if (typeof type1 === \"object\") {\n\t            extend(address3, type1);\n\t          }\n\t          this._offset += 1;\n\t        } else {\n\t          address3 = null;\n\t          var slice3 = null;\n\t          if (this._input.length > this._offset) {\n\t            slice3 = this._input.substring(this._offset, this._offset + 1);\n\t          } else {\n\t            slice3 = null;\n\t          }\n\t          if (!this.error || this.error.offset <= this._offset) {\n\t            this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[0-9a-fA-F]\"};\n\t          }\n\t        }\n\t        if (address3) {\n\t          elements1.push(address3);\n\t          text1 += address3.textValue;\n\t          var address4 = null;\n\t          var slice4 = null;\n\t          if (this._input.length > this._offset) {\n\t            slice4 = this._input.substring(this._offset, this._offset + 1);\n\t          } else {\n\t            slice4 = null;\n\t          }\n\t          if (slice4 && /^[0-9a-fA-F]/.test(slice4)) {\n\t            var klass2 = this.constructor.SyntaxNode;\n\t            var type2 = null;\n\t            address4 = new klass2(slice4, this._offset, []);\n\t            if (typeof type2 === \"object\") {\n\t              extend(address4, type2);\n\t            }\n\t            this._offset += 1;\n\t          } else {\n\t            address4 = null;\n\t            var slice5 = null;\n\t            if (this._input.length > this._offset) {\n\t              slice5 = this._input.substring(this._offset, this._offset + 1);\n\t            } else {\n\t              slice5 = null;\n\t            }\n\t            if (!this.error || this.error.offset <= this._offset) {\n\t              this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[0-9a-fA-F]\"};\n\t            }\n\t          }\n\t          if (address4) {\n\t            elements1.push(address4);\n\t            text1 += address4.textValue;\n\t            var address5 = null;\n\t            var slice6 = null;\n\t            if (this._input.length > this._offset) {\n\t              slice6 = this._input.substring(this._offset, this._offset + 1);\n\t            } else {\n\t              slice6 = null;\n\t            }\n\t            if (slice6 && /^[0-9a-fA-F]/.test(slice6)) {\n\t              var klass3 = this.constructor.SyntaxNode;\n\t              var type3 = null;\n\t              address5 = new klass3(slice6, this._offset, []);\n\t              if (typeof type3 === \"object\") {\n\t                extend(address5, type3);\n\t              }\n\t              this._offset += 1;\n\t            } else {\n\t              address5 = null;\n\t              var slice7 = null;\n\t              if (this._input.length > this._offset) {\n\t                slice7 = this._input.substring(this._offset, this._offset + 1);\n\t              } else {\n\t                slice7 = null;\n\t              }\n\t              if (!this.error || this.error.offset <= this._offset) {\n\t                this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[0-9a-fA-F]\"};\n\t              }\n\t            }\n\t            if (address5) {\n\t              elements1.push(address5);\n\t              text1 += address5.textValue;\n\t              var address6 = null;\n\t              var slice8 = null;\n\t              if (this._input.length > this._offset) {\n\t                slice8 = this._input.substring(this._offset, this._offset + 1);\n\t              } else {\n\t                slice8 = null;\n\t              }\n\t              if (slice8 && /^[0-9a-fA-F]/.test(slice8)) {\n\t                var klass4 = this.constructor.SyntaxNode;\n\t                var type4 = null;\n\t                address6 = new klass4(slice8, this._offset, []);\n\t                if (typeof type4 === \"object\") {\n\t                  extend(address6, type4);\n\t                }\n\t                this._offset += 1;\n\t              } else {\n\t                address6 = null;\n\t                var slice9 = null;\n\t                if (this._input.length > this._offset) {\n\t                  slice9 = this._input.substring(this._offset, this._offset + 1);\n\t                } else {\n\t                  slice9 = null;\n\t                }\n\t                if (!this.error || this.error.offset <= this._offset) {\n\t                  this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[0-9a-fA-F]\"};\n\t                }\n\t              }\n\t              if (address6) {\n\t                elements1.push(address6);\n\t                text1 += address6.textValue;\n\t              } else {\n\t                elements1 = null;\n\t                this._offset = index2;\n\t              }\n\t            } else {\n\t              elements1 = null;\n\t              this._offset = index2;\n\t            }\n\t          } else {\n\t            elements1 = null;\n\t            this._offset = index2;\n\t          }\n\t        } else {\n\t          elements1 = null;\n\t          this._offset = index2;\n\t        }\n\t        if (elements1) {\n\t          this._offset = index2;\n\t          var klass5 = this.constructor.SyntaxNode;\n\t          var type5 = null;\n\t          address2 = new klass5(text1, this._offset, elements1, labelled1);\n\t          if (typeof type5 === \"object\") {\n\t            extend(address2, type5);\n\t          }\n\t          this._offset += text1.length;\n\t        } else {\n\t          address2 = null;\n\t        }\n\t        if (address2) {\n\t          elements0.push(address2);\n\t          text0 += address2.textValue;\n\t          labelled0.arg = address2;\n\t        } else {\n\t          elements0 = null;\n\t          this._offset = index1;\n\t        }\n\t      } else {\n\t        elements0 = null;\n\t        this._offset = index1;\n\t      }\n\t      if (elements0) {\n\t        this._offset = index1;\n\t        var klass6 = this.constructor.SyntaxNode;\n\t        var type6 = null;\n\t        address0 = new klass6(text0, this._offset, elements0, labelled0);\n\t        if (typeof type6 === \"object\") {\n\t          extend(address0, type6);\n\t        }\n\t        this._offset += text0.length;\n\t      } else {\n\t        address0 = null;\n\t      }\n\t      return this._nodeCache[\"unicode_escape\"][index0] = address0;\n\t    },\n\t    __consume__null_escape: function(input) {\n\t      var address0 = null, index0 = this._offset;\n\t      this._nodeCache[\"null_escape\"] = this._nodeCache[\"null_escape\"] || {};\n\t      var cached = this._nodeCache[\"null_escape\"][index0];\n\t      if (cached) {\n\t        this._offset += cached.textValue.length;\n\t        return cached;\n\t      }\n\t      var index1 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n\t      var address1 = null;\n\t      var slice0 = null;\n\t      if (this._input.length > this._offset) {\n\t        slice0 = this._input.substring(this._offset, this._offset + 1);\n\t      } else {\n\t        slice0 = null;\n\t      }\n\t      if (slice0 === \"0\") {\n\t        var klass0 = this.constructor.SyntaxNode;\n\t        var type0 = null;\n\t        address1 = new klass0(\"0\", this._offset, []);\n\t        if (typeof type0 === \"object\") {\n\t          extend(address1, type0);\n\t        }\n\t        this._offset += 1;\n\t      } else {\n\t        address1 = null;\n\t        var slice1 = null;\n\t        if (this._input.length > this._offset) {\n\t          slice1 = this._input.substring(this._offset, this._offset + 1);\n\t        } else {\n\t          slice1 = null;\n\t        }\n\t        if (!this.error || this.error.offset <= this._offset) {\n\t          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"0\\\"\"};\n\t        }\n\t      }\n\t      if (address1) {\n\t        elements0.push(address1);\n\t        text0 += address1.textValue;\n\t        labelled0.code = address1;\n\t        var address2 = null;\n\t        var index2 = this._offset;\n\t        var slice2 = null;\n\t        if (this._input.length > this._offset) {\n\t          slice2 = this._input.substring(this._offset, this._offset + 0);\n\t        } else {\n\t          slice2 = null;\n\t        }\n\t        if (slice2 === \"\") {\n\t          var klass1 = this.constructor.SyntaxNode;\n\t          var type1 = null;\n\t          address2 = new klass1(\"\", this._offset, []);\n\t          if (typeof type1 === \"object\") {\n\t            extend(address2, type1);\n\t          }\n\t          this._offset += 0;\n\t        } else {\n\t          address2 = null;\n\t          var slice3 = null;\n\t          if (this._input.length > this._offset) {\n\t            slice3 = this._input.substring(this._offset, this._offset + 1);\n\t          } else {\n\t            slice3 = null;\n\t          }\n\t          if (!this.error || this.error.offset <= this._offset) {\n\t            this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"\\\"\"};\n\t          }\n\t        }\n\t        if (address2) {\n\t        } else {\n\t          this._offset = index2;\n\t          var klass2 = this.constructor.SyntaxNode;\n\t          var type2 = null;\n\t          address2 = new klass2(\"\", this._offset, []);\n\t          if (typeof type2 === \"object\") {\n\t            extend(address2, type2);\n\t          }\n\t          this._offset += 0;\n\t        }\n\t        if (address2) {\n\t          elements0.push(address2);\n\t          text0 += address2.textValue;\n\t          labelled0.arg = address2;\n\t        } else {\n\t          elements0 = null;\n\t          this._offset = index1;\n\t        }\n\t      } else {\n\t        elements0 = null;\n\t        this._offset = index1;\n\t      }\n\t      if (elements0) {\n\t        this._offset = index1;\n\t        var klass3 = this.constructor.SyntaxNode;\n\t        var type3 = null;\n\t        address0 = new klass3(text0, this._offset, elements0, labelled0);\n\t        if (typeof type3 === \"object\") {\n\t          extend(address0, type3);\n\t        }\n\t        this._offset += text0.length;\n\t      } else {\n\t        address0 = null;\n\t      }\n\t      return this._nodeCache[\"null_escape\"][index0] = address0;\n\t    }\n\t  };\n\t  \n\t  var Parser = function(input) {\n\t    this._input = input;\n\t    this._offset = 0;\n\t    this._nodeCache = {};\n\t  };\n\t  \n\t  Parser.prototype.parse = function() {\n\t    var result = this.__consume__root();\n\t    if (result && this._offset === this._input.length) {\n\t      return result;\n\t    }\n\t    if (!(this.error)) {\n\t      this.error = {input: this._input, offset: this._offset, expected: \"<EOF>\"};\n\t    }\n\t    var message = formatError(this.error);\n\t    var error = new Error(message);\n\t    throw error;\n\t  };\n\t  \n\t  Parser.parse = function(input) {\n\t    var parser = new Parser(input);\n\t    return parser.parse();\n\t  };\n\t  \n\t  extend(Parser.prototype, Grammar);\n\t  \n\t  var SyntaxNode = function(textValue, offset, elements, properties) {\n\t    this.textValue = textValue;\n\t    this.offset    = offset;\n\t    this.elements  = elements || [];\n\t    if (!properties) return;\n\t    for (var key in properties) this[key] = properties[key];\n\t  };\n\t  \n\t  SyntaxNode.prototype.forEach = function(block, context) {\n\t    for (var i = 0, n = this.elements.length; i < n; i++) {\n\t      block.call(context, this.elements[i], i);\n\t    }\n\t  };\n\t  \n\t  Parser.SyntaxNode = SyntaxNode;\n\t  \n\t  if (true) {\n\t    exports.Grammar = Grammar;\n\t    exports.Parser  = Parser;\n\t    exports.parse   = Parser.parse;\n\t    \n\t  } else {\n\t    var namespace = this;\n\t    JavascriptRegexp = Grammar;\n\t    JavascriptRegexpParser = Parser;\n\t    JavascriptRegexpParser.formatError = formatError;\n\t  }\n\t})();\n\t\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Base class for all nodes in the parse tree. An instance of this class is\n\t// created for each parsed node, and then extended with one of the node-type\n\t// modules.\n\t\n\t\n\tvar _util = __webpack_require__(1);\n\t\n\tvar _util2 = _interopRequireDefault(_util);\n\t\n\tvar _lodash = __webpack_require__(2);\n\t\n\tvar _lodash2 = _interopRequireDefault(_lodash);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Node = function () {\n\t  // Arguments passed in are defined by the canopy tool.\n\t  function Node(textValue, offset, elements, properties) {\n\t    _classCallCheck(this, Node);\n\t\n\t    this.textValue = textValue;\n\t    this.offset = offset;\n\t    this.elements = elements || [];\n\t\n\t    this.properties = properties;\n\t\n\t    // This is the current parser state (an instance\n\t    // [ParserState](./parser_state.html).)\n\t    this.state = Node.state;\n\t  }\n\t\n\t  // Node-type module to extend the Node instance with. Setting of this is\n\t  // done by canopy during parsing and is setup in [parser.js](./parser.html).\n\t\n\t\n\t  _createClass(Node, [{\n\t    key: 'getBBox',\n\t\n\t\n\t    // Returns the bounding box of the container with the anchor included.\n\t    value: function getBBox() {\n\t      return _lodash2.default.extend(_util2.default.normalizeBBox(this.container.getBBox()), this.anchor);\n\t    }\n\t\n\t    // Transforms the container.\n\t    //\n\t    // - __matrix__ - A matrix transform to be applied. Created using Snap.svg.\n\t\n\t  }, {\n\t    key: 'transform',\n\t    value: function transform(matrix) {\n\t      return this.container.transform(matrix);\n\t    }\n\t\n\t    // Returns a Promise that will be resolved with the provided value. If the\n\t    // render is cancelled before the Promise is resolved, then an exception will\n\t    // be thrown to halt any rendering.\n\t    //\n\t    // - __value__ - Value to resolve the returned promise with.\n\t\n\t  }, {\n\t    key: 'deferredStep',\n\t    value: function deferredStep(value) {\n\t      var _this = this;\n\t\n\t      return _util2.default.tick().then(function () {\n\t        if (_this.state.cancelRender) {\n\t          throw 'Render cancelled';\n\t        }\n\t\n\t        return value;\n\t      });\n\t    }\n\t\n\t    // Render this node.\n\t    //\n\t    // - __container__ - Optional element to render this node into. A container\n\t    //    must be specified, but if it has already been set, then it does not\n\t    //    need to be provided to render.\n\t\n\t  }, {\n\t    key: 'render',\n\t    value: function render(container) {\n\t      var _this2 = this;\n\t\n\t      if (container) {\n\t        this.container = container;\n\t      }\n\t\n\t      if (this.proxy) {\n\t        // For nodes that proxy to a child node, just render the child.\n\t        return this.proxy.render(this.container);\n\t      } else {\n\t        // Non-proxied nodes call their _render method (defined by the node-type\n\t        // module).\n\t        this.state.renderCounter++;\n\t        return this._render().then(function () {\n\t          _this2.state.renderCounter--;\n\t          return _this2;\n\t        });\n\t      }\n\t    }\n\t\n\t    // Renders a label centered within a rectangle which can be styled. Returns\n\t    // a Promise which will be resolved with the SVG group the rect and text are\n\t    // rendered in.\n\t    //\n\t    // - __text__ - String or array of strings to render as a label.\n\t\n\t  }, {\n\t    key: 'renderLabel',\n\t    value: function renderLabel(text) {\n\t      var group = this.container.group().addClass('label'),\n\t          rect = group.rect(),\n\t          label = group.text(0, 0, _lodash2.default.flatten([text]));\n\t\n\t      return this.deferredStep().then(function () {\n\t        var box = label.getBBox(),\n\t            margin = 5;\n\t\n\t        label.transform(Snap.matrix().translate(margin, box.height / 2 + 2 * margin));\n\t\n\t        rect.attr({\n\t          width: box.width + 2 * margin,\n\t          height: box.height + 2 * margin\n\t        });\n\t\n\t        return group;\n\t      });\n\t    }\n\t\n\t    // Renders a labeled box around another SVG element. Returns a Promise.\n\t    //\n\t    // - __text__ - String or array of strings to label the box with.\n\t    // - __content__ - SVG element to wrap in the box.\n\t    // - __options.padding__ - Pixels of padding to place between the content and\n\t    //    the box.\n\t\n\t  }, {\n\t    key: 'renderLabeledBox',\n\t    value: function renderLabeledBox(text, content, options) {\n\t      var label = this.container.text(0, 0, _lodash2.default.flatten([text])).addClass(this.type + '-label'),\n\t          box = this.container.rect().addClass(this.type + '-box').attr({\n\t        rx: 3,\n\t        ry: 3\n\t      });\n\t\n\t      options = _lodash2.default.defaults(options || {}, {\n\t        padding: 0\n\t      });\n\t\n\t      this.container.prepend(label);\n\t      this.container.prepend(box);\n\t\n\t      return this.deferredStep().then(function () {\n\t        var labelBox = label.getBBox(),\n\t            contentBox = content.getBBox();\n\t\n\t        label.transform(Snap.matrix().translate(0, labelBox.height));\n\t\n\t        box.transform(Snap.matrix().translate(0, labelBox.height)).attr({\n\t          width: Math.max(contentBox.width + options.padding * 2, labelBox.width),\n\t          height: contentBox.height + options.padding * 2\n\t        });\n\t\n\t        content.transform(Snap.matrix().translate(box.getBBox().cx - contentBox.cx, labelBox.height + options.padding));\n\t      });\n\t    }\n\t  }, {\n\t    key: 'module',\n\t    set: function set(mod) {\n\t      var _this3 = this;\n\t\n\t      _lodash2.default.extend(this, mod);\n\t\n\t      if (this.setup) {\n\t        this.setup();\n\t      }\n\t\n\t      _lodash2.default.forOwn(this.definedProperties || {}, function (methods, name) {\n\t        Object.defineProperty(_this3, name, methods);\n\t      });\n\t\n\t      delete this.definedProperties;\n\t    }\n\t\n\t    // The SVG element to render this node into. A node-type class is\n\t    // automatically added to the container. The class to set is defined on the\n\t    // module set during parsing.\n\t\n\t  }, {\n\t    key: 'container',\n\t    set: function set(container) {\n\t      this._container = container;\n\t      this._container.addClass(this.type);\n\t    },\n\t    get: function get() {\n\t      return this._container;\n\t    }\n\t\n\t    // The anchor defined the points on the left and right of the rendered node\n\t    // that the centerline of the rendered expression connects to. For most\n\t    // nodes, this element will be defined by the normalizeBBox method in\n\t    // [Util](../../util.html).\n\t\n\t  }, {\n\t    key: 'anchor',\n\t    get: function get() {\n\t      if (this.proxy) {\n\t        return this.proxy.anchor;\n\t      } else {\n\t        return this._anchor || {};\n\t      }\n\t    }\n\t  }]);\n\t\n\t  return Node;\n\t}();\n\t\n\texports.default = Node;\n\t;\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _lodash = __webpack_require__(2);\n\t\n\tvar _lodash2 = _interopRequireDefault(_lodash);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = {\n\t  type: 'root',\n\t\n\t  flagLabels: {\n\t    i: 'Ignore Case',\n\t    g: 'Global',\n\t    m: 'Multiline'\n\t  },\n\t\n\t  // Renders the root into the currently set container.\n\t  _render: function _render() {\n\t    var _this = this;\n\t\n\t    var flagText = void 0;\n\t\n\t    // Render a label for any flags that have been set of the expression.\n\t    if (this.flags.length > 0) {\n\t      flagText = this.container.text(0, 0, 'Flags: ' + this.flags.join(', '));\n\t    }\n\t\n\t    // Render the content of the regular expression.\n\t    return this.regexp.render(this.container.group()).then(function () {\n\t      // Move rendered regexp to account for flag label and to allow for\n\t      // decorative elements.\n\t      if (flagText) {\n\t        _this.regexp.transform(Snap.matrix().translate(10, flagText.getBBox().height));\n\t      } else {\n\t        _this.regexp.transform(Snap.matrix().translate(10, 0));\n\t      }\n\t\n\t      var box = _this.regexp.getBBox();\n\t\n\t      // Render decorative elements.\n\t      _this.container.path('M' + box.ax + ',' + box.ay + 'H0M' + box.ax2 + ',' + box.ay + 'H' + (box.x2 + 10));\n\t      _this.container.circle(0, box.ay, 5);\n\t      _this.container.circle(box.x2 + 10, box.ay, 5);\n\t    });\n\t  },\n\t  setup: function setup() {\n\t    var _this2 = this;\n\t\n\t    // Convert list of flags into text describing each flag.\n\t    this.flags = (0, _lodash2.default)(this.properties.flags.textValue).uniq().sort().map(function (flag) {\n\t      return _this2.flagLabels[flag];\n\t    }).value();\n\t\n\t    this.regexp = this.properties.regexp;\n\t  }\n\t}; // Root nodes contain the top-level [Regexp](./regexp.html) node. Any flags\n\t// and a few decorative elements are rendered by the root node.\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _util = __webpack_require__(1);\n\t\n\tvar _util2 = _interopRequireDefault(_util);\n\t\n\tvar _lodash = __webpack_require__(2);\n\t\n\tvar _lodash2 = _interopRequireDefault(_lodash);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// Regexp nodes are the entire regular expression. They consist of a collection\n\t// of [Match](./match.html) nodes separated by `|`.\n\t\n\texports.default = {\n\t  type: 'regexp',\n\t\n\t  // Renders the regexp into the currently set container.\n\t  _render: function _render() {\n\t    var _this = this;\n\t\n\t    var matchContainer = this.container.group().addClass('regexp-matches').transform(Snap.matrix().translate(20, 0));\n\t\n\t    // Renders each match into the match container.\n\t    return Promise.all(_lodash2.default.map(this.matches, function (match) {\n\t      return match.render(matchContainer.group());\n\t    })).then(function () {\n\t      var containerBox = void 0,\n\t          paths = void 0;\n\t\n\t      // Space matches vertically in the match container.\n\t      _util2.default.spaceVertically(_this.matches, {\n\t        padding: 5\n\t      });\n\t\n\t      containerBox = _this.getBBox();\n\t\n\t      // Creates the curves from the side lines for each match.\n\t      paths = _lodash2.default.map(_this.matches, function (match) {\n\t        return _this.makeCurve(containerBox, match);\n\t      });\n\t\n\t      // Add side lines to the list of paths.\n\t      paths.push(_this.makeSide(containerBox, _lodash2.default.first(_this.matches)));\n\t      paths.push(_this.makeSide(containerBox, _lodash2.default.last(_this.matches)));\n\t\n\t      // Render connector paths.\n\t      _this.container.prepend(_this.container.path((0, _lodash2.default)(paths).flatten().compact().values().join('')));\n\t\n\t      containerBox = matchContainer.getBBox();\n\t\n\t      // Create connections from side lines to each match and render into\n\t      // the match container.\n\t      paths = _lodash2.default.map(_this.matches, function (match) {\n\t        return _this.makeConnector(containerBox, match);\n\t      });\n\t      matchContainer.prepend(matchContainer.path(paths.join('')));\n\t    });\n\t  },\n\t\n\t\n\t  // Returns an array of SVG path strings to draw the vertical lines on the\n\t  // left and right of the node.\n\t  //\n\t  // - __containerBox__ - Bounding box of the container.\n\t  // - __match__ - Match node that the line will be drawn to.\n\t  makeSide: function makeSide(containerBox, match) {\n\t    var box = match.getBBox(),\n\t        distance = Math.abs(box.ay - containerBox.cy);\n\t\n\t    // Only need to draw side lines if the match is more than 15 pixels from\n\t    // the vertical center of the rendered regexp. Less that 15 pixels will be\n\t    // handled by the curve directly.\n\t    if (distance >= 15) {\n\t      var shift = box.ay > containerBox.cy ? 10 : -10,\n\t          edge = box.ay - shift;\n\t\n\t      return ['M0,' + containerBox.cy + 'q10,0 10,' + shift + 'V' + edge, 'M' + (containerBox.width + 40) + ',' + containerBox.cy + 'q-10,0 -10,' + shift + 'V' + edge];\n\t    }\n\t  },\n\t\n\t\n\t  // Returns an array of SVG path strings to draw the curves from the\n\t  // sidelines up to the anchor of the match node.\n\t  //\n\t  // - __containerBox__ - Bounding box of the container.\n\t  // - __match__ - Match node that the line will be drawn to.\n\t  makeCurve: function makeCurve(containerBox, match) {\n\t    var box = match.getBBox(),\n\t        distance = Math.abs(box.ay - containerBox.cy);\n\t\n\t    if (distance >= 15) {\n\t      // For match nodes more than 15 pixels from the center of the regexp, a\n\t      // quarter-circle curve is used to connect to the sideline.\n\t      var curve = box.ay > containerBox.cy ? 10 : -10;\n\t\n\t      return ['M10,' + (box.ay - curve) + 'q0,' + curve + ' 10,' + curve, 'M' + (containerBox.width + 30) + ',' + (box.ay - curve) + 'q0,' + curve + ' -10,' + curve];\n\t    } else {\n\t      // For match nodes less than 15 pixels from the center of the regexp, a\n\t      // slightly curved line is used to connect to the sideline.\n\t      var anchor = box.ay - containerBox.cy;\n\t\n\t      return ['M0,' + containerBox.cy + 'c10,0 10,' + anchor + ' 20,' + anchor, 'M' + (containerBox.width + 40) + ',' + containerBox.cy + 'c-10,0 -10,' + anchor + ' -20,' + anchor];\n\t    }\n\t  },\n\t\n\t\n\t  // Returns an array of SVG path strings to draw the connection from the\n\t  // curve to match node.\n\t  //\n\t  // - __containerBox__ - Bounding box of the container.\n\t  // - __match__ - Match node that the line will be drawn to.\n\t  makeConnector: function makeConnector(containerBox, match) {\n\t    var box = match.getBBox();\n\t\n\t    return 'M0,' + box.ay + 'h' + box.ax + 'M' + box.ax2 + ',' + box.ay + 'H' + containerBox.width;\n\t  },\n\t  setup: function setup() {\n\t    if (this.properties.alternates.elements.length === 0) {\n\t      // When there is only one match node to render, proxy to it.\n\t      this.proxy = this.properties.match;\n\t    } else {\n\t      // Merge all the match nodes into one array.\n\t      this.matches = [this.properties.match].concat(_lodash2.default.map(this.properties.alternates.elements, function (element) {\n\t        return element.properties.match;\n\t      }));\n\t    }\n\t  }\n\t};\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _util = __webpack_require__(1);\n\t\n\tvar _util2 = _interopRequireDefault(_util);\n\t\n\tvar _lodash = __webpack_require__(2);\n\t\n\tvar _lodash2 = _interopRequireDefault(_lodash);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// Match nodes are used for the parts of a regular expression between `|`\n\t// symbols. They consist of a series of [MatchFragment](./match_fragment.html)\n\t// nodes. Optional `^` and `$` symbols are also allowed at the beginning and\n\t// end of the Match.\n\t\n\texports.default = {\n\t  type: 'match',\n\t\n\t  definedProperties: {\n\t    // Default anchor is overridden to attach the left point of the anchor to\n\t    // the first element, and the right point to the last element.\n\t    _anchor: {\n\t      get: function get() {\n\t        var start = _util2.default.normalizeBBox(this.start.getBBox()),\n\t            end = _util2.default.normalizeBBox(this.end.getBBox()),\n\t            matrix = this.transform().localMatrix;\n\t\n\t        return {\n\t          ax: matrix.x(start.ax, start.ay),\n\t          ax2: matrix.x(end.ax2, end.ay),\n\t          ay: matrix.y(start.ax, start.ay)\n\t        };\n\t      }\n\t    }\n\t  },\n\t\n\t  // Renders the match into the currently set container.\n\t  _render: function _render() {\n\t    var _this = this;\n\t\n\t    // Render each of the match fragments.\n\t    var partPromises = _lodash2.default.map(this.parts, function (part) {\n\t      return part.render(_this.container.group());\n\t    }),\n\t        items = (0, _lodash2.default)(partPromises).compact().value();\n\t\n\t    // Handle the situation where a regular expression of `()` is rendered.\n\t    // This leads to a Match node with no fragments. Something must be rendered\n\t    // so that the anchor can be calculated based on it.\n\t    //\n\t    // Furthermore, the content rendered must have height and width or else the\n\t    // anchor calculations fail.\n\t    if (items.length === 0) {\n\t      items = [this.container.group().path('M0,0h10')];\n\t    }\n\t\n\t    return Promise.all(items).then(function (items) {\n\t      // Find SVG elements to be used when calculating the anchor.\n\t      _this.start = _lodash2.default.first(items);\n\t      _this.end = _lodash2.default.last(items);\n\t\n\t      _util2.default.spaceHorizontally(items, {\n\t        padding: 10\n\t      });\n\t\n\t      // Add lines between each item.\n\t      _this.container.prepend(_this.container.path(_this.connectorPaths(items).join('')));\n\t    });\n\t  },\n\t\n\t\n\t  // Returns an array of SVG path strings between each item.\n\t  // - __items__ - Array of SVG elements or nodes.\n\t  connectorPaths: function connectorPaths(items) {\n\t    var prev = void 0,\n\t        next = void 0;\n\t\n\t    prev = _util2.default.normalizeBBox(_lodash2.default.first(items).getBBox());\n\t    return _lodash2.default.map(items.slice(1), function (item) {\n\t      try {\n\t        next = _util2.default.normalizeBBox(item.getBBox());\n\t        return 'M' + prev.ax2 + ',' + prev.ay + 'H' + next.ax;\n\t      } finally {\n\t        prev = next;\n\t      }\n\t    });\n\t  },\n\t  setup: function setup() {\n\t    // Merged list of MatchFragments to be rendered.\n\t    this.parts = _lodash2.default.reduce(this.properties.parts.elements, function (result, node) {\n\t      var last = _lodash2.default.last(result);\n\t\n\t      if (last && node.canMerge && last.canMerge) {\n\t        // Merged the content of `node` into `last` when possible. This also\n\t        // discards `node` in the process since `result` has not been changed.\n\t        last.content.merge(node.content);\n\t      } else {\n\t        // `node` cannot be merged with the previous node, so it is added to\n\t        // the list of parts.\n\t        result.push(node);\n\t      }\n\t\n\t      return result;\n\t    }, []);\n\t\n\t    // When there is only one part, then proxy to the part.\n\t    if (this.parts.length === 1) {\n\t      this.proxy = this.parts[0];\n\t    }\n\t  }\n\t};\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _lodash = __webpack_require__(2);\n\t\n\tvar _lodash2 = _interopRequireDefault(_lodash);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = {\n\t  type: 'match-fragment',\n\t\n\t  definedProperties: {\n\t    // Default anchor is overridden to apply an transforms from the fragment\n\t    // to its content's anchor. Essentially, the fragment inherits the anchor\n\t    // of its content.\n\t    _anchor: {\n\t      get: function get() {\n\t        var anchor = this.content.getBBox(),\n\t            matrix = this.transform().localMatrix;\n\t\n\t        return {\n\t          ax: matrix.x(anchor.ax, anchor.ay),\n\t          ax2: matrix.x(anchor.ax2, anchor.ay),\n\t          ay: matrix.y(anchor.ax, anchor.ay)\n\t        };\n\t      }\n\t    }\n\t  },\n\t\n\t  // Renders the fragment into the currently set container.\n\t  _render: function _render() {\n\t    var _this = this;\n\t\n\t    return this.content.render(this.container.group()).then(function () {\n\t      var box = void 0,\n\t          paths = void 0;\n\t\n\t      // Contents must be transformed based on the repeat that is applied.\n\t      _this.content.transform(_this.repeat.contentPosition);\n\t\n\t      box = _this.content.getBBox();\n\t\n\t      // Add skip or repeat paths to the container.\n\t      paths = _lodash2.default.flatten([_this.repeat.skipPath(box), _this.repeat.loopPath(box)]);\n\t\n\t      _this.container.prepend(_this.container.path(paths.join('')));\n\t\n\t      _this.loopLabel();\n\t    });\n\t  },\n\t\n\t\n\t  // Renders label for the loop path indicating how many times the content may\n\t  // be matched.\n\t  loopLabel: function loopLabel() {\n\t    var labelStr = this.repeat.label,\n\t        tooltipStr = this.repeat.tooltip;\n\t\n\t    if (labelStr) {\n\t      var label = this.container.text(0, 0, [labelStr]).addClass('repeat-label'),\n\t          labelBox = label.getBBox(),\n\t          box = this.getBBox();\n\t\n\t      if (tooltipStr) {\n\t        var tooltip = this.container.el('title').append(this.container.text(0, 0, tooltipStr));\n\t        label.append(tooltip);\n\t      }\n\t\n\t      label.transform(Snap.matrix().translate(box.x2 - labelBox.width - (this.repeat.hasSkip ? 5 : 0), box.y2 + labelBox.height));\n\t    }\n\t  },\n\t  setup: function setup() {\n\t    // Then content of the fragment.\n\t    this.content = this.properties.content;\n\t    // The repetition rule for the fragment.\n\t    this.repeat = this.properties.repeat;\n\t\n\t    if (!this.repeat.hasLoop && !this.repeat.hasSkip) {\n\t      // For fragments without a skip or loop, rendering is proxied to the\n\t      // content. Also set flag indicating that contents can be merged if the\n\t      // content is a literal node.\n\t      this.canMerge = this.content.type === 'literal';\n\t      this.proxy = this.content;\n\t    } else {\n\t      // Fragments that have skip or loop lines cannot be merged with others.\n\t      this.canMerge = false;\n\t    }\n\t  }\n\t}; // MatchFragment nodes are part of a [Match](./match.html) followed by an\n\t// optional [Repeat](./repeat.html) node. If no repeat is applied, then\n\t// rendering is proxied to the content node.\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = {\n\t  _render: function _render() {\n\t    return this.renderLabel(this.label).then(function (label) {\n\t      return label.addClass('anchor');\n\t    });\n\t  },\n\t  setup: function setup() {\n\t    if (this.textValue === '^') {\n\t      this.label = 'Start of line';\n\t    } else {\n\t      this.label = 'End of line';\n\t    }\n\t  }\n\t};\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _lodash = __webpack_require__(2);\n\t\n\tvar _lodash2 = _interopRequireDefault(_lodash);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = {\n\t  type: 'subexp',\n\t\n\t  definedProperties: {\n\t    // Default anchor is overridden to move it down to account for the group\n\t    // label and outline box.\n\t    _anchor: {\n\t      get: function get() {\n\t        var anchor = this.regexp.getBBox(),\n\t            matrix = this.transform().localMatrix;\n\t\n\t        return {\n\t          ax: matrix.x(anchor.ax, anchor.ay),\n\t          ax2: matrix.x(anchor.ax2, anchor.ay),\n\t          ay: matrix.y(anchor.ax, anchor.ay)\n\t        };\n\t      }\n\t    }\n\t  },\n\t\n\t  labelMap: {\n\t    '?:': '',\n\t    '?=': 'positive lookahead',\n\t    '?!': 'negative lookahead'\n\t  },\n\t\n\t  // Renders the subexp into the currently set container.\n\t  _render: function _render() {\n\t    var _this = this;\n\t\n\t    // **NOTE:** `this.label()` **MUST** be called here, in _render, and before\n\t    // any child nodes are rendered. This is to keep the group numbers in the\n\t    // correct order.\n\t    var label = this.label();\n\t\n\t    // Render the contained regexp.\n\t    return this.regexp.render(this.container.group())\n\t    // Create the labeled box around the regexp.\n\t    .then(function () {\n\t      return _this.renderLabeledBox(label, _this.regexp, {\n\t        padding: 10\n\t      });\n\t    });\n\t  },\n\t\n\t\n\t  // Returns the label for the subexpression.\n\t  label: function label() {\n\t    if (_lodash2.default.has(this.labelMap, this.properties.capture.textValue)) {\n\t      return this.labelMap[this.properties.capture.textValue];\n\t    } else {\n\t      return 'group #' + this.state.groupCounter++;\n\t    }\n\t  },\n\t  setup: function setup() {\n\t    // **NOTE:** **DO NOT** call `this.label()` in setup. It will lead to\n\t    // groups being numbered in reverse order.\n\t    this.regexp = this.properties.regexp;\n\t\n\t    // If there is no need for a label, then proxy to the nested regexp.\n\t    if (this.properties.capture.textValue == '?:') {\n\t      this.proxy = this.regexp;\n\t    }\n\t  }\n\t}; // Subexp nodes are for expressions inside of parenthesis. It is rendered as a\n\t// labeled box around the contained expression if a label is required.\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _util = __webpack_require__(1);\n\t\n\tvar _util2 = _interopRequireDefault(_util);\n\t\n\tvar _lodash = __webpack_require__(2);\n\t\n\tvar _lodash2 = _interopRequireDefault(_lodash);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// Charset nodes are used for `[abc1-9]` regular expression syntax. It is\n\t// rendered as a labeled box with each literal, escape, and range rendering\n\t// handled by the nested node(s).\n\t\n\texports.default = {\n\t  type: 'charset',\n\t\n\t  definedProperties: {\n\t    // Default anchor is overridden to move it down so that it connects at the\n\t    // middle of the box that wraps all of the charset parts, instead of the\n\t    // middle of the container, which would take the label into account.\n\t    _anchor: {\n\t      get: function get() {\n\t        var matrix = this.transform().localMatrix;\n\t\n\t        return {\n\t          ay: matrix.y(0, this.partContainer.getBBox().cy)\n\t        };\n\t      }\n\t    }\n\t  },\n\t\n\t  // Renders the charset into the currently set container.\n\t  _render: function _render() {\n\t    var _this = this;\n\t\n\t    this.partContainer = this.container.group();\n\t\n\t    // Renders each part of the charset into the part container.\n\t    return Promise.all(_lodash2.default.map(this.elements, function (part) {\n\t      return part.render(_this.partContainer.group());\n\t    })).then(function () {\n\t      // Space the parts of the charset vertically in the part container.\n\t      _util2.default.spaceVertically(_this.elements, {\n\t        padding: 5\n\t      });\n\t\n\t      // Label the part container.\n\t      return _this.renderLabeledBox(_this.label, _this.partContainer, {\n\t        padding: 5\n\t      });\n\t    });\n\t  },\n\t  setup: function setup() {\n\t    // The label for the charset will be:\n\t    // - \"One of:\" for charsets of the form: `[abc]`.\n\t    // - \"None of:\" for charsets of the form: `[^abc]`.\n\t    this.label = this.properties.invert.textValue === '^' ? 'None of:' : 'One of:';\n\t\n\t    // Removes any duplicate parts from the charset. This is based on the type\n\t    // and text value of the part, so `[aa]` will have only one item, but\n\t    // `[a\\x61]` will contain two since the first matches \"a\" and the second\n\t    // matches 0x61 (even though both are an \"a\").\n\t    this.elements = _lodash2.default.uniqBy(this.properties.parts.elements, function (part) {\n\t      return part.type + ':' + part.textValue;\n\t    });\n\t\n\t    // Include a warning for charsets that attempt to match `\\c` followed by\n\t    // any character other than A-Z (case insensitive). Charsets like `[\\c@]`\n\t    // behave differently in different browsers. Some match the character\n\t    // reference by the control charater escape, others match \"\\\", \"c\", or \"@\",\n\t    // and some do not appear to match anything.\n\t    if (this.textValue.match(/\\\\c[^a-zA-Z]/)) {\n\t      this.state.warnings.push('The character set \"' + this.textValue + '\" contains the \\\\c escape followed by a character other than A-Z. This can lead to different behavior depending on browser. The representation here is the most common interpretation.');\n\t    }\n\t  }\n\t};\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _lodash = __webpack_require__(2);\n\t\n\tvar _lodash2 = _interopRequireDefault(_lodash);\n\t\n\tvar _escape = __webpack_require__(18);\n\t\n\tvar _escape2 = _interopRequireDefault(_escape);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// CharsetEscape nodes are for escape sequences inside of character sets. They\n\t// differ from other [Escape](./escape.html) nodes in that `\\b` matches a\n\t// backspace character instead of a word boundary.\n\t\n\texports.default = _lodash2.default.extend({}, _escape2.default, {\n\t  type: 'charset-escape',\n\t\n\t  b: ['backspace', 0x08, true]\n\t});\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); // Escape nodes are used for escape sequences. It is rendered as a label with\n\t// the description of the escape and the numeric code it matches when\n\t// appropriate.\n\t\n\tvar _lodash = __webpack_require__(2);\n\t\n\tvar _lodash2 = _interopRequireDefault(_lodash);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction hex(value) {\n\t  var str = value.toString(16).toUpperCase();\n\t\n\t  if (str.length < 2) {\n\t    str = '0' + str;\n\t  }\n\t\n\t  return '(0x' + str + ')';\n\t}\n\t\n\texports.default = {\n\t  type: 'escape',\n\t\n\t  // Renders the escape into the currently set container.\n\t  _render: function _render() {\n\t    return this.renderLabel(this.label).then(function (label) {\n\t      label.select('rect').attr({\n\t        rx: 3,\n\t        ry: 3\n\t      });\n\t      return label;\n\t    });\n\t  },\n\t  setup: function setup() {\n\t    var addHex = void 0;\n\t\n\t    // The escape code. For an escape such as `\\b` it would be \"b\".\n\t    this.code = this.properties.esc.properties.code.textValue;\n\t    // The argument. For an escape such as `\\xab` it would be \"ab\".\n\t    this.arg = this.properties.esc.properties.arg.textValue;\n\t    // Retrieves the label, ordinal value, an flag to control adding hex value\n\t    // from the escape code mappings\n\t\n\t    // When requested, add hex code to the label.\n\t    var _$result = _lodash2.default.result(this, this.code);\n\t\n\t    var _$result2 = _slicedToArray(_$result, 3);\n\t\n\t    this.label = _$result2[0];\n\t    this.ordinal = _$result2[1];\n\t    addHex = _$result2[2];\n\t    if (addHex) {\n\t      this.label = this.label + ' ' + hex(this.ordinal);\n\t    }\n\t  },\n\t\n\t\n\t  // Escape code mappings\n\t  b: ['word boundary', -1, false],\n\t  B: ['non-word boundary', -1, false],\n\t  d: ['digit', -1, false],\n\t  D: ['non-digit', -1, false],\n\t  f: ['form feed', 0x0c, true],\n\t  n: ['line feed', 0x0a, true],\n\t  r: ['carriage return', 0x0d, true],\n\t  s: ['white space', -1, false],\n\t  S: ['non-white space', -1, false],\n\t  t: ['tab', 0x09, true],\n\t  v: ['vertical tab', 0x0b, true],\n\t  w: ['word', -1, false],\n\t  W: ['non-word', -1, false],\n\t  1: ['Back reference (group = 1)', -1, false],\n\t  2: ['Back reference (group = 2)', -1, false],\n\t  3: ['Back reference (group = 3)', -1, false],\n\t  4: ['Back reference (group = 4)', -1, false],\n\t  5: ['Back reference (group = 5)', -1, false],\n\t  6: ['Back reference (group = 6)', -1, false],\n\t  7: ['Back reference (group = 7)', -1, false],\n\t  8: ['Back reference (group = 8)', -1, false],\n\t  9: ['Back reference (group = 9)', -1, false],\n\t  0: function _() {\n\t    if (this.arg) {\n\t      return ['octal: ' + this.arg, parseInt(this.arg, 8), true];\n\t    } else {\n\t      return ['null', 0, true];\n\t    }\n\t  },\n\t  c: function c() {\n\t    return ['ctrl-' + this.arg.toUpperCase(), this.arg.toUpperCase().charCodeAt(0) - 64, true];\n\t  },\n\t  x: function x() {\n\t    return ['0x' + this.arg.toUpperCase(), parseInt(this.arg, 16), false];\n\t  },\n\t  u: function u() {\n\t    return ['U+' + this.arg.toUpperCase(), parseInt(this.arg, 16), false];\n\t  }\n\t};\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _util = __webpack_require__(1);\n\t\n\tvar _util2 = _interopRequireDefault(_util);\n\t\n\tvar _lodash = __webpack_require__(2);\n\t\n\tvar _lodash2 = _interopRequireDefault(_lodash);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// CharsetRange nodes are used for `[a-z]` regular expression syntax. The two\n\t// literal or escape nodes are rendered with a hyphen between them.\n\t\n\texports.default = {\n\t  type: 'charset-range',\n\t\n\t  // Renders the charset range into the currently set container\n\t  _render: function _render() {\n\t    var contents = [this.first, this.container.text(0, 0, '-'), this.last];\n\t\n\t    // Render the nodes of the range.\n\t    return Promise.all([this.first.render(this.container.group()), this.last.render(this.container.group())]).then(function () {\n\t      // Space the nodes and hyphen horizontally.\n\t      _util2.default.spaceHorizontally(contents, {\n\t        padding: 5\n\t      });\n\t    });\n\t  },\n\t  setup: function setup() {\n\t    // The two nodes for the range. In `[a-z]` these would be\n\t    // [Literal](./literal.html) nodes for \"a\" and \"z\".\n\t    this.first = this.properties.first;\n\t    this.last = this.properties.last;\n\t\n\t    // Report invalid expression when extents of the range are out of order.\n\t    if (this.first.ordinal > this.last.ordinal) {\n\t      throw 'Range out of order in character class: ' + this.textValue;\n\t    }\n\t  }\n\t};\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _lodash = __webpack_require__(2);\n\t\n\tvar _lodash2 = _interopRequireDefault(_lodash);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = {\n\t  type: 'literal',\n\t\n\t  // Renders the literal into the currently set container.\n\t  _render: function _render() {\n\t    return this.renderLabel(['\\u201C', this.literal, '\\u201D']).then(function (label) {\n\t      var spans = label.selectAll('tspan');\n\t\n\t      // The quote marks get some styling to lighten their color so they are\n\t      // distinct from the actual literal value.\n\t      spans[0].addClass('quote');\n\t      spans[2].addClass('quote');\n\t\n\t      label.select('rect').attr({\n\t        rx: 3,\n\t        ry: 3\n\t      });\n\t\n\t      return label;\n\t    });\n\t  },\n\t\n\t\n\t  // Merges this literal with another. Literals come back as single characters\n\t  // during parsing, and must be post-processed into multi-character literals\n\t  // for rendering. This processing is done in [Match](./match.html).\n\t  merge: function merge(other) {\n\t    this.literal += other.literal;\n\t  },\n\t  setup: function setup() {\n\t    // Value of the literal.\n\t    this.literal = this.properties.literal.textValue;\n\t    // Ordinal value of the literal for use in\n\t    // [CharsetRange](./charset_range.html).\n\t    this.ordinal = this.literal.charCodeAt(0);\n\t  }\n\t}; // Literal nodes are for plain strings in the regular expression. They are\n\t// rendered as labels with the value of the literal quoted.\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _lodash = __webpack_require__(2);\n\t\n\tvar _lodash2 = _interopRequireDefault(_lodash);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = {\n\t  type: 'any-character',\n\t\n\t  _render: function _render() {\n\t    return this.renderLabel('any character');\n\t  }\n\t}; // AnyCharacter nodes are for `*` regular expression syntax. They are rendered\n\t// as just an \"any character\" label.\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t// Repeat nodes are for the various repetition syntaxes (`a*`, `a+`, `a?`, and\n\t// `a{1,3}`). It is not rendered directly, but contains data used for the\n\t// rendering of [MatchFragment](./match_fragment.html) nodes.\n\t\n\tfunction formatTimes(times) {\n\t  if (times === 1) {\n\t    return 'once';\n\t  } else {\n\t    return times + ' times';\n\t  }\n\t}\n\t\n\texports.default = {\n\t  definedProperties: {\n\t    // Translation to apply to content to be repeated to account for the loop\n\t    // and skip lines.\n\t    contentPosition: {\n\t      get: function get() {\n\t        var matrix = Snap.matrix();\n\t\n\t        if (this.hasSkip) {\n\t          return matrix.translate(15, 10);\n\t        } else if (this.hasLoop) {\n\t          return matrix.translate(10, 0);\n\t        } else {\n\t          return matrix.translate(0, 0);\n\t        }\n\t      }\n\t    },\n\t\n\t    // Label to place of loop path to indicate the number of times that path\n\t    // may be followed.\n\t    label: {\n\t      get: function get() {\n\t        if (this.minimum === this.maximum) {\n\t          if (this.minimum === 0) {\n\t            return undefined;\n\t          }\n\t          return formatTimes(this.minimum - 1);\n\t        } else if (this.minimum <= 1 && this.maximum >= 2) {\n\t          return 'at most ' + formatTimes(this.maximum - 1);\n\t        } else if (this.minimum >= 2) {\n\t          if (this.maximum === -1) {\n\t            return this.minimum - 1 + '+ times';\n\t          } else {\n\t            return this.minimum - 1 + '\\u2026' + formatTimes(this.maximum - 1);\n\t          }\n\t        }\n\t      }\n\t    },\n\t\n\t    // Tooltip to place of loop path label to provide further details.\n\t    tooltip: {\n\t      get: function get() {\n\t        var repeatCount = void 0;\n\t        if (this.minimum === this.maximum) {\n\t          if (this.minimum === 0) {\n\t            repeatCount = undefined;\n\t          } else {\n\t            repeatCount = formatTimes(this.minimum);\n\t          }\n\t        } else if (this.minimum <= 1 && this.maximum >= 2) {\n\t          repeatCount = 'at most ' + formatTimes(this.maximum);\n\t        } else if (this.minimum >= 2) {\n\t          if (this.maximum === -1) {\n\t            repeatCount = this.minimum + '+ times';\n\t          } else {\n\t            repeatCount = this.minimum + '\\u2026' + formatTimes(this.maximum);\n\t          }\n\t        }\n\t        return repeatCount ? 'repeats ' + repeatCount + ' in total' : repeatCount;\n\t      }\n\t    }\n\t  },\n\t\n\t  // Returns the path spec to render the line that skips over the content for\n\t  // fragments that are optionally matched.\n\t  skipPath: function skipPath(box) {\n\t    var paths = [];\n\t\n\t    if (this.hasSkip) {\n\t      var vert = Math.max(0, box.ay - box.y - 10),\n\t          horiz = box.width - 10;\n\t\n\t      paths.push('M0,' + box.ay + 'q10,0 10,-10v' + -vert + 'q0,-10 10,-10h' + horiz + 'q10,0 10,10v' + vert + 'q0,10 10,10');\n\t\n\t      // When the repeat is not greedy, the skip path gets a preference arrow.\n\t      if (!this.greedy) {\n\t        paths.push('M10,' + (box.ay - 15) + 'l5,5m-5,-5l-5,5');\n\t      }\n\t    }\n\t\n\t    return paths;\n\t  },\n\t\n\t\n\t  // Returns the path spec to render the line that repeats the content for\n\t  // fragments that are matched more than once.\n\t  loopPath: function loopPath(box) {\n\t    var paths = [];\n\t\n\t    if (this.hasLoop) {\n\t      var vert = box.y2 - box.ay - 10;\n\t\n\t      paths.push('M' + box.x + ',' + box.ay + 'q-10,0 -10,10v' + vert + 'q0,10 10,10h' + box.width + 'q10,0 10,-10v' + -vert + 'q0,-10 -10,-10');\n\t\n\t      // When the repeat is greedy, the loop path gets the preference arrow.\n\t      if (this.greedy) {\n\t        paths.push('M' + (box.x2 + 10) + ',' + (box.ay + 15) + 'l5,-5m-5,5l-5,-5');\n\t      }\n\t    }\n\t\n\t    return paths;\n\t  },\n\t  setup: function setup() {\n\t    this.minimum = this.properties.spec.minimum;\n\t    this.maximum = this.properties.spec.maximum;\n\t    this.greedy = this.properties.greedy.textValue === '';\n\t    this.hasSkip = this.minimum === 0;\n\t    this.hasLoop = this.maximum === -1 || this.maximum > 1;\n\t  }\n\t};\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t// RepeatAny nodes are used for `a*` regular expression syntax. It is not\n\t// rendered directly; it just indicates that the [Repeat](./repeat.html) node\n\t// loops zero or more times.\n\t\n\texports.default = {\n\t  minimum: 0,\n\t  maximum: -1\n\t};\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t// RepeatOptional nodes are used for `a?` regular expression syntax. It is not\n\t// rendered directly; it just indicates that the [Repeat](./repeat.html) node\n\t// loops zero or one times.\n\t\n\texports.default = {\n\t  minimum: 0,\n\t  maximum: 1\n\t};\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t// RepeatRequired nodes are used for `a+` regular expression syntax. It is not\n\t// rendered directly; it just indicates that the [Repeat](./repeat.html) node\n\t// loops one or more times.\n\t\n\texports.default = {\n\t  minimum: 1,\n\t  maximum: -1\n\t};\n\n/***/ },\n/* 26 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t// RepeatSpec nodes are used for `a{m,n}` regular expression syntax. It is not\n\t// rendered directly; it just indicates how many times the\n\t// [Repeat](./repeat.html) node loops.\n\t\n\texports.default = {\n\t  setup: function setup() {\n\t    if (this.properties.min) {\n\t      this.minimum = Number(this.properties.min.textValue);\n\t    } else if (this.properties.exact) {\n\t      this.minimum = Number(this.properties.exact.textValue);\n\t    } else {\n\t      this.minimum = 0;\n\t    }\n\t\n\t    if (this.properties.max) {\n\t      this.maximum = Number(this.properties.max.textValue);\n\t    } else if (this.properties.exact) {\n\t      this.maximum = Number(this.properties.exact.textValue);\n\t    } else {\n\t      this.maximum = -1;\n\t    }\n\t\n\t    // Report invalid repeat when the minimum is larger than the maximum.\n\t    if (this.minimum > this.maximum && this.maximum !== -1) {\n\t      throw \"Numbers out of order: \" + this.textValue;\n\t    }\n\t  }\n\t};\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t// State tracking for an in-progress parse and render.\n\tvar ParserState = function () {\n\t  // - __progress__ - DOM node to update to indicate completion progress.\n\t  function ParserState(progress) {\n\t    _classCallCheck(this, ParserState);\n\t\n\t    // Tracks the number of capture groups in the expression.\n\t    this.groupCounter = 1;\n\t    // Cancels the in-progress render when set to true.\n\t    this.cancelRender = false;\n\t    // Warnings that have been generated while rendering.\n\t    this.warnings = [];\n\t\n\t    // Used to display the progress indicator\n\t    this._renderCounter = 0;\n\t    this._maxCounter = 0;\n\t    this._progress = progress;\n\t  }\n\t\n\t  // Counts the number of in-progress rendering steps. As the counter goes up,\n\t  // a maximum value is also tracked. The maximum value and current render\n\t  // counter are used to calculate the completion process.\n\t\n\t\n\t  _createClass(ParserState, [{\n\t    key: 'renderCounter',\n\t    get: function get() {\n\t      return this._renderCounter;\n\t    },\n\t    set: function set(value) {\n\t      if (value > this.renderCounter) {\n\t        this._maxCounter = value;\n\t      }\n\t\n\t      this._renderCounter = value;\n\t\n\t      if (this._maxCounter && !this.cancelRender) {\n\t        this._progress.style.width = ((1 - this.renderCounter / this._maxCounter) * 100).toFixed(2) + '%';\n\t      }\n\t    }\n\t  }]);\n\t\n\t  return ParserState;\n\t}();\n\t\n\texports.default = ParserState;\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// js/main.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap eec0046e26096bafff5b","// This file contains code to start up pages on the site, and other code that\n// is not directly related to parsing and display of regular expressions.\n//\n// Since the code in this is executed immediately, it is all but impossible to\n// test. Therefore, this code is kept as simple as possible to reduce the need\n// to run it through automated tests.\n\nimport util from './util.js';\nimport Regexper from './regexper.js';\nimport Parser from './parser/javascript.js';\nimport _ from 'lodash';\n\n(function() {\n  // Global error handler that will send unhandled JavaScript exceptions and\n  // stack-traces to Google Analytics. This data can be used to find errors in\n  // code that were not found during testing.\n  window.addEventListener('error', function(error) {\n    if (error.lineno !== 0) {\n      util.track('send', 'event', 'global', 'exception',\n        `${error.filename}(${error.lineno},${error.colno}): ${error.message}`);\n\n      if (typeof error.error !== 'undefined' && typeof error.error.stack !== 'undefined') {\n        util.track('send', 'event', 'global', 'stack trace', error.error.stack);\n      }\n    }\n  });\n\n  // Initialize the main page of the site. Functionality is kept in the\n  // [Regexper class](./regexper.html).\n  if (document.body.querySelector('#content .application')) {\n    let regexper = new Regexper(document.body);\n\n    regexper.detectBuggyHash();\n    regexper.bindListeners();\n\n    util.tick().then(() => {\n      window.dispatchEvent(util.customEvent('hashchange'));\n    });\n  }\n\n  // Initialize other pages on the site (specifically the documentation page).\n  // Any element with a `data-expr` attribute will contain a rendering of the\n  // provided regular expression.\n  _.each(document.querySelectorAll('[data-expr]'), element => {\n    new Parser(element, { keepContent: true })\n      .parse(element.getAttribute('data-expr'))\n      .then(parser => {\n        parser.render();\n      })\n      .catch(util.exposeError);\n  });\n}());\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/main.js","// Utility functions used elsewhere in the codebase. Most JavaScript files on\n// the site use some functions defined in this file.\n\nimport _ from 'lodash';\n\n// Generate an `Event` object for triggering a custom event.\n//\n// - __name__ - Name of the custom event. This should be a String.\n// - __detail__ - Event details. The event details are provided to the event\n//    handler.\nfunction customEvent(name, detail) {\n  var evt = document.createEvent('Event');\n  evt.initEvent(name, true, true);\n  evt.detail = detail;\n  return evt;\n}\n\n// Add extra fields to a bounding box returned by `getBBox`. Specifically adds\n// details about the box's axis points (used when positioning elements for\n// display).\n//\n// - __box__ - Bounding box object to update. Attributes `ax`, `ax2`, and `ay`\n//    will be added if they are not already defined.\nfunction normalizeBBox(box) {\n  return _.defaults(box, {\n    ax: box.x,\n    ax2: box.x2,\n    ay: box.cy\n  });\n}\n\n// Positions a collection of items with their axis points aligned along a\n// horizontal line. This leads to the items being spaced horizontally and\n// effectively centered vertically.\n//\n// - __items__ - Array of items to be positioned\n// - __options.padding__ - Number of pixels to leave between items\nfunction spaceHorizontally(items, options) {\n  var verticalCenter,\n      values;\n\n  options = _.defaults(options || {}, {\n    padding: 0\n  });\n\n  values = _.map(items, item => ({\n    box: normalizeBBox(item.getBBox()),\n    item\n  }));\n\n  // Calculate where the axis points should be positioned vertically.\n  verticalCenter = _.reduce(values,\n    (center, { box }) => Math.max(center, box.ay),\n    0);\n\n  // Position items with padding between them and aligned their axis points.\n  _.reduce(values, (offset, { item, box }) => {\n    item.transform(Snap.matrix()\n      .translate(offset, verticalCenter - box.ay));\n\n    return offset + options.padding + box.width;\n  }, 0);\n}\n\n// Positions a collection of items centered horizontally in a vertical stack.\n//\n// - __items__ - Array of items to be positioned\n// - __options.padding__ - Number of pixels to leave between items\nfunction spaceVertically(items, options) {\n  var horizontalCenter,\n      values;\n\n  options = _.defaults(options || {}, {\n    padding: 0\n  });\n\n  values = _.map(items, item => ({\n    box: item.getBBox(),\n    item\n  }));\n\n  // Calculate where the center of each item should be positioned horizontally.\n  horizontalCenter = _.reduce(values,\n    (center, { box }) =>  Math.max(center, box.cx),\n    0);\n\n  // Position items with padding between them and align their centers.\n  _.reduce(values, (offset, { item, box }) => {\n    item.transform(Snap.matrix()\n      .translate(horizontalCenter - box.cx, offset));\n\n    return offset + options.padding + box.height;\n  }, 0);\n}\n\n// Creates a Promise that will be resolved after a specified delay.\n//\n// - __delay__ - Time in milliseconds to wait before resolving promise.\nfunction wait(delay) {\n  return new Promise((resolve, reject) => {\n    setTimeout(resolve, delay);\n  });\n}\n\n// Creates a Promise that will be resolved after 0 milliseconds. This is used\n// to create a short delay that allows the browser to address any pending tasks\n// while the JavaScript VM is not active.\nfunction tick() {\n  return wait(0);\n}\n\n// Re-throws an exception asynchronously. This is used to expose an exception\n// that was created during a Promise operation to be handled by global error\n// handlers (and to be displayed in the browser's debug console).\n//\n// - __error__ - Error/exception object to be re-thrown to the browser.\nfunction exposeError(error) {\n  setTimeout(() => {\n    throw error;\n  }, 0);\n}\n\n// Renders an SVG icon.\n//\n// - __selector__ - Selector to the SVG icon to render.\nfunction icon(selector) {\n  return `<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 8 8\"><use xlink:href=\"${selector}\" /></svg>`;\n}\n\n// Send tracking data.\nfunction track() {\n  if (window.ga) {\n    ga.apply(ga, arguments);\n  } else {\n    console.debug.apply(console, arguments);\n  }\n}\n\nexport default {\n  customEvent,\n  normalizeBBox,\n  spaceHorizontally,\n  spaceVertically,\n  wait,\n  tick,\n  exposeError,\n  icon,\n  track\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/util.js","/**\n * @license\n * Lodash <https://lodash.com/>\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n;(function() {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used as the semantic version number. */\n  var VERSION = '4.17.2';\n\n  /** Used as the size to enable large array optimizations. */\n  var LARGE_ARRAY_SIZE = 200;\n\n  /** Error message constants. */\n  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',\n      FUNC_ERROR_TEXT = 'Expected a function';\n\n  /** Used to stand-in for `undefined` hash values. */\n  var HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n  /** Used as the maximum memoize cache size. */\n  var MAX_MEMOIZE_SIZE = 500;\n\n  /** Used as the internal argument placeholder. */\n  var PLACEHOLDER = '__lodash_placeholder__';\n\n  /** Used to compose bitmasks for cloning. */\n  var CLONE_DEEP_FLAG = 1,\n      CLONE_FLAT_FLAG = 2,\n      CLONE_SYMBOLS_FLAG = 4;\n\n  /** Used to compose bitmasks for value comparisons. */\n  var COMPARE_PARTIAL_FLAG = 1,\n      COMPARE_UNORDERED_FLAG = 2;\n\n  /** Used to compose bitmasks for function metadata. */\n  var WRAP_BIND_FLAG = 1,\n      WRAP_BIND_KEY_FLAG = 2,\n      WRAP_CURRY_BOUND_FLAG = 4,\n      WRAP_CURRY_FLAG = 8,\n      WRAP_CURRY_RIGHT_FLAG = 16,\n      WRAP_PARTIAL_FLAG = 32,\n      WRAP_PARTIAL_RIGHT_FLAG = 64,\n      WRAP_ARY_FLAG = 128,\n      WRAP_REARG_FLAG = 256,\n      WRAP_FLIP_FLAG = 512;\n\n  /** Used as default options for `_.truncate`. */\n  var DEFAULT_TRUNC_LENGTH = 30,\n      DEFAULT_TRUNC_OMISSION = '...';\n\n  /** Used to detect hot functions by number of calls within a span of milliseconds. */\n  var HOT_COUNT = 800,\n      HOT_SPAN = 16;\n\n  /** Used to indicate the type of lazy iteratees. */\n  var LAZY_FILTER_FLAG = 1,\n      LAZY_MAP_FLAG = 2,\n      LAZY_WHILE_FLAG = 3;\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY = 1 / 0,\n      MAX_SAFE_INTEGER = 9007199254740991,\n      MAX_INTEGER = 1.7976931348623157e+308,\n      NAN = 0 / 0;\n\n  /** Used as references for the maximum length and index of an array. */\n  var MAX_ARRAY_LENGTH = 4294967295,\n      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,\n      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\n\n  /** Used to associate wrap methods with their bit flags. */\n  var wrapFlags = [\n    ['ary', WRAP_ARY_FLAG],\n    ['bind', WRAP_BIND_FLAG],\n    ['bindKey', WRAP_BIND_KEY_FLAG],\n    ['curry', WRAP_CURRY_FLAG],\n    ['curryRight', WRAP_CURRY_RIGHT_FLAG],\n    ['flip', WRAP_FLIP_FLAG],\n    ['partial', WRAP_PARTIAL_FLAG],\n    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],\n    ['rearg', WRAP_REARG_FLAG]\n  ];\n\n  /** `Object#toString` result references. */\n  var argsTag = '[object Arguments]',\n      arrayTag = '[object Array]',\n      asyncTag = '[object AsyncFunction]',\n      boolTag = '[object Boolean]',\n      dateTag = '[object Date]',\n      domExcTag = '[object DOMException]',\n      errorTag = '[object Error]',\n      funcTag = '[object Function]',\n      genTag = '[object GeneratorFunction]',\n      mapTag = '[object Map]',\n      numberTag = '[object Number]',\n      nullTag = '[object Null]',\n      objectTag = '[object Object]',\n      promiseTag = '[object Promise]',\n      proxyTag = '[object Proxy]',\n      regexpTag = '[object RegExp]',\n      setTag = '[object Set]',\n      stringTag = '[object String]',\n      symbolTag = '[object Symbol]',\n      undefinedTag = '[object Undefined]',\n      weakMapTag = '[object WeakMap]',\n      weakSetTag = '[object WeakSet]';\n\n  var arrayBufferTag = '[object ArrayBuffer]',\n      dataViewTag = '[object DataView]',\n      float32Tag = '[object Float32Array]',\n      float64Tag = '[object Float64Array]',\n      int8Tag = '[object Int8Array]',\n      int16Tag = '[object Int16Array]',\n      int32Tag = '[object Int32Array]',\n      uint8Tag = '[object Uint8Array]',\n      uint8ClampedTag = '[object Uint8ClampedArray]',\n      uint16Tag = '[object Uint16Array]',\n      uint32Tag = '[object Uint32Array]';\n\n  /** Used to match empty string literals in compiled template source. */\n  var reEmptyStringLeading = /\\b__p \\+= '';/g,\n      reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g,\n      reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n\n  /** Used to match HTML entities and HTML characters. */\n  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,\n      reUnescapedHtml = /[&<>\"']/g,\n      reHasEscapedHtml = RegExp(reEscapedHtml.source),\n      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n\n  /** Used to match template delimiters. */\n  var reEscape = /<%-([\\s\\S]+?)%>/g,\n      reEvaluate = /<%([\\s\\S]+?)%>/g,\n      reInterpolate = /<%=([\\s\\S]+?)%>/g;\n\n  /** Used to match property names within property paths. */\n  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n      reIsPlainProp = /^\\w*$/,\n      reLeadingDot = /^\\./,\n      rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n  /**\n   * Used to match `RegExp`\n   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n   */\n  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g,\n      reHasRegExpChar = RegExp(reRegExpChar.source);\n\n  /** Used to match leading and trailing whitespace. */\n  var reTrim = /^\\s+|\\s+$/g,\n      reTrimStart = /^\\s+/,\n      reTrimEnd = /\\s+$/;\n\n  /** Used to match wrap detail comments. */\n  var reWrapComment = /\\{(?:\\n\\/\\* \\[wrapped with .+\\] \\*\\/)?\\n?/,\n      reWrapDetails = /\\{\\n\\/\\* \\[wrapped with (.+)\\] \\*/,\n      reSplitDetails = /,? & /;\n\n  /** Used to match words composed of alphanumeric characters. */\n  var reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n\n  /** Used to match backslashes in property paths. */\n  var reEscapeChar = /\\\\(\\\\)?/g;\n\n  /**\n   * Used to match\n   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).\n   */\n  var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n\n  /** Used to match `RegExp` flags from their coerced string values. */\n  var reFlags = /\\w*$/;\n\n  /** Used to detect bad signed hexadecimal string values. */\n  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n  /** Used to detect binary string values. */\n  var reIsBinary = /^0b[01]+$/i;\n\n  /** Used to detect host constructors (Safari). */\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n  /** Used to detect octal string values. */\n  var reIsOctal = /^0o[0-7]+$/i;\n\n  /** Used to detect unsigned integer values. */\n  var reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n  /** Used to match Latin Unicode letters (excluding mathematical operators). */\n  var reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;\n\n  /** Used to ensure capturing order of template delimiters. */\n  var reNoMatch = /($^)/;\n\n  /** Used to match unescaped characters in compiled string literals. */\n  var reUnescapedString = /['\\n\\r\\u2028\\u2029\\\\]/g;\n\n  /** Used to compose unicode character classes. */\n  var rsAstralRange = '\\\\ud800-\\\\udfff',\n      rsComboMarksRange = '\\\\u0300-\\\\u036f',\n      reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n      rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n      rsDingbatRange = '\\\\u2700-\\\\u27bf',\n      rsLowerRange = 'a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff',\n      rsMathOpRange = '\\\\xac\\\\xb1\\\\xd7\\\\xf7',\n      rsNonCharRange = '\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf',\n      rsPunctuationRange = '\\\\u2000-\\\\u206f',\n      rsSpaceRange = ' \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000',\n      rsUpperRange = 'A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde',\n      rsVarRange = '\\\\ufe0e\\\\ufe0f',\n      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\n\n  /** Used to compose unicode capture groups. */\n  var rsApos = \"['\\u2019]\",\n      rsAstral = '[' + rsAstralRange + ']',\n      rsBreak = '[' + rsBreakRange + ']',\n      rsCombo = '[' + rsComboRange + ']',\n      rsDigits = '\\\\d+',\n      rsDingbat = '[' + rsDingbatRange + ']',\n      rsLower = '[' + rsLowerRange + ']',\n      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',\n      rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\n      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\n      rsNonAstral = '[^' + rsAstralRange + ']',\n      rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n      rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n      rsUpper = '[' + rsUpperRange + ']',\n      rsZWJ = '\\\\u200d';\n\n  /** Used to compose unicode regexes. */\n  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',\n      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',\n      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',\n      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',\n      reOptMod = rsModifier + '?',\n      rsOptVar = '[' + rsVarRange + ']?',\n      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n      rsOrdLower = '\\\\d*(?:(?:1st|2nd|3rd|(?![123])\\\\dth)\\\\b)',\n      rsOrdUpper = '\\\\d*(?:(?:1ST|2ND|3RD|(?![123])\\\\dTH)\\\\b)',\n      rsSeq = rsOptVar + reOptMod + rsOptJoin,\n      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,\n      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n  /** Used to match apostrophes. */\n  var reApos = RegExp(rsApos, 'g');\n\n  /**\n   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and\n   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).\n   */\n  var reComboMark = RegExp(rsCombo, 'g');\n\n  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\n  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n  /** Used to match complex or compound words. */\n  var reUnicodeWord = RegExp([\n    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',\n    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',\n    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,\n    rsUpper + '+' + rsOptContrUpper,\n    rsOrdUpper,\n    rsOrdLower,\n    rsDigits,\n    rsEmoji\n  ].join('|'), 'g');\n\n  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\n  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');\n\n  /** Used to detect strings that need a more robust regexp to match words. */\n  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;\n\n  /** Used to assign default `context` object properties. */\n  var contextProps = [\n    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',\n    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',\n    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',\n    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',\n    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'\n  ];\n\n  /** Used to make template sourceURLs easier to identify. */\n  var templateCounter = -1;\n\n  /** Used to identify `toStringTag` values of typed arrays. */\n  var typedArrayTags = {};\n  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\n  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\n  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\n  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\n  typedArrayTags[uint32Tag] = true;\n  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =\n  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\n  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\n  typedArrayTags[errorTag] = typedArrayTags[funcTag] =\n  typedArrayTags[mapTag] = typedArrayTags[numberTag] =\n  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =\n  typedArrayTags[setTag] = typedArrayTags[stringTag] =\n  typedArrayTags[weakMapTag] = false;\n\n  /** Used to identify `toStringTag` values supported by `_.clone`. */\n  var cloneableTags = {};\n  cloneableTags[argsTag] = cloneableTags[arrayTag] =\n  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\n  cloneableTags[boolTag] = cloneableTags[dateTag] =\n  cloneableTags[float32Tag] = cloneableTags[float64Tag] =\n  cloneableTags[int8Tag] = cloneableTags[int16Tag] =\n  cloneableTags[int32Tag] = cloneableTags[mapTag] =\n  cloneableTags[numberTag] = cloneableTags[objectTag] =\n  cloneableTags[regexpTag] = cloneableTags[setTag] =\n  cloneableTags[stringTag] = cloneableTags[symbolTag] =\n  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\n  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n  cloneableTags[errorTag] = cloneableTags[funcTag] =\n  cloneableTags[weakMapTag] = false;\n\n  /** Used to map Latin Unicode letters to basic Latin letters. */\n  var deburredLetters = {\n    // Latin-1 Supplement block.\n    '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\n    '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\n    '\\xc7': 'C',  '\\xe7': 'c',\n    '\\xd0': 'D',  '\\xf0': 'd',\n    '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\n    '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\n    '\\xcc': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\n    '\\xec': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\n    '\\xd1': 'N',  '\\xf1': 'n',\n    '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\n    '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\n    '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\n    '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\n    '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\n    '\\xc6': 'Ae', '\\xe6': 'ae',\n    '\\xde': 'Th', '\\xfe': 'th',\n    '\\xdf': 'ss',\n    // Latin Extended-A block.\n    '\\u0100': 'A',  '\\u0102': 'A', '\\u0104': 'A',\n    '\\u0101': 'a',  '\\u0103': 'a', '\\u0105': 'a',\n    '\\u0106': 'C',  '\\u0108': 'C', '\\u010a': 'C', '\\u010c': 'C',\n    '\\u0107': 'c',  '\\u0109': 'c', '\\u010b': 'c', '\\u010d': 'c',\n    '\\u010e': 'D',  '\\u0110': 'D', '\\u010f': 'd', '\\u0111': 'd',\n    '\\u0112': 'E',  '\\u0114': 'E', '\\u0116': 'E', '\\u0118': 'E', '\\u011a': 'E',\n    '\\u0113': 'e',  '\\u0115': 'e', '\\u0117': 'e', '\\u0119': 'e', '\\u011b': 'e',\n    '\\u011c': 'G',  '\\u011e': 'G', '\\u0120': 'G', '\\u0122': 'G',\n    '\\u011d': 'g',  '\\u011f': 'g', '\\u0121': 'g', '\\u0123': 'g',\n    '\\u0124': 'H',  '\\u0126': 'H', '\\u0125': 'h', '\\u0127': 'h',\n    '\\u0128': 'I',  '\\u012a': 'I', '\\u012c': 'I', '\\u012e': 'I', '\\u0130': 'I',\n    '\\u0129': 'i',  '\\u012b': 'i', '\\u012d': 'i', '\\u012f': 'i', '\\u0131': 'i',\n    '\\u0134': 'J',  '\\u0135': 'j',\n    '\\u0136': 'K',  '\\u0137': 'k', '\\u0138': 'k',\n    '\\u0139': 'L',  '\\u013b': 'L', '\\u013d': 'L', '\\u013f': 'L', '\\u0141': 'L',\n    '\\u013a': 'l',  '\\u013c': 'l', '\\u013e': 'l', '\\u0140': 'l', '\\u0142': 'l',\n    '\\u0143': 'N',  '\\u0145': 'N', '\\u0147': 'N', '\\u014a': 'N',\n    '\\u0144': 'n',  '\\u0146': 'n', '\\u0148': 'n', '\\u014b': 'n',\n    '\\u014c': 'O',  '\\u014e': 'O', '\\u0150': 'O',\n    '\\u014d': 'o',  '\\u014f': 'o', '\\u0151': 'o',\n    '\\u0154': 'R',  '\\u0156': 'R', '\\u0158': 'R',\n    '\\u0155': 'r',  '\\u0157': 'r', '\\u0159': 'r',\n    '\\u015a': 'S',  '\\u015c': 'S', '\\u015e': 'S', '\\u0160': 'S',\n    '\\u015b': 's',  '\\u015d': 's', '\\u015f': 's', '\\u0161': 's',\n    '\\u0162': 'T',  '\\u0164': 'T', '\\u0166': 'T',\n    '\\u0163': 't',  '\\u0165': 't', '\\u0167': 't',\n    '\\u0168': 'U',  '\\u016a': 'U', '\\u016c': 'U', '\\u016e': 'U', '\\u0170': 'U', '\\u0172': 'U',\n    '\\u0169': 'u',  '\\u016b': 'u', '\\u016d': 'u', '\\u016f': 'u', '\\u0171': 'u', '\\u0173': 'u',\n    '\\u0174': 'W',  '\\u0175': 'w',\n    '\\u0176': 'Y',  '\\u0177': 'y', '\\u0178': 'Y',\n    '\\u0179': 'Z',  '\\u017b': 'Z', '\\u017d': 'Z',\n    '\\u017a': 'z',  '\\u017c': 'z', '\\u017e': 'z',\n    '\\u0132': 'IJ', '\\u0133': 'ij',\n    '\\u0152': 'Oe', '\\u0153': 'oe',\n    '\\u0149': \"'n\", '\\u017f': 's'\n  };\n\n  /** Used to map characters to HTML entities. */\n  var htmlEscapes = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n\n  /** Used to map HTML entities to characters. */\n  var htmlUnescapes = {\n    '&amp;': '&',\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&#39;': \"'\"\n  };\n\n  /** Used to escape characters for inclusion in compiled string literals. */\n  var stringEscapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    '\\n': 'n',\n    '\\r': 'r',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  /** Built-in method references without a dependency on `root`. */\n  var freeParseFloat = parseFloat,\n      freeParseInt = parseInt;\n\n  /** Detect free variable `global` from Node.js. */\n  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n  /** Detect free variable `self`. */\n  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n  /** Used as a reference to the global object. */\n  var root = freeGlobal || freeSelf || Function('return this')();\n\n  /** Detect free variable `exports`. */\n  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n  /** Detect free variable `module`. */\n  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n  /** Detect the popular CommonJS extension `module.exports`. */\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n\n  /** Detect free variable `process` from Node.js. */\n  var freeProcess = moduleExports && freeGlobal.process;\n\n  /** Used to access faster Node.js helpers. */\n  var nodeUtil = (function() {\n    try {\n      return freeProcess && freeProcess.binding && freeProcess.binding('util');\n    } catch (e) {}\n  }());\n\n  /* Node.js helper references. */\n  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,\n      nodeIsDate = nodeUtil && nodeUtil.isDate,\n      nodeIsMap = nodeUtil && nodeUtil.isMap,\n      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,\n      nodeIsSet = nodeUtil && nodeUtil.isSet,\n      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Adds the key-value `pair` to `map`.\n   *\n   * @private\n   * @param {Object} map The map to modify.\n   * @param {Array} pair The key-value pair to add.\n   * @returns {Object} Returns `map`.\n   */\n  function addMapEntry(map, pair) {\n    // Don't return `map.set` because it's not chainable in IE 11.\n    map.set(pair[0], pair[1]);\n    return map;\n  }\n\n  /**\n   * Adds `value` to `set`.\n   *\n   * @private\n   * @param {Object} set The set to modify.\n   * @param {*} value The value to add.\n   * @returns {Object} Returns `set`.\n   */\n  function addSetEntry(set, value) {\n    // Don't return `set.add` because it's not chainable in IE 11.\n    set.add(value);\n    return set;\n  }\n\n  /**\n   * A faster alternative to `Function#apply`, this function invokes `func`\n   * with the `this` binding of `thisArg` and the arguments of `args`.\n   *\n   * @private\n   * @param {Function} func The function to invoke.\n   * @param {*} thisArg The `this` binding of `func`.\n   * @param {Array} args The arguments to invoke `func` with.\n   * @returns {*} Returns the result of `func`.\n   */\n  function apply(func, thisArg, args) {\n    switch (args.length) {\n      case 0: return func.call(thisArg);\n      case 1: return func.call(thisArg, args[0]);\n      case 2: return func.call(thisArg, args[0], args[1]);\n      case 3: return func.call(thisArg, args[0], args[1], args[2]);\n    }\n    return func.apply(thisArg, args);\n  }\n\n  /**\n   * A specialized version of `baseAggregator` for arrays.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} setter The function to set `accumulator` values.\n   * @param {Function} iteratee The iteratee to transform keys.\n   * @param {Object} accumulator The initial aggregated object.\n   * @returns {Function} Returns `accumulator`.\n   */\n  function arrayAggregator(array, setter, iteratee, accumulator) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      var value = array[index];\n      setter(accumulator, value, iteratee(value), array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.forEach` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEach(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (iteratee(array[index], index, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.forEachRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEachRight(array, iteratee) {\n    var length = array == null ? 0 : array.length;\n\n    while (length--) {\n      if (iteratee(array[length], length, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.every` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if all elements pass the predicate check,\n   *  else `false`.\n   */\n  function arrayEvery(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (!predicate(array[index], index, array)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * A specialized version of `_.filter` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   */\n  function arrayFilter(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (predicate(value, index, array)) {\n        result[resIndex++] = value;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * A specialized version of `_.includes` for arrays without support for\n   * specifying an index to search from.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludes(array, value) {\n    var length = array == null ? 0 : array.length;\n    return !!length && baseIndexOf(array, value, 0) > -1;\n  }\n\n  /**\n   * This function is like `arrayIncludes` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludesWith(array, value, comparator) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (comparator(value, array[index])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * A specialized version of `_.map` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   */\n  function arrayMap(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        result = Array(length);\n\n    while (++index < length) {\n      result[index] = iteratee(array[index], index, array);\n    }\n    return result;\n  }\n\n  /**\n   * Appends the elements of `values` to `array`.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {Array} values The values to append.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayPush(array, values) {\n    var index = -1,\n        length = values.length,\n        offset = array.length;\n\n    while (++index < length) {\n      array[offset + index] = values[index];\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.reduce` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the first element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduce(array, iteratee, accumulator, initAccum) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    if (initAccum && length) {\n      accumulator = array[++index];\n    }\n    while (++index < length) {\n      accumulator = iteratee(accumulator, array[index], index, array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.reduceRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the last element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduceRight(array, iteratee, accumulator, initAccum) {\n    var length = array == null ? 0 : array.length;\n    if (initAccum && length) {\n      accumulator = array[--length];\n    }\n    while (length--) {\n      accumulator = iteratee(accumulator, array[length], length, array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.some` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if any element passes the predicate check,\n   *  else `false`.\n   */\n  function arraySome(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (predicate(array[index], index, array)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Gets the size of an ASCII `string`.\n   *\n   * @private\n   * @param {string} string The string inspect.\n   * @returns {number} Returns the string size.\n   */\n  var asciiSize = baseProperty('length');\n\n  /**\n   * Converts an ASCII `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function asciiToArray(string) {\n    return string.split('');\n  }\n\n  /**\n   * Splits an ASCII `string` into an array of its words.\n   *\n   * @private\n   * @param {string} The string to inspect.\n   * @returns {Array} Returns the words of `string`.\n   */\n  function asciiWords(string) {\n    return string.match(reAsciiWord) || [];\n  }\n\n  /**\n   * The base implementation of methods like `_.findKey` and `_.findLastKey`,\n   * without support for iteratee shorthands, which iterates over `collection`\n   * using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the found element or its key, else `undefined`.\n   */\n  function baseFindKey(collection, predicate, eachFunc) {\n    var result;\n    eachFunc(collection, function(value, key, collection) {\n      if (predicate(value, key, collection)) {\n        result = key;\n        return false;\n      }\n    });\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.findIndex` and `_.findLastIndex` without\n   * support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {number} fromIndex The index to search from.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseFindIndex(array, predicate, fromIndex, fromRight) {\n    var length = array.length,\n        index = fromIndex + (fromRight ? 1 : -1);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (predicate(array[index], index, array)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOf(array, value, fromIndex) {\n    return value === value\n      ? strictIndexOf(array, value, fromIndex)\n      : baseFindIndex(array, baseIsNaN, fromIndex);\n  }\n\n  /**\n   * This function is like `baseIndexOf` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOfWith(array, value, fromIndex, comparator) {\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (comparator(array[index], value)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.isNaN` without support for number objects.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n   */\n  function baseIsNaN(value) {\n    return value !== value;\n  }\n\n  /**\n   * The base implementation of `_.mean` and `_.meanBy` without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {number} Returns the mean.\n   */\n  function baseMean(array, iteratee) {\n    var length = array == null ? 0 : array.length;\n    return length ? (baseSum(array, iteratee) / length) : NAN;\n  }\n\n  /**\n   * The base implementation of `_.property` without support for deep paths.\n   *\n   * @private\n   * @param {string} key The key of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function baseProperty(key) {\n    return function(object) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  /**\n   * The base implementation of `_.propertyOf` without support for deep paths.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function basePropertyOf(object) {\n    return function(key) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  /**\n   * The base implementation of `_.reduce` and `_.reduceRight`, without support\n   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} accumulator The initial value.\n   * @param {boolean} initAccum Specify using the first or last element of\n   *  `collection` as the initial value.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the accumulated value.\n   */\n  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n    eachFunc(collection, function(value, index, collection) {\n      accumulator = initAccum\n        ? (initAccum = false, value)\n        : iteratee(accumulator, value, index, collection);\n    });\n    return accumulator;\n  }\n\n  /**\n   * The base implementation of `_.sortBy` which uses `comparer` to define the\n   * sort order of `array` and replaces criteria objects with their corresponding\n   * values.\n   *\n   * @private\n   * @param {Array} array The array to sort.\n   * @param {Function} comparer The function to define sort order.\n   * @returns {Array} Returns `array`.\n   */\n  function baseSortBy(array, comparer) {\n    var length = array.length;\n\n    array.sort(comparer);\n    while (length--) {\n      array[length] = array[length].value;\n    }\n    return array;\n  }\n\n  /**\n   * The base implementation of `_.sum` and `_.sumBy` without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {number} Returns the sum.\n   */\n  function baseSum(array, iteratee) {\n    var result,\n        index = -1,\n        length = array.length;\n\n    while (++index < length) {\n      var current = iteratee(array[index]);\n      if (current !== undefined) {\n        result = result === undefined ? current : (result + current);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.times` without support for iteratee shorthands\n   * or max array length checks.\n   *\n   * @private\n   * @param {number} n The number of times to invoke `iteratee`.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the array of results.\n   */\n  function baseTimes(n, iteratee) {\n    var index = -1,\n        result = Array(n);\n\n    while (++index < n) {\n      result[index] = iteratee(index);\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array\n   * of key-value pairs for `object` corresponding to the property names of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the key-value pairs.\n   */\n  function baseToPairs(object, props) {\n    return arrayMap(props, function(key) {\n      return [key, object[key]];\n    });\n  }\n\n  /**\n   * The base implementation of `_.unary` without support for storing metadata.\n   *\n   * @private\n   * @param {Function} func The function to cap arguments for.\n   * @returns {Function} Returns the new capped function.\n   */\n  function baseUnary(func) {\n    return function(value) {\n      return func(value);\n    };\n  }\n\n  /**\n   * The base implementation of `_.values` and `_.valuesIn` which creates an\n   * array of `object` property values corresponding to the property names\n   * of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the array of property values.\n   */\n  function baseValues(object, props) {\n    return arrayMap(props, function(key) {\n      return object[key];\n    });\n  }\n\n  /**\n   * Checks if a `cache` value for `key` exists.\n   *\n   * @private\n   * @param {Object} cache The cache to query.\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function cacheHas(cache, key) {\n    return cache.has(key);\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the first unmatched string symbol.\n   */\n  function charsStartIndex(strSymbols, chrSymbols) {\n    var index = -1,\n        length = strSymbols.length;\n\n    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the last unmatched string symbol.\n   */\n  function charsEndIndex(strSymbols, chrSymbols) {\n    var index = strSymbols.length;\n\n    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n    return index;\n  }\n\n  /**\n   * Gets the number of `placeholder` occurrences in `array`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} placeholder The placeholder to search for.\n   * @returns {number} Returns the placeholder count.\n   */\n  function countHolders(array, placeholder) {\n    var length = array.length,\n        result = 0;\n\n    while (length--) {\n      if (array[length] === placeholder) {\n        ++result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A\n   * letters to basic Latin letters.\n   *\n   * @private\n   * @param {string} letter The matched letter to deburr.\n   * @returns {string} Returns the deburred letter.\n   */\n  var deburrLetter = basePropertyOf(deburredLetters);\n\n  /**\n   * Used by `_.escape` to convert characters to HTML entities.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  var escapeHtmlChar = basePropertyOf(htmlEscapes);\n\n  /**\n   * Used by `_.template` to escape characters for inclusion in compiled string literals.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  function escapeStringChar(chr) {\n    return '\\\\' + stringEscapes[chr];\n  }\n\n  /**\n   * Gets the value at `key` of `object`.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {string} key The key of the property to get.\n   * @returns {*} Returns the property value.\n   */\n  function getValue(object, key) {\n    return object == null ? undefined : object[key];\n  }\n\n  /**\n   * Checks if `string` contains Unicode symbols.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n   */\n  function hasUnicode(string) {\n    return reHasUnicode.test(string);\n  }\n\n  /**\n   * Checks if `string` contains a word composed of Unicode symbols.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {boolean} Returns `true` if a word is found, else `false`.\n   */\n  function hasUnicodeWord(string) {\n    return reHasUnicodeWord.test(string);\n  }\n\n  /**\n   * Converts `iterator` to an array.\n   *\n   * @private\n   * @param {Object} iterator The iterator to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function iteratorToArray(iterator) {\n    var data,\n        result = [];\n\n    while (!(data = iterator.next()).done) {\n      result.push(data.value);\n    }\n    return result;\n  }\n\n  /**\n   * Converts `map` to its key-value pairs.\n   *\n   * @private\n   * @param {Object} map The map to convert.\n   * @returns {Array} Returns the key-value pairs.\n   */\n  function mapToArray(map) {\n    var index = -1,\n        result = Array(map.size);\n\n    map.forEach(function(value, key) {\n      result[++index] = [key, value];\n    });\n    return result;\n  }\n\n  /**\n   * Creates a unary function that invokes `func` with its argument transformed.\n   *\n   * @private\n   * @param {Function} func The function to wrap.\n   * @param {Function} transform The argument transform.\n   * @returns {Function} Returns the new function.\n   */\n  function overArg(func, transform) {\n    return function(arg) {\n      return func(transform(arg));\n    };\n  }\n\n  /**\n   * Replaces all `placeholder` elements in `array` with an internal placeholder\n   * and returns an array of their indexes.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {*} placeholder The placeholder to replace.\n   * @returns {Array} Returns the new array of placeholder indexes.\n   */\n  function replaceHolders(array, placeholder) {\n    var index = -1,\n        length = array.length,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (value === placeholder || value === PLACEHOLDER) {\n        array[index] = PLACEHOLDER;\n        result[resIndex++] = index;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Converts `set` to an array of its values.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the values.\n   */\n  function setToArray(set) {\n    var index = -1,\n        result = Array(set.size);\n\n    set.forEach(function(value) {\n      result[++index] = value;\n    });\n    return result;\n  }\n\n  /**\n   * Converts `set` to its value-value pairs.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the value-value pairs.\n   */\n  function setToPairs(set) {\n    var index = -1,\n        result = Array(set.size);\n\n    set.forEach(function(value) {\n      result[++index] = [value, value];\n    });\n    return result;\n  }\n\n  /**\n   * A specialized version of `_.indexOf` which performs strict equality\n   * comparisons of values, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function strictIndexOf(array, value, fromIndex) {\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * A specialized version of `_.lastIndexOf` which performs strict equality\n   * comparisons of values, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function strictLastIndexOf(array, value, fromIndex) {\n    var index = fromIndex + 1;\n    while (index--) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Gets the number of symbols in `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the string size.\n   */\n  function stringSize(string) {\n    return hasUnicode(string)\n      ? unicodeSize(string)\n      : asciiSize(string);\n  }\n\n  /**\n   * Converts `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function stringToArray(string) {\n    return hasUnicode(string)\n      ? unicodeToArray(string)\n      : asciiToArray(string);\n  }\n\n  /**\n   * Used by `_.unescape` to convert HTML entities to characters.\n   *\n   * @private\n   * @param {string} chr The matched character to unescape.\n   * @returns {string} Returns the unescaped character.\n   */\n  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);\n\n  /**\n   * Gets the size of a Unicode `string`.\n   *\n   * @private\n   * @param {string} string The string inspect.\n   * @returns {number} Returns the string size.\n   */\n  function unicodeSize(string) {\n    var result = reUnicode.lastIndex = 0;\n    while (reUnicode.test(string)) {\n      ++result;\n    }\n    return result;\n  }\n\n  /**\n   * Converts a Unicode `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function unicodeToArray(string) {\n    return string.match(reUnicode) || [];\n  }\n\n  /**\n   * Splits a Unicode `string` into an array of its words.\n   *\n   * @private\n   * @param {string} The string to inspect.\n   * @returns {Array} Returns the words of `string`.\n   */\n  function unicodeWords(string) {\n    return string.match(reUnicodeWord) || [];\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Create a new pristine `lodash` function using the `context` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 1.1.0\n   * @category Util\n   * @param {Object} [context=root] The context object.\n   * @returns {Function} Returns a new `lodash` function.\n   * @example\n   *\n   * _.mixin({ 'foo': _.constant('foo') });\n   *\n   * var lodash = _.runInContext();\n   * lodash.mixin({ 'bar': lodash.constant('bar') });\n   *\n   * _.isFunction(_.foo);\n   * // => true\n   * _.isFunction(_.bar);\n   * // => false\n   *\n   * lodash.isFunction(lodash.foo);\n   * // => false\n   * lodash.isFunction(lodash.bar);\n   * // => true\n   *\n   * // Create a suped-up `defer` in Node.js.\n   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;\n   */\n  var runInContext = (function runInContext(context) {\n    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));\n\n    /** Built-in constructor references. */\n    var Array = context.Array,\n        Date = context.Date,\n        Error = context.Error,\n        Function = context.Function,\n        Math = context.Math,\n        Object = context.Object,\n        RegExp = context.RegExp,\n        String = context.String,\n        TypeError = context.TypeError;\n\n    /** Used for built-in method references. */\n    var arrayProto = Array.prototype,\n        funcProto = Function.prototype,\n        objectProto = Object.prototype;\n\n    /** Used to detect overreaching core-js shims. */\n    var coreJsData = context['__core-js_shared__'];\n\n    /** Used to resolve the decompiled source of functions. */\n    var funcToString = funcProto.toString;\n\n    /** Used to check objects for own properties. */\n    var hasOwnProperty = objectProto.hasOwnProperty;\n\n    /** Used to generate unique IDs. */\n    var idCounter = 0;\n\n    /** Used to detect methods masquerading as native. */\n    var maskSrcKey = (function() {\n      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n      return uid ? ('Symbol(src)_1.' + uid) : '';\n    }());\n\n    /**\n     * Used to resolve the\n     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n     * of values.\n     */\n    var nativeObjectToString = objectProto.toString;\n\n    /** Used to infer the `Object` constructor. */\n    var objectCtorString = funcToString.call(Object);\n\n    /** Used to restore the original `_` reference in `_.noConflict`. */\n    var oldDash = root._;\n\n    /** Used to detect if a method is native. */\n    var reIsNative = RegExp('^' +\n      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n      .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n    );\n\n    /** Built-in value references. */\n    var Buffer = moduleExports ? context.Buffer : undefined,\n        Symbol = context.Symbol,\n        Uint8Array = context.Uint8Array,\n        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,\n        getPrototype = overArg(Object.getPrototypeOf, Object),\n        objectCreate = Object.create,\n        propertyIsEnumerable = objectProto.propertyIsEnumerable,\n        splice = arrayProto.splice,\n        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,\n        symIterator = Symbol ? Symbol.iterator : undefined,\n        symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n    var defineProperty = (function() {\n      try {\n        var func = getNative(Object, 'defineProperty');\n        func({}, '', {});\n        return func;\n      } catch (e) {}\n    }());\n\n    /** Mocked built-ins. */\n    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,\n        ctxNow = Date && Date.now !== root.Date.now && Date.now,\n        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;\n\n    /* Built-in method references for those with the same name as other `lodash` methods. */\n    var nativeCeil = Math.ceil,\n        nativeFloor = Math.floor,\n        nativeGetSymbols = Object.getOwnPropertySymbols,\n        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n        nativeIsFinite = context.isFinite,\n        nativeJoin = arrayProto.join,\n        nativeKeys = overArg(Object.keys, Object),\n        nativeMax = Math.max,\n        nativeMin = Math.min,\n        nativeNow = Date.now,\n        nativeParseInt = context.parseInt,\n        nativeRandom = Math.random,\n        nativeReverse = arrayProto.reverse;\n\n    /* Built-in method references that are verified to be native. */\n    var DataView = getNative(context, 'DataView'),\n        Map = getNative(context, 'Map'),\n        Promise = getNative(context, 'Promise'),\n        Set = getNative(context, 'Set'),\n        WeakMap = getNative(context, 'WeakMap'),\n        nativeCreate = getNative(Object, 'create');\n\n    /** Used to store function metadata. */\n    var metaMap = WeakMap && new WeakMap;\n\n    /** Used to lookup unminified function names. */\n    var realNames = {};\n\n    /** Used to detect maps, sets, and weakmaps. */\n    var dataViewCtorString = toSource(DataView),\n        mapCtorString = toSource(Map),\n        promiseCtorString = toSource(Promise),\n        setCtorString = toSource(Set),\n        weakMapCtorString = toSource(WeakMap);\n\n    /** Used to convert symbols to primitives and strings. */\n    var symbolProto = Symbol ? Symbol.prototype : undefined,\n        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n        symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object which wraps `value` to enable implicit method\n     * chain sequences. Methods that operate on and return arrays, collections,\n     * and functions can be chained together. Methods that retrieve a single value\n     * or may return a primitive value will automatically end the chain sequence\n     * and return the unwrapped value. Otherwise, the value must be unwrapped\n     * with `_#value`.\n     *\n     * Explicit chain sequences, which must be unwrapped with `_#value`, may be\n     * enabled using `_.chain`.\n     *\n     * The execution of chained methods is lazy, that is, it's deferred until\n     * `_#value` is implicitly or explicitly called.\n     *\n     * Lazy evaluation allows several methods to support shortcut fusion.\n     * Shortcut fusion is an optimization to merge iteratee calls; this avoids\n     * the creation of intermediate arrays and can greatly reduce the number of\n     * iteratee executions. Sections of a chain sequence qualify for shortcut\n     * fusion if the section is applied to an array of at least `200` elements\n     * and any iteratees accept only one argument. The heuristic for whether a\n     * section qualifies for shortcut fusion is subject to change.\n     *\n     * Chaining is supported in custom builds as long as the `_#value` method is\n     * directly or indirectly included in the build.\n     *\n     * In addition to lodash methods, wrappers have `Array` and `String` methods.\n     *\n     * The wrapper `Array` methods are:\n     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`\n     *\n     * The wrapper `String` methods are:\n     * `replace` and `split`\n     *\n     * The wrapper methods that support shortcut fusion are:\n     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,\n     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,\n     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`\n     *\n     * The chainable wrapper methods are:\n     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,\n     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,\n     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,\n     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,\n     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,\n     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,\n     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,\n     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,\n     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,\n     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,\n     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,\n     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,\n     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,\n     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,\n     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,\n     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,\n     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,\n     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,\n     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,\n     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,\n     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,\n     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,\n     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,\n     * `zipObject`, `zipObjectDeep`, and `zipWith`\n     *\n     * The wrapper methods that are **not** chainable by default are:\n     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,\n     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,\n     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,\n     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,\n     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,\n     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,\n     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,\n     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,\n     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,\n     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,\n     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,\n     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,\n     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,\n     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,\n     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,\n     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,\n     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,\n     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,\n     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,\n     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,\n     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,\n     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,\n     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,\n     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,\n     * `upperFirst`, `value`, and `words`\n     *\n     * @name _\n     * @constructor\n     * @category Seq\n     * @param {*} value The value to wrap in a `lodash` instance.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var wrapped = _([1, 2, 3]);\n     *\n     * // Returns an unwrapped value.\n     * wrapped.reduce(_.add);\n     * // => 6\n     *\n     * // Returns a wrapped value.\n     * var squares = wrapped.map(square);\n     *\n     * _.isArray(squares);\n     * // => false\n     *\n     * _.isArray(squares.value());\n     * // => true\n     */\n    function lodash(value) {\n      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {\n        if (value instanceof LodashWrapper) {\n          return value;\n        }\n        if (hasOwnProperty.call(value, '__wrapped__')) {\n          return wrapperClone(value);\n        }\n      }\n      return new LodashWrapper(value);\n    }\n\n    /**\n     * The base implementation of `_.create` without support for assigning\n     * properties to the created object.\n     *\n     * @private\n     * @param {Object} proto The object to inherit from.\n     * @returns {Object} Returns the new object.\n     */\n    var baseCreate = (function() {\n      function object() {}\n      return function(proto) {\n        if (!isObject(proto)) {\n          return {};\n        }\n        if (objectCreate) {\n          return objectCreate(proto);\n        }\n        object.prototype = proto;\n        var result = new object;\n        object.prototype = undefined;\n        return result;\n      };\n    }());\n\n    /**\n     * The function whose prototype chain sequence wrappers inherit from.\n     *\n     * @private\n     */\n    function baseLodash() {\n      // No operation performed.\n    }\n\n    /**\n     * The base constructor for creating `lodash` wrapper objects.\n     *\n     * @private\n     * @param {*} value The value to wrap.\n     * @param {boolean} [chainAll] Enable explicit method chain sequences.\n     */\n    function LodashWrapper(value, chainAll) {\n      this.__wrapped__ = value;\n      this.__actions__ = [];\n      this.__chain__ = !!chainAll;\n      this.__index__ = 0;\n      this.__values__ = undefined;\n    }\n\n    /**\n     * By default, the template delimiters used by lodash are like those in\n     * embedded Ruby (ERB). Change the following template settings to use\n     * alternative delimiters.\n     *\n     * @static\n     * @memberOf _\n     * @type {Object}\n     */\n    lodash.templateSettings = {\n\n      /**\n       * Used to detect `data` property values to be HTML-escaped.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'escape': reEscape,\n\n      /**\n       * Used to detect code to be evaluated.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'evaluate': reEvaluate,\n\n      /**\n       * Used to detect `data` property values to inject.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'interpolate': reInterpolate,\n\n      /**\n       * Used to reference the data object in the template text.\n       *\n       * @memberOf _.templateSettings\n       * @type {string}\n       */\n      'variable': '',\n\n      /**\n       * Used to import variables into the compiled template.\n       *\n       * @memberOf _.templateSettings\n       * @type {Object}\n       */\n      'imports': {\n\n        /**\n         * A reference to the `lodash` function.\n         *\n         * @memberOf _.templateSettings.imports\n         * @type {Function}\n         */\n        '_': lodash\n      }\n    };\n\n    // Ensure wrappers are instances of `baseLodash`.\n    lodash.prototype = baseLodash.prototype;\n    lodash.prototype.constructor = lodash;\n\n    LodashWrapper.prototype = baseCreate(baseLodash.prototype);\n    LodashWrapper.prototype.constructor = LodashWrapper;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.\n     *\n     * @private\n     * @constructor\n     * @param {*} value The value to wrap.\n     */\n    function LazyWrapper(value) {\n      this.__wrapped__ = value;\n      this.__actions__ = [];\n      this.__dir__ = 1;\n      this.__filtered__ = false;\n      this.__iteratees__ = [];\n      this.__takeCount__ = MAX_ARRAY_LENGTH;\n      this.__views__ = [];\n    }\n\n    /**\n     * Creates a clone of the lazy wrapper object.\n     *\n     * @private\n     * @name clone\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the cloned `LazyWrapper` object.\n     */\n    function lazyClone() {\n      var result = new LazyWrapper(this.__wrapped__);\n      result.__actions__ = copyArray(this.__actions__);\n      result.__dir__ = this.__dir__;\n      result.__filtered__ = this.__filtered__;\n      result.__iteratees__ = copyArray(this.__iteratees__);\n      result.__takeCount__ = this.__takeCount__;\n      result.__views__ = copyArray(this.__views__);\n      return result;\n    }\n\n    /**\n     * Reverses the direction of lazy iteration.\n     *\n     * @private\n     * @name reverse\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the new reversed `LazyWrapper` object.\n     */\n    function lazyReverse() {\n      if (this.__filtered__) {\n        var result = new LazyWrapper(this);\n        result.__dir__ = -1;\n        result.__filtered__ = true;\n      } else {\n        result = this.clone();\n        result.__dir__ *= -1;\n      }\n      return result;\n    }\n\n    /**\n     * Extracts the unwrapped value from its lazy wrapper.\n     *\n     * @private\n     * @name value\n     * @memberOf LazyWrapper\n     * @returns {*} Returns the unwrapped value.\n     */\n    function lazyValue() {\n      var array = this.__wrapped__.value(),\n          dir = this.__dir__,\n          isArr = isArray(array),\n          isRight = dir < 0,\n          arrLength = isArr ? array.length : 0,\n          view = getView(0, arrLength, this.__views__),\n          start = view.start,\n          end = view.end,\n          length = end - start,\n          index = isRight ? end : (start - 1),\n          iteratees = this.__iteratees__,\n          iterLength = iteratees.length,\n          resIndex = 0,\n          takeCount = nativeMin(length, this.__takeCount__);\n\n      if (!isArr || arrLength < LARGE_ARRAY_SIZE ||\n          (arrLength == length && takeCount == length)) {\n        return baseWrapperValue(array, this.__actions__);\n      }\n      var result = [];\n\n      outer:\n      while (length-- && resIndex < takeCount) {\n        index += dir;\n\n        var iterIndex = -1,\n            value = array[index];\n\n        while (++iterIndex < iterLength) {\n          var data = iteratees[iterIndex],\n              iteratee = data.iteratee,\n              type = data.type,\n              computed = iteratee(value);\n\n          if (type == LAZY_MAP_FLAG) {\n            value = computed;\n          } else if (!computed) {\n            if (type == LAZY_FILTER_FLAG) {\n              continue outer;\n            } else {\n              break outer;\n            }\n          }\n        }\n        result[resIndex++] = value;\n      }\n      return result;\n    }\n\n    // Ensure `LazyWrapper` is an instance of `baseLodash`.\n    LazyWrapper.prototype = baseCreate(baseLodash.prototype);\n    LazyWrapper.prototype.constructor = LazyWrapper;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a hash object.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function Hash(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the hash.\n     *\n     * @private\n     * @name clear\n     * @memberOf Hash\n     */\n    function hashClear() {\n      this.__data__ = nativeCreate ? nativeCreate(null) : {};\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the hash.\n     *\n     * @private\n     * @name delete\n     * @memberOf Hash\n     * @param {Object} hash The hash to modify.\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function hashDelete(key) {\n      var result = this.has(key) && delete this.__data__[key];\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n\n    /**\n     * Gets the hash value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf Hash\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function hashGet(key) {\n      var data = this.__data__;\n      if (nativeCreate) {\n        var result = data[key];\n        return result === HASH_UNDEFINED ? undefined : result;\n      }\n      return hasOwnProperty.call(data, key) ? data[key] : undefined;\n    }\n\n    /**\n     * Checks if a hash value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf Hash\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function hashHas(key) {\n      var data = this.__data__;\n      return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n    }\n\n    /**\n     * Sets the hash `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf Hash\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the hash instance.\n     */\n    function hashSet(key, value) {\n      var data = this.__data__;\n      this.size += this.has(key) ? 0 : 1;\n      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n      return this;\n    }\n\n    // Add methods to `Hash`.\n    Hash.prototype.clear = hashClear;\n    Hash.prototype['delete'] = hashDelete;\n    Hash.prototype.get = hashGet;\n    Hash.prototype.has = hashHas;\n    Hash.prototype.set = hashSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an list cache object.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function ListCache(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the list cache.\n     *\n     * @private\n     * @name clear\n     * @memberOf ListCache\n     */\n    function listCacheClear() {\n      this.__data__ = [];\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the list cache.\n     *\n     * @private\n     * @name delete\n     * @memberOf ListCache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function listCacheDelete(key) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      if (index < 0) {\n        return false;\n      }\n      var lastIndex = data.length - 1;\n      if (index == lastIndex) {\n        data.pop();\n      } else {\n        splice.call(data, index, 1);\n      }\n      --this.size;\n      return true;\n    }\n\n    /**\n     * Gets the list cache value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf ListCache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function listCacheGet(key) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      return index < 0 ? undefined : data[index][1];\n    }\n\n    /**\n     * Checks if a list cache value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf ListCache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function listCacheHas(key) {\n      return assocIndexOf(this.__data__, key) > -1;\n    }\n\n    /**\n     * Sets the list cache `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf ListCache\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the list cache instance.\n     */\n    function listCacheSet(key, value) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      if (index < 0) {\n        ++this.size;\n        data.push([key, value]);\n      } else {\n        data[index][1] = value;\n      }\n      return this;\n    }\n\n    // Add methods to `ListCache`.\n    ListCache.prototype.clear = listCacheClear;\n    ListCache.prototype['delete'] = listCacheDelete;\n    ListCache.prototype.get = listCacheGet;\n    ListCache.prototype.has = listCacheHas;\n    ListCache.prototype.set = listCacheSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a map cache object to store key-value pairs.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function MapCache(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the map.\n     *\n     * @private\n     * @name clear\n     * @memberOf MapCache\n     */\n    function mapCacheClear() {\n      this.size = 0;\n      this.__data__ = {\n        'hash': new Hash,\n        'map': new (Map || ListCache),\n        'string': new Hash\n      };\n    }\n\n    /**\n     * Removes `key` and its value from the map.\n     *\n     * @private\n     * @name delete\n     * @memberOf MapCache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function mapCacheDelete(key) {\n      var result = getMapData(this, key)['delete'](key);\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n\n    /**\n     * Gets the map value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf MapCache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function mapCacheGet(key) {\n      return getMapData(this, key).get(key);\n    }\n\n    /**\n     * Checks if a map value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf MapCache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function mapCacheHas(key) {\n      return getMapData(this, key).has(key);\n    }\n\n    /**\n     * Sets the map `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf MapCache\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the map cache instance.\n     */\n    function mapCacheSet(key, value) {\n      var data = getMapData(this, key),\n          size = data.size;\n\n      data.set(key, value);\n      this.size += data.size == size ? 0 : 1;\n      return this;\n    }\n\n    // Add methods to `MapCache`.\n    MapCache.prototype.clear = mapCacheClear;\n    MapCache.prototype['delete'] = mapCacheDelete;\n    MapCache.prototype.get = mapCacheGet;\n    MapCache.prototype.has = mapCacheHas;\n    MapCache.prototype.set = mapCacheSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     *\n     * Creates an array cache object to store unique values.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [values] The values to cache.\n     */\n    function SetCache(values) {\n      var index = -1,\n          length = values == null ? 0 : values.length;\n\n      this.__data__ = new MapCache;\n      while (++index < length) {\n        this.add(values[index]);\n      }\n    }\n\n    /**\n     * Adds `value` to the array cache.\n     *\n     * @private\n     * @name add\n     * @memberOf SetCache\n     * @alias push\n     * @param {*} value The value to cache.\n     * @returns {Object} Returns the cache instance.\n     */\n    function setCacheAdd(value) {\n      this.__data__.set(value, HASH_UNDEFINED);\n      return this;\n    }\n\n    /**\n     * Checks if `value` is in the array cache.\n     *\n     * @private\n     * @name has\n     * @memberOf SetCache\n     * @param {*} value The value to search for.\n     * @returns {number} Returns `true` if `value` is found, else `false`.\n     */\n    function setCacheHas(value) {\n      return this.__data__.has(value);\n    }\n\n    // Add methods to `SetCache`.\n    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\n    SetCache.prototype.has = setCacheHas;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a stack cache object to store key-value pairs.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function Stack(entries) {\n      var data = this.__data__ = new ListCache(entries);\n      this.size = data.size;\n    }\n\n    /**\n     * Removes all key-value entries from the stack.\n     *\n     * @private\n     * @name clear\n     * @memberOf Stack\n     */\n    function stackClear() {\n      this.__data__ = new ListCache;\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the stack.\n     *\n     * @private\n     * @name delete\n     * @memberOf Stack\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function stackDelete(key) {\n      var data = this.__data__,\n          result = data['delete'](key);\n\n      this.size = data.size;\n      return result;\n    }\n\n    /**\n     * Gets the stack value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf Stack\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function stackGet(key) {\n      return this.__data__.get(key);\n    }\n\n    /**\n     * Checks if a stack value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf Stack\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function stackHas(key) {\n      return this.__data__.has(key);\n    }\n\n    /**\n     * Sets the stack `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf Stack\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the stack cache instance.\n     */\n    function stackSet(key, value) {\n      var data = this.__data__;\n      if (data instanceof ListCache) {\n        var pairs = data.__data__;\n        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n          pairs.push([key, value]);\n          this.size = ++data.size;\n          return this;\n        }\n        data = this.__data__ = new MapCache(pairs);\n      }\n      data.set(key, value);\n      this.size = data.size;\n      return this;\n    }\n\n    // Add methods to `Stack`.\n    Stack.prototype.clear = stackClear;\n    Stack.prototype['delete'] = stackDelete;\n    Stack.prototype.get = stackGet;\n    Stack.prototype.has = stackHas;\n    Stack.prototype.set = stackSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of the enumerable property names of the array-like `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @param {boolean} inherited Specify returning inherited property names.\n     * @returns {Array} Returns the array of property names.\n     */\n    function arrayLikeKeys(value, inherited) {\n      var isArr = isArray(value),\n          isArg = !isArr && isArguments(value),\n          isBuff = !isArr && !isArg && isBuffer(value),\n          isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n          skipIndexes = isArr || isArg || isBuff || isType,\n          result = skipIndexes ? baseTimes(value.length, String) : [],\n          length = result.length;\n\n      for (var key in value) {\n        if ((inherited || hasOwnProperty.call(value, key)) &&\n            !(skipIndexes && (\n               // Safari 9 has enumerable `arguments.length` in strict mode.\n               key == 'length' ||\n               // Node.js 0.10 has enumerable non-index properties on buffers.\n               (isBuff && (key == 'offset' || key == 'parent')) ||\n               // PhantomJS 2 has enumerable non-index properties on typed arrays.\n               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n               // Skip index properties.\n               isIndex(key, length)\n            ))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `_.sample` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to sample.\n     * @returns {*} Returns the random element.\n     */\n    function arraySample(array) {\n      var length = array.length;\n      return length ? array[baseRandom(0, length - 1)] : undefined;\n    }\n\n    /**\n     * A specialized version of `_.sampleSize` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to sample.\n     * @param {number} n The number of elements to sample.\n     * @returns {Array} Returns the random elements.\n     */\n    function arraySampleSize(array, n) {\n      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));\n    }\n\n    /**\n     * A specialized version of `_.shuffle` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     */\n    function arrayShuffle(array) {\n      return shuffleSelf(copyArray(array));\n    }\n\n    /**\n     * Used by `_.defaults` to customize its `_.assignIn` use.\n     *\n     * @private\n     * @param {*} objValue The destination value.\n     * @param {*} srcValue The source value.\n     * @param {string} key The key of the property to assign.\n     * @param {Object} object The parent object of `objValue`.\n     * @returns {*} Returns the value to assign.\n     */\n    function assignInDefaults(objValue, srcValue, key, object) {\n      if (objValue === undefined ||\n          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n        return srcValue;\n      }\n      return objValue;\n    }\n\n    /**\n     * This function is like `assignValue` except that it doesn't assign\n     * `undefined` values.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function assignMergeValue(object, key, value) {\n      if ((value !== undefined && !eq(object[key], value)) ||\n          (value === undefined && !(key in object))) {\n        baseAssignValue(object, key, value);\n      }\n    }\n\n    /**\n     * Assigns `value` to `key` of `object` if the existing value is not equivalent\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function assignValue(object, key, value) {\n      var objValue = object[key];\n      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n          (value === undefined && !(key in object))) {\n        baseAssignValue(object, key, value);\n      }\n    }\n\n    /**\n     * Gets the index at which the `key` is found in `array` of key-value pairs.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {*} key The key to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     */\n    function assocIndexOf(array, key) {\n      var length = array.length;\n      while (length--) {\n        if (eq(array[length][0], key)) {\n          return length;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Aggregates elements of `collection` on `accumulator` with keys transformed\n     * by `iteratee` and values set by `setter`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} setter The function to set `accumulator` values.\n     * @param {Function} iteratee The iteratee to transform keys.\n     * @param {Object} accumulator The initial aggregated object.\n     * @returns {Function} Returns `accumulator`.\n     */\n    function baseAggregator(collection, setter, iteratee, accumulator) {\n      baseEach(collection, function(value, key, collection) {\n        setter(accumulator, value, iteratee(value), collection);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The base implementation of `_.assign` without support for multiple sources\n     * or `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */\n    function baseAssign(object, source) {\n      return object && copyObject(source, keys(source), object);\n    }\n\n    /**\n     * The base implementation of `_.assignIn` without support for multiple sources\n     * or `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */\n    function baseAssignIn(object, source) {\n      return object && copyObject(source, keysIn(source), object);\n    }\n\n    /**\n     * The base implementation of `assignValue` and `assignMergeValue` without\n     * value checks.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function baseAssignValue(object, key, value) {\n      if (key == '__proto__' && defineProperty) {\n        defineProperty(object, key, {\n          'configurable': true,\n          'enumerable': true,\n          'value': value,\n          'writable': true\n        });\n      } else {\n        object[key] = value;\n      }\n    }\n\n    /**\n     * The base implementation of `_.at` without support for individual paths.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {string[]} paths The property paths to pick.\n     * @returns {Array} Returns the picked elements.\n     */\n    function baseAt(object, paths) {\n      var index = -1,\n          length = paths.length,\n          result = Array(length),\n          skip = object == null;\n\n      while (++index < length) {\n        result[index] = skip ? undefined : get(object, paths[index]);\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.clamp` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {number} number The number to clamp.\n     * @param {number} [lower] The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the clamped number.\n     */\n    function baseClamp(number, lower, upper) {\n      if (number === number) {\n        if (upper !== undefined) {\n          number = number <= upper ? number : upper;\n        }\n        if (lower !== undefined) {\n          number = number >= lower ? number : lower;\n        }\n      }\n      return number;\n    }\n\n    /**\n     * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n     * traversed objects.\n     *\n     * @private\n     * @param {*} value The value to clone.\n     * @param {boolean} bitmask The bitmask flags.\n     *  1 - Deep clone\n     *  2 - Flatten inherited properties\n     *  4 - Clone symbols\n     * @param {Function} [customizer] The function to customize cloning.\n     * @param {string} [key] The key of `value`.\n     * @param {Object} [object] The parent object of `value`.\n     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n     * @returns {*} Returns the cloned value.\n     */\n    function baseClone(value, bitmask, customizer, key, object, stack) {\n      var result,\n          isDeep = bitmask & CLONE_DEEP_FLAG,\n          isFlat = bitmask & CLONE_FLAT_FLAG,\n          isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n      if (customizer) {\n        result = object ? customizer(value, key, object, stack) : customizer(value);\n      }\n      if (result !== undefined) {\n        return result;\n      }\n      if (!isObject(value)) {\n        return value;\n      }\n      var isArr = isArray(value);\n      if (isArr) {\n        result = initCloneArray(value);\n        if (!isDeep) {\n          return copyArray(value, result);\n        }\n      } else {\n        var tag = getTag(value),\n            isFunc = tag == funcTag || tag == genTag;\n\n        if (isBuffer(value)) {\n          return cloneBuffer(value, isDeep);\n        }\n        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n          result = (isFlat || isFunc) ? {} : initCloneObject(value);\n          if (!isDeep) {\n            return isFlat\n              ? copySymbolsIn(value, baseAssignIn(result, value))\n              : copySymbols(value, baseAssign(result, value));\n          }\n        } else {\n          if (!cloneableTags[tag]) {\n            return object ? value : {};\n          }\n          result = initCloneByTag(value, tag, baseClone, isDeep);\n        }\n      }\n      // Check for circular references and return its corresponding clone.\n      stack || (stack = new Stack);\n      var stacked = stack.get(value);\n      if (stacked) {\n        return stacked;\n      }\n      stack.set(value, result);\n\n      var keysFunc = isFull\n        ? (isFlat ? getAllKeysIn : getAllKeys)\n        : (isFlat ? keysIn : keys);\n\n      var props = isArr ? undefined : keysFunc(value);\n      arrayEach(props || value, function(subValue, key) {\n        if (props) {\n          key = subValue;\n          subValue = value[key];\n        }\n        // Recursively populate clone (susceptible to call stack limits).\n        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.conforms` which doesn't clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseConforms(source) {\n      var props = keys(source);\n      return function(object) {\n        return baseConformsTo(object, source, props);\n      };\n    }\n\n    /**\n     * The base implementation of `_.conformsTo` which accepts `props` to check.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n     */\n    function baseConformsTo(object, source, props) {\n      var length = props.length;\n      if (object == null) {\n        return !length;\n      }\n      object = Object(object);\n      while (length--) {\n        var key = props[length],\n            predicate = source[key],\n            value = object[key];\n\n        if ((value === undefined && !(key in object)) || !predicate(value)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * The base implementation of `_.delay` and `_.defer` which accepts `args`\n     * to provide to `func`.\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {Array} args The arguments to provide to `func`.\n     * @returns {number|Object} Returns the timer id or timeout object.\n     */\n    function baseDelay(func, wait, args) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return setTimeout(function() { func.apply(undefined, args); }, wait);\n    }\n\n    /**\n     * The base implementation of methods like `_.difference` without support\n     * for excluding multiple arrays or iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Array} values The values to exclude.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     */\n    function baseDifference(array, values, iteratee, comparator) {\n      var index = -1,\n          includes = arrayIncludes,\n          isCommon = true,\n          length = array.length,\n          result = [],\n          valuesLength = values.length;\n\n      if (!length) {\n        return result;\n      }\n      if (iteratee) {\n        values = arrayMap(values, baseUnary(iteratee));\n      }\n      if (comparator) {\n        includes = arrayIncludesWith;\n        isCommon = false;\n      }\n      else if (values.length >= LARGE_ARRAY_SIZE) {\n        includes = cacheHas;\n        isCommon = false;\n        values = new SetCache(values);\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee == null ? value : iteratee(value);\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n          var valuesIndex = valuesLength;\n          while (valuesIndex--) {\n            if (values[valuesIndex] === computed) {\n              continue outer;\n            }\n          }\n          result.push(value);\n        }\n        else if (!includes(values, computed, comparator)) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.forEach` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     */\n    var baseEach = createBaseEach(baseForOwn);\n\n    /**\n     * The base implementation of `_.forEachRight` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     */\n    var baseEachRight = createBaseEach(baseForOwnRight, true);\n\n    /**\n     * The base implementation of `_.every` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`\n     */\n    function baseEvery(collection, predicate) {\n      var result = true;\n      baseEach(collection, function(value, index, collection) {\n        result = !!predicate(value, index, collection);\n        return result;\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of methods like `_.max` and `_.min` which accepts a\n     * `comparator` to determine the extremum value.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The iteratee invoked per iteration.\n     * @param {Function} comparator The comparator used to compare values.\n     * @returns {*} Returns the extremum value.\n     */\n    function baseExtremum(array, iteratee, comparator) {\n      var index = -1,\n          length = array.length;\n\n      while (++index < length) {\n        var value = array[index],\n            current = iteratee(value);\n\n        if (current != null && (computed === undefined\n              ? (current === current && !isSymbol(current))\n              : comparator(current, computed)\n            )) {\n          var computed = current,\n              result = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.fill` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     */\n    function baseFill(array, value, start, end) {\n      var length = array.length;\n\n      start = toInteger(start);\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = (end === undefined || end > length) ? length : toInteger(end);\n      if (end < 0) {\n        end += length;\n      }\n      end = start > end ? 0 : toLength(end);\n      while (start < end) {\n        array[start++] = value;\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.filter` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     */\n    function baseFilter(collection, predicate) {\n      var result = [];\n      baseEach(collection, function(value, index, collection) {\n        if (predicate(value, index, collection)) {\n          result.push(value);\n        }\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.flatten` with support for restricting flattening.\n     *\n     * @private\n     * @param {Array} array The array to flatten.\n     * @param {number} depth The maximum recursion depth.\n     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n     * @param {Array} [result=[]] The initial result value.\n     * @returns {Array} Returns the new flattened array.\n     */\n    function baseFlatten(array, depth, predicate, isStrict, result) {\n      var index = -1,\n          length = array.length;\n\n      predicate || (predicate = isFlattenable);\n      result || (result = []);\n\n      while (++index < length) {\n        var value = array[index];\n        if (depth > 0 && predicate(value)) {\n          if (depth > 1) {\n            // Recursively flatten arrays (susceptible to call stack limits).\n            baseFlatten(value, depth - 1, predicate, isStrict, result);\n          } else {\n            arrayPush(result, value);\n          }\n        } else if (!isStrict) {\n          result[result.length] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `baseForOwn` which iterates over `object`\n     * properties returned by `keysFunc` and invokes `iteratee` for each property.\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseFor = createBaseFor();\n\n    /**\n     * This function is like `baseFor` except that it iterates over properties\n     * in the opposite order.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseForRight = createBaseFor(true);\n\n    /**\n     * The base implementation of `_.forOwn` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwn(object, iteratee) {\n      return object && baseFor(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwnRight(object, iteratee) {\n      return object && baseForRight(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.functions` which creates an array of\n     * `object` function property names filtered from `props`.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Array} props The property names to filter.\n     * @returns {Array} Returns the function names.\n     */\n    function baseFunctions(object, props) {\n      return arrayFilter(props, function(key) {\n        return isFunction(object[key]);\n      });\n    }\n\n    /**\n     * The base implementation of `_.get` without support for default values.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseGet(object, path) {\n      path = castPath(path, object);\n\n      var index = 0,\n          length = path.length;\n\n      while (object != null && index < length) {\n        object = object[toKey(path[index++])];\n      }\n      return (index && index == length) ? object : undefined;\n    }\n\n    /**\n     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n     * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n     * symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @param {Function} symbolsFunc The function to get the symbols of `object`.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function baseGetAllKeys(object, keysFunc, symbolsFunc) {\n      var result = keysFunc(object);\n      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n    }\n\n    /**\n     * The base implementation of `getTag` without fallbacks for buggy environments.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */\n    function baseGetTag(value) {\n      if (value == null) {\n        return value === undefined ? undefinedTag : nullTag;\n      }\n      value = Object(value);\n      return (symToStringTag && symToStringTag in value)\n        ? getRawTag(value)\n        : objectToString(value);\n    }\n\n    /**\n     * The base implementation of `_.gt` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than `other`,\n     *  else `false`.\n     */\n    function baseGt(value, other) {\n      return value > other;\n    }\n\n    /**\n     * The base implementation of `_.has` without support for deep paths.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {Array|string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n     */\n    function baseHas(object, key) {\n      return object != null && hasOwnProperty.call(object, key);\n    }\n\n    /**\n     * The base implementation of `_.hasIn` without support for deep paths.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {Array|string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n     */\n    function baseHasIn(object, key) {\n      return object != null && key in Object(object);\n    }\n\n    /**\n     * The base implementation of `_.inRange` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {number} number The number to check.\n     * @param {number} start The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n     */\n    function baseInRange(number, start, end) {\n      return number >= nativeMin(start, end) && number < nativeMax(start, end);\n    }\n\n    /**\n     * The base implementation of methods like `_.intersection`, without support\n     * for iteratee shorthands, that accepts an array of arrays to inspect.\n     *\n     * @private\n     * @param {Array} arrays The arrays to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of shared values.\n     */\n    function baseIntersection(arrays, iteratee, comparator) {\n      var includes = comparator ? arrayIncludesWith : arrayIncludes,\n          length = arrays[0].length,\n          othLength = arrays.length,\n          othIndex = othLength,\n          caches = Array(othLength),\n          maxLength = Infinity,\n          result = [];\n\n      while (othIndex--) {\n        var array = arrays[othIndex];\n        if (othIndex && iteratee) {\n          array = arrayMap(array, baseUnary(iteratee));\n        }\n        maxLength = nativeMin(array.length, maxLength);\n        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))\n          ? new SetCache(othIndex && array)\n          : undefined;\n      }\n      array = arrays[0];\n\n      var index = -1,\n          seen = caches[0];\n\n      outer:\n      while (++index < length && result.length < maxLength) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (!(seen\n              ? cacheHas(seen, computed)\n              : includes(result, computed, comparator)\n            )) {\n          othIndex = othLength;\n          while (--othIndex) {\n            var cache = caches[othIndex];\n            if (!(cache\n                  ? cacheHas(cache, computed)\n                  : includes(arrays[othIndex], computed, comparator))\n                ) {\n              continue outer;\n            }\n          }\n          if (seen) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.invert` and `_.invertBy` which inverts\n     * `object` with values transformed by `iteratee` and set by `setter`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} setter The function to set `accumulator` values.\n     * @param {Function} iteratee The iteratee to transform values.\n     * @param {Object} accumulator The initial inverted object.\n     * @returns {Function} Returns `accumulator`.\n     */\n    function baseInverter(object, setter, iteratee, accumulator) {\n      baseForOwn(object, function(value, key, object) {\n        setter(accumulator, iteratee(value), key, object);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The base implementation of `_.invoke` without support for individual\n     * method arguments.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {Array} args The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     */\n    function baseInvoke(object, path, args) {\n      path = castPath(path, object);\n      object = parent(object, path);\n      var func = object == null ? object : object[toKey(last(path))];\n      return func == null ? undefined : apply(func, object, args);\n    }\n\n    /**\n     * The base implementation of `_.isArguments`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n     */\n    function baseIsArguments(value) {\n      return isObjectLike(value) && baseGetTag(value) == argsTag;\n    }\n\n    /**\n     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n     */\n    function baseIsArrayBuffer(value) {\n      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;\n    }\n\n    /**\n     * The base implementation of `_.isDate` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n     */\n    function baseIsDate(value) {\n      return isObjectLike(value) && baseGetTag(value) == dateTag;\n    }\n\n    /**\n     * The base implementation of `_.isEqual` which supports partial comparisons\n     * and tracks traversed objects.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {boolean} bitmask The bitmask flags.\n     *  1 - Unordered comparison\n     *  2 - Partial comparison\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     */\n    function baseIsEqual(value, other, bitmask, customizer, stack) {\n      if (value === other) {\n        return true;\n      }\n      if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {\n        return value !== value && other !== other;\n      }\n      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n    }\n\n    /**\n     * A specialized version of `baseIsEqual` for arrays and objects which performs\n     * deep comparisons and tracks traversed objects enabling objects with circular\n     * references to be compared.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n      var objIsArr = isArray(object),\n          othIsArr = isArray(other),\n          objTag = arrayTag,\n          othTag = arrayTag;\n\n      if (!objIsArr) {\n        objTag = getTag(object);\n        objTag = objTag == argsTag ? objectTag : objTag;\n      }\n      if (!othIsArr) {\n        othTag = getTag(other);\n        othTag = othTag == argsTag ? objectTag : othTag;\n      }\n      var objIsObj = objTag == objectTag,\n          othIsObj = othTag == objectTag,\n          isSameTag = objTag == othTag;\n\n      if (isSameTag && isBuffer(object)) {\n        if (!isBuffer(other)) {\n          return false;\n        }\n        objIsArr = true;\n        objIsObj = false;\n      }\n      if (isSameTag && !objIsObj) {\n        stack || (stack = new Stack);\n        return (objIsArr || isTypedArray(object))\n          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n      }\n      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n        if (objIsWrapped || othIsWrapped) {\n          var objUnwrapped = objIsWrapped ? object.value() : object,\n              othUnwrapped = othIsWrapped ? other.value() : other;\n\n          stack || (stack = new Stack);\n          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n        }\n      }\n      if (!isSameTag) {\n        return false;\n      }\n      stack || (stack = new Stack);\n      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n    }\n\n    /**\n     * The base implementation of `_.isMap` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n     */\n    function baseIsMap(value) {\n      return isObjectLike(value) && getTag(value) == mapTag;\n    }\n\n    /**\n     * The base implementation of `_.isMatch` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Array} matchData The property names, values, and compare flags to match.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     */\n    function baseIsMatch(object, source, matchData, customizer) {\n      var index = matchData.length,\n          length = index,\n          noCustomizer = !customizer;\n\n      if (object == null) {\n        return !length;\n      }\n      object = Object(object);\n      while (index--) {\n        var data = matchData[index];\n        if ((noCustomizer && data[2])\n              ? data[1] !== object[data[0]]\n              : !(data[0] in object)\n            ) {\n          return false;\n        }\n      }\n      while (++index < length) {\n        data = matchData[index];\n        var key = data[0],\n            objValue = object[key],\n            srcValue = data[1];\n\n        if (noCustomizer && data[2]) {\n          if (objValue === undefined && !(key in object)) {\n            return false;\n          }\n        } else {\n          var stack = new Stack;\n          if (customizer) {\n            var result = customizer(objValue, srcValue, key, object, source, stack);\n          }\n          if (!(result === undefined\n                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n                : result\n              )) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n\n    /**\n     * The base implementation of `_.isNative` without bad shim checks.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function,\n     *  else `false`.\n     */\n    function baseIsNative(value) {\n      if (!isObject(value) || isMasked(value)) {\n        return false;\n      }\n      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n      return pattern.test(toSource(value));\n    }\n\n    /**\n     * The base implementation of `_.isRegExp` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n     */\n    function baseIsRegExp(value) {\n      return isObjectLike(value) && baseGetTag(value) == regexpTag;\n    }\n\n    /**\n     * The base implementation of `_.isSet` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n     */\n    function baseIsSet(value) {\n      return isObjectLike(value) && getTag(value) == setTag;\n    }\n\n    /**\n     * The base implementation of `_.isTypedArray` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n     */\n    function baseIsTypedArray(value) {\n      return isObjectLike(value) &&\n        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n    }\n\n    /**\n     * The base implementation of `_.iteratee`.\n     *\n     * @private\n     * @param {*} [value=_.identity] The value to convert to an iteratee.\n     * @returns {Function} Returns the iteratee.\n     */\n    function baseIteratee(value) {\n      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n      if (typeof value == 'function') {\n        return value;\n      }\n      if (value == null) {\n        return identity;\n      }\n      if (typeof value == 'object') {\n        return isArray(value)\n          ? baseMatchesProperty(value[0], value[1])\n          : baseMatches(value);\n      }\n      return property(value);\n    }\n\n    /**\n     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function baseKeys(object) {\n      if (!isPrototype(object)) {\n        return nativeKeys(object);\n      }\n      var result = [];\n      for (var key in Object(object)) {\n        if (hasOwnProperty.call(object, key) && key != 'constructor') {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function baseKeysIn(object) {\n      if (!isObject(object)) {\n        return nativeKeysIn(object);\n      }\n      var isProto = isPrototype(object),\n          result = [];\n\n      for (var key in object) {\n        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.lt` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than `other`,\n     *  else `false`.\n     */\n    function baseLt(value, other) {\n      return value < other;\n    }\n\n    /**\n     * The base implementation of `_.map` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     */\n    function baseMap(collection, iteratee) {\n      var index = -1,\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value, key, collection) {\n        result[++index] = iteratee(value, key, collection);\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.matches` which doesn't clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseMatches(source) {\n      var matchData = getMatchData(source);\n      if (matchData.length == 1 && matchData[0][2]) {\n        return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n      }\n      return function(object) {\n        return object === source || baseIsMatch(object, source, matchData);\n      };\n    }\n\n    /**\n     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n     *\n     * @private\n     * @param {string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseMatchesProperty(path, srcValue) {\n      if (isKey(path) && isStrictComparable(srcValue)) {\n        return matchesStrictComparable(toKey(path), srcValue);\n      }\n      return function(object) {\n        var objValue = get(object, path);\n        return (objValue === undefined && objValue === srcValue)\n          ? hasIn(object, path)\n          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n      };\n    }\n\n    /**\n     * The base implementation of `_.merge` without support for multiple sources.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {number} srcIndex The index of `source`.\n     * @param {Function} [customizer] The function to customize merged values.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     */\n    function baseMerge(object, source, srcIndex, customizer, stack) {\n      if (object === source) {\n        return;\n      }\n      baseFor(source, function(srcValue, key) {\n        if (isObject(srcValue)) {\n          stack || (stack = new Stack);\n          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n        }\n        else {\n          var newValue = customizer\n            ? customizer(object[key], srcValue, (key + ''), object, source, stack)\n            : undefined;\n\n          if (newValue === undefined) {\n            newValue = srcValue;\n          }\n          assignMergeValue(object, key, newValue);\n        }\n      }, keysIn);\n    }\n\n    /**\n     * A specialized version of `baseMerge` for arrays and objects which performs\n     * deep merges and tracks traversed objects enabling objects with circular\n     * references to be merged.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {string} key The key of the value to merge.\n     * @param {number} srcIndex The index of `source`.\n     * @param {Function} mergeFunc The function to merge values.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     */\n    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n      var objValue = object[key],\n          srcValue = source[key],\n          stacked = stack.get(srcValue);\n\n      if (stacked) {\n        assignMergeValue(object, key, stacked);\n        return;\n      }\n      var newValue = customizer\n        ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n        : undefined;\n\n      var isCommon = newValue === undefined;\n\n      if (isCommon) {\n        var isArr = isArray(srcValue),\n            isBuff = !isArr && isBuffer(srcValue),\n            isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n\n        newValue = srcValue;\n        if (isArr || isBuff || isTyped) {\n          if (isArray(objValue)) {\n            newValue = objValue;\n          }\n          else if (isArrayLikeObject(objValue)) {\n            newValue = copyArray(objValue);\n          }\n          else if (isBuff) {\n            isCommon = false;\n            newValue = cloneBuffer(srcValue, true);\n          }\n          else if (isTyped) {\n            isCommon = false;\n            newValue = cloneTypedArray(srcValue, true);\n          }\n          else {\n            newValue = [];\n          }\n        }\n        else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n          newValue = objValue;\n          if (isArguments(objValue)) {\n            newValue = toPlainObject(objValue);\n          }\n          else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {\n            newValue = initCloneObject(srcValue);\n          }\n        }\n        else {\n          isCommon = false;\n        }\n      }\n      if (isCommon) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, newValue);\n        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n        stack['delete'](srcValue);\n      }\n      assignMergeValue(object, key, newValue);\n    }\n\n    /**\n     * The base implementation of `_.nth` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {number} n The index of the element to return.\n     * @returns {*} Returns the nth element of `array`.\n     */\n    function baseNth(array, n) {\n      var length = array.length;\n      if (!length) {\n        return;\n      }\n      n += n < 0 ? length : 0;\n      return isIndex(n, length) ? array[n] : undefined;\n    }\n\n    /**\n     * The base implementation of `_.orderBy` without param guards.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n     * @param {string[]} orders The sort orders of `iteratees`.\n     * @returns {Array} Returns the new sorted array.\n     */\n    function baseOrderBy(collection, iteratees, orders) {\n      var index = -1;\n      iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));\n\n      var result = baseMap(collection, function(value, key, collection) {\n        var criteria = arrayMap(iteratees, function(iteratee) {\n          return iteratee(value);\n        });\n        return { 'criteria': criteria, 'index': ++index, 'value': value };\n      });\n\n      return baseSortBy(result, function(object, other) {\n        return compareMultiple(object, other, orders);\n      });\n    }\n\n    /**\n     * The base implementation of `_.pick` without support for individual\n     * property identifiers.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} paths The property paths to pick.\n     * @returns {Object} Returns the new object.\n     */\n    function basePick(object, paths) {\n      object = Object(object);\n      return basePickBy(object, paths, function(value, path) {\n        return hasIn(object, path);\n      });\n    }\n\n    /**\n     * The base implementation of  `_.pickBy` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} paths The property paths to pick.\n     * @param {Function} predicate The function invoked per property.\n     * @returns {Object} Returns the new object.\n     */\n    function basePickBy(object, paths, predicate) {\n      var index = -1,\n          length = paths.length,\n          result = {};\n\n      while (++index < length) {\n        var path = paths[index],\n            value = baseGet(object, path);\n\n        if (predicate(value, path)) {\n          baseSet(result, castPath(path, object), value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseProperty` which supports deep paths.\n     *\n     * @private\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     */\n    function basePropertyDeep(path) {\n      return function(object) {\n        return baseGet(object, path);\n      };\n    }\n\n    /**\n     * The base implementation of `_.pullAllBy` without support for iteratee\n     * shorthands.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAll(array, values, iteratee, comparator) {\n      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,\n          index = -1,\n          length = values.length,\n          seen = array;\n\n      if (array === values) {\n        values = copyArray(values);\n      }\n      if (iteratee) {\n        seen = arrayMap(array, baseUnary(iteratee));\n      }\n      while (++index < length) {\n        var fromIndex = 0,\n            value = values[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {\n          if (seen !== array) {\n            splice.call(seen, fromIndex, 1);\n          }\n          splice.call(array, fromIndex, 1);\n        }\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.pullAt` without support for individual\n     * indexes or capturing the removed elements.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {number[]} indexes The indexes of elements to remove.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAt(array, indexes) {\n      var length = array ? indexes.length : 0,\n          lastIndex = length - 1;\n\n      while (length--) {\n        var index = indexes[length];\n        if (length == lastIndex || index !== previous) {\n          var previous = index;\n          if (isIndex(index)) {\n            splice.call(array, index, 1);\n          } else {\n            baseUnset(array, index);\n          }\n        }\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.random` without support for returning\n     * floating-point numbers.\n     *\n     * @private\n     * @param {number} lower The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the random number.\n     */\n    function baseRandom(lower, upper) {\n      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));\n    }\n\n    /**\n     * The base implementation of `_.range` and `_.rangeRight` which doesn't\n     * coerce arguments.\n     *\n     * @private\n     * @param {number} start The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} step The value to increment or decrement by.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the range of numbers.\n     */\n    function baseRange(start, end, step, fromRight) {\n      var index = -1,\n          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n          result = Array(length);\n\n      while (length--) {\n        result[fromRight ? length : ++index] = start;\n        start += step;\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.repeat` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {string} string The string to repeat.\n     * @param {number} n The number of times to repeat the string.\n     * @returns {string} Returns the repeated string.\n     */\n    function baseRepeat(string, n) {\n      var result = '';\n      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {\n        return result;\n      }\n      // Leverage the exponentiation by squaring algorithm for a faster repeat.\n      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.\n      do {\n        if (n % 2) {\n          result += string;\n        }\n        n = nativeFloor(n / 2);\n        if (n) {\n          string += string;\n        }\n      } while (n);\n\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     */\n    function baseRest(func, start) {\n      return setToString(overRest(func, start, identity), func + '');\n    }\n\n    /**\n     * The base implementation of `_.sample`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to sample.\n     * @returns {*} Returns the random element.\n     */\n    function baseSample(collection) {\n      return arraySample(values(collection));\n    }\n\n    /**\n     * The base implementation of `_.sampleSize` without param guards.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to sample.\n     * @param {number} n The number of elements to sample.\n     * @returns {Array} Returns the random elements.\n     */\n    function baseSampleSize(collection, n) {\n      var array = values(collection);\n      return shuffleSelf(array, baseClamp(n, 0, array.length));\n    }\n\n    /**\n     * The base implementation of `_.set`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @param {Function} [customizer] The function to customize path creation.\n     * @returns {Object} Returns `object`.\n     */\n    function baseSet(object, path, value, customizer) {\n      if (!isObject(object)) {\n        return object;\n      }\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length,\n          lastIndex = length - 1,\n          nested = object;\n\n      while (nested != null && ++index < length) {\n        var key = toKey(path[index]),\n            newValue = value;\n\n        if (index != lastIndex) {\n          var objValue = nested[key];\n          newValue = customizer ? customizer(objValue, key, nested) : undefined;\n          if (newValue === undefined) {\n            newValue = isObject(objValue)\n              ? objValue\n              : (isIndex(path[index + 1]) ? [] : {});\n          }\n        }\n        assignValue(nested, key, newValue);\n        nested = nested[key];\n      }\n      return object;\n    }\n\n    /**\n     * The base implementation of `setData` without support for hot loop shorting.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var baseSetData = !metaMap ? identity : function(func, data) {\n      metaMap.set(func, data);\n      return func;\n    };\n\n    /**\n     * The base implementation of `setToString` without support for hot loop shorting.\n     *\n     * @private\n     * @param {Function} func The function to modify.\n     * @param {Function} string The `toString` result.\n     * @returns {Function} Returns `func`.\n     */\n    var baseSetToString = !defineProperty ? identity : function(func, string) {\n      return defineProperty(func, 'toString', {\n        'configurable': true,\n        'enumerable': false,\n        'value': constant(string),\n        'writable': true\n      });\n    };\n\n    /**\n     * The base implementation of `_.shuffle`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     */\n    function baseShuffle(collection) {\n      return shuffleSelf(values(collection));\n    }\n\n    /**\n     * The base implementation of `_.slice` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseSlice(array, start, end) {\n      var index = -1,\n          length = array.length;\n\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = end > length ? length : end;\n      if (end < 0) {\n        end += length;\n      }\n      length = start > end ? 0 : ((end - start) >>> 0);\n      start >>>= 0;\n\n      var result = Array(length);\n      while (++index < length) {\n        result[index] = array[index + start];\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.some` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     */\n    function baseSome(collection, predicate) {\n      var result;\n\n      baseEach(collection, function(value, index, collection) {\n        result = predicate(value, index, collection);\n        return !result;\n      });\n      return !!result;\n    }\n\n    /**\n     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which\n     * performs a binary search of `array` to determine the index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function baseSortedIndex(array, value, retHighest) {\n      var low = 0,\n          high = array == null ? low : array.length;\n\n      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\n        while (low < high) {\n          var mid = (low + high) >>> 1,\n              computed = array[mid];\n\n          if (computed !== null && !isSymbol(computed) &&\n              (retHighest ? (computed <= value) : (computed < value))) {\n            low = mid + 1;\n          } else {\n            high = mid;\n          }\n        }\n        return high;\n      }\n      return baseSortedIndexBy(array, value, identity, retHighest);\n    }\n\n    /**\n     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`\n     * which invokes `iteratee` for `value` and each element of `array` to compute\n     * their sort ranking. The iteratee is invoked with one argument; (value).\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} iteratee The iteratee invoked per element.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function baseSortedIndexBy(array, value, iteratee, retHighest) {\n      value = iteratee(value);\n\n      var low = 0,\n          high = array == null ? 0 : array.length,\n          valIsNaN = value !== value,\n          valIsNull = value === null,\n          valIsSymbol = isSymbol(value),\n          valIsUndefined = value === undefined;\n\n      while (low < high) {\n        var mid = nativeFloor((low + high) / 2),\n            computed = iteratee(array[mid]),\n            othIsDefined = computed !== undefined,\n            othIsNull = computed === null,\n            othIsReflexive = computed === computed,\n            othIsSymbol = isSymbol(computed);\n\n        if (valIsNaN) {\n          var setLow = retHighest || othIsReflexive;\n        } else if (valIsUndefined) {\n          setLow = othIsReflexive && (retHighest || othIsDefined);\n        } else if (valIsNull) {\n          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);\n        } else if (valIsSymbol) {\n          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);\n        } else if (othIsNull || othIsSymbol) {\n          setLow = false;\n        } else {\n          setLow = retHighest ? (computed <= value) : (computed < value);\n        }\n        if (setLow) {\n          low = mid + 1;\n        } else {\n          high = mid;\n        }\n      }\n      return nativeMin(high, MAX_ARRAY_INDEX);\n    }\n\n    /**\n     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without\n     * support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     */\n    function baseSortedUniq(array, iteratee) {\n      var index = -1,\n          length = array.length,\n          resIndex = 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        if (!index || !eq(computed, seen)) {\n          var seen = computed;\n          result[resIndex++] = value === 0 ? 0 : value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.toNumber` which doesn't ensure correct\n     * conversions of binary, hexadecimal, or octal string values.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {number} Returns the number.\n     */\n    function baseToNumber(value) {\n      if (typeof value == 'number') {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      return +value;\n    }\n\n    /**\n     * The base implementation of `_.toString` which doesn't convert nullish\n     * values to empty strings.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {string} Returns the string.\n     */\n    function baseToString(value) {\n      // Exit early for strings to avoid a performance hit in some environments.\n      if (typeof value == 'string') {\n        return value;\n      }\n      if (isArray(value)) {\n        // Recursively convert values (susceptible to call stack limits).\n        return arrayMap(value, baseToString) + '';\n      }\n      if (isSymbol(value)) {\n        return symbolToString ? symbolToString.call(value) : '';\n      }\n      var result = (value + '');\n      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n    }\n\n    /**\n     * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     */\n    function baseUniq(array, iteratee, comparator) {\n      var index = -1,\n          includes = arrayIncludes,\n          length = array.length,\n          isCommon = true,\n          result = [],\n          seen = result;\n\n      if (comparator) {\n        isCommon = false;\n        includes = arrayIncludesWith;\n      }\n      else if (length >= LARGE_ARRAY_SIZE) {\n        var set = iteratee ? null : createSet(array);\n        if (set) {\n          return setToArray(set);\n        }\n        isCommon = false;\n        includes = cacheHas;\n        seen = new SetCache;\n      }\n      else {\n        seen = iteratee ? [] : result;\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n          var seenIndex = seen.length;\n          while (seenIndex--) {\n            if (seen[seenIndex] === computed) {\n              continue outer;\n            }\n          }\n          if (iteratee) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n        else if (!includes(seen, computed, comparator)) {\n          if (seen !== result) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.unset`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The property path to unset.\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n     */\n    function baseUnset(object, path) {\n      path = castPath(path, object);\n      object = parent(object, path);\n      return object == null || delete object[toKey(last(path))];\n    }\n\n    /**\n     * The base implementation of `_.update`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to update.\n     * @param {Function} updater The function to produce the updated value.\n     * @param {Function} [customizer] The function to customize path creation.\n     * @returns {Object} Returns `object`.\n     */\n    function baseUpdate(object, path, updater, customizer) {\n      return baseSet(object, path, updater(baseGet(object, path)), customizer);\n    }\n\n    /**\n     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`\n     * without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {Function} predicate The function invoked per iteration.\n     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseWhile(array, predicate, isDrop, fromRight) {\n      var length = array.length,\n          index = fromRight ? length : -1;\n\n      while ((fromRight ? index-- : ++index < length) &&\n        predicate(array[index], index, array)) {}\n\n      return isDrop\n        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))\n        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));\n    }\n\n    /**\n     * The base implementation of `wrapperValue` which returns the result of\n     * performing a sequence of actions on the unwrapped `value`, where each\n     * successive action is supplied the return value of the previous.\n     *\n     * @private\n     * @param {*} value The unwrapped value.\n     * @param {Array} actions Actions to perform to resolve the unwrapped value.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseWrapperValue(value, actions) {\n      var result = value;\n      if (result instanceof LazyWrapper) {\n        result = result.value();\n      }\n      return arrayReduce(actions, function(result, action) {\n        return action.func.apply(action.thisArg, arrayPush([result], action.args));\n      }, result);\n    }\n\n    /**\n     * The base implementation of methods like `_.xor`, without support for\n     * iteratee shorthands, that accepts an array of arrays to inspect.\n     *\n     * @private\n     * @param {Array} arrays The arrays to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of values.\n     */\n    function baseXor(arrays, iteratee, comparator) {\n      var length = arrays.length;\n      if (length < 2) {\n        return length ? baseUniq(arrays[0]) : [];\n      }\n      var index = -1,\n          result = Array(length);\n\n      while (++index < length) {\n        var array = arrays[index],\n            othIndex = -1;\n\n        while (++othIndex < length) {\n          if (othIndex != index) {\n            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);\n          }\n        }\n      }\n      return baseUniq(baseFlatten(result, 1), iteratee, comparator);\n    }\n\n    /**\n     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.\n     *\n     * @private\n     * @param {Array} props The property identifiers.\n     * @param {Array} values The property values.\n     * @param {Function} assignFunc The function to assign values.\n     * @returns {Object} Returns the new object.\n     */\n    function baseZipObject(props, values, assignFunc) {\n      var index = -1,\n          length = props.length,\n          valsLength = values.length,\n          result = {};\n\n      while (++index < length) {\n        var value = index < valsLength ? values[index] : undefined;\n        assignFunc(result, props[index], value);\n      }\n      return result;\n    }\n\n    /**\n     * Casts `value` to an empty array if it's not an array like object.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {Array|Object} Returns the cast array-like object.\n     */\n    function castArrayLikeObject(value) {\n      return isArrayLikeObject(value) ? value : [];\n    }\n\n    /**\n     * Casts `value` to `identity` if it's not a function.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {Function} Returns cast function.\n     */\n    function castFunction(value) {\n      return typeof value == 'function' ? value : identity;\n    }\n\n    /**\n     * Casts `value` to a path array if it's not one.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {Array} Returns the cast property path array.\n     */\n    function castPath(value, object) {\n      if (isArray(value)) {\n        return value;\n      }\n      return isKey(value, object) ? [value] : stringToPath(toString(value));\n    }\n\n    /**\n     * A `baseRest` alias which can be replaced with `identity` by module\n     * replacement plugins.\n     *\n     * @private\n     * @type {Function}\n     * @param {Function} func The function to apply a rest parameter to.\n     * @returns {Function} Returns the new function.\n     */\n    var castRest = baseRest;\n\n    /**\n     * Casts `array` to a slice if it's needed.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {number} start The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the cast slice.\n     */\n    function castSlice(array, start, end) {\n      var length = array.length;\n      end = end === undefined ? length : end;\n      return (!start && end >= length) ? array : baseSlice(array, start, end);\n    }\n\n    /**\n     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).\n     *\n     * @private\n     * @param {number|Object} id The timer id or timeout object of the timer to clear.\n     */\n    var clearTimeout = ctxClearTimeout || function(id) {\n      return root.clearTimeout(id);\n    };\n\n    /**\n     * Creates a clone of  `buffer`.\n     *\n     * @private\n     * @param {Buffer} buffer The buffer to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Buffer} Returns the cloned buffer.\n     */\n    function cloneBuffer(buffer, isDeep) {\n      if (isDeep) {\n        return buffer.slice();\n      }\n      var length = buffer.length,\n          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n      buffer.copy(result);\n      return result;\n    }\n\n    /**\n     * Creates a clone of `arrayBuffer`.\n     *\n     * @private\n     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n     * @returns {ArrayBuffer} Returns the cloned array buffer.\n     */\n    function cloneArrayBuffer(arrayBuffer) {\n      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n      new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n      return result;\n    }\n\n    /**\n     * Creates a clone of `dataView`.\n     *\n     * @private\n     * @param {Object} dataView The data view to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned data view.\n     */\n    function cloneDataView(dataView, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n    }\n\n    /**\n     * Creates a clone of `map`.\n     *\n     * @private\n     * @param {Object} map The map to clone.\n     * @param {Function} cloneFunc The function to clone values.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned map.\n     */\n    function cloneMap(map, isDeep, cloneFunc) {\n      var array = isDeep ? cloneFunc(mapToArray(map), CLONE_DEEP_FLAG) : mapToArray(map);\n      return arrayReduce(array, addMapEntry, new map.constructor);\n    }\n\n    /**\n     * Creates a clone of `regexp`.\n     *\n     * @private\n     * @param {Object} regexp The regexp to clone.\n     * @returns {Object} Returns the cloned regexp.\n     */\n    function cloneRegExp(regexp) {\n      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n      result.lastIndex = regexp.lastIndex;\n      return result;\n    }\n\n    /**\n     * Creates a clone of `set`.\n     *\n     * @private\n     * @param {Object} set The set to clone.\n     * @param {Function} cloneFunc The function to clone values.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned set.\n     */\n    function cloneSet(set, isDeep, cloneFunc) {\n      var array = isDeep ? cloneFunc(setToArray(set), CLONE_DEEP_FLAG) : setToArray(set);\n      return arrayReduce(array, addSetEntry, new set.constructor);\n    }\n\n    /**\n     * Creates a clone of the `symbol` object.\n     *\n     * @private\n     * @param {Object} symbol The symbol object to clone.\n     * @returns {Object} Returns the cloned symbol object.\n     */\n    function cloneSymbol(symbol) {\n      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n    }\n\n    /**\n     * Creates a clone of `typedArray`.\n     *\n     * @private\n     * @param {Object} typedArray The typed array to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned typed array.\n     */\n    function cloneTypedArray(typedArray, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n    }\n\n    /**\n     * Compares values to sort them in ascending order.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {number} Returns the sort order indicator for `value`.\n     */\n    function compareAscending(value, other) {\n      if (value !== other) {\n        var valIsDefined = value !== undefined,\n            valIsNull = value === null,\n            valIsReflexive = value === value,\n            valIsSymbol = isSymbol(value);\n\n        var othIsDefined = other !== undefined,\n            othIsNull = other === null,\n            othIsReflexive = other === other,\n            othIsSymbol = isSymbol(other);\n\n        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n            (valIsNull && othIsDefined && othIsReflexive) ||\n            (!valIsDefined && othIsReflexive) ||\n            !valIsReflexive) {\n          return 1;\n        }\n        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n            (othIsNull && valIsDefined && valIsReflexive) ||\n            (!othIsDefined && valIsReflexive) ||\n            !othIsReflexive) {\n          return -1;\n        }\n      }\n      return 0;\n    }\n\n    /**\n     * Used by `_.orderBy` to compare multiple properties of a value to another\n     * and stable sort them.\n     *\n     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n     * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n     * of corresponding values.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {boolean[]|string[]} orders The order to sort by for each property.\n     * @returns {number} Returns the sort order indicator for `object`.\n     */\n    function compareMultiple(object, other, orders) {\n      var index = -1,\n          objCriteria = object.criteria,\n          othCriteria = other.criteria,\n          length = objCriteria.length,\n          ordersLength = orders.length;\n\n      while (++index < length) {\n        var result = compareAscending(objCriteria[index], othCriteria[index]);\n        if (result) {\n          if (index >= ordersLength) {\n            return result;\n          }\n          var order = orders[index];\n          return result * (order == 'desc' ? -1 : 1);\n        }\n      }\n      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n      // that causes it, under certain circumstances, to provide the same value for\n      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n      // for more details.\n      //\n      // This also ensures a stable sort in V8 and other engines.\n      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n      return object.index - other.index;\n    }\n\n    /**\n     * Creates an array that is the composition of partially applied arguments,\n     * placeholders, and provided arguments into a single array of arguments.\n     *\n     * @private\n     * @param {Array} args The provided arguments.\n     * @param {Array} partials The arguments to prepend to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @params {boolean} [isCurried] Specify composing for a curried function.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgs(args, partials, holders, isCurried) {\n      var argsIndex = -1,\n          argsLength = args.length,\n          holdersLength = holders.length,\n          leftIndex = -1,\n          leftLength = partials.length,\n          rangeLength = nativeMax(argsLength - holdersLength, 0),\n          result = Array(leftLength + rangeLength),\n          isUncurried = !isCurried;\n\n      while (++leftIndex < leftLength) {\n        result[leftIndex] = partials[leftIndex];\n      }\n      while (++argsIndex < holdersLength) {\n        if (isUncurried || argsIndex < argsLength) {\n          result[holders[argsIndex]] = args[argsIndex];\n        }\n      }\n      while (rangeLength--) {\n        result[leftIndex++] = args[argsIndex++];\n      }\n      return result;\n    }\n\n    /**\n     * This function is like `composeArgs` except that the arguments composition\n     * is tailored for `_.partialRight`.\n     *\n     * @private\n     * @param {Array} args The provided arguments.\n     * @param {Array} partials The arguments to append to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @params {boolean} [isCurried] Specify composing for a curried function.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgsRight(args, partials, holders, isCurried) {\n      var argsIndex = -1,\n          argsLength = args.length,\n          holdersIndex = -1,\n          holdersLength = holders.length,\n          rightIndex = -1,\n          rightLength = partials.length,\n          rangeLength = nativeMax(argsLength - holdersLength, 0),\n          result = Array(rangeLength + rightLength),\n          isUncurried = !isCurried;\n\n      while (++argsIndex < rangeLength) {\n        result[argsIndex] = args[argsIndex];\n      }\n      var offset = argsIndex;\n      while (++rightIndex < rightLength) {\n        result[offset + rightIndex] = partials[rightIndex];\n      }\n      while (++holdersIndex < holdersLength) {\n        if (isUncurried || argsIndex < argsLength) {\n          result[offset + holders[holdersIndex]] = args[argsIndex++];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Copies the values of `source` to `array`.\n     *\n     * @private\n     * @param {Array} source The array to copy values from.\n     * @param {Array} [array=[]] The array to copy values to.\n     * @returns {Array} Returns `array`.\n     */\n    function copyArray(source, array) {\n      var index = -1,\n          length = source.length;\n\n      array || (array = Array(length));\n      while (++index < length) {\n        array[index] = source[index];\n      }\n      return array;\n    }\n\n    /**\n     * Copies properties of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy properties from.\n     * @param {Array} props The property identifiers to copy.\n     * @param {Object} [object={}] The object to copy properties to.\n     * @param {Function} [customizer] The function to customize copied values.\n     * @returns {Object} Returns `object`.\n     */\n    function copyObject(source, props, object, customizer) {\n      var isNew = !object;\n      object || (object = {});\n\n      var index = -1,\n          length = props.length;\n\n      while (++index < length) {\n        var key = props[index];\n\n        var newValue = customizer\n          ? customizer(object[key], source[key], key, object, source)\n          : undefined;\n\n        if (newValue === undefined) {\n          newValue = source[key];\n        }\n        if (isNew) {\n          baseAssignValue(object, key, newValue);\n        } else {\n          assignValue(object, key, newValue);\n        }\n      }\n      return object;\n    }\n\n    /**\n     * Copies own symbols of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy symbols from.\n     * @param {Object} [object={}] The object to copy symbols to.\n     * @returns {Object} Returns `object`.\n     */\n    function copySymbols(source, object) {\n      return copyObject(source, getSymbols(source), object);\n    }\n\n    /**\n     * Copies own and inherited symbols of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy symbols from.\n     * @param {Object} [object={}] The object to copy symbols to.\n     * @returns {Object} Returns `object`.\n     */\n    function copySymbolsIn(source, object) {\n      return copyObject(source, getSymbolsIn(source), object);\n    }\n\n    /**\n     * Creates a function like `_.groupBy`.\n     *\n     * @private\n     * @param {Function} setter The function to set accumulator values.\n     * @param {Function} [initializer] The accumulator object initializer.\n     * @returns {Function} Returns the new aggregator function.\n     */\n    function createAggregator(setter, initializer) {\n      return function(collection, iteratee) {\n        var func = isArray(collection) ? arrayAggregator : baseAggregator,\n            accumulator = initializer ? initializer() : {};\n\n        return func(collection, setter, getIteratee(iteratee, 2), accumulator);\n      };\n    }\n\n    /**\n     * Creates a function like `_.assign`.\n     *\n     * @private\n     * @param {Function} assigner The function to assign values.\n     * @returns {Function} Returns the new assigner function.\n     */\n    function createAssigner(assigner) {\n      return baseRest(function(object, sources) {\n        var index = -1,\n            length = sources.length,\n            customizer = length > 1 ? sources[length - 1] : undefined,\n            guard = length > 2 ? sources[2] : undefined;\n\n        customizer = (assigner.length > 3 && typeof customizer == 'function')\n          ? (length--, customizer)\n          : undefined;\n\n        if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n          customizer = length < 3 ? undefined : customizer;\n          length = 1;\n        }\n        object = Object(object);\n        while (++index < length) {\n          var source = sources[index];\n          if (source) {\n            assigner(object, source, index, customizer);\n          }\n        }\n        return object;\n      });\n    }\n\n    /**\n     * Creates a `baseEach` or `baseEachRight` function.\n     *\n     * @private\n     * @param {Function} eachFunc The function to iterate over a collection.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseEach(eachFunc, fromRight) {\n      return function(collection, iteratee) {\n        if (collection == null) {\n          return collection;\n        }\n        if (!isArrayLike(collection)) {\n          return eachFunc(collection, iteratee);\n        }\n        var length = collection.length,\n            index = fromRight ? length : -1,\n            iterable = Object(collection);\n\n        while ((fromRight ? index-- : ++index < length)) {\n          if (iteratee(iterable[index], index, iterable) === false) {\n            break;\n          }\n        }\n        return collection;\n      };\n    }\n\n    /**\n     * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseFor(fromRight) {\n      return function(object, iteratee, keysFunc) {\n        var index = -1,\n            iterable = Object(object),\n            props = keysFunc(object),\n            length = props.length;\n\n        while (length--) {\n          var key = props[fromRight ? length : ++index];\n          if (iteratee(iterable[key], key, iterable) === false) {\n            break;\n          }\n        }\n        return object;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with the optional `this`\n     * binding of `thisArg`.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createBind(func, bitmask, thisArg) {\n      var isBind = bitmask & WRAP_BIND_FLAG,\n          Ctor = createCtor(func);\n\n      function wrapper() {\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return fn.apply(isBind ? thisArg : this, arguments);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a function like `_.lowerFirst`.\n     *\n     * @private\n     * @param {string} methodName The name of the `String` case method to use.\n     * @returns {Function} Returns the new case function.\n     */\n    function createCaseFirst(methodName) {\n      return function(string) {\n        string = toString(string);\n\n        var strSymbols = hasUnicode(string)\n          ? stringToArray(string)\n          : undefined;\n\n        var chr = strSymbols\n          ? strSymbols[0]\n          : string.charAt(0);\n\n        var trailing = strSymbols\n          ? castSlice(strSymbols, 1).join('')\n          : string.slice(1);\n\n        return chr[methodName]() + trailing;\n      };\n    }\n\n    /**\n     * Creates a function like `_.camelCase`.\n     *\n     * @private\n     * @param {Function} callback The function to combine each word.\n     * @returns {Function} Returns the new compounder function.\n     */\n    function createCompounder(callback) {\n      return function(string) {\n        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');\n      };\n    }\n\n    /**\n     * Creates a function that produces an instance of `Ctor` regardless of\n     * whether it was invoked as part of a `new` expression or by `call` or `apply`.\n     *\n     * @private\n     * @param {Function} Ctor The constructor to wrap.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCtor(Ctor) {\n      return function() {\n        // Use a `switch` statement to work with class constructors. See\n        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist\n        // for more details.\n        var args = arguments;\n        switch (args.length) {\n          case 0: return new Ctor;\n          case 1: return new Ctor(args[0]);\n          case 2: return new Ctor(args[0], args[1]);\n          case 3: return new Ctor(args[0], args[1], args[2]);\n          case 4: return new Ctor(args[0], args[1], args[2], args[3]);\n          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);\n          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);\n          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n        }\n        var thisBinding = baseCreate(Ctor.prototype),\n            result = Ctor.apply(thisBinding, args);\n\n        // Mimic the constructor's `return` behavior.\n        // See https://es5.github.io/#x13.2.2 for more details.\n        return isObject(result) ? result : thisBinding;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to enable currying.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {number} arity The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCurry(func, bitmask, arity) {\n      var Ctor = createCtor(func);\n\n      function wrapper() {\n        var length = arguments.length,\n            args = Array(length),\n            index = length,\n            placeholder = getHolder(wrapper);\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)\n          ? []\n          : replaceHolders(args, placeholder);\n\n        length -= holders.length;\n        if (length < arity) {\n          return createRecurry(\n            func, bitmask, createHybrid, wrapper.placeholder, undefined,\n            args, holders, undefined, undefined, arity - length);\n        }\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return apply(fn, this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `_.find` or `_.findLast` function.\n     *\n     * @private\n     * @param {Function} findIndexFunc The function to find the collection index.\n     * @returns {Function} Returns the new find function.\n     */\n    function createFind(findIndexFunc) {\n      return function(collection, predicate, fromIndex) {\n        var iterable = Object(collection);\n        if (!isArrayLike(collection)) {\n          var iteratee = getIteratee(predicate, 3);\n          collection = keys(collection);\n          predicate = function(key) { return iteratee(iterable[key], key, iterable); };\n        }\n        var index = findIndexFunc(collection, predicate, fromIndex);\n        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n      };\n    }\n\n    /**\n     * Creates a `_.flow` or `_.flowRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new flow function.\n     */\n    function createFlow(fromRight) {\n      return flatRest(function(funcs) {\n        var length = funcs.length,\n            index = length,\n            prereq = LodashWrapper.prototype.thru;\n\n        if (fromRight) {\n          funcs.reverse();\n        }\n        while (index--) {\n          var func = funcs[index];\n          if (typeof func != 'function') {\n            throw new TypeError(FUNC_ERROR_TEXT);\n          }\n          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {\n            var wrapper = new LodashWrapper([], true);\n          }\n        }\n        index = wrapper ? index : length;\n        while (++index < length) {\n          func = funcs[index];\n\n          var funcName = getFuncName(func),\n              data = funcName == 'wrapper' ? getData(func) : undefined;\n\n          if (data && isLaziable(data[0]) &&\n                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&\n                !data[4].length && data[9] == 1\n              ) {\n            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);\n          } else {\n            wrapper = (func.length == 1 && isLaziable(func))\n              ? wrapper[funcName]()\n              : wrapper.thru(func);\n          }\n        }\n        return function() {\n          var args = arguments,\n              value = args[0];\n\n          if (wrapper && args.length == 1 &&\n              isArray(value) && value.length >= LARGE_ARRAY_SIZE) {\n            return wrapper.plant(value).value();\n          }\n          var index = 0,\n              result = length ? funcs[index].apply(this, args) : value;\n\n          while (++index < length) {\n            result = funcs[index].call(this, result);\n          }\n          return result;\n        };\n      });\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with optional `this`\n     * binding of `thisArg`, partial application, and currying.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to\n     *  the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [partialsRight] The arguments to append to those provided\n     *  to the new function.\n     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {\n      var isAry = bitmask & WRAP_ARY_FLAG,\n          isBind = bitmask & WRAP_BIND_FLAG,\n          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,\n          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),\n          isFlip = bitmask & WRAP_FLIP_FLAG,\n          Ctor = isBindKey ? undefined : createCtor(func);\n\n      function wrapper() {\n        var length = arguments.length,\n            args = Array(length),\n            index = length;\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        if (isCurried) {\n          var placeholder = getHolder(wrapper),\n              holdersCount = countHolders(args, placeholder);\n        }\n        if (partials) {\n          args = composeArgs(args, partials, holders, isCurried);\n        }\n        if (partialsRight) {\n          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);\n        }\n        length -= holdersCount;\n        if (isCurried && length < arity) {\n          var newHolders = replaceHolders(args, placeholder);\n          return createRecurry(\n            func, bitmask, createHybrid, wrapper.placeholder, thisArg,\n            args, newHolders, argPos, ary, arity - length\n          );\n        }\n        var thisBinding = isBind ? thisArg : this,\n            fn = isBindKey ? thisBinding[func] : func;\n\n        length = args.length;\n        if (argPos) {\n          args = reorder(args, argPos);\n        } else if (isFlip && length > 1) {\n          args.reverse();\n        }\n        if (isAry && ary < length) {\n          args.length = ary;\n        }\n        if (this && this !== root && this instanceof wrapper) {\n          fn = Ctor || createCtor(fn);\n        }\n        return fn.apply(thisBinding, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a function like `_.invertBy`.\n     *\n     * @private\n     * @param {Function} setter The function to set accumulator values.\n     * @param {Function} toIteratee The function to resolve iteratees.\n     * @returns {Function} Returns the new inverter function.\n     */\n    function createInverter(setter, toIteratee) {\n      return function(object, iteratee) {\n        return baseInverter(object, setter, toIteratee(iteratee), {});\n      };\n    }\n\n    /**\n     * Creates a function that performs a mathematical operation on two values.\n     *\n     * @private\n     * @param {Function} operator The function to perform the operation.\n     * @param {number} [defaultValue] The value used for `undefined` arguments.\n     * @returns {Function} Returns the new mathematical operation function.\n     */\n    function createMathOperation(operator, defaultValue) {\n      return function(value, other) {\n        var result;\n        if (value === undefined && other === undefined) {\n          return defaultValue;\n        }\n        if (value !== undefined) {\n          result = value;\n        }\n        if (other !== undefined) {\n          if (result === undefined) {\n            return other;\n          }\n          if (typeof value == 'string' || typeof other == 'string') {\n            value = baseToString(value);\n            other = baseToString(other);\n          } else {\n            value = baseToNumber(value);\n            other = baseToNumber(other);\n          }\n          result = operator(value, other);\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function like `_.over`.\n     *\n     * @private\n     * @param {Function} arrayFunc The function to iterate over iteratees.\n     * @returns {Function} Returns the new over function.\n     */\n    function createOver(arrayFunc) {\n      return flatRest(function(iteratees) {\n        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));\n        return baseRest(function(args) {\n          var thisArg = this;\n          return arrayFunc(iteratees, function(iteratee) {\n            return apply(iteratee, thisArg, args);\n          });\n        });\n      });\n    }\n\n    /**\n     * Creates the padding for `string` based on `length`. The `chars` string\n     * is truncated if the number of characters exceeds `length`.\n     *\n     * @private\n     * @param {number} length The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padding for `string`.\n     */\n    function createPadding(length, chars) {\n      chars = chars === undefined ? ' ' : baseToString(chars);\n\n      var charsLength = chars.length;\n      if (charsLength < 2) {\n        return charsLength ? baseRepeat(chars, length) : chars;\n      }\n      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));\n      return hasUnicode(chars)\n        ? castSlice(stringToArray(result), 0, length).join('')\n        : result.slice(0, length);\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with the `this` binding\n     * of `thisArg` and `partials` prepended to the arguments it receives.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {Array} partials The arguments to prepend to those provided to\n     *  the new function.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createPartial(func, bitmask, thisArg, partials) {\n      var isBind = bitmask & WRAP_BIND_FLAG,\n          Ctor = createCtor(func);\n\n      function wrapper() {\n        var argsIndex = -1,\n            argsLength = arguments.length,\n            leftIndex = -1,\n            leftLength = partials.length,\n            args = Array(leftLength + argsLength),\n            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n\n        while (++leftIndex < leftLength) {\n          args[leftIndex] = partials[leftIndex];\n        }\n        while (argsLength--) {\n          args[leftIndex++] = arguments[++argsIndex];\n        }\n        return apply(fn, isBind ? thisArg : this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `_.range` or `_.rangeRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new range function.\n     */\n    function createRange(fromRight) {\n      return function(start, end, step) {\n        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {\n          end = step = undefined;\n        }\n        // Ensure the sign of `-0` is preserved.\n        start = toFinite(start);\n        if (end === undefined) {\n          end = start;\n          start = 0;\n        } else {\n          end = toFinite(end);\n        }\n        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);\n        return baseRange(start, end, step, fromRight);\n      };\n    }\n\n    /**\n     * Creates a function that performs a relational operation on two values.\n     *\n     * @private\n     * @param {Function} operator The function to perform the operation.\n     * @returns {Function} Returns the new relational operation function.\n     */\n    function createRelationalOperation(operator) {\n      return function(value, other) {\n        if (!(typeof value == 'string' && typeof other == 'string')) {\n          value = toNumber(value);\n          other = toNumber(other);\n        }\n        return operator(value, other);\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to continue currying.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {Function} wrapFunc The function to create the `func` wrapper.\n     * @param {*} placeholder The placeholder value.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to\n     *  the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {\n      var isCurry = bitmask & WRAP_CURRY_FLAG,\n          newHolders = isCurry ? holders : undefined,\n          newHoldersRight = isCurry ? undefined : holders,\n          newPartials = isCurry ? partials : undefined,\n          newPartialsRight = isCurry ? undefined : partials;\n\n      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);\n      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);\n\n      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {\n        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);\n      }\n      var newData = [\n        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,\n        newHoldersRight, argPos, ary, arity\n      ];\n\n      var result = wrapFunc.apply(undefined, newData);\n      if (isLaziable(func)) {\n        setData(result, newData);\n      }\n      result.placeholder = placeholder;\n      return setWrapToString(result, func, bitmask);\n    }\n\n    /**\n     * Creates a function like `_.round`.\n     *\n     * @private\n     * @param {string} methodName The name of the `Math` method to use when rounding.\n     * @returns {Function} Returns the new round function.\n     */\n    function createRound(methodName) {\n      var func = Math[methodName];\n      return function(number, precision) {\n        number = toNumber(number);\n        precision = nativeMin(toInteger(precision), 292);\n        if (precision) {\n          // Shift with exponential notation to avoid floating-point issues.\n          // See [MDN](https://mdn.io/round#Examples) for more details.\n          var pair = (toString(number) + 'e').split('e'),\n              value = func(pair[0] + 'e' + (+pair[1] + precision));\n\n          pair = (toString(value) + 'e').split('e');\n          return +(pair[0] + 'e' + (+pair[1] - precision));\n        }\n        return func(number);\n      };\n    }\n\n    /**\n     * Creates a set object of `values`.\n     *\n     * @private\n     * @param {Array} values The values to add to the set.\n     * @returns {Object} Returns the new set.\n     */\n    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n      return new Set(values);\n    };\n\n    /**\n     * Creates a `_.toPairs` or `_.toPairsIn` function.\n     *\n     * @private\n     * @param {Function} keysFunc The function to get the keys of a given object.\n     * @returns {Function} Returns the new pairs function.\n     */\n    function createToPairs(keysFunc) {\n      return function(object) {\n        var tag = getTag(object);\n        if (tag == mapTag) {\n          return mapToArray(object);\n        }\n        if (tag == setTag) {\n          return setToPairs(object);\n        }\n        return baseToPairs(object, keysFunc(object));\n      };\n    }\n\n    /**\n     * Creates a function that either curries or invokes `func` with optional\n     * `this` binding and partially applied arguments.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to wrap.\n     * @param {number} bitmask The bitmask flags.\n     *    1 - `_.bind`\n     *    2 - `_.bindKey`\n     *    4 - `_.curry` or `_.curryRight` of a bound function\n     *    8 - `_.curry`\n     *   16 - `_.curryRight`\n     *   32 - `_.partial`\n     *   64 - `_.partialRight`\n     *  128 - `_.rearg`\n     *  256 - `_.ary`\n     *  512 - `_.flip`\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to be partially applied.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {\n      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;\n      if (!isBindKey && typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var length = partials ? partials.length : 0;\n      if (!length) {\n        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);\n        partials = holders = undefined;\n      }\n      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);\n      arity = arity === undefined ? arity : toInteger(arity);\n      length -= holders ? holders.length : 0;\n\n      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {\n        var partialsRight = partials,\n            holdersRight = holders;\n\n        partials = holders = undefined;\n      }\n      var data = isBindKey ? undefined : getData(func);\n\n      var newData = [\n        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,\n        argPos, ary, arity\n      ];\n\n      if (data) {\n        mergeData(newData, data);\n      }\n      func = newData[0];\n      bitmask = newData[1];\n      thisArg = newData[2];\n      partials = newData[3];\n      holders = newData[4];\n      arity = newData[9] = newData[9] == null\n        ? (isBindKey ? 0 : func.length)\n        : nativeMax(newData[9] - length, 0);\n\n      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {\n        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);\n      }\n      if (!bitmask || bitmask == WRAP_BIND_FLAG) {\n        var result = createBind(func, bitmask, thisArg);\n      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {\n        result = createCurry(func, bitmask, arity);\n      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {\n        result = createPartial(func, bitmask, thisArg, partials);\n      } else {\n        result = createHybrid.apply(undefined, newData);\n      }\n      var setter = data ? baseSetData : setData;\n      return setWrapToString(setter(result, newData), func, bitmask);\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for arrays with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Array} array The array to compare.\n     * @param {Array} other The other array to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `array` and `other` objects.\n     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n     */\n    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n          arrLength = array.length,\n          othLength = other.length;\n\n      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(array);\n      if (stacked && stack.get(other)) {\n        return stacked == other;\n      }\n      var index = -1,\n          result = true,\n          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n      stack.set(array, other);\n      stack.set(other, array);\n\n      // Ignore non-index properties.\n      while (++index < arrLength) {\n        var arrValue = array[index],\n            othValue = other[index];\n\n        if (customizer) {\n          var compared = isPartial\n            ? customizer(othValue, arrValue, index, other, array, stack)\n            : customizer(arrValue, othValue, index, array, other, stack);\n        }\n        if (compared !== undefined) {\n          if (compared) {\n            continue;\n          }\n          result = false;\n          break;\n        }\n        // Recursively compare arrays (susceptible to call stack limits).\n        if (seen) {\n          if (!arraySome(other, function(othValue, othIndex) {\n                if (!cacheHas(seen, othIndex) &&\n                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n                  return seen.push(othIndex);\n                }\n              })) {\n            result = false;\n            break;\n          }\n        } else if (!(\n              arrValue === othValue ||\n                equalFunc(arrValue, othValue, bitmask, customizer, stack)\n            )) {\n          result = false;\n          break;\n        }\n      }\n      stack['delete'](array);\n      stack['delete'](other);\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for comparing objects of\n     * the same `toStringTag`.\n     *\n     * **Note:** This function only supports comparing values with tags of\n     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {string} tag The `toStringTag` of the objects to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n      switch (tag) {\n        case dataViewTag:\n          if ((object.byteLength != other.byteLength) ||\n              (object.byteOffset != other.byteOffset)) {\n            return false;\n          }\n          object = object.buffer;\n          other = other.buffer;\n\n        case arrayBufferTag:\n          if ((object.byteLength != other.byteLength) ||\n              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n            return false;\n          }\n          return true;\n\n        case boolTag:\n        case dateTag:\n        case numberTag:\n          // Coerce booleans to `1` or `0` and dates to milliseconds.\n          // Invalid dates are coerced to `NaN`.\n          return eq(+object, +other);\n\n        case errorTag:\n          return object.name == other.name && object.message == other.message;\n\n        case regexpTag:\n        case stringTag:\n          // Coerce regexes to strings and treat strings, primitives and objects,\n          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n          // for more details.\n          return object == (other + '');\n\n        case mapTag:\n          var convert = mapToArray;\n\n        case setTag:\n          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n          convert || (convert = setToArray);\n\n          if (object.size != other.size && !isPartial) {\n            return false;\n          }\n          // Assume cyclic values are equal.\n          var stacked = stack.get(object);\n          if (stacked) {\n            return stacked == other;\n          }\n          bitmask |= COMPARE_UNORDERED_FLAG;\n\n          // Recursively compare objects (susceptible to call stack limits).\n          stack.set(object, other);\n          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n          stack['delete'](object);\n          return result;\n\n        case symbolTag:\n          if (symbolValueOf) {\n            return symbolValueOf.call(object) == symbolValueOf.call(other);\n          }\n      }\n      return false;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for objects with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n          objProps = keys(object),\n          objLength = objProps.length,\n          othProps = keys(other),\n          othLength = othProps.length;\n\n      if (objLength != othLength && !isPartial) {\n        return false;\n      }\n      var index = objLength;\n      while (index--) {\n        var key = objProps[index];\n        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n          return false;\n        }\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked && stack.get(other)) {\n        return stacked == other;\n      }\n      var result = true;\n      stack.set(object, other);\n      stack.set(other, object);\n\n      var skipCtor = isPartial;\n      while (++index < objLength) {\n        key = objProps[index];\n        var objValue = object[key],\n            othValue = other[key];\n\n        if (customizer) {\n          var compared = isPartial\n            ? customizer(othValue, objValue, key, other, object, stack)\n            : customizer(objValue, othValue, key, object, other, stack);\n        }\n        // Recursively compare objects (susceptible to call stack limits).\n        if (!(compared === undefined\n              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n              : compared\n            )) {\n          result = false;\n          break;\n        }\n        skipCtor || (skipCtor = key == 'constructor');\n      }\n      if (result && !skipCtor) {\n        var objCtor = object.constructor,\n            othCtor = other.constructor;\n\n        // Non `Object` object instances with different constructors are not equal.\n        if (objCtor != othCtor &&\n            ('constructor' in object && 'constructor' in other) &&\n            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n              typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n          result = false;\n        }\n      }\n      stack['delete'](object);\n      stack['delete'](other);\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseRest` which flattens the rest array.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @returns {Function} Returns the new function.\n     */\n    function flatRest(func) {\n      return setToString(overRest(func, undefined, flatten), func + '');\n    }\n\n    /**\n     * Creates an array of own enumerable property names and symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function getAllKeys(object) {\n      return baseGetAllKeys(object, keys, getSymbols);\n    }\n\n    /**\n     * Creates an array of own and inherited enumerable property names and\n     * symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function getAllKeysIn(object) {\n      return baseGetAllKeys(object, keysIn, getSymbolsIn);\n    }\n\n    /**\n     * Gets metadata for `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {*} Returns the metadata for `func`.\n     */\n    var getData = !metaMap ? noop : function(func) {\n      return metaMap.get(func);\n    };\n\n    /**\n     * Gets the name of `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {string} Returns the function name.\n     */\n    function getFuncName(func) {\n      var result = (func.name + ''),\n          array = realNames[result],\n          length = hasOwnProperty.call(realNames, result) ? array.length : 0;\n\n      while (length--) {\n        var data = array[length],\n            otherFunc = data.func;\n        if (otherFunc == null || otherFunc == func) {\n          return data.name;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Gets the argument placeholder value for `func`.\n     *\n     * @private\n     * @param {Function} func The function to inspect.\n     * @returns {*} Returns the placeholder value.\n     */\n    function getHolder(func) {\n      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;\n      return object.placeholder;\n    }\n\n    /**\n     * Gets the appropriate \"iteratee\" function. If `_.iteratee` is customized,\n     * this function returns the custom method, otherwise it returns `baseIteratee`.\n     * If arguments are provided, the chosen function is invoked with them and\n     * its result is returned.\n     *\n     * @private\n     * @param {*} [value] The value to convert to an iteratee.\n     * @param {number} [arity] The arity of the created iteratee.\n     * @returns {Function} Returns the chosen function or its result.\n     */\n    function getIteratee() {\n      var result = lodash.iteratee || iteratee;\n      result = result === iteratee ? baseIteratee : result;\n      return arguments.length ? result(arguments[0], arguments[1]) : result;\n    }\n\n    /**\n     * Gets the data for `map`.\n     *\n     * @private\n     * @param {Object} map The map to query.\n     * @param {string} key The reference key.\n     * @returns {*} Returns the map data.\n     */\n    function getMapData(map, key) {\n      var data = map.__data__;\n      return isKeyable(key)\n        ? data[typeof key == 'string' ? 'string' : 'hash']\n        : data.map;\n    }\n\n    /**\n     * Gets the property names, values, and compare flags of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the match data of `object`.\n     */\n    function getMatchData(object) {\n      var result = keys(object),\n          length = result.length;\n\n      while (length--) {\n        var key = result[length],\n            value = object[key];\n\n        result[length] = [key, value, isStrictComparable(value)];\n      }\n      return result;\n    }\n\n    /**\n     * Gets the native function at `key` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the method to get.\n     * @returns {*} Returns the function if it's native, else `undefined`.\n     */\n    function getNative(object, key) {\n      var value = getValue(object, key);\n      return baseIsNative(value) ? value : undefined;\n    }\n\n    /**\n     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the raw `toStringTag`.\n     */\n    function getRawTag(value) {\n      var isOwn = hasOwnProperty.call(value, symToStringTag),\n          tag = value[symToStringTag];\n\n      try {\n        value[symToStringTag] = undefined;\n        var unmasked = true;\n      } catch (e) {}\n\n      var result = nativeObjectToString.call(value);\n      if (unmasked) {\n        if (isOwn) {\n          value[symToStringTag] = tag;\n        } else {\n          delete value[symToStringTag];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array of the own enumerable symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of symbols.\n     */\n    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;\n\n    /**\n     * Creates an array of the own and inherited enumerable symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of symbols.\n     */\n    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n      var result = [];\n      while (object) {\n        arrayPush(result, getSymbols(object));\n        object = getPrototype(object);\n      }\n      return result;\n    };\n\n    /**\n     * Gets the `toStringTag` of `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */\n    var getTag = baseGetTag;\n\n    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\n    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n        (Map && getTag(new Map) != mapTag) ||\n        (Promise && getTag(Promise.resolve()) != promiseTag) ||\n        (Set && getTag(new Set) != setTag) ||\n        (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n      getTag = function(value) {\n        var result = baseGetTag(value),\n            Ctor = result == objectTag ? value.constructor : undefined,\n            ctorString = Ctor ? toSource(Ctor) : '';\n\n        if (ctorString) {\n          switch (ctorString) {\n            case dataViewCtorString: return dataViewTag;\n            case mapCtorString: return mapTag;\n            case promiseCtorString: return promiseTag;\n            case setCtorString: return setTag;\n            case weakMapCtorString: return weakMapTag;\n          }\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Gets the view, applying any `transforms` to the `start` and `end` positions.\n     *\n     * @private\n     * @param {number} start The start of the view.\n     * @param {number} end The end of the view.\n     * @param {Array} transforms The transformations to apply to the view.\n     * @returns {Object} Returns an object containing the `start` and `end`\n     *  positions of the view.\n     */\n    function getView(start, end, transforms) {\n      var index = -1,\n          length = transforms.length;\n\n      while (++index < length) {\n        var data = transforms[index],\n            size = data.size;\n\n        switch (data.type) {\n          case 'drop':      start += size; break;\n          case 'dropRight': end -= size; break;\n          case 'take':      end = nativeMin(end, start + size); break;\n          case 'takeRight': start = nativeMax(start, end - size); break;\n        }\n      }\n      return { 'start': start, 'end': end };\n    }\n\n    /**\n     * Extracts wrapper details from the `source` body comment.\n     *\n     * @private\n     * @param {string} source The source to inspect.\n     * @returns {Array} Returns the wrapper details.\n     */\n    function getWrapDetails(source) {\n      var match = source.match(reWrapDetails);\n      return match ? match[1].split(reSplitDetails) : [];\n    }\n\n    /**\n     * Checks if `path` exists on `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @param {Function} hasFunc The function to check properties.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     */\n    function hasPath(object, path, hasFunc) {\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length,\n          result = false;\n\n      while (++index < length) {\n        var key = toKey(path[index]);\n        if (!(result = object != null && hasFunc(object, key))) {\n          break;\n        }\n        object = object[key];\n      }\n      if (result || ++index != length) {\n        return result;\n      }\n      length = object == null ? 0 : object.length;\n      return !!length && isLength(length) && isIndex(key, length) &&\n        (isArray(object) || isArguments(object));\n    }\n\n    /**\n     * Initializes an array clone.\n     *\n     * @private\n     * @param {Array} array The array to clone.\n     * @returns {Array} Returns the initialized clone.\n     */\n    function initCloneArray(array) {\n      var length = array.length,\n          result = array.constructor(length);\n\n      // Add properties assigned by `RegExp#exec`.\n      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n        result.index = array.index;\n        result.input = array.input;\n      }\n      return result;\n    }\n\n    /**\n     * Initializes an object clone.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneObject(object) {\n      return (typeof object.constructor == 'function' && !isPrototype(object))\n        ? baseCreate(getPrototype(object))\n        : {};\n    }\n\n    /**\n     * Initializes an object clone based on its `toStringTag`.\n     *\n     * **Note:** This function only supports cloning values with tags of\n     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @param {string} tag The `toStringTag` of the object to clone.\n     * @param {Function} cloneFunc The function to clone values.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneByTag(object, tag, cloneFunc, isDeep) {\n      var Ctor = object.constructor;\n      switch (tag) {\n        case arrayBufferTag:\n          return cloneArrayBuffer(object);\n\n        case boolTag:\n        case dateTag:\n          return new Ctor(+object);\n\n        case dataViewTag:\n          return cloneDataView(object, isDeep);\n\n        case float32Tag: case float64Tag:\n        case int8Tag: case int16Tag: case int32Tag:\n        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n          return cloneTypedArray(object, isDeep);\n\n        case mapTag:\n          return cloneMap(object, isDeep, cloneFunc);\n\n        case numberTag:\n        case stringTag:\n          return new Ctor(object);\n\n        case regexpTag:\n          return cloneRegExp(object);\n\n        case setTag:\n          return cloneSet(object, isDeep, cloneFunc);\n\n        case symbolTag:\n          return cloneSymbol(object);\n      }\n    }\n\n    /**\n     * Inserts wrapper `details` in a comment at the top of the `source` body.\n     *\n     * @private\n     * @param {string} source The source to modify.\n     * @returns {Array} details The details to insert.\n     * @returns {string} Returns the modified source.\n     */\n    function insertWrapDetails(source, details) {\n      var length = details.length;\n      if (!length) {\n        return source;\n      }\n      var lastIndex = length - 1;\n      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];\n      details = details.join(length > 2 ? ', ' : ' ');\n      return source.replace(reWrapComment, '{\\n/* [wrapped with ' + details + '] */\\n');\n    }\n\n    /**\n     * Checks if `value` is a flattenable `arguments` object or array.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n     */\n    function isFlattenable(value) {\n      return isArray(value) || isArguments(value) ||\n        !!(spreadableSymbol && value && value[spreadableSymbol]);\n    }\n\n    /**\n     * Checks if `value` is a valid array-like index.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n     */\n    function isIndex(value, length) {\n      length = length == null ? MAX_SAFE_INTEGER : length;\n      return !!length &&\n        (typeof value == 'number' || reIsUint.test(value)) &&\n        (value > -1 && value % 1 == 0 && value < length);\n    }\n\n    /**\n     * Checks if the given arguments are from an iteratee call.\n     *\n     * @private\n     * @param {*} value The potential iteratee value argument.\n     * @param {*} index The potential iteratee index or key argument.\n     * @param {*} object The potential iteratee object argument.\n     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n     *  else `false`.\n     */\n    function isIterateeCall(value, index, object) {\n      if (!isObject(object)) {\n        return false;\n      }\n      var type = typeof index;\n      if (type == 'number'\n            ? (isArrayLike(object) && isIndex(index, object.length))\n            : (type == 'string' && index in object)\n          ) {\n        return eq(object[index], value);\n      }\n      return false;\n    }\n\n    /**\n     * Checks if `value` is a property name and not a property path.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n     */\n    function isKey(value, object) {\n      if (isArray(value)) {\n        return false;\n      }\n      var type = typeof value;\n      if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n          value == null || isSymbol(value)) {\n        return true;\n      }\n      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n        (object != null && value in Object(object));\n    }\n\n    /**\n     * Checks if `value` is suitable for use as unique object key.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n     */\n    function isKeyable(value) {\n      var type = typeof value;\n      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n        ? (value !== '__proto__')\n        : (value === null);\n    }\n\n    /**\n     * Checks if `func` has a lazy counterpart.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,\n     *  else `false`.\n     */\n    function isLaziable(func) {\n      var funcName = getFuncName(func),\n          other = lodash[funcName];\n\n      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {\n        return false;\n      }\n      if (func === other) {\n        return true;\n      }\n      var data = getData(other);\n      return !!data && func === data[0];\n    }\n\n    /**\n     * Checks if `func` has its source masked.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n     */\n    function isMasked(func) {\n      return !!maskSrcKey && (maskSrcKey in func);\n    }\n\n    /**\n     * Checks if `func` is capable of being masked.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.\n     */\n    var isMaskable = coreJsData ? isFunction : stubFalse;\n\n    /**\n     * Checks if `value` is likely a prototype object.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n     */\n    function isPrototype(value) {\n      var Ctor = value && value.constructor,\n          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n      return value === proto;\n    }\n\n    /**\n     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` if suitable for strict\n     *  equality comparisons, else `false`.\n     */\n    function isStrictComparable(value) {\n      return value === value && !isObject(value);\n    }\n\n    /**\n     * A specialized version of `matchesProperty` for source values suitable\n     * for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {string} key The key of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function matchesStrictComparable(key, srcValue) {\n      return function(object) {\n        if (object == null) {\n          return false;\n        }\n        return object[key] === srcValue &&\n          (srcValue !== undefined || (key in Object(object)));\n      };\n    }\n\n    /**\n     * A specialized version of `_.memoize` which clears the memoized function's\n     * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n     *\n     * @private\n     * @param {Function} func The function to have its output memoized.\n     * @returns {Function} Returns the new memoized function.\n     */\n    function memoizeCapped(func) {\n      var result = memoize(func, function(key) {\n        if (cache.size === MAX_MEMOIZE_SIZE) {\n          cache.clear();\n        }\n        return key;\n      });\n\n      var cache = result.cache;\n      return result;\n    }\n\n    /**\n     * Merges the function metadata of `source` into `data`.\n     *\n     * Merging metadata reduces the number of wrappers used to invoke a function.\n     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`\n     * may be applied regardless of execution order. Methods like `_.ary` and\n     * `_.rearg` modify function arguments, making the order in which they are\n     * executed important, preventing the merging of metadata. However, we make\n     * an exception for a safe combined case where curried functions have `_.ary`\n     * and or `_.rearg` applied.\n     *\n     * @private\n     * @param {Array} data The destination metadata.\n     * @param {Array} source The source metadata.\n     * @returns {Array} Returns `data`.\n     */\n    function mergeData(data, source) {\n      var bitmask = data[1],\n          srcBitmask = source[1],\n          newBitmask = bitmask | srcBitmask,\n          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);\n\n      var isCombo =\n        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||\n        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||\n        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));\n\n      // Exit early if metadata can't be merged.\n      if (!(isCommon || isCombo)) {\n        return data;\n      }\n      // Use source `thisArg` if available.\n      if (srcBitmask & WRAP_BIND_FLAG) {\n        data[2] = source[2];\n        // Set when currying a bound function.\n        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;\n      }\n      // Compose partial arguments.\n      var value = source[3];\n      if (value) {\n        var partials = data[3];\n        data[3] = partials ? composeArgs(partials, value, source[4]) : value;\n        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];\n      }\n      // Compose partial right arguments.\n      value = source[5];\n      if (value) {\n        partials = data[5];\n        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;\n        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];\n      }\n      // Use source `argPos` if available.\n      value = source[7];\n      if (value) {\n        data[7] = value;\n      }\n      // Use source `ary` if it's smaller.\n      if (srcBitmask & WRAP_ARY_FLAG) {\n        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);\n      }\n      // Use source `arity` if one is not provided.\n      if (data[9] == null) {\n        data[9] = source[9];\n      }\n      // Use source `func` and merge bitmasks.\n      data[0] = source[0];\n      data[1] = newBitmask;\n\n      return data;\n    }\n\n    /**\n     * Used by `_.defaultsDeep` to customize its `_.merge` use.\n     *\n     * @private\n     * @param {*} objValue The destination value.\n     * @param {*} srcValue The source value.\n     * @param {string} key The key of the property to merge.\n     * @param {Object} object The parent object of `objValue`.\n     * @param {Object} source The parent object of `srcValue`.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     * @returns {*} Returns the value to assign.\n     */\n    function mergeDefaults(objValue, srcValue, key, object, source, stack) {\n      if (isObject(objValue) && isObject(srcValue)) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, objValue);\n        baseMerge(objValue, srcValue, undefined, mergeDefaults, stack);\n        stack['delete'](srcValue);\n      }\n      return objValue;\n    }\n\n    /**\n     * This function is like\n     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n     * except that it includes inherited enumerable properties.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function nativeKeysIn(object) {\n      var result = [];\n      if (object != null) {\n        for (var key in Object(object)) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Converts `value` to a string using `Object.prototype.toString`.\n     *\n     * @private\n     * @param {*} value The value to convert.\n     * @returns {string} Returns the converted string.\n     */\n    function objectToString(value) {\n      return nativeObjectToString.call(value);\n    }\n\n    /**\n     * A specialized version of `baseRest` which transforms the rest array.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @param {Function} transform The rest array transform.\n     * @returns {Function} Returns the new function.\n     */\n    function overRest(func, start, transform) {\n      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n      return function() {\n        var args = arguments,\n            index = -1,\n            length = nativeMax(args.length - start, 0),\n            array = Array(length);\n\n        while (++index < length) {\n          array[index] = args[start + index];\n        }\n        index = -1;\n        var otherArgs = Array(start + 1);\n        while (++index < start) {\n          otherArgs[index] = args[index];\n        }\n        otherArgs[start] = transform(array);\n        return apply(func, this, otherArgs);\n      };\n    }\n\n    /**\n     * Gets the parent value at `path` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array} path The path to get the parent value of.\n     * @returns {*} Returns the parent value.\n     */\n    function parent(object, path) {\n      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));\n    }\n\n    /**\n     * Reorder `array` according to the specified indexes where the element at\n     * the first index is assigned as the first element, the element at\n     * the second index is assigned as the second element, and so on.\n     *\n     * @private\n     * @param {Array} array The array to reorder.\n     * @param {Array} indexes The arranged array indexes.\n     * @returns {Array} Returns `array`.\n     */\n    function reorder(array, indexes) {\n      var arrLength = array.length,\n          length = nativeMin(indexes.length, arrLength),\n          oldArray = copyArray(array);\n\n      while (length--) {\n        var index = indexes[length];\n        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;\n      }\n      return array;\n    }\n\n    /**\n     * Sets metadata for `func`.\n     *\n     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short\n     * period of time, it will trip its breaker and transition to an identity\n     * function to avoid garbage collection pauses in V8. See\n     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)\n     * for more details.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var setData = shortOut(baseSetData);\n\n    /**\n     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @returns {number|Object} Returns the timer id or timeout object.\n     */\n    var setTimeout = ctxSetTimeout || function(func, wait) {\n      return root.setTimeout(func, wait);\n    };\n\n    /**\n     * Sets the `toString` method of `func` to return `string`.\n     *\n     * @private\n     * @param {Function} func The function to modify.\n     * @param {Function} string The `toString` result.\n     * @returns {Function} Returns `func`.\n     */\n    var setToString = shortOut(baseSetToString);\n\n    /**\n     * Sets the `toString` method of `wrapper` to mimic the source of `reference`\n     * with wrapper details in a comment at the top of the source body.\n     *\n     * @private\n     * @param {Function} wrapper The function to modify.\n     * @param {Function} reference The reference function.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @returns {Function} Returns `wrapper`.\n     */\n    function setWrapToString(wrapper, reference, bitmask) {\n      var source = (reference + '');\n      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));\n    }\n\n    /**\n     * Creates a function that'll short out and invoke `identity` instead\n     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n     * milliseconds.\n     *\n     * @private\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new shortable function.\n     */\n    function shortOut(func) {\n      var count = 0,\n          lastCalled = 0;\n\n      return function() {\n        var stamp = nativeNow(),\n            remaining = HOT_SPAN - (stamp - lastCalled);\n\n        lastCalled = stamp;\n        if (remaining > 0) {\n          if (++count >= HOT_COUNT) {\n            return arguments[0];\n          }\n        } else {\n          count = 0;\n        }\n        return func.apply(undefined, arguments);\n      };\n    }\n\n    /**\n     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.\n     *\n     * @private\n     * @param {Array} array The array to shuffle.\n     * @param {number} [size=array.length] The size of `array`.\n     * @returns {Array} Returns `array`.\n     */\n    function shuffleSelf(array, size) {\n      var index = -1,\n          length = array.length,\n          lastIndex = length - 1;\n\n      size = size === undefined ? length : size;\n      while (++index < size) {\n        var rand = baseRandom(index, lastIndex),\n            value = array[rand];\n\n        array[rand] = array[index];\n        array[index] = value;\n      }\n      array.length = size;\n      return array;\n    }\n\n    /**\n     * Converts `string` to a property path array.\n     *\n     * @private\n     * @param {string} string The string to convert.\n     * @returns {Array} Returns the property path array.\n     */\n    var stringToPath = memoizeCapped(function(string) {\n      var result = [];\n      if (reLeadingDot.test(string)) {\n        result.push('');\n      }\n      string.replace(rePropName, function(match, number, quote, string) {\n        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n      });\n      return result;\n    });\n\n    /**\n     * Converts `value` to a string key if it's not a string or symbol.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {string|symbol} Returns the key.\n     */\n    function toKey(value) {\n      if (typeof value == 'string' || isSymbol(value)) {\n        return value;\n      }\n      var result = (value + '');\n      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n    }\n\n    /**\n     * Converts `func` to its source code.\n     *\n     * @private\n     * @param {Function} func The function to convert.\n     * @returns {string} Returns the source code.\n     */\n    function toSource(func) {\n      if (func != null) {\n        try {\n          return funcToString.call(func);\n        } catch (e) {}\n        try {\n          return (func + '');\n        } catch (e) {}\n      }\n      return '';\n    }\n\n    /**\n     * Updates wrapper `details` based on `bitmask` flags.\n     *\n     * @private\n     * @returns {Array} details The details to modify.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @returns {Array} Returns `details`.\n     */\n    function updateWrapDetails(details, bitmask) {\n      arrayEach(wrapFlags, function(pair) {\n        var value = '_.' + pair[0];\n        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {\n          details.push(value);\n        }\n      });\n      return details.sort();\n    }\n\n    /**\n     * Creates a clone of `wrapper`.\n     *\n     * @private\n     * @param {Object} wrapper The wrapper to clone.\n     * @returns {Object} Returns the cloned wrapper.\n     */\n    function wrapperClone(wrapper) {\n      if (wrapper instanceof LazyWrapper) {\n        return wrapper.clone();\n      }\n      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);\n      result.__actions__ = copyArray(wrapper.__actions__);\n      result.__index__  = wrapper.__index__;\n      result.__values__ = wrapper.__values__;\n      return result;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of elements split into groups the length of `size`.\n     * If `array` can't be split evenly, the final chunk will be the remaining\n     * elements.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to process.\n     * @param {number} [size=1] The length of each chunk\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the new array of chunks.\n     * @example\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 2);\n     * // => [['a', 'b'], ['c', 'd']]\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 3);\n     * // => [['a', 'b', 'c'], ['d']]\n     */\n    function chunk(array, size, guard) {\n      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {\n        size = 1;\n      } else {\n        size = nativeMax(toInteger(size), 0);\n      }\n      var length = array == null ? 0 : array.length;\n      if (!length || size < 1) {\n        return [];\n      }\n      var index = 0,\n          resIndex = 0,\n          result = Array(nativeCeil(length / size));\n\n      while (index < length) {\n        result[resIndex++] = baseSlice(array, index, (index += size));\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array with all falsey values removed. The values `false`, `null`,\n     * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to compact.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.compact([0, 1, false, 2, '', 3]);\n     * // => [1, 2, 3]\n     */\n    function compact(array) {\n      var index = -1,\n          length = array == null ? 0 : array.length,\n          resIndex = 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n        if (value) {\n          result[resIndex++] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates a new array concatenating `array` with any additional arrays\n     * and/or values.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to concatenate.\n     * @param {...*} [values] The values to concatenate.\n     * @returns {Array} Returns the new concatenated array.\n     * @example\n     *\n     * var array = [1];\n     * var other = _.concat(array, 2, [3], [[4]]);\n     *\n     * console.log(other);\n     * // => [1, 2, 3, [4]]\n     *\n     * console.log(array);\n     * // => [1]\n     */\n    function concat() {\n      var length = arguments.length;\n      if (!length) {\n        return [];\n      }\n      var args = Array(length - 1),\n          array = arguments[0],\n          index = length;\n\n      while (index--) {\n        args[index - 1] = arguments[index];\n      }\n      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));\n    }\n\n    /**\n     * Creates an array of `array` values not included in the other given arrays\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. The order and references of result values are\n     * determined by the first array.\n     *\n     * **Note:** Unlike `_.pullAll`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.without, _.xor\n     * @example\n     *\n     * _.difference([2, 1], [2, 3]);\n     * // => [1]\n     */\n    var difference = baseRest(function(array, values) {\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))\n        : [];\n    });\n\n    /**\n     * This method is like `_.difference` except that it accepts `iteratee` which\n     * is invoked for each element of `array` and `values` to generate the criterion\n     * by which they're compared. The order and references of result values are\n     * determined by the first array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');\n     * // => [{ 'x': 2 }]\n     */\n    var differenceBy = baseRest(function(array, values) {\n      var iteratee = last(values);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))\n        : [];\n    });\n\n    /**\n     * This method is like `_.difference` except that it accepts `comparator`\n     * which is invoked to compare elements of `array` to `values`. The order and\n     * references of result values are determined by the first array. The comparator\n     * is invoked with two arguments: (arrVal, othVal).\n     *\n     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     *\n     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);\n     * // => [{ 'x': 2, 'y': 1 }]\n     */\n    var differenceWith = baseRest(function(array, values) {\n      var comparator = last(values);\n      if (isArrayLikeObject(comparator)) {\n        comparator = undefined;\n      }\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)\n        : [];\n    });\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.drop([1, 2, 3]);\n     * // => [2, 3]\n     *\n     * _.drop([1, 2, 3], 2);\n     * // => [3]\n     *\n     * _.drop([1, 2, 3], 5);\n     * // => []\n     *\n     * _.drop([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function drop(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      return baseSlice(array, n < 0 ? 0 : n, length);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the end.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.dropRight([1, 2, 3]);\n     * // => [1, 2]\n     *\n     * _.dropRight([1, 2, 3], 2);\n     * // => [1]\n     *\n     * _.dropRight([1, 2, 3], 5);\n     * // => []\n     *\n     * _.dropRight([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function dropRight(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      n = length - n;\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the end.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.dropRightWhile(users, function(o) { return !o.active; });\n     * // => objects for ['barney']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.dropRightWhile(users, ['active', false]);\n     * // => objects for ['barney']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.dropRightWhile(users, 'active');\n     * // => objects for ['barney', 'fred', 'pebbles']\n     */\n    function dropRightWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), true, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the beginning.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.dropWhile(users, function(o) { return !o.active; });\n     * // => objects for ['pebbles']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.dropWhile(users, { 'user': 'barney', 'active': false });\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.dropWhile(users, ['active', false]);\n     * // => objects for ['pebbles']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.dropWhile(users, 'active');\n     * // => objects for ['barney', 'fred', 'pebbles']\n     */\n    function dropWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), true)\n        : [];\n    }\n\n    /**\n     * Fills elements of `array` with `value` from `start` up to, but not\n     * including, `end`.\n     *\n     * **Note:** This method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Array\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.fill(array, 'a');\n     * console.log(array);\n     * // => ['a', 'a', 'a']\n     *\n     * _.fill(Array(3), 2);\n     * // => [2, 2, 2]\n     *\n     * _.fill([4, 6, 8, 10], '*', 1, 3);\n     * // => [4, '*', '*', 10]\n     */\n    function fill(array, value, start, end) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {\n        start = 0;\n        end = length;\n      }\n      return baseFill(array, value, start, end);\n    }\n\n    /**\n     * This method is like `_.find` except that it returns the index of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.findIndex(users, function(o) { return o.user == 'barney'; });\n     * // => 0\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findIndex(users, { 'user': 'fred', 'active': false });\n     * // => 1\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findIndex(users, ['active', false]);\n     * // => 0\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findIndex(users, 'active');\n     * // => 2\n     */\n    function findIndex(array, predicate, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n      if (index < 0) {\n        index = nativeMax(length + index, 0);\n      }\n      return baseFindIndex(array, getIteratee(predicate, 3), index);\n    }\n\n    /**\n     * This method is like `_.findIndex` except that it iterates over elements\n     * of `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });\n     * // => 2\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findLastIndex(users, { 'user': 'barney', 'active': true });\n     * // => 0\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findLastIndex(users, ['active', false]);\n     * // => 2\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findLastIndex(users, 'active');\n     * // => 0\n     */\n    function findLastIndex(array, predicate, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = length - 1;\n      if (fromIndex !== undefined) {\n        index = toInteger(fromIndex);\n        index = fromIndex < 0\n          ? nativeMax(length + index, 0)\n          : nativeMin(index, length - 1);\n      }\n      return baseFindIndex(array, getIteratee(predicate, 3), index, true);\n    }\n\n    /**\n     * Flattens `array` a single level deep.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flatten([1, [2, [3, [4]], 5]]);\n     * // => [1, 2, [3, [4]], 5]\n     */\n    function flatten(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseFlatten(array, 1) : [];\n    }\n\n    /**\n     * Recursively flattens `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flattenDeep([1, [2, [3, [4]], 5]]);\n     * // => [1, 2, 3, 4, 5]\n     */\n    function flattenDeep(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseFlatten(array, INFINITY) : [];\n    }\n\n    /**\n     * Recursively flatten `array` up to `depth` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.4.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @param {number} [depth=1] The maximum recursion depth.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * var array = [1, [2, [3, [4]], 5]];\n     *\n     * _.flattenDepth(array, 1);\n     * // => [1, 2, [3, [4]], 5]\n     *\n     * _.flattenDepth(array, 2);\n     * // => [1, 2, 3, [4], 5]\n     */\n    function flattenDepth(array, depth) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      depth = depth === undefined ? 1 : toInteger(depth);\n      return baseFlatten(array, depth);\n    }\n\n    /**\n     * The inverse of `_.toPairs`; this method returns an object composed\n     * from key-value `pairs`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} pairs The key-value pairs.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.fromPairs([['a', 1], ['b', 2]]);\n     * // => { 'a': 1, 'b': 2 }\n     */\n    function fromPairs(pairs) {\n      var index = -1,\n          length = pairs == null ? 0 : pairs.length,\n          result = {};\n\n      while (++index < length) {\n        var pair = pairs[index];\n        result[pair[0]] = pair[1];\n      }\n      return result;\n    }\n\n    /**\n     * Gets the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @alias first\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the first element of `array`.\n     * @example\n     *\n     * _.head([1, 2, 3]);\n     * // => 1\n     *\n     * _.head([]);\n     * // => undefined\n     */\n    function head(array) {\n      return (array && array.length) ? array[0] : undefined;\n    }\n\n    /**\n     * Gets the index at which the first occurrence of `value` is found in `array`\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. If `fromIndex` is negative, it's used as the\n     * offset from the end of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.indexOf([1, 2, 1, 2], 2);\n     * // => 1\n     *\n     * // Search from the `fromIndex`.\n     * _.indexOf([1, 2, 1, 2], 2, 2);\n     * // => 3\n     */\n    function indexOf(array, value, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n      if (index < 0) {\n        index = nativeMax(length + index, 0);\n      }\n      return baseIndexOf(array, value, index);\n    }\n\n    /**\n     * Gets all but the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.initial([1, 2, 3]);\n     * // => [1, 2]\n     */\n    function initial(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseSlice(array, 0, -1) : [];\n    }\n\n    /**\n     * Creates an array of unique values that are included in all given arrays\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. The order and references of result values are\n     * determined by the first array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * _.intersection([2, 1], [2, 3]);\n     * // => [2]\n     */\n    var intersection = baseRest(function(arrays) {\n      var mapped = arrayMap(arrays, castArrayLikeObject);\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped)\n        : [];\n    });\n\n    /**\n     * This method is like `_.intersection` except that it accepts `iteratee`\n     * which is invoked for each element of each `arrays` to generate the criterion\n     * by which they're compared. The order and references of result values are\n     * determined by the first array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [2.1]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }]\n     */\n    var intersectionBy = baseRest(function(arrays) {\n      var iteratee = last(arrays),\n          mapped = arrayMap(arrays, castArrayLikeObject);\n\n      if (iteratee === last(mapped)) {\n        iteratee = undefined;\n      } else {\n        mapped.pop();\n      }\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped, getIteratee(iteratee, 2))\n        : [];\n    });\n\n    /**\n     * This method is like `_.intersection` except that it accepts `comparator`\n     * which is invoked to compare elements of `arrays`. The order and references\n     * of result values are determined by the first array. The comparator is\n     * invoked with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.intersectionWith(objects, others, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }]\n     */\n    var intersectionWith = baseRest(function(arrays) {\n      var comparator = last(arrays),\n          mapped = arrayMap(arrays, castArrayLikeObject);\n\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      if (comparator) {\n        mapped.pop();\n      }\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped, undefined, comparator)\n        : [];\n    });\n\n    /**\n     * Converts all elements in `array` into a string separated by `separator`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to convert.\n     * @param {string} [separator=','] The element separator.\n     * @returns {string} Returns the joined string.\n     * @example\n     *\n     * _.join(['a', 'b', 'c'], '~');\n     * // => 'a~b~c'\n     */\n    function join(array, separator) {\n      return array == null ? '' : nativeJoin.call(array, separator);\n    }\n\n    /**\n     * Gets the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the last element of `array`.\n     * @example\n     *\n     * _.last([1, 2, 3]);\n     * // => 3\n     */\n    function last(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? array[length - 1] : undefined;\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it iterates over elements of\n     * `array` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.lastIndexOf([1, 2, 1, 2], 2);\n     * // => 3\n     *\n     * // Search from the `fromIndex`.\n     * _.lastIndexOf([1, 2, 1, 2], 2, 2);\n     * // => 1\n     */\n    function lastIndexOf(array, value, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = length;\n      if (fromIndex !== undefined) {\n        index = toInteger(fromIndex);\n        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);\n      }\n      return value === value\n        ? strictLastIndexOf(array, value, index)\n        : baseFindIndex(array, baseIsNaN, index, true);\n    }\n\n    /**\n     * Gets the element at index `n` of `array`. If `n` is negative, the nth\n     * element from the end is returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.11.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=0] The index of the element to return.\n     * @returns {*} Returns the nth element of `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'd'];\n     *\n     * _.nth(array, 1);\n     * // => 'b'\n     *\n     * _.nth(array, -2);\n     * // => 'c';\n     */\n    function nth(array, n) {\n      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;\n    }\n\n    /**\n     * Removes all given values from `array` using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`\n     * to remove elements from an array by predicate.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...*} [values] The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n     *\n     * _.pull(array, 'a', 'c');\n     * console.log(array);\n     * // => ['b', 'b']\n     */\n    var pull = baseRest(pullAll);\n\n    /**\n     * This method is like `_.pull` except that it accepts an array of values to remove.\n     *\n     * **Note:** Unlike `_.difference`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n     *\n     * _.pullAll(array, ['a', 'c']);\n     * console.log(array);\n     * // => ['b', 'b']\n     */\n    function pullAll(array, values) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values)\n        : array;\n    }\n\n    /**\n     * This method is like `_.pullAll` except that it accepts `iteratee` which is\n     * invoked for each element of `array` and `values` to generate the criterion\n     * by which they're compared. The iteratee is invoked with one argument: (value).\n     *\n     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];\n     *\n     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');\n     * console.log(array);\n     * // => [{ 'x': 2 }]\n     */\n    function pullAllBy(array, values, iteratee) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values, getIteratee(iteratee, 2))\n        : array;\n    }\n\n    /**\n     * This method is like `_.pullAll` except that it accepts `comparator` which\n     * is invoked to compare elements of `array` to `values`. The comparator is\n     * invoked with two arguments: (arrVal, othVal).\n     *\n     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];\n     *\n     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);\n     * console.log(array);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]\n     */\n    function pullAllWith(array, values, comparator) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values, undefined, comparator)\n        : array;\n    }\n\n    /**\n     * Removes elements from `array` corresponding to `indexes` and returns an\n     * array of removed elements.\n     *\n     * **Note:** Unlike `_.at`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...(number|number[])} [indexes] The indexes of elements to remove.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'd'];\n     * var pulled = _.pullAt(array, [1, 3]);\n     *\n     * console.log(array);\n     * // => ['a', 'c']\n     *\n     * console.log(pulled);\n     * // => ['b', 'd']\n     */\n    var pullAt = flatRest(function(array, indexes) {\n      var length = array == null ? 0 : array.length,\n          result = baseAt(array, indexes);\n\n      basePullAt(array, arrayMap(indexes, function(index) {\n        return isIndex(index, length) ? +index : index;\n      }).sort(compareAscending));\n\n      return result;\n    });\n\n    /**\n     * Removes all elements from `array` that `predicate` returns truthy for\n     * and returns an array of the removed elements. The predicate is invoked\n     * with three arguments: (value, index, array).\n     *\n     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`\n     * to pull elements from an array by value.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = [1, 2, 3, 4];\n     * var evens = _.remove(array, function(n) {\n     *   return n % 2 == 0;\n     * });\n     *\n     * console.log(array);\n     * // => [1, 3]\n     *\n     * console.log(evens);\n     * // => [2, 4]\n     */\n    function remove(array, predicate) {\n      var result = [];\n      if (!(array && array.length)) {\n        return result;\n      }\n      var index = -1,\n          indexes = [],\n          length = array.length;\n\n      predicate = getIteratee(predicate, 3);\n      while (++index < length) {\n        var value = array[index];\n        if (predicate(value, index, array)) {\n          result.push(value);\n          indexes.push(index);\n        }\n      }\n      basePullAt(array, indexes);\n      return result;\n    }\n\n    /**\n     * Reverses `array` so that the first element becomes the last, the second\n     * element becomes the second to last, and so on.\n     *\n     * **Note:** This method mutates `array` and is based on\n     * [`Array#reverse`](https://mdn.io/Array/reverse).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.reverse(array);\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function reverse(array) {\n      return array == null ? array : nativeReverse.call(array);\n    }\n\n    /**\n     * Creates a slice of `array` from `start` up to, but not including, `end`.\n     *\n     * **Note:** This method is used instead of\n     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are\n     * returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function slice(array, start, end) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {\n        start = 0;\n        end = length;\n      }\n      else {\n        start = start == null ? 0 : toInteger(start);\n        end = end === undefined ? length : toInteger(end);\n      }\n      return baseSlice(array, start, end);\n    }\n\n    /**\n     * Uses a binary search to determine the lowest index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedIndex([30, 50], 40);\n     * // => 1\n     */\n    function sortedIndex(array, value) {\n      return baseSortedIndex(array, value);\n    }\n\n    /**\n     * This method is like `_.sortedIndex` except that it accepts `iteratee`\n     * which is invoked for `value` and each element of `array` to compute their\n     * sort ranking. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * var objects = [{ 'x': 4 }, { 'x': 5 }];\n     *\n     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n     * // => 0\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');\n     * // => 0\n     */\n    function sortedIndexBy(array, value, iteratee) {\n      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it performs a binary\n     * search on a sorted `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);\n     * // => 1\n     */\n    function sortedIndexOf(array, value) {\n      var length = array == null ? 0 : array.length;\n      if (length) {\n        var index = baseSortedIndex(array, value);\n        if (index < length && eq(array[index], value)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.sortedIndex` except that it returns the highest\n     * index at which `value` should be inserted into `array` in order to\n     * maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);\n     * // => 4\n     */\n    function sortedLastIndex(array, value) {\n      return baseSortedIndex(array, value, true);\n    }\n\n    /**\n     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`\n     * which is invoked for `value` and each element of `array` to compute their\n     * sort ranking. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * var objects = [{ 'x': 4 }, { 'x': 5 }];\n     *\n     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n     * // => 1\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');\n     * // => 1\n     */\n    function sortedLastIndexBy(array, value, iteratee) {\n      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);\n    }\n\n    /**\n     * This method is like `_.lastIndexOf` except that it performs a binary\n     * search on a sorted `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);\n     * // => 3\n     */\n    function sortedLastIndexOf(array, value) {\n      var length = array == null ? 0 : array.length;\n      if (length) {\n        var index = baseSortedIndex(array, value, true) - 1;\n        if (eq(array[index], value)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.uniq` except that it's designed and optimized\n     * for sorted arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.sortedUniq([1, 1, 2]);\n     * // => [1, 2]\n     */\n    function sortedUniq(array) {\n      return (array && array.length)\n        ? baseSortedUniq(array)\n        : [];\n    }\n\n    /**\n     * This method is like `_.uniqBy` except that it's designed and optimized\n     * for sorted arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);\n     * // => [1.1, 2.3]\n     */\n    function sortedUniqBy(array, iteratee) {\n      return (array && array.length)\n        ? baseSortedUniq(array, getIteratee(iteratee, 2))\n        : [];\n    }\n\n    /**\n     * Gets all but the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.tail([1, 2, 3]);\n     * // => [2, 3]\n     */\n    function tail(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseSlice(array, 1, length) : [];\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.take([1, 2, 3]);\n     * // => [1]\n     *\n     * _.take([1, 2, 3], 2);\n     * // => [1, 2]\n     *\n     * _.take([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.take([1, 2, 3], 0);\n     * // => []\n     */\n    function take(array, n, guard) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the end.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.takeRight([1, 2, 3]);\n     * // => [3]\n     *\n     * _.takeRight([1, 2, 3], 2);\n     * // => [2, 3]\n     *\n     * _.takeRight([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.takeRight([1, 2, 3], 0);\n     * // => []\n     */\n    function takeRight(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      n = length - n;\n      return baseSlice(array, n < 0 ? 0 : n, length);\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the end. Elements are\n     * taken until `predicate` returns falsey. The predicate is invoked with\n     * three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.takeRightWhile(users, function(o) { return !o.active; });\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });\n     * // => objects for ['pebbles']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.takeRightWhile(users, ['active', false]);\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.takeRightWhile(users, 'active');\n     * // => []\n     */\n    function takeRightWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), false, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the beginning. Elements\n     * are taken until `predicate` returns falsey. The predicate is invoked with\n     * three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false},\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.takeWhile(users, function(o) { return !o.active; });\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.takeWhile(users, { 'user': 'barney', 'active': false });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.takeWhile(users, ['active', false]);\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.takeWhile(users, 'active');\n     * // => []\n     */\n    function takeWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3))\n        : [];\n    }\n\n    /**\n     * Creates an array of unique values, in order, from all given arrays using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.union([2], [1, 2]);\n     * // => [2, 1]\n     */\n    var union = baseRest(function(arrays) {\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));\n    });\n\n    /**\n     * This method is like `_.union` except that it accepts `iteratee` which is\n     * invoked for each element of each `arrays` to generate the criterion by\n     * which uniqueness is computed. Result values are chosen from the first\n     * array in which the value occurs. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.unionBy([2.1], [1.2, 2.3], Math.floor);\n     * // => [2.1, 1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    var unionBy = baseRest(function(arrays) {\n      var iteratee = last(arrays);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));\n    });\n\n    /**\n     * This method is like `_.union` except that it accepts `comparator` which\n     * is invoked to compare elements of `arrays`. Result values are chosen from\n     * the first array in which the value occurs. The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.unionWith(objects, others, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n     */\n    var unionWith = baseRest(function(arrays) {\n      var comparator = last(arrays);\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);\n    });\n\n    /**\n     * Creates a duplicate-free version of an array, using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons, in which only the first occurrence of each element\n     * is kept. The order of result values is determined by the order they occur\n     * in the array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.uniq([2, 1, 2]);\n     * // => [2, 1]\n     */\n    function uniq(array) {\n      return (array && array.length) ? baseUniq(array) : [];\n    }\n\n    /**\n     * This method is like `_.uniq` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * uniqueness is computed. The order of result values is determined by the\n     * order they occur in the array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n     * // => [2.1, 1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    function uniqBy(array, iteratee) {\n      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];\n    }\n\n    /**\n     * This method is like `_.uniq` except that it accepts `comparator` which\n     * is invoked to compare elements of `array`. The order of result values is\n     * determined by the order they occur in the array.The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.uniqWith(objects, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]\n     */\n    function uniqWith(array, comparator) {\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts an array of grouped\n     * elements and creates an array regrouping the elements to their pre-zip\n     * configuration.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.2.0\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);\n     * // => [['a', 1, true], ['b', 2, false]]\n     *\n     * _.unzip(zipped);\n     * // => [['a', 'b'], [1, 2], [true, false]]\n     */\n    function unzip(array) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      var length = 0;\n      array = arrayFilter(array, function(group) {\n        if (isArrayLikeObject(group)) {\n          length = nativeMax(group.length, length);\n          return true;\n        }\n      });\n      return baseTimes(length, function(index) {\n        return arrayMap(array, baseProperty(index));\n      });\n    }\n\n    /**\n     * This method is like `_.unzip` except that it accepts `iteratee` to specify\n     * how regrouped values should be combined. The iteratee is invoked with the\n     * elements of each group: (...group).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @param {Function} [iteratee=_.identity] The function to combine\n     *  regrouped values.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);\n     * // => [[1, 10, 100], [2, 20, 200]]\n     *\n     * _.unzipWith(zipped, _.add);\n     * // => [3, 30, 300]\n     */\n    function unzipWith(array, iteratee) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      var result = unzip(array);\n      if (iteratee == null) {\n        return result;\n      }\n      return arrayMap(result, function(group) {\n        return apply(iteratee, undefined, group);\n      });\n    }\n\n    /**\n     * Creates an array excluding all given values using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * **Note:** Unlike `_.pull`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...*} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.difference, _.xor\n     * @example\n     *\n     * _.without([2, 1, 2, 3], 1, 2);\n     * // => [3]\n     */\n    var without = baseRest(function(array, values) {\n      return isArrayLikeObject(array)\n        ? baseDifference(array, values)\n        : [];\n    });\n\n    /**\n     * Creates an array of unique values that is the\n     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)\n     * of the given arrays. The order of result values is determined by the order\n     * they occur in the arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.difference, _.without\n     * @example\n     *\n     * _.xor([2, 1], [2, 3]);\n     * // => [1, 3]\n     */\n    var xor = baseRest(function(arrays) {\n      return baseXor(arrayFilter(arrays, isArrayLikeObject));\n    });\n\n    /**\n     * This method is like `_.xor` except that it accepts `iteratee` which is\n     * invoked for each element of each `arrays` to generate the criterion by\n     * which by which they're compared. The order of result values is determined\n     * by the order they occur in the arrays. The iteratee is invoked with one\n     * argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [1.2, 3.4]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 2 }]\n     */\n    var xorBy = baseRest(function(arrays) {\n      var iteratee = last(arrays);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));\n    });\n\n    /**\n     * This method is like `_.xor` except that it accepts `comparator` which is\n     * invoked to compare elements of `arrays`. The order of result values is\n     * determined by the order they occur in the arrays. The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.xorWith(objects, others, _.isEqual);\n     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n     */\n    var xorWith = baseRest(function(arrays) {\n      var comparator = last(arrays);\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);\n    });\n\n    /**\n     * Creates an array of grouped elements, the first of which contains the\n     * first elements of the given arrays, the second of which contains the\n     * second elements of the given arrays, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zip(['a', 'b'], [1, 2], [true, false]);\n     * // => [['a', 1, true], ['b', 2, false]]\n     */\n    var zip = baseRest(unzip);\n\n    /**\n     * This method is like `_.fromPairs` except that it accepts two arrays,\n     * one of property identifiers and one of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.4.0\n     * @category Array\n     * @param {Array} [props=[]] The property identifiers.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObject(['a', 'b'], [1, 2]);\n     * // => { 'a': 1, 'b': 2 }\n     */\n    function zipObject(props, values) {\n      return baseZipObject(props || [], values || [], assignValue);\n    }\n\n    /**\n     * This method is like `_.zipObject` except that it supports property paths.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.1.0\n     * @category Array\n     * @param {Array} [props=[]] The property identifiers.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);\n     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }\n     */\n    function zipObjectDeep(props, values) {\n      return baseZipObject(props || [], values || [], baseSet);\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts `iteratee` to specify\n     * how grouped values should be combined. The iteratee is invoked with the\n     * elements of each group: (...group).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @param {Function} [iteratee=_.identity] The function to combine\n     *  grouped values.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {\n     *   return a + b + c;\n     * });\n     * // => [111, 222]\n     */\n    var zipWith = baseRest(function(arrays) {\n      var length = arrays.length,\n          iteratee = length > 1 ? arrays[length - 1] : undefined;\n\n      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;\n      return unzipWith(arrays, iteratee);\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` wrapper instance that wraps `value` with explicit method\n     * chain sequences enabled. The result of such sequences must be unwrapped\n     * with `_#value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.3.0\n     * @category Seq\n     * @param {*} value The value to wrap.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36 },\n     *   { 'user': 'fred',    'age': 40 },\n     *   { 'user': 'pebbles', 'age': 1 }\n     * ];\n     *\n     * var youngest = _\n     *   .chain(users)\n     *   .sortBy('age')\n     *   .map(function(o) {\n     *     return o.user + ' is ' + o.age;\n     *   })\n     *   .head()\n     *   .value();\n     * // => 'pebbles is 1'\n     */\n    function chain(value) {\n      var result = lodash(value);\n      result.__chain__ = true;\n      return result;\n    }\n\n    /**\n     * This method invokes `interceptor` and returns `value`. The interceptor\n     * is invoked with one argument; (value). The purpose of this method is to\n     * \"tap into\" a method chain sequence in order to modify intermediate results.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * _([1, 2, 3])\n     *  .tap(function(array) {\n     *    // Mutate input array.\n     *    array.pop();\n     *  })\n     *  .reverse()\n     *  .value();\n     * // => [2, 1]\n     */\n    function tap(value, interceptor) {\n      interceptor(value);\n      return value;\n    }\n\n    /**\n     * This method is like `_.tap` except that it returns the result of `interceptor`.\n     * The purpose of this method is to \"pass thru\" values replacing intermediate\n     * results in a method chain sequence.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Seq\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns the result of `interceptor`.\n     * @example\n     *\n     * _('  abc  ')\n     *  .chain()\n     *  .trim()\n     *  .thru(function(value) {\n     *    return [value];\n     *  })\n     *  .value();\n     * // => ['abc']\n     */\n    function thru(value, interceptor) {\n      return interceptor(value);\n    }\n\n    /**\n     * This method is the wrapper version of `_.at`.\n     *\n     * @name at\n     * @memberOf _\n     * @since 1.0.0\n     * @category Seq\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n     *\n     * _(object).at(['a[0].b.c', 'a[1]']).value();\n     * // => [3, 4]\n     */\n    var wrapperAt = flatRest(function(paths) {\n      var length = paths.length,\n          start = length ? paths[0] : 0,\n          value = this.__wrapped__,\n          interceptor = function(object) { return baseAt(object, paths); };\n\n      if (length > 1 || this.__actions__.length ||\n          !(value instanceof LazyWrapper) || !isIndex(start)) {\n        return this.thru(interceptor);\n      }\n      value = value.slice(start, +start + (length ? 1 : 0));\n      value.__actions__.push({\n        'func': thru,\n        'args': [interceptor],\n        'thisArg': undefined\n      });\n      return new LodashWrapper(value, this.__chain__).thru(function(array) {\n        if (length && !array.length) {\n          array.push(undefined);\n        }\n        return array;\n      });\n    });\n\n    /**\n     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.\n     *\n     * @name chain\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * // A sequence without explicit chaining.\n     * _(users).head();\n     * // => { 'user': 'barney', 'age': 36 }\n     *\n     * // A sequence with explicit chaining.\n     * _(users)\n     *   .chain()\n     *   .head()\n     *   .pick('user')\n     *   .value();\n     * // => { 'user': 'barney' }\n     */\n    function wrapperChain() {\n      return chain(this);\n    }\n\n    /**\n     * Executes the chain sequence and returns the wrapped result.\n     *\n     * @name commit\n     * @memberOf _\n     * @since 3.2.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2];\n     * var wrapped = _(array).push(3);\n     *\n     * console.log(array);\n     * // => [1, 2]\n     *\n     * wrapped = wrapped.commit();\n     * console.log(array);\n     * // => [1, 2, 3]\n     *\n     * wrapped.last();\n     * // => 3\n     *\n     * console.log(array);\n     * // => [1, 2, 3]\n     */\n    function wrapperCommit() {\n      return new LodashWrapper(this.value(), this.__chain__);\n    }\n\n    /**\n     * Gets the next value on a wrapped object following the\n     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).\n     *\n     * @name next\n     * @memberOf _\n     * @since 4.0.0\n     * @category Seq\n     * @returns {Object} Returns the next iterator value.\n     * @example\n     *\n     * var wrapped = _([1, 2]);\n     *\n     * wrapped.next();\n     * // => { 'done': false, 'value': 1 }\n     *\n     * wrapped.next();\n     * // => { 'done': false, 'value': 2 }\n     *\n     * wrapped.next();\n     * // => { 'done': true, 'value': undefined }\n     */\n    function wrapperNext() {\n      if (this.__values__ === undefined) {\n        this.__values__ = toArray(this.value());\n      }\n      var done = this.__index__ >= this.__values__.length,\n          value = done ? undefined : this.__values__[this.__index__++];\n\n      return { 'done': done, 'value': value };\n    }\n\n    /**\n     * Enables the wrapper to be iterable.\n     *\n     * @name Symbol.iterator\n     * @memberOf _\n     * @since 4.0.0\n     * @category Seq\n     * @returns {Object} Returns the wrapper object.\n     * @example\n     *\n     * var wrapped = _([1, 2]);\n     *\n     * wrapped[Symbol.iterator]() === wrapped;\n     * // => true\n     *\n     * Array.from(wrapped);\n     * // => [1, 2]\n     */\n    function wrapperToIterator() {\n      return this;\n    }\n\n    /**\n     * Creates a clone of the chain sequence planting `value` as the wrapped value.\n     *\n     * @name plant\n     * @memberOf _\n     * @since 3.2.0\n     * @category Seq\n     * @param {*} value The value to plant.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var wrapped = _([1, 2]).map(square);\n     * var other = wrapped.plant([3, 4]);\n     *\n     * other.value();\n     * // => [9, 16]\n     *\n     * wrapped.value();\n     * // => [1, 4]\n     */\n    function wrapperPlant(value) {\n      var result,\n          parent = this;\n\n      while (parent instanceof baseLodash) {\n        var clone = wrapperClone(parent);\n        clone.__index__ = 0;\n        clone.__values__ = undefined;\n        if (result) {\n          previous.__wrapped__ = clone;\n        } else {\n          result = clone;\n        }\n        var previous = clone;\n        parent = parent.__wrapped__;\n      }\n      previous.__wrapped__ = value;\n      return result;\n    }\n\n    /**\n     * This method is the wrapper version of `_.reverse`.\n     *\n     * **Note:** This method mutates the wrapped array.\n     *\n     * @name reverse\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _(array).reverse().value()\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function wrapperReverse() {\n      var value = this.__wrapped__;\n      if (value instanceof LazyWrapper) {\n        var wrapped = value;\n        if (this.__actions__.length) {\n          wrapped = new LazyWrapper(this);\n        }\n        wrapped = wrapped.reverse();\n        wrapped.__actions__.push({\n          'func': thru,\n          'args': [reverse],\n          'thisArg': undefined\n        });\n        return new LodashWrapper(wrapped, this.__chain__);\n      }\n      return this.thru(reverse);\n    }\n\n    /**\n     * Executes the chain sequence to resolve the unwrapped value.\n     *\n     * @name value\n     * @memberOf _\n     * @since 0.1.0\n     * @alias toJSON, valueOf\n     * @category Seq\n     * @returns {*} Returns the resolved unwrapped value.\n     * @example\n     *\n     * _([1, 2, 3]).value();\n     * // => [1, 2, 3]\n     */\n    function wrapperValue() {\n      return baseWrapperValue(this.__wrapped__, this.__actions__);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The corresponding value of\n     * each key is the number of times the key was returned by `iteratee`. The\n     * iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.countBy([6.1, 4.2, 6.3], Math.floor);\n     * // => { '4': 1, '6': 2 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.countBy(['one', 'two', 'three'], 'length');\n     * // => { '3': 2, '5': 1 }\n     */\n    var countBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        ++result[key];\n      } else {\n        baseAssignValue(result, key, 1);\n      }\n    });\n\n    /**\n     * Checks if `predicate` returns truthy for **all** elements of `collection`.\n     * Iteration is stopped once `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * **Note:** This method returns `true` for\n     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because\n     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of\n     * elements of empty collections.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.every([true, 1, null, 'yes'], Boolean);\n     * // => false\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.every(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.every(users, ['active', false]);\n     * // => true\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.every(users, 'active');\n     * // => false\n     */\n    function every(collection, predicate, guard) {\n      var func = isArray(collection) ? arrayEvery : baseEvery;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = undefined;\n      }\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning an array of all elements\n     * `predicate` returns truthy for. The predicate is invoked with three\n     * arguments: (value, index|key, collection).\n     *\n     * **Note:** Unlike `_.remove`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     * @see _.reject\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * _.filter(users, function(o) { return !o.active; });\n     * // => objects for ['fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.filter(users, { 'age': 36, 'active': true });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.filter(users, ['active', false]);\n     * // => objects for ['fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.filter(users, 'active');\n     * // => objects for ['barney']\n     */\n    function filter(collection, predicate) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning the first element\n     * `predicate` returns truthy for. The predicate is invoked with three\n     * arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': true },\n     *   { 'user': 'fred',    'age': 40, 'active': false },\n     *   { 'user': 'pebbles', 'age': 1,  'active': true }\n     * ];\n     *\n     * _.find(users, function(o) { return o.age < 40; });\n     * // => object for 'barney'\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.find(users, { 'age': 1, 'active': true });\n     * // => object for 'pebbles'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.find(users, ['active', false]);\n     * // => object for 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.find(users, 'active');\n     * // => object for 'barney'\n     */\n    var find = createFind(findIndex);\n\n    /**\n     * This method is like `_.find` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=collection.length-1] The index to search from.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * _.findLast([1, 2, 3, 4], function(n) {\n     *   return n % 2 == 1;\n     * });\n     * // => 3\n     */\n    var findLast = createFind(findLastIndex);\n\n    /**\n     * Creates a flattened array of values by running each element in `collection`\n     * thru `iteratee` and flattening the mapped results. The iteratee is invoked\n     * with three arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [n, n];\n     * }\n     *\n     * _.flatMap([1, 2], duplicate);\n     * // => [1, 1, 2, 2]\n     */\n    function flatMap(collection, iteratee) {\n      return baseFlatten(map(collection, iteratee), 1);\n    }\n\n    /**\n     * This method is like `_.flatMap` except that it recursively flattens the\n     * mapped results.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [[[n, n]]];\n     * }\n     *\n     * _.flatMapDeep([1, 2], duplicate);\n     * // => [1, 1, 2, 2]\n     */\n    function flatMapDeep(collection, iteratee) {\n      return baseFlatten(map(collection, iteratee), INFINITY);\n    }\n\n    /**\n     * This method is like `_.flatMap` except that it recursively flattens the\n     * mapped results up to `depth` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {number} [depth=1] The maximum recursion depth.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [[[n, n]]];\n     * }\n     *\n     * _.flatMapDepth([1, 2], duplicate, 2);\n     * // => [[1, 1], [2, 2]]\n     */\n    function flatMapDepth(collection, iteratee, depth) {\n      depth = depth === undefined ? 1 : toInteger(depth);\n      return baseFlatten(map(collection, iteratee), depth);\n    }\n\n    /**\n     * Iterates over elements of `collection` and invokes `iteratee` for each element.\n     * The iteratee is invoked with three arguments: (value, index|key, collection).\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n     * property are iterated like arrays. To avoid this behavior use `_.forIn`\n     * or `_.forOwn` for object iteration.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @alias each\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     * @see _.forEachRight\n     * @example\n     *\n     * _.forEach([1, 2], function(value) {\n     *   console.log(value);\n     * });\n     * // => Logs `1` then `2`.\n     *\n     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n     */\n    function forEach(collection, iteratee) {\n      var func = isArray(collection) ? arrayEach : baseEach;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.forEach` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @alias eachRight\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     * @see _.forEach\n     * @example\n     *\n     * _.forEachRight([1, 2], function(value) {\n     *   console.log(value);\n     * });\n     * // => Logs `2` then `1`.\n     */\n    function forEachRight(collection, iteratee) {\n      var func = isArray(collection) ? arrayEachRight : baseEachRight;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The order of grouped values\n     * is determined by the order they occur in `collection`. The corresponding\n     * value of each key is an array of elements responsible for generating the\n     * key. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n     * // => { '4': [4.2], '6': [6.1, 6.3] }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.groupBy(['one', 'two', 'three'], 'length');\n     * // => { '3': ['one', 'two'], '5': ['three'] }\n     */\n    var groupBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        result[key].push(value);\n      } else {\n        baseAssignValue(result, key, [value]);\n      }\n    });\n\n    /**\n     * Checks if `value` is in `collection`. If `collection` is a string, it's\n     * checked for a substring of `value`, otherwise\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * is used for equality comparisons. If `fromIndex` is negative, it's used as\n     * the offset from the end of `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n     * @returns {boolean} Returns `true` if `value` is found, else `false`.\n     * @example\n     *\n     * _.includes([1, 2, 3], 1);\n     * // => true\n     *\n     * _.includes([1, 2, 3], 1, 2);\n     * // => false\n     *\n     * _.includes({ 'a': 1, 'b': 2 }, 1);\n     * // => true\n     *\n     * _.includes('abcd', 'bc');\n     * // => true\n     */\n    function includes(collection, value, fromIndex, guard) {\n      collection = isArrayLike(collection) ? collection : values(collection);\n      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\n\n      var length = collection.length;\n      if (fromIndex < 0) {\n        fromIndex = nativeMax(length + fromIndex, 0);\n      }\n      return isString(collection)\n        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\n        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\n    }\n\n    /**\n     * Invokes the method at `path` of each element in `collection`, returning\n     * an array of the results of each invoked method. Any additional arguments\n     * are provided to each invoked method. If `path` is a function, it's invoked\n     * for, and `this` bound to, each element in `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Array|Function|string} path The path of the method to invoke or\n     *  the function invoked per iteration.\n     * @param {...*} [args] The arguments to invoke each method with.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');\n     * // => [[1, 5, 7], [1, 2, 3]]\n     *\n     * _.invokeMap([123, 456], String.prototype.split, '');\n     * // => [['1', '2', '3'], ['4', '5', '6']]\n     */\n    var invokeMap = baseRest(function(collection, path, args) {\n      var index = -1,\n          isFunc = typeof path == 'function',\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value) {\n        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);\n      });\n      return result;\n    });\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The corresponding value of\n     * each key is the last element responsible for generating the key. The\n     * iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * var array = [\n     *   { 'dir': 'left', 'code': 97 },\n     *   { 'dir': 'right', 'code': 100 }\n     * ];\n     *\n     * _.keyBy(array, function(o) {\n     *   return String.fromCharCode(o.code);\n     * });\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.keyBy(array, 'dir');\n     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n     */\n    var keyBy = createAggregator(function(result, value, key) {\n      baseAssignValue(result, key, value);\n    });\n\n    /**\n     * Creates an array of values by running each element in `collection` thru\n     * `iteratee`. The iteratee is invoked with three arguments:\n     * (value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n     *\n     * The guarded methods are:\n     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * _.map([4, 8], square);\n     * // => [16, 64]\n     *\n     * _.map({ 'a': 4, 'b': 8 }, square);\n     * // => [16, 64] (iteration order is not guaranteed)\n     *\n     * var users = [\n     *   { 'user': 'barney' },\n     *   { 'user': 'fred' }\n     * ];\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.map(users, 'user');\n     * // => ['barney', 'fred']\n     */\n    function map(collection, iteratee) {\n      var func = isArray(collection) ? arrayMap : baseMap;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.sortBy` except that it allows specifying the sort\n     * orders of the iteratees to sort by. If `orders` is unspecified, all values\n     * are sorted in ascending order. Otherwise, specify an order of \"desc\" for\n     * descending or \"asc\" for ascending sort order of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]\n     *  The iteratees to sort by.\n     * @param {string[]} [orders] The sort orders of `iteratees`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 34 },\n     *   { 'user': 'fred',   'age': 40 },\n     *   { 'user': 'barney', 'age': 36 }\n     * ];\n     *\n     * // Sort by `user` in ascending order and by `age` in descending order.\n     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n     */\n    function orderBy(collection, iteratees, orders, guard) {\n      if (collection == null) {\n        return [];\n      }\n      if (!isArray(iteratees)) {\n        iteratees = iteratees == null ? [] : [iteratees];\n      }\n      orders = guard ? undefined : orders;\n      if (!isArray(orders)) {\n        orders = orders == null ? [] : [orders];\n      }\n      return baseOrderBy(collection, iteratees, orders);\n    }\n\n    /**\n     * Creates an array of elements split into two groups, the first of which\n     * contains elements `predicate` returns truthy for, the second of which\n     * contains elements `predicate` returns falsey for. The predicate is\n     * invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the array of grouped elements.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': false },\n     *   { 'user': 'fred',    'age': 40, 'active': true },\n     *   { 'user': 'pebbles', 'age': 1,  'active': false }\n     * ];\n     *\n     * _.partition(users, function(o) { return o.active; });\n     * // => objects for [['fred'], ['barney', 'pebbles']]\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.partition(users, { 'age': 1, 'active': false });\n     * // => objects for [['pebbles'], ['barney', 'fred']]\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.partition(users, ['active', false]);\n     * // => objects for [['barney', 'pebbles'], ['fred']]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.partition(users, 'active');\n     * // => objects for [['fred'], ['barney', 'pebbles']]\n     */\n    var partition = createAggregator(function(result, value, key) {\n      result[key ? 0 : 1].push(value);\n    }, function() { return [[], []]; });\n\n    /**\n     * Reduces `collection` to a value which is the accumulated result of running\n     * each element in `collection` thru `iteratee`, where each successive\n     * invocation is supplied the return value of the previous. If `accumulator`\n     * is not given, the first element of `collection` is used as the initial\n     * value. The iteratee is invoked with four arguments:\n     * (accumulator, value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.reduce`, `_.reduceRight`, and `_.transform`.\n     *\n     * The guarded methods are:\n     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n     * and `sortBy`\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @returns {*} Returns the accumulated value.\n     * @see _.reduceRight\n     * @example\n     *\n     * _.reduce([1, 2], function(sum, n) {\n     *   return sum + n;\n     * }, 0);\n     * // => 3\n     *\n     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n     *   (result[value] || (result[value] = [])).push(key);\n     *   return result;\n     * }, {});\n     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n     */\n    function reduce(collection, iteratee, accumulator) {\n      var func = isArray(collection) ? arrayReduce : baseReduce,\n          initAccum = arguments.length < 3;\n\n      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);\n    }\n\n    /**\n     * This method is like `_.reduce` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @returns {*} Returns the accumulated value.\n     * @see _.reduce\n     * @example\n     *\n     * var array = [[0, 1], [2, 3], [4, 5]];\n     *\n     * _.reduceRight(array, function(flattened, other) {\n     *   return flattened.concat(other);\n     * }, []);\n     * // => [4, 5, 2, 3, 0, 1]\n     */\n    function reduceRight(collection, iteratee, accumulator) {\n      var func = isArray(collection) ? arrayReduceRight : baseReduce,\n          initAccum = arguments.length < 3;\n\n      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);\n    }\n\n    /**\n     * The opposite of `_.filter`; this method returns the elements of `collection`\n     * that `predicate` does **not** return truthy for.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     * @see _.filter\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': true }\n     * ];\n     *\n     * _.reject(users, function(o) { return !o.active; });\n     * // => objects for ['fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.reject(users, { 'age': 40, 'active': true });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.reject(users, ['active', false]);\n     * // => objects for ['fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.reject(users, 'active');\n     * // => objects for ['barney']\n     */\n    function reject(collection, predicate) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      return func(collection, negate(getIteratee(predicate, 3)));\n    }\n\n    /**\n     * Gets a random element from `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to sample.\n     * @returns {*} Returns the random element.\n     * @example\n     *\n     * _.sample([1, 2, 3, 4]);\n     * // => 2\n     */\n    function sample(collection) {\n      var func = isArray(collection) ? arraySample : baseSample;\n      return func(collection);\n    }\n\n    /**\n     * Gets `n` random elements at unique keys from `collection` up to the\n     * size of `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to sample.\n     * @param {number} [n=1] The number of elements to sample.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the random elements.\n     * @example\n     *\n     * _.sampleSize([1, 2, 3], 2);\n     * // => [3, 1]\n     *\n     * _.sampleSize([1, 2, 3], 4);\n     * // => [2, 3, 1]\n     */\n    function sampleSize(collection, n, guard) {\n      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {\n        n = 1;\n      } else {\n        n = toInteger(n);\n      }\n      var func = isArray(collection) ? arraySampleSize : baseSampleSize;\n      return func(collection, n);\n    }\n\n    /**\n     * Creates an array of shuffled values, using a version of the\n     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     * @example\n     *\n     * _.shuffle([1, 2, 3, 4]);\n     * // => [4, 1, 3, 2]\n     */\n    function shuffle(collection) {\n      var func = isArray(collection) ? arrayShuffle : baseShuffle;\n      return func(collection);\n    }\n\n    /**\n     * Gets the size of `collection` by returning its length for array-like\n     * values or the number of own enumerable string keyed properties for objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @returns {number} Returns the collection size.\n     * @example\n     *\n     * _.size([1, 2, 3]);\n     * // => 3\n     *\n     * _.size({ 'a': 1, 'b': 2 });\n     * // => 2\n     *\n     * _.size('pebbles');\n     * // => 7\n     */\n    function size(collection) {\n      if (collection == null) {\n        return 0;\n      }\n      if (isArrayLike(collection)) {\n        return isString(collection) ? stringSize(collection) : collection.length;\n      }\n      var tag = getTag(collection);\n      if (tag == mapTag || tag == setTag) {\n        return collection.size;\n      }\n      return baseKeys(collection).length;\n    }\n\n    /**\n     * Checks if `predicate` returns truthy for **any** element of `collection`.\n     * Iteration is stopped once `predicate` returns truthy. The predicate is\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.some([null, 0, 'yes', false], Boolean);\n     * // => true\n     *\n     * var users = [\n     *   { 'user': 'barney', 'active': true },\n     *   { 'user': 'fred',   'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.some(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.some(users, ['active', false]);\n     * // => true\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.some(users, 'active');\n     * // => true\n     */\n    function some(collection, predicate, guard) {\n      var func = isArray(collection) ? arraySome : baseSome;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = undefined;\n      }\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Creates an array of elements, sorted in ascending order by the results of\n     * running each element in a collection thru each iteratee. This method\n     * performs a stable sort, that is, it preserves the original sort order of\n     * equal elements. The iteratees are invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {...(Function|Function[])} [iteratees=[_.identity]]\n     *  The iteratees to sort by.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 },\n     *   { 'user': 'barney', 'age': 34 }\n     * ];\n     *\n     * _.sortBy(users, [function(o) { return o.user; }]);\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n     *\n     * _.sortBy(users, ['user', 'age']);\n     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]\n     */\n    var sortBy = baseRest(function(collection, iteratees) {\n      if (collection == null) {\n        return [];\n      }\n      var length = iteratees.length;\n      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n        iteratees = [];\n      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n        iteratees = [iteratees[0]];\n      }\n      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Gets the timestamp of the number of milliseconds that have elapsed since\n     * the Unix epoch (1 January 1970 00:00:00 UTC).\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Date\n     * @returns {number} Returns the timestamp.\n     * @example\n     *\n     * _.defer(function(stamp) {\n     *   console.log(_.now() - stamp);\n     * }, _.now());\n     * // => Logs the number of milliseconds it took for the deferred invocation.\n     */\n    var now = ctxNow || function() {\n      return root.Date.now();\n    };\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The opposite of `_.before`; this method creates a function that invokes\n     * `func` once it's called `n` or more times.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {number} n The number of calls before `func` is invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var saves = ['profile', 'settings'];\n     *\n     * var done = _.after(saves.length, function() {\n     *   console.log('done saving!');\n     * });\n     *\n     * _.forEach(saves, function(type) {\n     *   asyncSave({ 'type': type, 'complete': done });\n     * });\n     * // => Logs 'done saving!' after the two async saves have completed.\n     */\n    function after(n, func) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      n = toInteger(n);\n      return function() {\n        if (--n < 1) {\n          return func.apply(this, arguments);\n        }\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func`, with up to `n` arguments,\n     * ignoring any additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @param {number} [n=func.length] The arity cap.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new capped function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.ary(parseInt, 1));\n     * // => [6, 8, 10]\n     */\n    function ary(func, n, guard) {\n      n = guard ? undefined : n;\n      n = (func && n == null) ? func.length : n;\n      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);\n    }\n\n    /**\n     * Creates a function that invokes `func`, with the `this` binding and arguments\n     * of the created function, while it's called less than `n` times. Subsequent\n     * calls to the created function return the result of the last `func` invocation.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {number} n The number of calls at which `func` is no longer invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * jQuery(element).on('click', _.before(5, addContactToList));\n     * // => Allows adding up to 4 contacts to the list.\n     */\n    function before(n, func) {\n      var result;\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      n = toInteger(n);\n      return function() {\n        if (--n > 0) {\n          result = func.apply(this, arguments);\n        }\n        if (n <= 1) {\n          func = undefined;\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of `thisArg`\n     * and `partials` prepended to the arguments it receives.\n     *\n     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** Unlike native `Function#bind`, this method doesn't set the \"length\"\n     * property of bound functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to bind.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * function greet(greeting, punctuation) {\n     *   return greeting + ' ' + this.user + punctuation;\n     * }\n     *\n     * var object = { 'user': 'fred' };\n     *\n     * var bound = _.bind(greet, object, 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * // Bound with placeholders.\n     * var bound = _.bind(greet, object, _, '!');\n     * bound('hi');\n     * // => 'hi fred!'\n     */\n    var bind = baseRest(function(func, thisArg, partials) {\n      var bitmask = WRAP_BIND_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, getHolder(bind));\n        bitmask |= WRAP_PARTIAL_FLAG;\n      }\n      return createWrap(func, bitmask, thisArg, partials, holders);\n    });\n\n    /**\n     * Creates a function that invokes the method at `object[key]` with `partials`\n     * prepended to the arguments it receives.\n     *\n     * This method differs from `_.bind` by allowing bound functions to reference\n     * methods that may be redefined or don't yet exist. See\n     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)\n     * for more details.\n     *\n     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.10.0\n     * @category Function\n     * @param {Object} object The object to invoke the method on.\n     * @param {string} key The key of the method.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var object = {\n     *   'user': 'fred',\n     *   'greet': function(greeting, punctuation) {\n     *     return greeting + ' ' + this.user + punctuation;\n     *   }\n     * };\n     *\n     * var bound = _.bindKey(object, 'greet', 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * object.greet = function(greeting, punctuation) {\n     *   return greeting + 'ya ' + this.user + punctuation;\n     * };\n     *\n     * bound('!');\n     * // => 'hiya fred!'\n     *\n     * // Bound with placeholders.\n     * var bound = _.bindKey(object, 'greet', _, '!');\n     * bound('hi');\n     * // => 'hiya fred!'\n     */\n    var bindKey = baseRest(function(object, key, partials) {\n      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, getHolder(bindKey));\n        bitmask |= WRAP_PARTIAL_FLAG;\n      }\n      return createWrap(key, bitmask, object, partials, holders);\n    });\n\n    /**\n     * Creates a function that accepts arguments of `func` and either invokes\n     * `func` returning its result, if at least `arity` number of arguments have\n     * been provided, or returns a function that accepts the remaining `func`\n     * arguments, and so on. The arity of `func` may be specified if `func.length`\n     * is not sufficient.\n     *\n     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curry(abc);\n     *\n     * curried(1)(2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // Curried with placeholders.\n     * curried(1)(_, 3)(2);\n     * // => [1, 2, 3]\n     */\n    function curry(func, arity, guard) {\n      arity = guard ? undefined : arity;\n      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n      result.placeholder = curry.placeholder;\n      return result;\n    }\n\n    /**\n     * This method is like `_.curry` except that arguments are applied to `func`\n     * in the manner of `_.partialRight` instead of `_.partial`.\n     *\n     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curryRight(abc);\n     *\n     * curried(3)(2)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(2, 3)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // Curried with placeholders.\n     * curried(3)(1, _)(2);\n     * // => [1, 2, 3]\n     */\n    function curryRight(func, arity, guard) {\n      arity = guard ? undefined : arity;\n      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n      result.placeholder = curryRight.placeholder;\n      return result;\n    }\n\n    /**\n     * Creates a debounced function that delays invoking `func` until after `wait`\n     * milliseconds have elapsed since the last time the debounced function was\n     * invoked. The debounced function comes with a `cancel` method to cancel\n     * delayed `func` invocations and a `flush` method to immediately invoke them.\n     * Provide `options` to indicate whether `func` should be invoked on the\n     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n     * with the last arguments provided to the debounced function. Subsequent\n     * calls to the debounced function return the result of the last `func`\n     * invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is\n     * invoked on the trailing edge of the timeout only if the debounced function\n     * is invoked more than once during the `wait` timeout.\n     *\n     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n     *\n     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n     * for details over the differences between `_.debounce` and `_.throttle`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to debounce.\n     * @param {number} [wait=0] The number of milliseconds to delay.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.leading=false]\n     *  Specify invoking on the leading edge of the timeout.\n     * @param {number} [options.maxWait]\n     *  The maximum time `func` is allowed to be delayed before it's invoked.\n     * @param {boolean} [options.trailing=true]\n     *  Specify invoking on the trailing edge of the timeout.\n     * @returns {Function} Returns the new debounced function.\n     * @example\n     *\n     * // Avoid costly calculations while the window size is in flux.\n     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n     *\n     * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n     * jQuery(element).on('click', _.debounce(sendMail, 300, {\n     *   'leading': true,\n     *   'trailing': false\n     * }));\n     *\n     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n     * var source = new EventSource('/stream');\n     * jQuery(source).on('message', debounced);\n     *\n     * // Cancel the trailing debounced invocation.\n     * jQuery(window).on('popstate', debounced.cancel);\n     */\n    function debounce(func, wait, options) {\n      var lastArgs,\n          lastThis,\n          maxWait,\n          result,\n          timerId,\n          lastCallTime,\n          lastInvokeTime = 0,\n          leading = false,\n          maxing = false,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      wait = toNumber(wait) || 0;\n      if (isObject(options)) {\n        leading = !!options.leading;\n        maxing = 'maxWait' in options;\n        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n\n      function invokeFunc(time) {\n        var args = lastArgs,\n            thisArg = lastThis;\n\n        lastArgs = lastThis = undefined;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n      }\n\n      function leadingEdge(time) {\n        // Reset any `maxWait` timer.\n        lastInvokeTime = time;\n        // Start the timer for the trailing edge.\n        timerId = setTimeout(timerExpired, wait);\n        // Invoke the leading edge.\n        return leading ? invokeFunc(time) : result;\n      }\n\n      function remainingWait(time) {\n        var timeSinceLastCall = time - lastCallTime,\n            timeSinceLastInvoke = time - lastInvokeTime,\n            result = wait - timeSinceLastCall;\n\n        return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n      }\n\n      function shouldInvoke(time) {\n        var timeSinceLastCall = time - lastCallTime,\n            timeSinceLastInvoke = time - lastInvokeTime;\n\n        // Either this is the first call, activity has stopped and we're at the\n        // trailing edge, the system time has gone backwards and we're treating\n        // it as the trailing edge, or we've hit the `maxWait` limit.\n        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n      }\n\n      function timerExpired() {\n        var time = now();\n        if (shouldInvoke(time)) {\n          return trailingEdge(time);\n        }\n        // Restart the timer.\n        timerId = setTimeout(timerExpired, remainingWait(time));\n      }\n\n      function trailingEdge(time) {\n        timerId = undefined;\n\n        // Only invoke if we have `lastArgs` which means `func` has been\n        // debounced at least once.\n        if (trailing && lastArgs) {\n          return invokeFunc(time);\n        }\n        lastArgs = lastThis = undefined;\n        return result;\n      }\n\n      function cancel() {\n        if (timerId !== undefined) {\n          clearTimeout(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = undefined;\n      }\n\n      function flush() {\n        return timerId === undefined ? result : trailingEdge(now());\n      }\n\n      function debounced() {\n        var time = now(),\n            isInvoking = shouldInvoke(time);\n\n        lastArgs = arguments;\n        lastThis = this;\n        lastCallTime = time;\n\n        if (isInvoking) {\n          if (timerId === undefined) {\n            return leadingEdge(lastCallTime);\n          }\n          if (maxing) {\n            // Handle invocations in a tight loop.\n            timerId = setTimeout(timerExpired, wait);\n            return invokeFunc(lastCallTime);\n          }\n        }\n        if (timerId === undefined) {\n          timerId = setTimeout(timerExpired, wait);\n        }\n        return result;\n      }\n      debounced.cancel = cancel;\n      debounced.flush = flush;\n      return debounced;\n    }\n\n    /**\n     * Defers invoking the `func` until the current call stack has cleared. Any\n     * additional arguments are provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to defer.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.defer(function(text) {\n     *   console.log(text);\n     * }, 'deferred');\n     * // => Logs 'deferred' after one millisecond.\n     */\n    var defer = baseRest(function(func, args) {\n      return baseDelay(func, 1, args);\n    });\n\n    /**\n     * Invokes `func` after `wait` milliseconds. Any additional arguments are\n     * provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.delay(function(text) {\n     *   console.log(text);\n     * }, 1000, 'later');\n     * // => Logs 'later' after one second.\n     */\n    var delay = baseRest(function(func, wait, args) {\n      return baseDelay(func, toNumber(wait) || 0, args);\n    });\n\n    /**\n     * Creates a function that invokes `func` with arguments reversed.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to flip arguments for.\n     * @returns {Function} Returns the new flipped function.\n     * @example\n     *\n     * var flipped = _.flip(function() {\n     *   return _.toArray(arguments);\n     * });\n     *\n     * flipped('a', 'b', 'c', 'd');\n     * // => ['d', 'c', 'b', 'a']\n     */\n    function flip(func) {\n      return createWrap(func, WRAP_FLIP_FLAG);\n    }\n\n    /**\n     * Creates a function that memoizes the result of `func`. If `resolver` is\n     * provided, it determines the cache key for storing the result based on the\n     * arguments provided to the memoized function. By default, the first argument\n     * provided to the memoized function is used as the map cache key. The `func`\n     * is invoked with the `this` binding of the memoized function.\n     *\n     * **Note:** The cache is exposed as the `cache` property on the memoized\n     * function. Its creation may be customized by replacing the `_.memoize.Cache`\n     * constructor with one whose instances implement the\n     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n     * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to have its output memoized.\n     * @param {Function} [resolver] The function to resolve the cache key.\n     * @returns {Function} Returns the new memoized function.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     * var other = { 'c': 3, 'd': 4 };\n     *\n     * var values = _.memoize(_.values);\n     * values(object);\n     * // => [1, 2]\n     *\n     * values(other);\n     * // => [3, 4]\n     *\n     * object.a = 2;\n     * values(object);\n     * // => [1, 2]\n     *\n     * // Modify the result cache.\n     * values.cache.set(object, ['a', 'b']);\n     * values(object);\n     * // => ['a', 'b']\n     *\n     * // Replace `_.memoize.Cache`.\n     * _.memoize.Cache = WeakMap;\n     */\n    function memoize(func, resolver) {\n      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var memoized = function() {\n        var args = arguments,\n            key = resolver ? resolver.apply(this, args) : args[0],\n            cache = memoized.cache;\n\n        if (cache.has(key)) {\n          return cache.get(key);\n        }\n        var result = func.apply(this, args);\n        memoized.cache = cache.set(key, result) || cache;\n        return result;\n      };\n      memoized.cache = new (memoize.Cache || MapCache);\n      return memoized;\n    }\n\n    // Expose `MapCache`.\n    memoize.Cache = MapCache;\n\n    /**\n     * Creates a function that negates the result of the predicate `func`. The\n     * `func` predicate is invoked with the `this` binding and arguments of the\n     * created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} predicate The predicate to negate.\n     * @returns {Function} Returns the new negated function.\n     * @example\n     *\n     * function isEven(n) {\n     *   return n % 2 == 0;\n     * }\n     *\n     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n     * // => [1, 3, 5]\n     */\n    function negate(predicate) {\n      if (typeof predicate != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return function() {\n        var args = arguments;\n        switch (args.length) {\n          case 0: return !predicate.call(this);\n          case 1: return !predicate.call(this, args[0]);\n          case 2: return !predicate.call(this, args[0], args[1]);\n          case 3: return !predicate.call(this, args[0], args[1], args[2]);\n        }\n        return !predicate.apply(this, args);\n      };\n    }\n\n    /**\n     * Creates a function that is restricted to invoking `func` once. Repeat calls\n     * to the function return the value of the first invocation. The `func` is\n     * invoked with the `this` binding and arguments of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var initialize = _.once(createApplication);\n     * initialize();\n     * initialize();\n     * // => `createApplication` is invoked once\n     */\n    function once(func) {\n      return before(2, func);\n    }\n\n    /**\n     * Creates a function that invokes `func` with its arguments transformed.\n     *\n     * @static\n     * @since 4.0.0\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to wrap.\n     * @param {...(Function|Function[])} [transforms=[_.identity]]\n     *  The argument transforms.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * function doubled(n) {\n     *   return n * 2;\n     * }\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var func = _.overArgs(function(x, y) {\n     *   return [x, y];\n     * }, [square, doubled]);\n     *\n     * func(9, 3);\n     * // => [81, 6]\n     *\n     * func(10, 5);\n     * // => [100, 10]\n     */\n    var overArgs = castRest(function(func, transforms) {\n      transforms = (transforms.length == 1 && isArray(transforms[0]))\n        ? arrayMap(transforms[0], baseUnary(getIteratee()))\n        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));\n\n      var funcsLength = transforms.length;\n      return baseRest(function(args) {\n        var index = -1,\n            length = nativeMin(args.length, funcsLength);\n\n        while (++index < length) {\n          args[index] = transforms[index].call(this, args[index]);\n        }\n        return apply(func, this, args);\n      });\n    });\n\n    /**\n     * Creates a function that invokes `func` with `partials` prepended to the\n     * arguments it receives. This method is like `_.bind` except it does **not**\n     * alter the `this` binding.\n     *\n     * The `_.partial.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.2.0\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * function greet(greeting, name) {\n     *   return greeting + ' ' + name;\n     * }\n     *\n     * var sayHelloTo = _.partial(greet, 'hello');\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     *\n     * // Partially applied with placeholders.\n     * var greetFred = _.partial(greet, _, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     */\n    var partial = baseRest(function(func, partials) {\n      var holders = replaceHolders(partials, getHolder(partial));\n      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);\n    });\n\n    /**\n     * This method is like `_.partial` except that partially applied arguments\n     * are appended to the arguments it receives.\n     *\n     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * function greet(greeting, name) {\n     *   return greeting + ' ' + name;\n     * }\n     *\n     * var greetFred = _.partialRight(greet, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     *\n     * // Partially applied with placeholders.\n     * var sayHelloTo = _.partialRight(greet, 'hello', _);\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     */\n    var partialRight = baseRest(function(func, partials) {\n      var holders = replaceHolders(partials, getHolder(partialRight));\n      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);\n    });\n\n    /**\n     * Creates a function that invokes `func` with arguments arranged according\n     * to the specified `indexes` where the argument value at the first index is\n     * provided as the first argument, the argument value at the second index is\n     * provided as the second argument, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to rearrange arguments for.\n     * @param {...(number|number[])} indexes The arranged argument indexes.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var rearged = _.rearg(function(a, b, c) {\n     *   return [a, b, c];\n     * }, [2, 0, 1]);\n     *\n     * rearged('b', 'c', 'a')\n     * // => ['a', 'b', 'c']\n     */\n    var rearg = flatRest(function(func, indexes) {\n      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);\n    });\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * created function and arguments from `start` and beyond provided as\n     * an array.\n     *\n     * **Note:** This method is based on the\n     * [rest parameter](https://mdn.io/rest_parameters).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.rest(function(what, names) {\n     *   return what + ' ' + _.initial(names).join(', ') +\n     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\n     * });\n     *\n     * say('hello', 'fred', 'barney', 'pebbles');\n     * // => 'hello fred, barney, & pebbles'\n     */\n    function rest(func, start) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      start = start === undefined ? start : toInteger(start);\n      return baseRest(func, start);\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * create function and an array of arguments much like\n     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).\n     *\n     * **Note:** This method is based on the\n     * [spread operator](https://mdn.io/spread_operator).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Function\n     * @param {Function} func The function to spread arguments over.\n     * @param {number} [start=0] The start position of the spread.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.spread(function(who, what) {\n     *   return who + ' says ' + what;\n     * });\n     *\n     * say(['fred', 'hello']);\n     * // => 'fred says hello'\n     *\n     * var numbers = Promise.all([\n     *   Promise.resolve(40),\n     *   Promise.resolve(36)\n     * ]);\n     *\n     * numbers.then(_.spread(function(x, y) {\n     *   return x + y;\n     * }));\n     * // => a Promise of 76\n     */\n    function spread(func, start) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      start = start === undefined ? 0 : nativeMax(toInteger(start), 0);\n      return baseRest(function(args) {\n        var array = args[start],\n            otherArgs = castSlice(args, 0, start);\n\n        if (array) {\n          arrayPush(otherArgs, array);\n        }\n        return apply(func, this, otherArgs);\n      });\n    }\n\n    /**\n     * Creates a throttled function that only invokes `func` at most once per\n     * every `wait` milliseconds. The throttled function comes with a `cancel`\n     * method to cancel delayed `func` invocations and a `flush` method to\n     * immediately invoke them. Provide `options` to indicate whether `func`\n     * should be invoked on the leading and/or trailing edge of the `wait`\n     * timeout. The `func` is invoked with the last arguments provided to the\n     * throttled function. Subsequent calls to the throttled function return the\n     * result of the last `func` invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is\n     * invoked on the trailing edge of the timeout only if the throttled function\n     * is invoked more than once during the `wait` timeout.\n     *\n     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n     *\n     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n     * for details over the differences between `_.throttle` and `_.debounce`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to throttle.\n     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.leading=true]\n     *  Specify invoking on the leading edge of the timeout.\n     * @param {boolean} [options.trailing=true]\n     *  Specify invoking on the trailing edge of the timeout.\n     * @returns {Function} Returns the new throttled function.\n     * @example\n     *\n     * // Avoid excessively updating the position while scrolling.\n     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n     *\n     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n     * jQuery(element).on('click', throttled);\n     *\n     * // Cancel the trailing throttled invocation.\n     * jQuery(window).on('popstate', throttled.cancel);\n     */\n    function throttle(func, wait, options) {\n      var leading = true,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      if (isObject(options)) {\n        leading = 'leading' in options ? !!options.leading : leading;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n      return debounce(func, wait, {\n        'leading': leading,\n        'maxWait': wait,\n        'trailing': trailing\n      });\n    }\n\n    /**\n     * Creates a function that accepts up to one argument, ignoring any\n     * additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @returns {Function} Returns the new capped function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.unary(parseInt));\n     * // => [6, 8, 10]\n     */\n    function unary(func) {\n      return ary(func, 1);\n    }\n\n    /**\n     * Creates a function that provides `value` to `wrapper` as its first\n     * argument. Any additional arguments provided to the function are appended\n     * to those provided to the `wrapper`. The wrapper is invoked with the `this`\n     * binding of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {*} value The value to wrap.\n     * @param {Function} [wrapper=identity] The wrapper function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var p = _.wrap(_.escape, function(func, text) {\n     *   return '<p>' + func(text) + '</p>';\n     * });\n     *\n     * p('fred, barney, & pebbles');\n     * // => '<p>fred, barney, &amp; pebbles</p>'\n     */\n    function wrap(value, wrapper) {\n      return partial(castFunction(wrapper), value);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Casts `value` as an array if it's not one.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.4.0\n     * @category Lang\n     * @param {*} value The value to inspect.\n     * @returns {Array} Returns the cast array.\n     * @example\n     *\n     * _.castArray(1);\n     * // => [1]\n     *\n     * _.castArray({ 'a': 1 });\n     * // => [{ 'a': 1 }]\n     *\n     * _.castArray('abc');\n     * // => ['abc']\n     *\n     * _.castArray(null);\n     * // => [null]\n     *\n     * _.castArray(undefined);\n     * // => [undefined]\n     *\n     * _.castArray();\n     * // => []\n     *\n     * var array = [1, 2, 3];\n     * console.log(_.castArray(array) === array);\n     * // => true\n     */\n    function castArray() {\n      if (!arguments.length) {\n        return [];\n      }\n      var value = arguments[0];\n      return isArray(value) ? value : [value];\n    }\n\n    /**\n     * Creates a shallow clone of `value`.\n     *\n     * **Note:** This method is loosely based on the\n     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n     * and supports cloning arrays, array buffers, booleans, date objects, maps,\n     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n     * arrays. The own enumerable properties of `arguments` objects are cloned\n     * as plain objects. An empty object is returned for uncloneable values such\n     * as error objects, functions, DOM nodes, and WeakMaps.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @returns {*} Returns the cloned value.\n     * @see _.cloneDeep\n     * @example\n     *\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n     *\n     * var shallow = _.clone(objects);\n     * console.log(shallow[0] === objects[0]);\n     * // => true\n     */\n    function clone(value) {\n      return baseClone(value, CLONE_SYMBOLS_FLAG);\n    }\n\n    /**\n     * This method is like `_.clone` except that it accepts `customizer` which\n     * is invoked to produce the cloned value. If `customizer` returns `undefined`,\n     * cloning is handled by the method instead. The `customizer` is invoked with\n     * up to four arguments; (value [, index|key, object, stack]).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @returns {*} Returns the cloned value.\n     * @see _.cloneDeepWith\n     * @example\n     *\n     * function customizer(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(false);\n     *   }\n     * }\n     *\n     * var el = _.cloneWith(document.body, customizer);\n     *\n     * console.log(el === document.body);\n     * // => false\n     * console.log(el.nodeName);\n     * // => 'BODY'\n     * console.log(el.childNodes.length);\n     * // => 0\n     */\n    function cloneWith(value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);\n    }\n\n    /**\n     * This method is like `_.clone` except that it recursively clones `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Lang\n     * @param {*} value The value to recursively clone.\n     * @returns {*} Returns the deep cloned value.\n     * @see _.clone\n     * @example\n     *\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n     *\n     * var deep = _.cloneDeep(objects);\n     * console.log(deep[0] === objects[0]);\n     * // => false\n     */\n    function cloneDeep(value) {\n      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n    }\n\n    /**\n     * This method is like `_.cloneWith` except that it recursively clones `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to recursively clone.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @returns {*} Returns the deep cloned value.\n     * @see _.cloneWith\n     * @example\n     *\n     * function customizer(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(true);\n     *   }\n     * }\n     *\n     * var el = _.cloneDeepWith(document.body, customizer);\n     *\n     * console.log(el === document.body);\n     * // => false\n     * console.log(el.nodeName);\n     * // => 'BODY'\n     * console.log(el.childNodes.length);\n     * // => 20\n     */\n    function cloneDeepWith(value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);\n    }\n\n    /**\n     * Checks if `object` conforms to `source` by invoking the predicate\n     * properties of `source` with the corresponding property values of `object`.\n     *\n     * **Note:** This method is equivalent to `_.conforms` when `source` is\n     * partially applied.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.14.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     *\n     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });\n     * // => true\n     *\n     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });\n     * // => false\n     */\n    function conformsTo(object, source) {\n      return source == null || baseConformsTo(object, source, keys(source));\n    }\n\n    /**\n     * Performs a\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * comparison between two values to determine if they are equivalent.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     * var other = { 'a': 1 };\n     *\n     * _.eq(object, object);\n     * // => true\n     *\n     * _.eq(object, other);\n     * // => false\n     *\n     * _.eq('a', 'a');\n     * // => true\n     *\n     * _.eq('a', Object('a'));\n     * // => false\n     *\n     * _.eq(NaN, NaN);\n     * // => true\n     */\n    function eq(value, other) {\n      return value === other || (value !== value && other !== other);\n    }\n\n    /**\n     * Checks if `value` is greater than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than `other`,\n     *  else `false`.\n     * @see _.lt\n     * @example\n     *\n     * _.gt(3, 1);\n     * // => true\n     *\n     * _.gt(3, 3);\n     * // => false\n     *\n     * _.gt(1, 3);\n     * // => false\n     */\n    var gt = createRelationalOperation(baseGt);\n\n    /**\n     * Checks if `value` is greater than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than or equal to\n     *  `other`, else `false`.\n     * @see _.lte\n     * @example\n     *\n     * _.gte(3, 1);\n     * // => true\n     *\n     * _.gte(3, 3);\n     * // => true\n     *\n     * _.gte(1, 3);\n     * // => false\n     */\n    var gte = createRelationalOperation(function(value, other) {\n      return value >= other;\n    });\n\n    /**\n     * Checks if `value` is likely an `arguments` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArguments(function() { return arguments; }());\n     * // => true\n     *\n     * _.isArguments([1, 2, 3]);\n     * // => false\n     */\n    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n        !propertyIsEnumerable.call(value, 'callee');\n    };\n\n    /**\n     * Checks if `value` is classified as an `Array` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n     * @example\n     *\n     * _.isArray([1, 2, 3]);\n     * // => true\n     *\n     * _.isArray(document.body.children);\n     * // => false\n     *\n     * _.isArray('abc');\n     * // => false\n     *\n     * _.isArray(_.noop);\n     * // => false\n     */\n    var isArray = Array.isArray;\n\n    /**\n     * Checks if `value` is classified as an `ArrayBuffer` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n     * @example\n     *\n     * _.isArrayBuffer(new ArrayBuffer(2));\n     * // => true\n     *\n     * _.isArrayBuffer(new Array(2));\n     * // => false\n     */\n    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;\n\n    /**\n     * Checks if `value` is array-like. A value is considered array-like if it's\n     * not a function and has a `value.length` that's an integer greater than or\n     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n     * @example\n     *\n     * _.isArrayLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLike(document.body.children);\n     * // => true\n     *\n     * _.isArrayLike('abc');\n     * // => true\n     *\n     * _.isArrayLike(_.noop);\n     * // => false\n     */\n    function isArrayLike(value) {\n      return value != null && isLength(value.length) && !isFunction(value);\n    }\n\n    /**\n     * This method is like `_.isArrayLike` except that it also checks if `value`\n     * is an object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array-like object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArrayLikeObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLikeObject(document.body.children);\n     * // => true\n     *\n     * _.isArrayLikeObject('abc');\n     * // => false\n     *\n     * _.isArrayLikeObject(_.noop);\n     * // => false\n     */\n    function isArrayLikeObject(value) {\n      return isObjectLike(value) && isArrayLike(value);\n    }\n\n    /**\n     * Checks if `value` is classified as a boolean primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.\n     * @example\n     *\n     * _.isBoolean(false);\n     * // => true\n     *\n     * _.isBoolean(null);\n     * // => false\n     */\n    function isBoolean(value) {\n      return value === true || value === false ||\n        (isObjectLike(value) && baseGetTag(value) == boolTag);\n    }\n\n    /**\n     * Checks if `value` is a buffer.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n     * @example\n     *\n     * _.isBuffer(new Buffer(2));\n     * // => true\n     *\n     * _.isBuffer(new Uint8Array(2));\n     * // => false\n     */\n    var isBuffer = nativeIsBuffer || stubFalse;\n\n    /**\n     * Checks if `value` is classified as a `Date` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n     * @example\n     *\n     * _.isDate(new Date);\n     * // => true\n     *\n     * _.isDate('Mon April 23 2012');\n     * // => false\n     */\n    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;\n\n    /**\n     * Checks if `value` is likely a DOM element.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.\n     * @example\n     *\n     * _.isElement(document.body);\n     * // => true\n     *\n     * _.isElement('<body>');\n     * // => false\n     */\n    function isElement(value) {\n      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);\n    }\n\n    /**\n     * Checks if `value` is an empty object, collection, map, or set.\n     *\n     * Objects are considered empty if they have no own enumerable string keyed\n     * properties.\n     *\n     * Array-like values such as `arguments` objects, arrays, buffers, strings, or\n     * jQuery-like collections are considered empty if they have a `length` of `0`.\n     * Similarly, maps and sets are considered empty if they have a `size` of `0`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n     * @example\n     *\n     * _.isEmpty(null);\n     * // => true\n     *\n     * _.isEmpty(true);\n     * // => true\n     *\n     * _.isEmpty(1);\n     * // => true\n     *\n     * _.isEmpty([1, 2, 3]);\n     * // => false\n     *\n     * _.isEmpty({ 'a': 1 });\n     * // => false\n     */\n    function isEmpty(value) {\n      if (value == null) {\n        return true;\n      }\n      if (isArrayLike(value) &&\n          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||\n            isBuffer(value) || isTypedArray(value) || isArguments(value))) {\n        return !value.length;\n      }\n      var tag = getTag(value);\n      if (tag == mapTag || tag == setTag) {\n        return !value.size;\n      }\n      if (isPrototype(value)) {\n        return !baseKeys(value).length;\n      }\n      for (var key in value) {\n        if (hasOwnProperty.call(value, key)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Performs a deep comparison between two values to determine if they are\n     * equivalent.\n     *\n     * **Note:** This method supports comparing arrays, array buffers, booleans,\n     * date objects, error objects, maps, numbers, `Object` objects, regexes,\n     * sets, strings, symbols, and typed arrays. `Object` objects are compared\n     * by their own, not inherited, enumerable properties. Functions and DOM\n     * nodes are **not** supported.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     * var other = { 'a': 1 };\n     *\n     * _.isEqual(object, other);\n     * // => true\n     *\n     * object === other;\n     * // => false\n     */\n    function isEqual(value, other) {\n      return baseIsEqual(value, other);\n    }\n\n    /**\n     * This method is like `_.isEqual` except that it accepts `customizer` which\n     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n     * are handled by the method instead. The `customizer` is invoked with up to\n     * six arguments: (objValue, othValue [, index|key, object, other, stack]).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * function isGreeting(value) {\n     *   return /^h(?:i|ello)$/.test(value);\n     * }\n     *\n     * function customizer(objValue, othValue) {\n     *   if (isGreeting(objValue) && isGreeting(othValue)) {\n     *     return true;\n     *   }\n     * }\n     *\n     * var array = ['hello', 'goodbye'];\n     * var other = ['hi', 'goodbye'];\n     *\n     * _.isEqualWith(array, other, customizer);\n     * // => true\n     */\n    function isEqualWith(value, other, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      var result = customizer ? customizer(value, other) : undefined;\n      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;\n    }\n\n    /**\n     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,\n     * `SyntaxError`, `TypeError`, or `URIError` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.\n     * @example\n     *\n     * _.isError(new Error);\n     * // => true\n     *\n     * _.isError(Error);\n     * // => false\n     */\n    function isError(value) {\n      if (!isObjectLike(value)) {\n        return false;\n      }\n      var tag = baseGetTag(value);\n      return tag == errorTag || tag == domExcTag ||\n        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));\n    }\n\n    /**\n     * Checks if `value` is a finite primitive number.\n     *\n     * **Note:** This method is based on\n     * [`Number.isFinite`](https://mdn.io/Number/isFinite).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.\n     * @example\n     *\n     * _.isFinite(3);\n     * // => true\n     *\n     * _.isFinite(Number.MIN_VALUE);\n     * // => true\n     *\n     * _.isFinite(Infinity);\n     * // => false\n     *\n     * _.isFinite('3');\n     * // => false\n     */\n    function isFinite(value) {\n      return typeof value == 'number' && nativeIsFinite(value);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Function` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n     * @example\n     *\n     * _.isFunction(_);\n     * // => true\n     *\n     * _.isFunction(/abc/);\n     * // => false\n     */\n    function isFunction(value) {\n      if (!isObject(value)) {\n        return false;\n      }\n      // The use of `Object#toString` avoids issues with the `typeof` operator\n      // in Safari 9 which returns 'object' for typed arrays and other constructors.\n      var tag = baseGetTag(value);\n      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n    }\n\n    /**\n     * Checks if `value` is an integer.\n     *\n     * **Note:** This method is based on\n     * [`Number.isInteger`](https://mdn.io/Number/isInteger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.\n     * @example\n     *\n     * _.isInteger(3);\n     * // => true\n     *\n     * _.isInteger(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isInteger(Infinity);\n     * // => false\n     *\n     * _.isInteger('3');\n     * // => false\n     */\n    function isInteger(value) {\n      return typeof value == 'number' && value == toInteger(value);\n    }\n\n    /**\n     * Checks if `value` is a valid array-like length.\n     *\n     * **Note:** This method is loosely based on\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n     * @example\n     *\n     * _.isLength(3);\n     * // => true\n     *\n     * _.isLength(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isLength(Infinity);\n     * // => false\n     *\n     * _.isLength('3');\n     * // => false\n     */\n    function isLength(value) {\n      return typeof value == 'number' &&\n        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is the\n     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n     * @example\n     *\n     * _.isObject({});\n     * // => true\n     *\n     * _.isObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isObject(_.noop);\n     * // => true\n     *\n     * _.isObject(null);\n     * // => false\n     */\n    function isObject(value) {\n      var type = typeof value;\n      return value != null && (type == 'object' || type == 'function');\n    }\n\n    /**\n     * Checks if `value` is object-like. A value is object-like if it's not `null`\n     * and has a `typeof` result of \"object\".\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n     * @example\n     *\n     * _.isObjectLike({});\n     * // => true\n     *\n     * _.isObjectLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isObjectLike(_.noop);\n     * // => false\n     *\n     * _.isObjectLike(null);\n     * // => false\n     */\n    function isObjectLike(value) {\n      return value != null && typeof value == 'object';\n    }\n\n    /**\n     * Checks if `value` is classified as a `Map` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n     * @example\n     *\n     * _.isMap(new Map);\n     * // => true\n     *\n     * _.isMap(new WeakMap);\n     * // => false\n     */\n    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\n    /**\n     * Performs a partial deep comparison between `object` and `source` to\n     * determine if `object` contains equivalent property values.\n     *\n     * **Note:** This method is equivalent to `_.matches` when `source` is\n     * partially applied.\n     *\n     * Partial comparisons will match empty array and empty object `source`\n     * values against any array or object value, respectively. See `_.isEqual`\n     * for a list of supported value comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     *\n     * _.isMatch(object, { 'b': 2 });\n     * // => true\n     *\n     * _.isMatch(object, { 'b': 1 });\n     * // => false\n     */\n    function isMatch(object, source) {\n      return object === source || baseIsMatch(object, source, getMatchData(source));\n    }\n\n    /**\n     * This method is like `_.isMatch` except that it accepts `customizer` which\n     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n     * are handled by the method instead. The `customizer` is invoked with five\n     * arguments: (objValue, srcValue, index|key, object, source).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * function isGreeting(value) {\n     *   return /^h(?:i|ello)$/.test(value);\n     * }\n     *\n     * function customizer(objValue, srcValue) {\n     *   if (isGreeting(objValue) && isGreeting(srcValue)) {\n     *     return true;\n     *   }\n     * }\n     *\n     * var object = { 'greeting': 'hello' };\n     * var source = { 'greeting': 'hi' };\n     *\n     * _.isMatchWith(object, source, customizer);\n     * // => true\n     */\n    function isMatchWith(object, source, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseIsMatch(object, source, getMatchData(source), customizer);\n    }\n\n    /**\n     * Checks if `value` is `NaN`.\n     *\n     * **Note:** This method is based on\n     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as\n     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for\n     * `undefined` and other non-number values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n     * @example\n     *\n     * _.isNaN(NaN);\n     * // => true\n     *\n     * _.isNaN(new Number(NaN));\n     * // => true\n     *\n     * isNaN(undefined);\n     * // => true\n     *\n     * _.isNaN(undefined);\n     * // => false\n     */\n    function isNaN(value) {\n      // An `NaN` primitive is the only value that is not equal to itself.\n      // Perform the `toStringTag` check first to avoid errors with some\n      // ActiveX objects in IE.\n      return isNumber(value) && value != +value;\n    }\n\n    /**\n     * Checks if `value` is a pristine native function.\n     *\n     * **Note:** This method can't reliably detect native functions in the presence\n     * of the core-js package because core-js circumvents this kind of detection.\n     * Despite multiple requests, the core-js maintainer has made it clear: any\n     * attempt to fix the detection will be obstructed. As a result, we're left\n     * with little choice but to throw an error. Unfortunately, this also affects\n     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),\n     * which rely on core-js.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function,\n     *  else `false`.\n     * @example\n     *\n     * _.isNative(Array.prototype.push);\n     * // => true\n     *\n     * _.isNative(_);\n     * // => false\n     */\n    function isNative(value) {\n      if (isMaskable(value)) {\n        throw new Error(CORE_ERROR_TEXT);\n      }\n      return baseIsNative(value);\n    }\n\n    /**\n     * Checks if `value` is `null`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.\n     * @example\n     *\n     * _.isNull(null);\n     * // => true\n     *\n     * _.isNull(void 0);\n     * // => false\n     */\n    function isNull(value) {\n      return value === null;\n    }\n\n    /**\n     * Checks if `value` is `null` or `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.\n     * @example\n     *\n     * _.isNil(null);\n     * // => true\n     *\n     * _.isNil(void 0);\n     * // => true\n     *\n     * _.isNil(NaN);\n     * // => false\n     */\n    function isNil(value) {\n      return value == null;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Number` primitive or object.\n     *\n     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are\n     * classified as numbers, use the `_.isFinite` method.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a number, else `false`.\n     * @example\n     *\n     * _.isNumber(3);\n     * // => true\n     *\n     * _.isNumber(Number.MIN_VALUE);\n     * // => true\n     *\n     * _.isNumber(Infinity);\n     * // => true\n     *\n     * _.isNumber('3');\n     * // => false\n     */\n    function isNumber(value) {\n      return typeof value == 'number' ||\n        (isObjectLike(value) && baseGetTag(value) == numberTag);\n    }\n\n    /**\n     * Checks if `value` is a plain object, that is, an object created by the\n     * `Object` constructor or one with a `[[Prototype]]` of `null`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.8.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * _.isPlainObject(new Foo);\n     * // => false\n     *\n     * _.isPlainObject([1, 2, 3]);\n     * // => false\n     *\n     * _.isPlainObject({ 'x': 0, 'y': 0 });\n     * // => true\n     *\n     * _.isPlainObject(Object.create(null));\n     * // => true\n     */\n    function isPlainObject(value) {\n      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n        return false;\n      }\n      var proto = getPrototype(value);\n      if (proto === null) {\n        return true;\n      }\n      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n      return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n        funcToString.call(Ctor) == objectCtorString;\n    }\n\n    /**\n     * Checks if `value` is classified as a `RegExp` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n     * @example\n     *\n     * _.isRegExp(/abc/);\n     * // => true\n     *\n     * _.isRegExp('/abc/');\n     * // => false\n     */\n    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n\n    /**\n     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754\n     * double precision number which isn't the result of a rounded unsafe integer.\n     *\n     * **Note:** This method is based on\n     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.\n     * @example\n     *\n     * _.isSafeInteger(3);\n     * // => true\n     *\n     * _.isSafeInteger(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isSafeInteger(Infinity);\n     * // => false\n     *\n     * _.isSafeInteger('3');\n     * // => false\n     */\n    function isSafeInteger(value) {\n      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Set` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n     * @example\n     *\n     * _.isSet(new Set);\n     * // => true\n     *\n     * _.isSet(new WeakSet);\n     * // => false\n     */\n    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\n    /**\n     * Checks if `value` is classified as a `String` primitive or object.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n     * @example\n     *\n     * _.isString('abc');\n     * // => true\n     *\n     * _.isString(1);\n     * // => false\n     */\n    function isString(value) {\n      return typeof value == 'string' ||\n        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Symbol` primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n     * @example\n     *\n     * _.isSymbol(Symbol.iterator);\n     * // => true\n     *\n     * _.isSymbol('abc');\n     * // => false\n     */\n    function isSymbol(value) {\n      return typeof value == 'symbol' ||\n        (isObjectLike(value) && baseGetTag(value) == symbolTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a typed array.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n     * @example\n     *\n     * _.isTypedArray(new Uint8Array);\n     * // => true\n     *\n     * _.isTypedArray([]);\n     * // => false\n     */\n    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n    /**\n     * Checks if `value` is `undefined`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n     * @example\n     *\n     * _.isUndefined(void 0);\n     * // => true\n     *\n     * _.isUndefined(null);\n     * // => false\n     */\n    function isUndefined(value) {\n      return value === undefined;\n    }\n\n    /**\n     * Checks if `value` is classified as a `WeakMap` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.\n     * @example\n     *\n     * _.isWeakMap(new WeakMap);\n     * // => true\n     *\n     * _.isWeakMap(new Map);\n     * // => false\n     */\n    function isWeakMap(value) {\n      return isObjectLike(value) && getTag(value) == weakMapTag;\n    }\n\n    /**\n     * Checks if `value` is classified as a `WeakSet` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.\n     * @example\n     *\n     * _.isWeakSet(new WeakSet);\n     * // => true\n     *\n     * _.isWeakSet(new Set);\n     * // => false\n     */\n    function isWeakSet(value) {\n      return isObjectLike(value) && baseGetTag(value) == weakSetTag;\n    }\n\n    /**\n     * Checks if `value` is less than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than `other`,\n     *  else `false`.\n     * @see _.gt\n     * @example\n     *\n     * _.lt(1, 3);\n     * // => true\n     *\n     * _.lt(3, 3);\n     * // => false\n     *\n     * _.lt(3, 1);\n     * // => false\n     */\n    var lt = createRelationalOperation(baseLt);\n\n    /**\n     * Checks if `value` is less than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than or equal to\n     *  `other`, else `false`.\n     * @see _.gte\n     * @example\n     *\n     * _.lte(1, 3);\n     * // => true\n     *\n     * _.lte(3, 3);\n     * // => true\n     *\n     * _.lte(3, 1);\n     * // => false\n     */\n    var lte = createRelationalOperation(function(value, other) {\n      return value <= other;\n    });\n\n    /**\n     * Converts `value` to an array.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the converted array.\n     * @example\n     *\n     * _.toArray({ 'a': 1, 'b': 2 });\n     * // => [1, 2]\n     *\n     * _.toArray('abc');\n     * // => ['a', 'b', 'c']\n     *\n     * _.toArray(1);\n     * // => []\n     *\n     * _.toArray(null);\n     * // => []\n     */\n    function toArray(value) {\n      if (!value) {\n        return [];\n      }\n      if (isArrayLike(value)) {\n        return isString(value) ? stringToArray(value) : copyArray(value);\n      }\n      if (symIterator && value[symIterator]) {\n        return iteratorToArray(value[symIterator]());\n      }\n      var tag = getTag(value),\n          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);\n\n      return func(value);\n    }\n\n    /**\n     * Converts `value` to a finite number.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.12.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted number.\n     * @example\n     *\n     * _.toFinite(3.2);\n     * // => 3.2\n     *\n     * _.toFinite(Number.MIN_VALUE);\n     * // => 5e-324\n     *\n     * _.toFinite(Infinity);\n     * // => 1.7976931348623157e+308\n     *\n     * _.toFinite('3.2');\n     * // => 3.2\n     */\n    function toFinite(value) {\n      if (!value) {\n        return value === 0 ? value : 0;\n      }\n      value = toNumber(value);\n      if (value === INFINITY || value === -INFINITY) {\n        var sign = (value < 0 ? -1 : 1);\n        return sign * MAX_INTEGER;\n      }\n      return value === value ? value : 0;\n    }\n\n    /**\n     * Converts `value` to an integer.\n     *\n     * **Note:** This method is loosely based on\n     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toInteger(3.2);\n     * // => 3\n     *\n     * _.toInteger(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toInteger(Infinity);\n     * // => 1.7976931348623157e+308\n     *\n     * _.toInteger('3.2');\n     * // => 3\n     */\n    function toInteger(value) {\n      var result = toFinite(value),\n          remainder = result % 1;\n\n      return result === result ? (remainder ? result - remainder : result) : 0;\n    }\n\n    /**\n     * Converts `value` to an integer suitable for use as the length of an\n     * array-like object.\n     *\n     * **Note:** This method is based on\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toLength(3.2);\n     * // => 3\n     *\n     * _.toLength(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toLength(Infinity);\n     * // => 4294967295\n     *\n     * _.toLength('3.2');\n     * // => 3\n     */\n    function toLength(value) {\n      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;\n    }\n\n    /**\n     * Converts `value` to a number.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to process.\n     * @returns {number} Returns the number.\n     * @example\n     *\n     * _.toNumber(3.2);\n     * // => 3.2\n     *\n     * _.toNumber(Number.MIN_VALUE);\n     * // => 5e-324\n     *\n     * _.toNumber(Infinity);\n     * // => Infinity\n     *\n     * _.toNumber('3.2');\n     * // => 3.2\n     */\n    function toNumber(value) {\n      if (typeof value == 'number') {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      if (isObject(value)) {\n        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n        value = isObject(other) ? (other + '') : other;\n      }\n      if (typeof value != 'string') {\n        return value === 0 ? value : +value;\n      }\n      value = value.replace(reTrim, '');\n      var isBinary = reIsBinary.test(value);\n      return (isBinary || reIsOctal.test(value))\n        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n        : (reIsBadHex.test(value) ? NAN : +value);\n    }\n\n    /**\n     * Converts `value` to a plain object flattening inherited enumerable string\n     * keyed properties of `value` to own properties of the plain object.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Object} Returns the converted plain object.\n     * @example\n     *\n     * function Foo() {\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.assign({ 'a': 1 }, new Foo);\n     * // => { 'a': 1, 'b': 2 }\n     *\n     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n     * // => { 'a': 1, 'b': 2, 'c': 3 }\n     */\n    function toPlainObject(value) {\n      return copyObject(value, keysIn(value));\n    }\n\n    /**\n     * Converts `value` to a safe integer. A safe integer can be compared and\n     * represented correctly.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toSafeInteger(3.2);\n     * // => 3\n     *\n     * _.toSafeInteger(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toSafeInteger(Infinity);\n     * // => 9007199254740991\n     *\n     * _.toSafeInteger('3.2');\n     * // => 3\n     */\n    function toSafeInteger(value) {\n      return baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);\n    }\n\n    /**\n     * Converts `value` to a string. An empty string is returned for `null`\n     * and `undefined` values. The sign of `-0` is preserved.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.toString(null);\n     * // => ''\n     *\n     * _.toString(-0);\n     * // => '-0'\n     *\n     * _.toString([1, 2, 3]);\n     * // => '1,2,3'\n     */\n    function toString(value) {\n      return value == null ? '' : baseToString(value);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Assigns own enumerable string keyed properties of source objects to the\n     * destination object. Source objects are applied from left to right.\n     * Subsequent sources overwrite property assignments of previous sources.\n     *\n     * **Note:** This method mutates `object` and is loosely based on\n     * [`Object.assign`](https://mdn.io/Object/assign).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.10.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.assignIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * function Bar() {\n     *   this.c = 3;\n     * }\n     *\n     * Foo.prototype.b = 2;\n     * Bar.prototype.d = 4;\n     *\n     * _.assign({ 'a': 0 }, new Foo, new Bar);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    var assign = createAssigner(function(object, source) {\n      if (isPrototype(source) || isArrayLike(source)) {\n        copyObject(source, keys(source), object);\n        return;\n      }\n      for (var key in source) {\n        if (hasOwnProperty.call(source, key)) {\n          assignValue(object, key, source[key]);\n        }\n      }\n    });\n\n    /**\n     * This method is like `_.assign` except that it iterates over own and\n     * inherited source properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias extend\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.assign\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * function Bar() {\n     *   this.c = 3;\n     * }\n     *\n     * Foo.prototype.b = 2;\n     * Bar.prototype.d = 4;\n     *\n     * _.assignIn({ 'a': 0 }, new Foo, new Bar);\n     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }\n     */\n    var assignIn = createAssigner(function(object, source) {\n      copyObject(source, keysIn(source), object);\n    });\n\n    /**\n     * This method is like `_.assignIn` except that it accepts `customizer`\n     * which is invoked to produce the assigned values. If `customizer` returns\n     * `undefined`, assignment is handled by the method instead. The `customizer`\n     * is invoked with five arguments: (objValue, srcValue, key, object, source).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias extendWith\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @see _.assignWith\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\n     * }\n     *\n     * var defaults = _.partialRight(_.assignInWith, customizer);\n     *\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {\n      copyObject(source, keysIn(source), object, customizer);\n    });\n\n    /**\n     * This method is like `_.assign` except that it accepts `customizer`\n     * which is invoked to produce the assigned values. If `customizer` returns\n     * `undefined`, assignment is handled by the method instead. The `customizer`\n     * is invoked with five arguments: (objValue, srcValue, key, object, source).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @see _.assignInWith\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\n     * }\n     *\n     * var defaults = _.partialRight(_.assignWith, customizer);\n     *\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {\n      copyObject(source, keys(source), object, customizer);\n    });\n\n    /**\n     * Creates an array of values corresponding to `paths` of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Array} Returns the picked values.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n     *\n     * _.at(object, ['a[0].b.c', 'a[1]']);\n     * // => [3, 4]\n     */\n    var at = flatRest(baseAt);\n\n    /**\n     * Creates an object that inherits from the `prototype` object. If a\n     * `properties` object is given, its own enumerable string keyed properties\n     * are assigned to the created object.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.3.0\n     * @category Object\n     * @param {Object} prototype The object to inherit from.\n     * @param {Object} [properties] The properties to assign to the object.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * function Circle() {\n     *   Shape.call(this);\n     * }\n     *\n     * Circle.prototype = _.create(Shape.prototype, {\n     *   'constructor': Circle\n     * });\n     *\n     * var circle = new Circle;\n     * circle instanceof Circle;\n     * // => true\n     *\n     * circle instanceof Shape;\n     * // => true\n     */\n    function create(prototype, properties) {\n      var result = baseCreate(prototype);\n      return properties == null ? result : baseAssign(result, properties);\n    }\n\n    /**\n     * Assigns own and inherited enumerable string keyed properties of source\n     * objects to the destination object for all destination properties that\n     * resolve to `undefined`. Source objects are applied from left to right.\n     * Once a property is set, additional values of the same property are ignored.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.defaultsDeep\n     * @example\n     *\n     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var defaults = baseRest(function(args) {\n      args.push(undefined, assignInDefaults);\n      return apply(assignInWith, undefined, args);\n    });\n\n    /**\n     * This method is like `_.defaults` except that it recursively assigns\n     * default properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.defaults\n     * @example\n     *\n     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });\n     * // => { 'a': { 'b': 2, 'c': 3 } }\n     */\n    var defaultsDeep = baseRest(function(args) {\n      args.push(undefined, mergeDefaults);\n      return apply(mergeWith, undefined, args);\n    });\n\n    /**\n     * This method is like `_.find` except that it returns the key of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {string|undefined} Returns the key of the matched element,\n     *  else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findKey(users, function(o) { return o.age < 40; });\n     * // => 'barney' (iteration order is not guaranteed)\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findKey(users, { 'age': 1, 'active': true });\n     * // => 'pebbles'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findKey(users, ['active', false]);\n     * // => 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findKey(users, 'active');\n     * // => 'barney'\n     */\n    function findKey(object, predicate) {\n      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);\n    }\n\n    /**\n     * This method is like `_.findKey` except that it iterates over elements of\n     * a collection in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {string|undefined} Returns the key of the matched element,\n     *  else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findLastKey(users, function(o) { return o.age < 40; });\n     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findLastKey(users, { 'age': 36, 'active': true });\n     * // => 'barney'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findLastKey(users, ['active', false]);\n     * // => 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findLastKey(users, 'active');\n     * // => 'pebbles'\n     */\n    function findLastKey(object, predicate) {\n      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);\n    }\n\n    /**\n     * Iterates over own and inherited enumerable string keyed properties of an\n     * object and invokes `iteratee` for each property. The iteratee is invoked\n     * with three arguments: (value, key, object). Iteratee functions may exit\n     * iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forInRight\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forIn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).\n     */\n    function forIn(object, iteratee) {\n      return object == null\n        ? object\n        : baseFor(object, getIteratee(iteratee, 3), keysIn);\n    }\n\n    /**\n     * This method is like `_.forIn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forInRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.\n     */\n    function forInRight(object, iteratee) {\n      return object == null\n        ? object\n        : baseForRight(object, getIteratee(iteratee, 3), keysIn);\n    }\n\n    /**\n     * Iterates over own enumerable string keyed properties of an object and\n     * invokes `iteratee` for each property. The iteratee is invoked with three\n     * arguments: (value, key, object). Iteratee functions may exit iteration\n     * early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forOwnRight\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n     */\n    function forOwn(object, iteratee) {\n      return object && baseForOwn(object, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.forOwn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forOwn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwnRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.\n     */\n    function forOwnRight(object, iteratee) {\n      return object && baseForOwnRight(object, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * Creates an array of function property names from own enumerable properties\n     * of `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the function names.\n     * @see _.functionsIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = _.constant('a');\n     *   this.b = _.constant('b');\n     * }\n     *\n     * Foo.prototype.c = _.constant('c');\n     *\n     * _.functions(new Foo);\n     * // => ['a', 'b']\n     */\n    function functions(object) {\n      return object == null ? [] : baseFunctions(object, keys(object));\n    }\n\n    /**\n     * Creates an array of function property names from own and inherited\n     * enumerable properties of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the function names.\n     * @see _.functions\n     * @example\n     *\n     * function Foo() {\n     *   this.a = _.constant('a');\n     *   this.b = _.constant('b');\n     * }\n     *\n     * Foo.prototype.c = _.constant('c');\n     *\n     * _.functionsIn(new Foo);\n     * // => ['a', 'b', 'c']\n     */\n    function functionsIn(object) {\n      return object == null ? [] : baseFunctions(object, keysIn(object));\n    }\n\n    /**\n     * Gets the value at `path` of `object`. If the resolved value is\n     * `undefined`, the `defaultValue` is returned in its place.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.get(object, 'a[0].b.c');\n     * // => 3\n     *\n     * _.get(object, ['a', '0', 'b', 'c']);\n     * // => 3\n     *\n     * _.get(object, 'a.b.c', 'default');\n     * // => 'default'\n     */\n    function get(object, path, defaultValue) {\n      var result = object == null ? undefined : baseGet(object, path);\n      return result === undefined ? defaultValue : result;\n    }\n\n    /**\n     * Checks if `path` is a direct property of `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     * @example\n     *\n     * var object = { 'a': { 'b': 2 } };\n     * var other = _.create({ 'a': _.create({ 'b': 2 }) });\n     *\n     * _.has(object, 'a');\n     * // => true\n     *\n     * _.has(object, 'a.b');\n     * // => true\n     *\n     * _.has(object, ['a', 'b']);\n     * // => true\n     *\n     * _.has(other, 'a');\n     * // => false\n     */\n    function has(object, path) {\n      return object != null && hasPath(object, path, baseHas);\n    }\n\n    /**\n     * Checks if `path` is a direct or inherited property of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     * @example\n     *\n     * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n     *\n     * _.hasIn(object, 'a');\n     * // => true\n     *\n     * _.hasIn(object, 'a.b');\n     * // => true\n     *\n     * _.hasIn(object, ['a', 'b']);\n     * // => true\n     *\n     * _.hasIn(object, 'b');\n     * // => false\n     */\n    function hasIn(object, path) {\n      return object != null && hasPath(object, path, baseHasIn);\n    }\n\n    /**\n     * Creates an object composed of the inverted keys and values of `object`.\n     * If `object` contains duplicate values, subsequent values overwrite\n     * property assignments of previous values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.7.0\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invert(object);\n     * // => { '1': 'c', '2': 'b' }\n     */\n    var invert = createInverter(function(result, value, key) {\n      result[value] = key;\n    }, constant(identity));\n\n    /**\n     * This method is like `_.invert` except that the inverted object is generated\n     * from the results of running each element of `object` thru `iteratee`. The\n     * corresponding inverted value of each inverted key is an array of keys\n     * responsible for generating the inverted value. The iteratee is invoked\n     * with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.1.0\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invertBy(object);\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     *\n     * _.invertBy(object, function(value) {\n     *   return 'group' + value;\n     * });\n     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }\n     */\n    var invertBy = createInverter(function(result, value, key) {\n      if (hasOwnProperty.call(result, value)) {\n        result[value].push(key);\n      } else {\n        result[value] = [key];\n      }\n    }, getIteratee);\n\n    /**\n     * Invokes the method at `path` of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };\n     *\n     * _.invoke(object, 'a[0].b.c.slice', 1, 3);\n     * // => [2, 3]\n     */\n    var invoke = baseRest(baseInvoke);\n\n    /**\n     * Creates an array of the own enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects. See the\n     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n     * for more details.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keys(new Foo);\n     * // => ['a', 'b'] (iteration order is not guaranteed)\n     *\n     * _.keys('hi');\n     * // => ['0', '1']\n     */\n    function keys(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keysIn(new Foo);\n     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n     */\n    function keysIn(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n    }\n\n    /**\n     * The opposite of `_.mapValues`; this method creates an object with the\n     * same values as `object` and keys generated by running each own enumerable\n     * string keyed property of `object` thru `iteratee`. The iteratee is invoked\n     * with three arguments: (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns the new mapped object.\n     * @see _.mapValues\n     * @example\n     *\n     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   return key + value;\n     * });\n     * // => { 'a1': 1, 'b2': 2 }\n     */\n    function mapKeys(object, iteratee) {\n      var result = {};\n      iteratee = getIteratee(iteratee, 3);\n\n      baseForOwn(object, function(value, key, object) {\n        baseAssignValue(result, iteratee(value, key, object), value);\n      });\n      return result;\n    }\n\n    /**\n     * Creates an object with the same keys as `object` and values generated\n     * by running each own enumerable string keyed property of `object` thru\n     * `iteratee`. The iteratee is invoked with three arguments:\n     * (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns the new mapped object.\n     * @see _.mapKeys\n     * @example\n     *\n     * var users = {\n     *   'fred':    { 'user': 'fred',    'age': 40 },\n     *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n     * };\n     *\n     * _.mapValues(users, function(o) { return o.age; });\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.mapValues(users, 'age');\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     */\n    function mapValues(object, iteratee) {\n      var result = {};\n      iteratee = getIteratee(iteratee, 3);\n\n      baseForOwn(object, function(value, key, object) {\n        baseAssignValue(result, key, iteratee(value, key, object));\n      });\n      return result;\n    }\n\n    /**\n     * This method is like `_.assign` except that it recursively merges own and\n     * inherited enumerable string keyed properties of source objects into the\n     * destination object. Source properties that resolve to `undefined` are\n     * skipped if a destination value exists. Array and plain object properties\n     * are merged recursively. Other objects and value types are overridden by\n     * assignment. Source objects are applied from left to right. Subsequent\n     * sources overwrite property assignments of previous sources.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {\n     *   'a': [{ 'b': 2 }, { 'd': 4 }]\n     * };\n     *\n     * var other = {\n     *   'a': [{ 'c': 3 }, { 'e': 5 }]\n     * };\n     *\n     * _.merge(object, other);\n     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n     */\n    var merge = createAssigner(function(object, source, srcIndex) {\n      baseMerge(object, source, srcIndex);\n    });\n\n    /**\n     * This method is like `_.merge` except that it accepts `customizer` which\n     * is invoked to produce the merged values of the destination and source\n     * properties. If `customizer` returns `undefined`, merging is handled by the\n     * method instead. The `customizer` is invoked with six arguments:\n     * (objValue, srcValue, key, object, source, stack).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} customizer The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   if (_.isArray(objValue)) {\n     *     return objValue.concat(srcValue);\n     *   }\n     * }\n     *\n     * var object = { 'a': [1], 'b': [2] };\n     * var other = { 'a': [3], 'b': [4] };\n     *\n     * _.mergeWith(object, other, customizer);\n     * // => { 'a': [1, 3], 'b': [2, 4] }\n     */\n    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {\n      baseMerge(object, source, srcIndex, customizer);\n    });\n\n    /**\n     * The opposite of `_.pick`; this method creates an object composed of the\n     * own and inherited enumerable property paths of `object` that are not omitted.\n     *\n     * **Note:** This method is considerably slower than `_.pick`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {...(string|string[])} [paths] The property paths to omit.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.omit(object, ['a', 'c']);\n     * // => { 'b': '2' }\n     */\n    var omit = flatRest(function(object, paths) {\n      var result = {};\n      if (object == null) {\n        return result;\n      }\n      var isDeep = false;\n      paths = arrayMap(paths, function(path) {\n        path = castPath(path, object);\n        isDeep || (isDeep = path.length > 1);\n        return path;\n      });\n      copyObject(object, getAllKeysIn(object), result);\n      if (isDeep) {\n        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG);\n      }\n      var length = paths.length;\n      while (length--) {\n        baseUnset(result, paths[length]);\n      }\n      return result;\n    });\n\n    /**\n     * The opposite of `_.pickBy`; this method creates an object composed of\n     * the own and inherited enumerable string keyed properties of `object` that\n     * `predicate` doesn't return truthy for. The predicate is invoked with two\n     * arguments: (value, key).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function} [predicate=_.identity] The function invoked per property.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.omitBy(object, _.isNumber);\n     * // => { 'b': '2' }\n     */\n    function omitBy(object, predicate) {\n      return pickBy(object, negate(getIteratee(predicate)));\n    }\n\n    /**\n     * Creates an object composed of the picked `object` properties.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.pick(object, ['a', 'c']);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    var pick = flatRest(function(object, paths) {\n      return object == null ? {} : basePick(object, paths);\n    });\n\n    /**\n     * Creates an object composed of the `object` properties `predicate` returns\n     * truthy for. The predicate is invoked with two arguments: (value, key).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function} [predicate=_.identity] The function invoked per property.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.pickBy(object, _.isNumber);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    function pickBy(object, predicate) {\n      if (object == null) {\n        return {};\n      }\n      var props = arrayMap(getAllKeysIn(object), function(prop) {\n        return [prop];\n      });\n      predicate = getIteratee(predicate);\n      return basePickBy(object, props, function(value, path) {\n        return predicate(value, path[0]);\n      });\n    }\n\n    /**\n     * This method is like `_.get` except that if the resolved value is a\n     * function it's invoked with the `this` binding of its parent object and\n     * its result is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to resolve.\n     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };\n     *\n     * _.result(object, 'a[0].b.c1');\n     * // => 3\n     *\n     * _.result(object, 'a[0].b.c2');\n     * // => 4\n     *\n     * _.result(object, 'a[0].b.c3', 'default');\n     * // => 'default'\n     *\n     * _.result(object, 'a[0].b.c3', _.constant('default'));\n     * // => 'default'\n     */\n    function result(object, path, defaultValue) {\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length;\n\n      // Ensure the loop is entered when path is empty.\n      if (!length) {\n        length = 1;\n        object = undefined;\n      }\n      while (++index < length) {\n        var value = object == null ? undefined : object[toKey(path[index])];\n        if (value === undefined) {\n          index = length;\n          value = defaultValue;\n        }\n        object = isFunction(value) ? value.call(object) : value;\n      }\n      return object;\n    }\n\n    /**\n     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\n     * it's created. Arrays are created for missing index properties while objects\n     * are created for all other missing properties. Use `_.setWith` to customize\n     * `path` creation.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.set(object, 'a[0].b.c', 4);\n     * console.log(object.a[0].b.c);\n     * // => 4\n     *\n     * _.set(object, ['x', '0', 'y', 'z'], 5);\n     * console.log(object.x[0].y.z);\n     * // => 5\n     */\n    function set(object, path, value) {\n      return object == null ? object : baseSet(object, path, value);\n    }\n\n    /**\n     * This method is like `_.set` except that it accepts `customizer` which is\n     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n     * path creation is handled by the method instead. The `customizer` is invoked\n     * with three arguments: (nsValue, key, nsObject).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {};\n     *\n     * _.setWith(object, '[0][1]', 'a', Object);\n     * // => { '0': { '1': 'a' } }\n     */\n    function setWith(object, path, value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return object == null ? object : baseSet(object, path, value, customizer);\n    }\n\n    /**\n     * Creates an array of own enumerable string keyed-value pairs for `object`\n     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its\n     * entries are returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias entries\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the key-value pairs.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.toPairs(new Foo);\n     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)\n     */\n    var toPairs = createToPairs(keys);\n\n    /**\n     * Creates an array of own and inherited enumerable string keyed-value pairs\n     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map\n     * or set, its entries are returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias entriesIn\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the key-value pairs.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.toPairsIn(new Foo);\n     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)\n     */\n    var toPairsIn = createToPairs(keysIn);\n\n    /**\n     * An alternative to `_.reduce`; this method transforms `object` to a new\n     * `accumulator` object which is the result of running each of its own\n     * enumerable string keyed properties thru `iteratee`, with each invocation\n     * potentially mutating the `accumulator` object. If `accumulator` is not\n     * provided, a new object with the same `[[Prototype]]` will be used. The\n     * iteratee is invoked with four arguments: (accumulator, value, key, object).\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The custom accumulator value.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * _.transform([2, 3, 4], function(result, n) {\n     *   result.push(n *= n);\n     *   return n % 2 == 0;\n     * }, []);\n     * // => [4, 9]\n     *\n     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n     *   (result[value] || (result[value] = [])).push(key);\n     * }, {});\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     */\n    function transform(object, iteratee, accumulator) {\n      var isArr = isArray(object),\n          isArrLike = isArr || isBuffer(object) || isTypedArray(object);\n\n      iteratee = getIteratee(iteratee, 4);\n      if (accumulator == null) {\n        var Ctor = object && object.constructor;\n        if (isArrLike) {\n          accumulator = isArr ? new Ctor : [];\n        }\n        else if (isObject(object)) {\n          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};\n        }\n        else {\n          accumulator = {};\n        }\n      }\n      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {\n        return iteratee(accumulator, value, index, object);\n      });\n      return accumulator;\n    }\n\n    /**\n     * Removes the property at `path` of `object`.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to unset.\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 7 } }] };\n     * _.unset(object, 'a[0].b.c');\n     * // => true\n     *\n     * console.log(object);\n     * // => { 'a': [{ 'b': {} }] };\n     *\n     * _.unset(object, ['a', '0', 'b', 'c']);\n     * // => true\n     *\n     * console.log(object);\n     * // => { 'a': [{ 'b': {} }] };\n     */\n    function unset(object, path) {\n      return object == null ? true : baseUnset(object, path);\n    }\n\n    /**\n     * This method is like `_.set` except that accepts `updater` to produce the\n     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`\n     * is invoked with one argument: (value).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {Function} updater The function to produce the updated value.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.update(object, 'a[0].b.c', function(n) { return n * n; });\n     * console.log(object.a[0].b.c);\n     * // => 9\n     *\n     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });\n     * console.log(object.x[0].y.z);\n     * // => 0\n     */\n    function update(object, path, updater) {\n      return object == null ? object : baseUpdate(object, path, castFunction(updater));\n    }\n\n    /**\n     * This method is like `_.update` except that it accepts `customizer` which is\n     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n     * path creation is handled by the method instead. The `customizer` is invoked\n     * with three arguments: (nsValue, key, nsObject).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {Function} updater The function to produce the updated value.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {};\n     *\n     * _.updateWith(object, '[0][1]', _.constant('a'), Object);\n     * // => { '0': { '1': 'a' } }\n     */\n    function updateWith(object, path, updater, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);\n    }\n\n    /**\n     * Creates an array of the own enumerable string keyed property values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.values(new Foo);\n     * // => [1, 2] (iteration order is not guaranteed)\n     *\n     * _.values('hi');\n     * // => ['h', 'i']\n     */\n    function values(object) {\n      return object == null ? [] : baseValues(object, keys(object));\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable string keyed property\n     * values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.valuesIn(new Foo);\n     * // => [1, 2, 3] (iteration order is not guaranteed)\n     */\n    function valuesIn(object) {\n      return object == null ? [] : baseValues(object, keysIn(object));\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Clamps `number` within the inclusive `lower` and `upper` bounds.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Number\n     * @param {number} number The number to clamp.\n     * @param {number} [lower] The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the clamped number.\n     * @example\n     *\n     * _.clamp(-10, -5, 5);\n     * // => -5\n     *\n     * _.clamp(10, -5, 5);\n     * // => 5\n     */\n    function clamp(number, lower, upper) {\n      if (upper === undefined) {\n        upper = lower;\n        lower = undefined;\n      }\n      if (upper !== undefined) {\n        upper = toNumber(upper);\n        upper = upper === upper ? upper : 0;\n      }\n      if (lower !== undefined) {\n        lower = toNumber(lower);\n        lower = lower === lower ? lower : 0;\n      }\n      return baseClamp(toNumber(number), lower, upper);\n    }\n\n    /**\n     * Checks if `n` is between `start` and up to, but not including, `end`. If\n     * `end` is not specified, it's set to `start` with `start` then set to `0`.\n     * If `start` is greater than `end` the params are swapped to support\n     * negative ranges.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.3.0\n     * @category Number\n     * @param {number} number The number to check.\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n     * @see _.range, _.rangeRight\n     * @example\n     *\n     * _.inRange(3, 2, 4);\n     * // => true\n     *\n     * _.inRange(4, 8);\n     * // => true\n     *\n     * _.inRange(4, 2);\n     * // => false\n     *\n     * _.inRange(2, 2);\n     * // => false\n     *\n     * _.inRange(1.2, 2);\n     * // => true\n     *\n     * _.inRange(5.2, 4);\n     * // => false\n     *\n     * _.inRange(-3, -2, -6);\n     * // => true\n     */\n    function inRange(number, start, end) {\n      start = toFinite(start);\n      if (end === undefined) {\n        end = start;\n        start = 0;\n      } else {\n        end = toFinite(end);\n      }\n      number = toNumber(number);\n      return baseInRange(number, start, end);\n    }\n\n    /**\n     * Produces a random number between the inclusive `lower` and `upper` bounds.\n     * If only one argument is provided a number between `0` and the given number\n     * is returned. If `floating` is `true`, or either `lower` or `upper` are\n     * floats, a floating-point number is returned instead of an integer.\n     *\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n     * floating-point values which can produce unexpected results.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.7.0\n     * @category Number\n     * @param {number} [lower=0] The lower bound.\n     * @param {number} [upper=1] The upper bound.\n     * @param {boolean} [floating] Specify returning a floating-point number.\n     * @returns {number} Returns the random number.\n     * @example\n     *\n     * _.random(0, 5);\n     * // => an integer between 0 and 5\n     *\n     * _.random(5);\n     * // => also an integer between 0 and 5\n     *\n     * _.random(5, true);\n     * // => a floating-point number between 0 and 5\n     *\n     * _.random(1.2, 5.2);\n     * // => a floating-point number between 1.2 and 5.2\n     */\n    function random(lower, upper, floating) {\n      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {\n        upper = floating = undefined;\n      }\n      if (floating === undefined) {\n        if (typeof upper == 'boolean') {\n          floating = upper;\n          upper = undefined;\n        }\n        else if (typeof lower == 'boolean') {\n          floating = lower;\n          lower = undefined;\n        }\n      }\n      if (lower === undefined && upper === undefined) {\n        lower = 0;\n        upper = 1;\n      }\n      else {\n        lower = toFinite(lower);\n        if (upper === undefined) {\n          upper = lower;\n          lower = 0;\n        } else {\n          upper = toFinite(upper);\n        }\n      }\n      if (lower > upper) {\n        var temp = lower;\n        lower = upper;\n        upper = temp;\n      }\n      if (floating || lower % 1 || upper % 1) {\n        var rand = nativeRandom();\n        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);\n      }\n      return baseRandom(lower, upper);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the camel cased string.\n     * @example\n     *\n     * _.camelCase('Foo Bar');\n     * // => 'fooBar'\n     *\n     * _.camelCase('--foo-bar--');\n     * // => 'fooBar'\n     *\n     * _.camelCase('__FOO_BAR__');\n     * // => 'fooBar'\n     */\n    var camelCase = createCompounder(function(result, word, index) {\n      word = word.toLowerCase();\n      return result + (index ? capitalize(word) : word);\n    });\n\n    /**\n     * Converts the first character of `string` to upper case and the remaining\n     * to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to capitalize.\n     * @returns {string} Returns the capitalized string.\n     * @example\n     *\n     * _.capitalize('FRED');\n     * // => 'Fred'\n     */\n    function capitalize(string) {\n      return upperFirst(toString(string).toLowerCase());\n    }\n\n    /**\n     * Deburrs `string` by converting\n     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\n     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)\n     * letters to basic Latin letters and removing\n     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to deburr.\n     * @returns {string} Returns the deburred string.\n     * @example\n     *\n     * _.deburr('déjà vu');\n     * // => 'deja vu'\n     */\n    function deburr(string) {\n      string = toString(string);\n      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');\n    }\n\n    /**\n     * Checks if `string` ends with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=string.length] The position to search up to.\n     * @returns {boolean} Returns `true` if `string` ends with `target`,\n     *  else `false`.\n     * @example\n     *\n     * _.endsWith('abc', 'c');\n     * // => true\n     *\n     * _.endsWith('abc', 'b');\n     * // => false\n     *\n     * _.endsWith('abc', 'b', 2);\n     * // => true\n     */\n    function endsWith(string, target, position) {\n      string = toString(string);\n      target = baseToString(target);\n\n      var length = string.length;\n      position = position === undefined\n        ? length\n        : baseClamp(toInteger(position), 0, length);\n\n      var end = position;\n      position -= target.length;\n      return position >= 0 && string.slice(position, end) == target;\n    }\n\n    /**\n     * Converts the characters \"&\", \"<\", \">\", '\"', and \"'\" in `string` to their\n     * corresponding HTML entities.\n     *\n     * **Note:** No other characters are escaped. To escape additional\n     * characters use a third-party library like [_he_](https://mths.be/he).\n     *\n     * Though the \">\" character is escaped for symmetry, characters like\n     * \">\" and \"/\" don't need escaping in HTML and have no special meaning\n     * unless they're part of a tag or unquoted attribute value. See\n     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)\n     * (under \"semi-related fun fact\") for more details.\n     *\n     * When working with HTML you should always\n     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce\n     * XSS vectors.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escape('fred, barney, & pebbles');\n     * // => 'fred, barney, &amp; pebbles'\n     */\n    function escape(string) {\n      string = toString(string);\n      return (string && reHasUnescapedHtml.test(string))\n        ? string.replace(reUnescapedHtml, escapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Escapes the `RegExp` special characters \"^\", \"$\", \"\\\", \".\", \"*\", \"+\",\n     * \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escapeRegExp('[lodash](https://lodash.com/)');\n     * // => '\\[lodash\\]\\(https://lodash\\.com/\\)'\n     */\n    function escapeRegExp(string) {\n      string = toString(string);\n      return (string && reHasRegExpChar.test(string))\n        ? string.replace(reRegExpChar, '\\\\$&')\n        : string;\n    }\n\n    /**\n     * Converts `string` to\n     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the kebab cased string.\n     * @example\n     *\n     * _.kebabCase('Foo Bar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('fooBar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('__FOO_BAR__');\n     * // => 'foo-bar'\n     */\n    var kebabCase = createCompounder(function(result, word, index) {\n      return result + (index ? '-' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts `string`, as space separated words, to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the lower cased string.\n     * @example\n     *\n     * _.lowerCase('--Foo-Bar--');\n     * // => 'foo bar'\n     *\n     * _.lowerCase('fooBar');\n     * // => 'foo bar'\n     *\n     * _.lowerCase('__FOO_BAR__');\n     * // => 'foo bar'\n     */\n    var lowerCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts the first character of `string` to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.lowerFirst('Fred');\n     * // => 'fred'\n     *\n     * _.lowerFirst('FRED');\n     * // => 'fRED'\n     */\n    var lowerFirst = createCaseFirst('toLowerCase');\n\n    /**\n     * Pads `string` on the left and right sides if it's shorter than `length`.\n     * Padding characters are truncated if they can't be evenly divided by `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.pad('abc', 8);\n     * // => '  abc   '\n     *\n     * _.pad('abc', 8, '_-');\n     * // => '_-abc_-_'\n     *\n     * _.pad('abc', 3);\n     * // => 'abc'\n     */\n    function pad(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      if (!length || strLength >= length) {\n        return string;\n      }\n      var mid = (length - strLength) / 2;\n      return (\n        createPadding(nativeFloor(mid), chars) +\n        string +\n        createPadding(nativeCeil(mid), chars)\n      );\n    }\n\n    /**\n     * Pads `string` on the right side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padEnd('abc', 6);\n     * // => 'abc   '\n     *\n     * _.padEnd('abc', 6, '_-');\n     * // => 'abc_-_'\n     *\n     * _.padEnd('abc', 3);\n     * // => 'abc'\n     */\n    function padEnd(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      return (length && strLength < length)\n        ? (string + createPadding(length - strLength, chars))\n        : string;\n    }\n\n    /**\n     * Pads `string` on the left side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padStart('abc', 6);\n     * // => '   abc'\n     *\n     * _.padStart('abc', 6, '_-');\n     * // => '_-_abc'\n     *\n     * _.padStart('abc', 3);\n     * // => 'abc'\n     */\n    function padStart(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      return (length && strLength < length)\n        ? (createPadding(length - strLength, chars) + string)\n        : string;\n    }\n\n    /**\n     * Converts `string` to an integer of the specified radix. If `radix` is\n     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a\n     * hexadecimal, in which case a `radix` of `16` is used.\n     *\n     * **Note:** This method aligns with the\n     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category String\n     * @param {string} string The string to convert.\n     * @param {number} [radix=10] The radix to interpret `value` by.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.parseInt('08');\n     * // => 8\n     *\n     * _.map(['6', '08', '10'], _.parseInt);\n     * // => [6, 8, 10]\n     */\n    function parseInt(string, radix, guard) {\n      if (guard || radix == null) {\n        radix = 0;\n      } else if (radix) {\n        radix = +radix;\n      }\n      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);\n    }\n\n    /**\n     * Repeats the given string `n` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to repeat.\n     * @param {number} [n=1] The number of times to repeat the string.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the repeated string.\n     * @example\n     *\n     * _.repeat('*', 3);\n     * // => '***'\n     *\n     * _.repeat('abc', 2);\n     * // => 'abcabc'\n     *\n     * _.repeat('abc', 0);\n     * // => ''\n     */\n    function repeat(string, n, guard) {\n      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {\n        n = 1;\n      } else {\n        n = toInteger(n);\n      }\n      return baseRepeat(toString(string), n);\n    }\n\n    /**\n     * Replaces matches for `pattern` in `string` with `replacement`.\n     *\n     * **Note:** This method is based on\n     * [`String#replace`](https://mdn.io/String/replace).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to modify.\n     * @param {RegExp|string} pattern The pattern to replace.\n     * @param {Function|string} replacement The match replacement.\n     * @returns {string} Returns the modified string.\n     * @example\n     *\n     * _.replace('Hi Fred', 'Fred', 'Barney');\n     * // => 'Hi Barney'\n     */\n    function replace() {\n      var args = arguments,\n          string = toString(args[0]);\n\n      return args.length < 3 ? string : string.replace(args[1], args[2]);\n    }\n\n    /**\n     * Converts `string` to\n     * [snake case](https://en.wikipedia.org/wiki/Snake_case).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the snake cased string.\n     * @example\n     *\n     * _.snakeCase('Foo Bar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('fooBar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('--FOO-BAR--');\n     * // => 'foo_bar'\n     */\n    var snakeCase = createCompounder(function(result, word, index) {\n      return result + (index ? '_' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Splits `string` by `separator`.\n     *\n     * **Note:** This method is based on\n     * [`String#split`](https://mdn.io/String/split).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to split.\n     * @param {RegExp|string} separator The separator pattern to split by.\n     * @param {number} [limit] The length to truncate results to.\n     * @returns {Array} Returns the string segments.\n     * @example\n     *\n     * _.split('a-b-c', '-', 2);\n     * // => ['a', 'b']\n     */\n    function split(string, separator, limit) {\n      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {\n        separator = limit = undefined;\n      }\n      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;\n      if (!limit) {\n        return [];\n      }\n      string = toString(string);\n      if (string && (\n            typeof separator == 'string' ||\n            (separator != null && !isRegExp(separator))\n          )) {\n        separator = baseToString(separator);\n        if (!separator && hasUnicode(string)) {\n          return castSlice(stringToArray(string), 0, limit);\n        }\n      }\n      return string.split(separator, limit);\n    }\n\n    /**\n     * Converts `string` to\n     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.1.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the start cased string.\n     * @example\n     *\n     * _.startCase('--foo-bar--');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('fooBar');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('__FOO_BAR__');\n     * // => 'FOO BAR'\n     */\n    var startCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + upperFirst(word);\n    });\n\n    /**\n     * Checks if `string` starts with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=0] The position to search from.\n     * @returns {boolean} Returns `true` if `string` starts with `target`,\n     *  else `false`.\n     * @example\n     *\n     * _.startsWith('abc', 'a');\n     * // => true\n     *\n     * _.startsWith('abc', 'b');\n     * // => false\n     *\n     * _.startsWith('abc', 'b', 1);\n     * // => true\n     */\n    function startsWith(string, target, position) {\n      string = toString(string);\n      position = baseClamp(toInteger(position), 0, string.length);\n      target = baseToString(target);\n      return string.slice(position, position + target.length) == target;\n    }\n\n    /**\n     * Creates a compiled template function that can interpolate data properties\n     * in \"interpolate\" delimiters, HTML-escape interpolated data properties in\n     * \"escape\" delimiters, and execute JavaScript in \"evaluate\" delimiters. Data\n     * properties may be accessed as free variables in the template. If a setting\n     * object is given, it takes precedence over `_.templateSettings` values.\n     *\n     * **Note:** In the development build `_.template` utilizes\n     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)\n     * for easier debugging.\n     *\n     * For more information on precompiling templates see\n     * [lodash's custom builds documentation](https://lodash.com/custom-builds).\n     *\n     * For more information on Chrome extension sandboxes see\n     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The template string.\n     * @param {Object} [options={}] The options object.\n     * @param {RegExp} [options.escape=_.templateSettings.escape]\n     *  The HTML \"escape\" delimiter.\n     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]\n     *  The \"evaluate\" delimiter.\n     * @param {Object} [options.imports=_.templateSettings.imports]\n     *  An object to import into the template as free variables.\n     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]\n     *  The \"interpolate\" delimiter.\n     * @param {string} [options.sourceURL='lodash.templateSources[n]']\n     *  The sourceURL of the compiled template.\n     * @param {string} [options.variable='obj']\n     *  The data object variable name.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the compiled template function.\n     * @example\n     *\n     * // Use the \"interpolate\" delimiter to create a compiled template.\n     * var compiled = _.template('hello <%= user %>!');\n     * compiled({ 'user': 'fred' });\n     * // => 'hello fred!'\n     *\n     * // Use the HTML \"escape\" delimiter to escape data property values.\n     * var compiled = _.template('<b><%- value %></b>');\n     * compiled({ 'value': '<script>' });\n     * // => '<b>&lt;script&gt;</b>'\n     *\n     * // Use the \"evaluate\" delimiter to execute JavaScript and generate HTML.\n     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // Use the internal `print` function in \"evaluate\" delimiters.\n     * var compiled = _.template('<% print(\"hello \" + user); %>!');\n     * compiled({ 'user': 'barney' });\n     * // => 'hello barney!'\n     *\n     * // Use the ES template literal delimiter as an \"interpolate\" delimiter.\n     * // Disable support by replacing the \"interpolate\" delimiter.\n     * var compiled = _.template('hello ${ user }!');\n     * compiled({ 'user': 'pebbles' });\n     * // => 'hello pebbles!'\n     *\n     * // Use backslashes to treat delimiters as plain text.\n     * var compiled = _.template('<%= \"\\\\<%- value %\\\\>\" %>');\n     * compiled({ 'value': 'ignored' });\n     * // => '<%- value %>'\n     *\n     * // Use the `imports` option to import `jQuery` as `jq`.\n     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';\n     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // Use the `sourceURL` option to specify a custom sourceURL for the template.\n     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });\n     * compiled(data);\n     * // => Find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector.\n     *\n     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.\n     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });\n     * compiled.source;\n     * // => function(data) {\n     * //   var __t, __p = '';\n     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';\n     * //   return __p;\n     * // }\n     *\n     * // Use custom template delimiters.\n     * _.templateSettings.interpolate = /{{([\\s\\S]+?)}}/g;\n     * var compiled = _.template('hello {{ user }}!');\n     * compiled({ 'user': 'mustache' });\n     * // => 'hello mustache!'\n     *\n     * // Use the `source` property to inline compiled templates for meaningful\n     * // line numbers in error messages and stack traces.\n     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\\\n     *   var JST = {\\\n     *     \"main\": ' + _.template(mainText).source + '\\\n     *   };\\\n     * ');\n     */\n    function template(string, options, guard) {\n      // Based on John Resig's `tmpl` implementation\n      // (http://ejohn.org/blog/javascript-micro-templating/)\n      // and Laura Doktorova's doT.js (https://github.com/olado/doT).\n      var settings = lodash.templateSettings;\n\n      if (guard && isIterateeCall(string, options, guard)) {\n        options = undefined;\n      }\n      string = toString(string);\n      options = assignInWith({}, options, settings, assignInDefaults);\n\n      var imports = assignInWith({}, options.imports, settings.imports, assignInDefaults),\n          importsKeys = keys(imports),\n          importsValues = baseValues(imports, importsKeys);\n\n      var isEscaping,\n          isEvaluating,\n          index = 0,\n          interpolate = options.interpolate || reNoMatch,\n          source = \"__p += '\";\n\n      // Compile the regexp to match each delimiter.\n      var reDelimiters = RegExp(\n        (options.escape || reNoMatch).source + '|' +\n        interpolate.source + '|' +\n        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +\n        (options.evaluate || reNoMatch).source + '|$'\n      , 'g');\n\n      // Use a sourceURL for easier debugging.\n      var sourceURL = '//# sourceURL=' +\n        ('sourceURL' in options\n          ? options.sourceURL\n          : ('lodash.templateSources[' + (++templateCounter) + ']')\n        ) + '\\n';\n\n      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n        interpolateValue || (interpolateValue = esTemplateValue);\n\n        // Escape characters that can't be included in string literals.\n        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n\n        // Replace delimiters with snippets.\n        if (escapeValue) {\n          isEscaping = true;\n          source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\n        }\n        if (evaluateValue) {\n          isEvaluating = true;\n          source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n        }\n        if (interpolateValue) {\n          source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n        }\n        index = offset + match.length;\n\n        // The JS engine embedded in Adobe products needs `match` returned in\n        // order to produce the correct `offset` value.\n        return match;\n      });\n\n      source += \"';\\n\";\n\n      // If `variable` is not specified wrap a with-statement around the generated\n      // code to add the data object to the top of the scope chain.\n      var variable = options.variable;\n      if (!variable) {\n        source = 'with (obj) {\\n' + source + '\\n}\\n';\n      }\n      // Cleanup code by stripping empty strings.\n      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)\n        .replace(reEmptyStringMiddle, '$1')\n        .replace(reEmptyStringTrailing, '$1;');\n\n      // Frame code as the function body.\n      source = 'function(' + (variable || 'obj') + ') {\\n' +\n        (variable\n          ? ''\n          : 'obj || (obj = {});\\n'\n        ) +\n        \"var __t, __p = ''\" +\n        (isEscaping\n           ? ', __e = _.escape'\n           : ''\n        ) +\n        (isEvaluating\n          ? ', __j = Array.prototype.join;\\n' +\n            \"function print() { __p += __j.call(arguments, '') }\\n\"\n          : ';\\n'\n        ) +\n        source +\n        'return __p\\n}';\n\n      var result = attempt(function() {\n        return Function(importsKeys, sourceURL + 'return ' + source)\n          .apply(undefined, importsValues);\n      });\n\n      // Provide the compiled function's source by its `toString` method or\n      // the `source` property as a convenience for inlining compiled templates.\n      result.source = source;\n      if (isError(result)) {\n        throw result;\n      }\n      return result;\n    }\n\n    /**\n     * Converts `string`, as a whole, to lower case just like\n     * [String#toLowerCase](https://mdn.io/toLowerCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the lower cased string.\n     * @example\n     *\n     * _.toLower('--Foo-Bar--');\n     * // => '--foo-bar--'\n     *\n     * _.toLower('fooBar');\n     * // => 'foobar'\n     *\n     * _.toLower('__FOO_BAR__');\n     * // => '__foo_bar__'\n     */\n    function toLower(value) {\n      return toString(value).toLowerCase();\n    }\n\n    /**\n     * Converts `string`, as a whole, to upper case just like\n     * [String#toUpperCase](https://mdn.io/toUpperCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the upper cased string.\n     * @example\n     *\n     * _.toUpper('--foo-bar--');\n     * // => '--FOO-BAR--'\n     *\n     * _.toUpper('fooBar');\n     * // => 'FOOBAR'\n     *\n     * _.toUpper('__foo_bar__');\n     * // => '__FOO_BAR__'\n     */\n    function toUpper(value) {\n      return toString(value).toUpperCase();\n    }\n\n    /**\n     * Removes leading and trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trim('  abc  ');\n     * // => 'abc'\n     *\n     * _.trim('-_-abc-_-', '_-');\n     * // => 'abc'\n     *\n     * _.map(['  foo  ', '  bar  '], _.trim);\n     * // => ['foo', 'bar']\n     */\n    function trim(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.replace(reTrim, '');\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          chrSymbols = stringToArray(chars),\n          start = charsStartIndex(strSymbols, chrSymbols),\n          end = charsEndIndex(strSymbols, chrSymbols) + 1;\n\n      return castSlice(strSymbols, start, end).join('');\n    }\n\n    /**\n     * Removes trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimEnd('  abc  ');\n     * // => '  abc'\n     *\n     * _.trimEnd('-_-abc-_-', '_-');\n     * // => '-_-abc'\n     */\n    function trimEnd(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.replace(reTrimEnd, '');\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;\n\n      return castSlice(strSymbols, 0, end).join('');\n    }\n\n    /**\n     * Removes leading whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimStart('  abc  ');\n     * // => 'abc  '\n     *\n     * _.trimStart('-_-abc-_-', '_-');\n     * // => 'abc-_-'\n     */\n    function trimStart(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.replace(reTrimStart, '');\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          start = charsStartIndex(strSymbols, stringToArray(chars));\n\n      return castSlice(strSymbols, start).join('');\n    }\n\n    /**\n     * Truncates `string` if it's longer than the given maximum string length.\n     * The last characters of the truncated string are replaced with the omission\n     * string which defaults to \"...\".\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to truncate.\n     * @param {Object} [options={}] The options object.\n     * @param {number} [options.length=30] The maximum string length.\n     * @param {string} [options.omission='...'] The string to indicate text is omitted.\n     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.\n     * @returns {string} Returns the truncated string.\n     * @example\n     *\n     * _.truncate('hi-diddly-ho there, neighborino');\n     * // => 'hi-diddly-ho there, neighbo...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': ' '\n     * });\n     * // => 'hi-diddly-ho there,...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': /,? +/\n     * });\n     * // => 'hi-diddly-ho there...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'omission': ' [...]'\n     * });\n     * // => 'hi-diddly-ho there, neig [...]'\n     */\n    function truncate(string, options) {\n      var length = DEFAULT_TRUNC_LENGTH,\n          omission = DEFAULT_TRUNC_OMISSION;\n\n      if (isObject(options)) {\n        var separator = 'separator' in options ? options.separator : separator;\n        length = 'length' in options ? toInteger(options.length) : length;\n        omission = 'omission' in options ? baseToString(options.omission) : omission;\n      }\n      string = toString(string);\n\n      var strLength = string.length;\n      if (hasUnicode(string)) {\n        var strSymbols = stringToArray(string);\n        strLength = strSymbols.length;\n      }\n      if (length >= strLength) {\n        return string;\n      }\n      var end = length - stringSize(omission);\n      if (end < 1) {\n        return omission;\n      }\n      var result = strSymbols\n        ? castSlice(strSymbols, 0, end).join('')\n        : string.slice(0, end);\n\n      if (separator === undefined) {\n        return result + omission;\n      }\n      if (strSymbols) {\n        end += (result.length - end);\n      }\n      if (isRegExp(separator)) {\n        if (string.slice(end).search(separator)) {\n          var match,\n              substring = result;\n\n          if (!separator.global) {\n            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');\n          }\n          separator.lastIndex = 0;\n          while ((match = separator.exec(substring))) {\n            var newEnd = match.index;\n          }\n          result = result.slice(0, newEnd === undefined ? end : newEnd);\n        }\n      } else if (string.indexOf(baseToString(separator), end) != end) {\n        var index = result.lastIndexOf(separator);\n        if (index > -1) {\n          result = result.slice(0, index);\n        }\n      }\n      return result + omission;\n    }\n\n    /**\n     * The inverse of `_.escape`; this method converts the HTML entities\n     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to\n     * their corresponding characters.\n     *\n     * **Note:** No other HTML entities are unescaped. To unescape additional\n     * HTML entities use a third-party library like [_he_](https://mths.be/he).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.6.0\n     * @category String\n     * @param {string} [string=''] The string to unescape.\n     * @returns {string} Returns the unescaped string.\n     * @example\n     *\n     * _.unescape('fred, barney, &amp; pebbles');\n     * // => 'fred, barney, & pebbles'\n     */\n    function unescape(string) {\n      string = toString(string);\n      return (string && reHasEscapedHtml.test(string))\n        ? string.replace(reEscapedHtml, unescapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Converts `string`, as space separated words, to upper case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the upper cased string.\n     * @example\n     *\n     * _.upperCase('--foo-bar');\n     * // => 'FOO BAR'\n     *\n     * _.upperCase('fooBar');\n     * // => 'FOO BAR'\n     *\n     * _.upperCase('__foo_bar__');\n     * // => 'FOO BAR'\n     */\n    var upperCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + word.toUpperCase();\n    });\n\n    /**\n     * Converts the first character of `string` to upper case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.upperFirst('fred');\n     * // => 'Fred'\n     *\n     * _.upperFirst('FRED');\n     * // => 'FRED'\n     */\n    var upperFirst = createCaseFirst('toUpperCase');\n\n    /**\n     * Splits `string` into an array of its words.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {RegExp|string} [pattern] The pattern to match words.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the words of `string`.\n     * @example\n     *\n     * _.words('fred, barney, & pebbles');\n     * // => ['fred', 'barney', 'pebbles']\n     *\n     * _.words('fred, barney, & pebbles', /[^, ]+/g);\n     * // => ['fred', 'barney', '&', 'pebbles']\n     */\n    function words(string, pattern, guard) {\n      string = toString(string);\n      pattern = guard ? undefined : pattern;\n\n      if (pattern === undefined) {\n        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\n      }\n      return string.match(pattern) || [];\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Attempts to invoke `func`, returning either the result or the caught error\n     * object. Any additional arguments are provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Function} func The function to attempt.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {*} Returns the `func` result or error object.\n     * @example\n     *\n     * // Avoid throwing errors for invalid selectors.\n     * var elements = _.attempt(function(selector) {\n     *   return document.querySelectorAll(selector);\n     * }, '>_>');\n     *\n     * if (_.isError(elements)) {\n     *   elements = [];\n     * }\n     */\n    var attempt = baseRest(function(func, args) {\n      try {\n        return apply(func, undefined, args);\n      } catch (e) {\n        return isError(e) ? e : new Error(e);\n      }\n    });\n\n    /**\n     * Binds methods of an object to the object itself, overwriting the existing\n     * method.\n     *\n     * **Note:** This method doesn't set the \"length\" property of bound functions.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {Object} object The object to bind and assign the bound methods to.\n     * @param {...(string|string[])} methodNames The object method names to bind.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var view = {\n     *   'label': 'docs',\n     *   'click': function() {\n     *     console.log('clicked ' + this.label);\n     *   }\n     * };\n     *\n     * _.bindAll(view, ['click']);\n     * jQuery(element).on('click', view.click);\n     * // => Logs 'clicked docs' when clicked.\n     */\n    var bindAll = flatRest(function(object, methodNames) {\n      arrayEach(methodNames, function(key) {\n        key = toKey(key);\n        baseAssignValue(object, key, bind(object[key], object));\n      });\n      return object;\n    });\n\n    /**\n     * Creates a function that iterates over `pairs` and invokes the corresponding\n     * function of the first predicate to return truthy. The predicate-function\n     * pairs are invoked with the `this` binding and arguments of the created\n     * function.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {Array} pairs The predicate-function pairs.\n     * @returns {Function} Returns the new composite function.\n     * @example\n     *\n     * var func = _.cond([\n     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],\n     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],\n     *   [_.stubTrue,                      _.constant('no match')]\n     * ]);\n     *\n     * func({ 'a': 1, 'b': 2 });\n     * // => 'matches A'\n     *\n     * func({ 'a': 0, 'b': 1 });\n     * // => 'matches B'\n     *\n     * func({ 'a': '1', 'b': '2' });\n     * // => 'no match'\n     */\n    function cond(pairs) {\n      var length = pairs == null ? 0 : pairs.length,\n          toIteratee = getIteratee();\n\n      pairs = !length ? [] : arrayMap(pairs, function(pair) {\n        if (typeof pair[1] != 'function') {\n          throw new TypeError(FUNC_ERROR_TEXT);\n        }\n        return [toIteratee(pair[0]), pair[1]];\n      });\n\n      return baseRest(function(args) {\n        var index = -1;\n        while (++index < length) {\n          var pair = pairs[index];\n          if (apply(pair[0], this, args)) {\n            return apply(pair[1], this, args);\n          }\n        }\n      });\n    }\n\n    /**\n     * Creates a function that invokes the predicate properties of `source` with\n     * the corresponding property values of a given object, returning `true` if\n     * all predicates return truthy, else `false`.\n     *\n     * **Note:** The created function is equivalent to `_.conformsTo` with\n     * `source` partially applied.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 2, 'b': 1 },\n     *   { 'a': 1, 'b': 2 }\n     * ];\n     *\n     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));\n     * // => [{ 'a': 1, 'b': 2 }]\n     */\n    function conforms(source) {\n      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that returns `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Util\n     * @param {*} value The value to return from the new function.\n     * @returns {Function} Returns the new constant function.\n     * @example\n     *\n     * var objects = _.times(2, _.constant({ 'a': 1 }));\n     *\n     * console.log(objects);\n     * // => [{ 'a': 1 }, { 'a': 1 }]\n     *\n     * console.log(objects[0] === objects[1]);\n     * // => true\n     */\n    function constant(value) {\n      return function() {\n        return value;\n      };\n    }\n\n    /**\n     * Checks `value` to determine whether a default value should be returned in\n     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,\n     * or `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.14.0\n     * @category Util\n     * @param {*} value The value to check.\n     * @param {*} defaultValue The default value.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * _.defaultTo(1, 10);\n     * // => 1\n     *\n     * _.defaultTo(undefined, 10);\n     * // => 10\n     */\n    function defaultTo(value, defaultValue) {\n      return (value == null || value !== value) ? defaultValue : value;\n    }\n\n    /**\n     * Creates a function that returns the result of invoking the given functions\n     * with the `this` binding of the created function, where each successive\n     * invocation is supplied the return value of the previous.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [funcs] The functions to invoke.\n     * @returns {Function} Returns the new composite function.\n     * @see _.flowRight\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flow([_.add, square]);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flow = createFlow();\n\n    /**\n     * This method is like `_.flow` except that it creates a function that\n     * invokes the given functions from right to left.\n     *\n     * @static\n     * @since 3.0.0\n     * @memberOf _\n     * @category Util\n     * @param {...(Function|Function[])} [funcs] The functions to invoke.\n     * @returns {Function} Returns the new composite function.\n     * @see _.flow\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flowRight([square, _.add]);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flowRight = createFlow(true);\n\n    /**\n     * This method returns the first argument it receives.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {*} value Any value.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     *\n     * console.log(_.identity(object) === object);\n     * // => true\n     */\n    function identity(value) {\n      return value;\n    }\n\n    /**\n     * Creates a function that invokes `func` with the arguments of the created\n     * function. If `func` is a property name, the created function returns the\n     * property value for a given element. If `func` is an array or object, the\n     * created function returns `true` for elements that contain the equivalent\n     * source properties, otherwise it returns `false`.\n     *\n     * @static\n     * @since 4.0.0\n     * @memberOf _\n     * @category Util\n     * @param {*} [func=_.identity] The value to convert to a callback.\n     * @returns {Function} Returns the callback.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));\n     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.filter(users, _.iteratee(['user', 'fred']));\n     * // => [{ 'user': 'fred', 'age': 40 }]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.map(users, _.iteratee('user'));\n     * // => ['barney', 'fred']\n     *\n     * // Create custom iteratee shorthands.\n     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {\n     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {\n     *     return func.test(string);\n     *   };\n     * });\n     *\n     * _.filter(['abc', 'def'], /ef/);\n     * // => ['def']\n     */\n    function iteratee(func) {\n      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that performs a partial deep comparison between a given\n     * object and `source`, returning `true` if the given object has equivalent\n     * property values, else `false`.\n     *\n     * **Note:** The created function is equivalent to `_.isMatch` with `source`\n     * partially applied.\n     *\n     * Partial comparisons will match empty array and empty object `source`\n     * values against any array or object value, respectively. See `_.isEqual`\n     * for a list of supported value comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 1, 'b': 2, 'c': 3 },\n     *   { 'a': 4, 'b': 5, 'c': 6 }\n     * ];\n     *\n     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));\n     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]\n     */\n    function matches(source) {\n      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that performs a partial deep comparison between the\n     * value at `path` of a given object to `srcValue`, returning `true` if the\n     * object value is equivalent, else `false`.\n     *\n     * **Note:** Partial comparisons will match empty array and empty object\n     * `srcValue` values against any array or object value, respectively. See\n     * `_.isEqual` for a list of supported value comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Util\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 1, 'b': 2, 'c': 3 },\n     *   { 'a': 4, 'b': 5, 'c': 6 }\n     * ];\n     *\n     * _.find(objects, _.matchesProperty('a', 4));\n     * // => { 'a': 4, 'b': 5, 'c': 6 }\n     */\n    function matchesProperty(path, srcValue) {\n      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that invokes the method at `path` of a given object.\n     * Any additional arguments are provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Util\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new invoker function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': _.constant(2) } },\n     *   { 'a': { 'b': _.constant(1) } }\n     * ];\n     *\n     * _.map(objects, _.method('a.b'));\n     * // => [2, 1]\n     *\n     * _.map(objects, _.method(['a', 'b']));\n     * // => [2, 1]\n     */\n    var method = baseRest(function(path, args) {\n      return function(object) {\n        return baseInvoke(object, path, args);\n      };\n    });\n\n    /**\n     * The opposite of `_.method`; this method creates a function that invokes\n     * the method at a given path of `object`. Any additional arguments are\n     * provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Util\n     * @param {Object} object The object to query.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new invoker function.\n     * @example\n     *\n     * var array = _.times(3, _.constant),\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.methodOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));\n     * // => [2, 0]\n     */\n    var methodOf = baseRest(function(object, args) {\n      return function(path) {\n        return baseInvoke(object, path, args);\n      };\n    });\n\n    /**\n     * Adds all own enumerable string keyed function properties of a source\n     * object to the destination object. If `object` is a function, then methods\n     * are added to its prototype as well.\n     *\n     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to\n     * avoid conflicts caused by modifying the original.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {Function|Object} [object=lodash] The destination object.\n     * @param {Object} source The object of functions to add.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.\n     * @returns {Function|Object} Returns `object`.\n     * @example\n     *\n     * function vowels(string) {\n     *   return _.filter(string, function(v) {\n     *     return /[aeiou]/i.test(v);\n     *   });\n     * }\n     *\n     * _.mixin({ 'vowels': vowels });\n     * _.vowels('fred');\n     * // => ['e']\n     *\n     * _('fred').vowels().value();\n     * // => ['e']\n     *\n     * _.mixin({ 'vowels': vowels }, { 'chain': false });\n     * _('fred').vowels();\n     * // => ['e']\n     */\n    function mixin(object, source, options) {\n      var props = keys(source),\n          methodNames = baseFunctions(source, props);\n\n      if (options == null &&\n          !(isObject(source) && (methodNames.length || !props.length))) {\n        options = source;\n        source = object;\n        object = this;\n        methodNames = baseFunctions(source, keys(source));\n      }\n      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,\n          isFunc = isFunction(object);\n\n      arrayEach(methodNames, function(methodName) {\n        var func = source[methodName];\n        object[methodName] = func;\n        if (isFunc) {\n          object.prototype[methodName] = function() {\n            var chainAll = this.__chain__;\n            if (chain || chainAll) {\n              var result = object(this.__wrapped__),\n                  actions = result.__actions__ = copyArray(this.__actions__);\n\n              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });\n              result.__chain__ = chainAll;\n              return result;\n            }\n            return func.apply(object, arrayPush([this.value()], arguments));\n          };\n        }\n      });\n\n      return object;\n    }\n\n    /**\n     * Reverts the `_` variable to its previous value and returns a reference to\n     * the `lodash` function.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @returns {Function} Returns the `lodash` function.\n     * @example\n     *\n     * var lodash = _.noConflict();\n     */\n    function noConflict() {\n      if (root._ === this) {\n        root._ = oldDash;\n      }\n      return this;\n    }\n\n    /**\n     * This method returns `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.3.0\n     * @category Util\n     * @example\n     *\n     * _.times(2, _.noop);\n     * // => [undefined, undefined]\n     */\n    function noop() {\n      // No operation performed.\n    }\n\n    /**\n     * Creates a function that gets the argument at index `n`. If `n` is negative,\n     * the nth argument from the end is returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {number} [n=0] The index of the argument to return.\n     * @returns {Function} Returns the new pass-thru function.\n     * @example\n     *\n     * var func = _.nthArg(1);\n     * func('a', 'b', 'c', 'd');\n     * // => 'b'\n     *\n     * var func = _.nthArg(-2);\n     * func('a', 'b', 'c', 'd');\n     * // => 'c'\n     */\n    function nthArg(n) {\n      n = toInteger(n);\n      return baseRest(function(args) {\n        return baseNth(args, n);\n      });\n    }\n\n    /**\n     * Creates a function that invokes `iteratees` with the arguments it receives\n     * and returns their results.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [iteratees=[_.identity]]\n     *  The iteratees to invoke.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.over([Math.max, Math.min]);\n     *\n     * func(1, 2, 3, 4);\n     * // => [4, 1]\n     */\n    var over = createOver(arrayMap);\n\n    /**\n     * Creates a function that checks if **all** of the `predicates` return\n     * truthy when invoked with the arguments it receives.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [predicates=[_.identity]]\n     *  The predicates to check.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.overEvery([Boolean, isFinite]);\n     *\n     * func('1');\n     * // => true\n     *\n     * func(null);\n     * // => false\n     *\n     * func(NaN);\n     * // => false\n     */\n    var overEvery = createOver(arrayEvery);\n\n    /**\n     * Creates a function that checks if **any** of the `predicates` return\n     * truthy when invoked with the arguments it receives.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [predicates=[_.identity]]\n     *  The predicates to check.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.overSome([Boolean, isFinite]);\n     *\n     * func('1');\n     * // => true\n     *\n     * func(null);\n     * // => true\n     *\n     * func(NaN);\n     * // => false\n     */\n    var overSome = createOver(arraySome);\n\n    /**\n     * Creates a function that returns the value at `path` of a given object.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Util\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': 2 } },\n     *   { 'a': { 'b': 1 } }\n     * ];\n     *\n     * _.map(objects, _.property('a.b'));\n     * // => [2, 1]\n     *\n     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n     * // => [1, 2]\n     */\n    function property(path) {\n      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n    }\n\n    /**\n     * The opposite of `_.property`; this method creates a function that returns\n     * the value at a given path of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Object} object The object to query.\n     * @returns {Function} Returns the new accessor function.\n     * @example\n     *\n     * var array = [0, 1, 2],\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));\n     * // => [2, 0]\n     */\n    function propertyOf(object) {\n      return function(path) {\n        return object == null ? undefined : baseGet(object, path);\n      };\n    }\n\n    /**\n     * Creates an array of numbers (positive and/or negative) progressing from\n     * `start` up to, but not including, `end`. A step of `-1` is used if a negative\n     * `start` is specified without an `end` or `step`. If `end` is not specified,\n     * it's set to `start` with `start` then set to `0`.\n     *\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n     * floating-point values which can produce unexpected results.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the range of numbers.\n     * @see _.inRange, _.rangeRight\n     * @example\n     *\n     * _.range(4);\n     * // => [0, 1, 2, 3]\n     *\n     * _.range(-4);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 5);\n     * // => [1, 2, 3, 4]\n     *\n     * _.range(0, 20, 5);\n     * // => [0, 5, 10, 15]\n     *\n     * _.range(0, -4, -1);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.range(0);\n     * // => []\n     */\n    var range = createRange();\n\n    /**\n     * This method is like `_.range` except that it populates values in\n     * descending order.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the range of numbers.\n     * @see _.inRange, _.range\n     * @example\n     *\n     * _.rangeRight(4);\n     * // => [3, 2, 1, 0]\n     *\n     * _.rangeRight(-4);\n     * // => [-3, -2, -1, 0]\n     *\n     * _.rangeRight(1, 5);\n     * // => [4, 3, 2, 1]\n     *\n     * _.rangeRight(0, 20, 5);\n     * // => [15, 10, 5, 0]\n     *\n     * _.rangeRight(0, -4, -1);\n     * // => [-3, -2, -1, 0]\n     *\n     * _.rangeRight(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.rangeRight(0);\n     * // => []\n     */\n    var rangeRight = createRange(true);\n\n    /**\n     * This method returns a new empty array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {Array} Returns the new empty array.\n     * @example\n     *\n     * var arrays = _.times(2, _.stubArray);\n     *\n     * console.log(arrays);\n     * // => [[], []]\n     *\n     * console.log(arrays[0] === arrays[1]);\n     * // => false\n     */\n    function stubArray() {\n      return [];\n    }\n\n    /**\n     * This method returns `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {boolean} Returns `false`.\n     * @example\n     *\n     * _.times(2, _.stubFalse);\n     * // => [false, false]\n     */\n    function stubFalse() {\n      return false;\n    }\n\n    /**\n     * This method returns a new empty object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {Object} Returns the new empty object.\n     * @example\n     *\n     * var objects = _.times(2, _.stubObject);\n     *\n     * console.log(objects);\n     * // => [{}, {}]\n     *\n     * console.log(objects[0] === objects[1]);\n     * // => false\n     */\n    function stubObject() {\n      return {};\n    }\n\n    /**\n     * This method returns an empty string.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {string} Returns the empty string.\n     * @example\n     *\n     * _.times(2, _.stubString);\n     * // => ['', '']\n     */\n    function stubString() {\n      return '';\n    }\n\n    /**\n     * This method returns `true`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {boolean} Returns `true`.\n     * @example\n     *\n     * _.times(2, _.stubTrue);\n     * // => [true, true]\n     */\n    function stubTrue() {\n      return true;\n    }\n\n    /**\n     * Invokes the iteratee `n` times, returning an array of the results of\n     * each invocation. The iteratee is invoked with one argument; (index).\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {number} n The number of times to invoke `iteratee`.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.times(3, String);\n     * // => ['0', '1', '2']\n     *\n     *  _.times(4, _.constant(0));\n     * // => [0, 0, 0, 0]\n     */\n    function times(n, iteratee) {\n      n = toInteger(n);\n      if (n < 1 || n > MAX_SAFE_INTEGER) {\n        return [];\n      }\n      var index = MAX_ARRAY_LENGTH,\n          length = nativeMin(n, MAX_ARRAY_LENGTH);\n\n      iteratee = getIteratee(iteratee);\n      n -= MAX_ARRAY_LENGTH;\n\n      var result = baseTimes(length, iteratee);\n      while (++index < n) {\n        iteratee(index);\n      }\n      return result;\n    }\n\n    /**\n     * Converts `value` to a property path array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the new property path array.\n     * @example\n     *\n     * _.toPath('a.b.c');\n     * // => ['a', 'b', 'c']\n     *\n     * _.toPath('a[0].b.c');\n     * // => ['a', '0', 'b', 'c']\n     */\n    function toPath(value) {\n      if (isArray(value)) {\n        return arrayMap(value, toKey);\n      }\n      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));\n    }\n\n    /**\n     * Generates a unique ID. If `prefix` is given, the ID is appended to it.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {string} [prefix=''] The value to prefix the ID with.\n     * @returns {string} Returns the unique ID.\n     * @example\n     *\n     * _.uniqueId('contact_');\n     * // => 'contact_104'\n     *\n     * _.uniqueId();\n     * // => '105'\n     */\n    function uniqueId(prefix) {\n      var id = ++idCounter;\n      return toString(prefix) + id;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Adds two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.4.0\n     * @category Math\n     * @param {number} augend The first number in an addition.\n     * @param {number} addend The second number in an addition.\n     * @returns {number} Returns the total.\n     * @example\n     *\n     * _.add(6, 4);\n     * // => 10\n     */\n    var add = createMathOperation(function(augend, addend) {\n      return augend + addend;\n    }, 0);\n\n    /**\n     * Computes `number` rounded up to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round up.\n     * @param {number} [precision=0] The precision to round up to.\n     * @returns {number} Returns the rounded up number.\n     * @example\n     *\n     * _.ceil(4.006);\n     * // => 5\n     *\n     * _.ceil(6.004, 2);\n     * // => 6.01\n     *\n     * _.ceil(6040, -2);\n     * // => 6100\n     */\n    var ceil = createRound('ceil');\n\n    /**\n     * Divide two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {number} dividend The first number in a division.\n     * @param {number} divisor The second number in a division.\n     * @returns {number} Returns the quotient.\n     * @example\n     *\n     * _.divide(6, 4);\n     * // => 1.5\n     */\n    var divide = createMathOperation(function(dividend, divisor) {\n      return dividend / divisor;\n    }, 1);\n\n    /**\n     * Computes `number` rounded down to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round down.\n     * @param {number} [precision=0] The precision to round down to.\n     * @returns {number} Returns the rounded down number.\n     * @example\n     *\n     * _.floor(4.006);\n     * // => 4\n     *\n     * _.floor(0.046, 2);\n     * // => 0.04\n     *\n     * _.floor(4060, -2);\n     * // => 4000\n     */\n    var floor = createRound('floor');\n\n    /**\n     * Computes the maximum value of `array`. If `array` is empty or falsey,\n     * `undefined` is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * _.max([4, 2, 8, 6]);\n     * // => 8\n     *\n     * _.max([]);\n     * // => undefined\n     */\n    function max(array) {\n      return (array && array.length)\n        ? baseExtremum(array, identity, baseGt)\n        : undefined;\n    }\n\n    /**\n     * This method is like `_.max` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * the value is ranked. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n     *\n     * _.maxBy(objects, function(o) { return o.n; });\n     * // => { 'n': 2 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.maxBy(objects, 'n');\n     * // => { 'n': 2 }\n     */\n    function maxBy(array, iteratee) {\n      return (array && array.length)\n        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)\n        : undefined;\n    }\n\n    /**\n     * Computes the mean of the values in `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {number} Returns the mean.\n     * @example\n     *\n     * _.mean([4, 2, 8, 6]);\n     * // => 5\n     */\n    function mean(array) {\n      return baseMean(array, identity);\n    }\n\n    /**\n     * This method is like `_.mean` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the value to be averaged.\n     * The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the mean.\n     * @example\n     *\n     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n     *\n     * _.meanBy(objects, function(o) { return o.n; });\n     * // => 5\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.meanBy(objects, 'n');\n     * // => 5\n     */\n    function meanBy(array, iteratee) {\n      return baseMean(array, getIteratee(iteratee, 2));\n    }\n\n    /**\n     * Computes the minimum value of `array`. If `array` is empty or falsey,\n     * `undefined` is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * _.min([4, 2, 8, 6]);\n     * // => 2\n     *\n     * _.min([]);\n     * // => undefined\n     */\n    function min(array) {\n      return (array && array.length)\n        ? baseExtremum(array, identity, baseLt)\n        : undefined;\n    }\n\n    /**\n     * This method is like `_.min` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * the value is ranked. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n     *\n     * _.minBy(objects, function(o) { return o.n; });\n     * // => { 'n': 1 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.minBy(objects, 'n');\n     * // => { 'n': 1 }\n     */\n    function minBy(array, iteratee) {\n      return (array && array.length)\n        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)\n        : undefined;\n    }\n\n    /**\n     * Multiply two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {number} multiplier The first number in a multiplication.\n     * @param {number} multiplicand The second number in a multiplication.\n     * @returns {number} Returns the product.\n     * @example\n     *\n     * _.multiply(6, 4);\n     * // => 24\n     */\n    var multiply = createMathOperation(function(multiplier, multiplicand) {\n      return multiplier * multiplicand;\n    }, 1);\n\n    /**\n     * Computes `number` rounded to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round.\n     * @param {number} [precision=0] The precision to round to.\n     * @returns {number} Returns the rounded number.\n     * @example\n     *\n     * _.round(4.006);\n     * // => 4\n     *\n     * _.round(4.006, 2);\n     * // => 4.01\n     *\n     * _.round(4060, -2);\n     * // => 4100\n     */\n    var round = createRound('round');\n\n    /**\n     * Subtract two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {number} minuend The first number in a subtraction.\n     * @param {number} subtrahend The second number in a subtraction.\n     * @returns {number} Returns the difference.\n     * @example\n     *\n     * _.subtract(6, 4);\n     * // => 2\n     */\n    var subtract = createMathOperation(function(minuend, subtrahend) {\n      return minuend - subtrahend;\n    }, 0);\n\n    /**\n     * Computes the sum of the values in `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.4.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * _.sum([4, 2, 8, 6]);\n     * // => 20\n     */\n    function sum(array) {\n      return (array && array.length)\n        ? baseSum(array, identity)\n        : 0;\n    }\n\n    /**\n     * This method is like `_.sum` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the value to be summed.\n     * The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n     *\n     * _.sumBy(objects, function(o) { return o.n; });\n     * // => 20\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sumBy(objects, 'n');\n     * // => 20\n     */\n    function sumBy(array, iteratee) {\n      return (array && array.length)\n        ? baseSum(array, getIteratee(iteratee, 2))\n        : 0;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    // Add methods that return wrapped values in chain sequences.\n    lodash.after = after;\n    lodash.ary = ary;\n    lodash.assign = assign;\n    lodash.assignIn = assignIn;\n    lodash.assignInWith = assignInWith;\n    lodash.assignWith = assignWith;\n    lodash.at = at;\n    lodash.before = before;\n    lodash.bind = bind;\n    lodash.bindAll = bindAll;\n    lodash.bindKey = bindKey;\n    lodash.castArray = castArray;\n    lodash.chain = chain;\n    lodash.chunk = chunk;\n    lodash.compact = compact;\n    lodash.concat = concat;\n    lodash.cond = cond;\n    lodash.conforms = conforms;\n    lodash.constant = constant;\n    lodash.countBy = countBy;\n    lodash.create = create;\n    lodash.curry = curry;\n    lodash.curryRight = curryRight;\n    lodash.debounce = debounce;\n    lodash.defaults = defaults;\n    lodash.defaultsDeep = defaultsDeep;\n    lodash.defer = defer;\n    lodash.delay = delay;\n    lodash.difference = difference;\n    lodash.differenceBy = differenceBy;\n    lodash.differenceWith = differenceWith;\n    lodash.drop = drop;\n    lodash.dropRight = dropRight;\n    lodash.dropRightWhile = dropRightWhile;\n    lodash.dropWhile = dropWhile;\n    lodash.fill = fill;\n    lodash.filter = filter;\n    lodash.flatMap = flatMap;\n    lodash.flatMapDeep = flatMapDeep;\n    lodash.flatMapDepth = flatMapDepth;\n    lodash.flatten = flatten;\n    lodash.flattenDeep = flattenDeep;\n    lodash.flattenDepth = flattenDepth;\n    lodash.flip = flip;\n    lodash.flow = flow;\n    lodash.flowRight = flowRight;\n    lodash.fromPairs = fromPairs;\n    lodash.functions = functions;\n    lodash.functionsIn = functionsIn;\n    lodash.groupBy = groupBy;\n    lodash.initial = initial;\n    lodash.intersection = intersection;\n    lodash.intersectionBy = intersectionBy;\n    lodash.intersectionWith = intersectionWith;\n    lodash.invert = invert;\n    lodash.invertBy = invertBy;\n    lodash.invokeMap = invokeMap;\n    lodash.iteratee = iteratee;\n    lodash.keyBy = keyBy;\n    lodash.keys = keys;\n    lodash.keysIn = keysIn;\n    lodash.map = map;\n    lodash.mapKeys = mapKeys;\n    lodash.mapValues = mapValues;\n    lodash.matches = matches;\n    lodash.matchesProperty = matchesProperty;\n    lodash.memoize = memoize;\n    lodash.merge = merge;\n    lodash.mergeWith = mergeWith;\n    lodash.method = method;\n    lodash.methodOf = methodOf;\n    lodash.mixin = mixin;\n    lodash.negate = negate;\n    lodash.nthArg = nthArg;\n    lodash.omit = omit;\n    lodash.omitBy = omitBy;\n    lodash.once = once;\n    lodash.orderBy = orderBy;\n    lodash.over = over;\n    lodash.overArgs = overArgs;\n    lodash.overEvery = overEvery;\n    lodash.overSome = overSome;\n    lodash.partial = partial;\n    lodash.partialRight = partialRight;\n    lodash.partition = partition;\n    lodash.pick = pick;\n    lodash.pickBy = pickBy;\n    lodash.property = property;\n    lodash.propertyOf = propertyOf;\n    lodash.pull = pull;\n    lodash.pullAll = pullAll;\n    lodash.pullAllBy = pullAllBy;\n    lodash.pullAllWith = pullAllWith;\n    lodash.pullAt = pullAt;\n    lodash.range = range;\n    lodash.rangeRight = rangeRight;\n    lodash.rearg = rearg;\n    lodash.reject = reject;\n    lodash.remove = remove;\n    lodash.rest = rest;\n    lodash.reverse = reverse;\n    lodash.sampleSize = sampleSize;\n    lodash.set = set;\n    lodash.setWith = setWith;\n    lodash.shuffle = shuffle;\n    lodash.slice = slice;\n    lodash.sortBy = sortBy;\n    lodash.sortedUniq = sortedUniq;\n    lodash.sortedUniqBy = sortedUniqBy;\n    lodash.split = split;\n    lodash.spread = spread;\n    lodash.tail = tail;\n    lodash.take = take;\n    lodash.takeRight = takeRight;\n    lodash.takeRightWhile = takeRightWhile;\n    lodash.takeWhile = takeWhile;\n    lodash.tap = tap;\n    lodash.throttle = throttle;\n    lodash.thru = thru;\n    lodash.toArray = toArray;\n    lodash.toPairs = toPairs;\n    lodash.toPairsIn = toPairsIn;\n    lodash.toPath = toPath;\n    lodash.toPlainObject = toPlainObject;\n    lodash.transform = transform;\n    lodash.unary = unary;\n    lodash.union = union;\n    lodash.unionBy = unionBy;\n    lodash.unionWith = unionWith;\n    lodash.uniq = uniq;\n    lodash.uniqBy = uniqBy;\n    lodash.uniqWith = uniqWith;\n    lodash.unset = unset;\n    lodash.unzip = unzip;\n    lodash.unzipWith = unzipWith;\n    lodash.update = update;\n    lodash.updateWith = updateWith;\n    lodash.values = values;\n    lodash.valuesIn = valuesIn;\n    lodash.without = without;\n    lodash.words = words;\n    lodash.wrap = wrap;\n    lodash.xor = xor;\n    lodash.xorBy = xorBy;\n    lodash.xorWith = xorWith;\n    lodash.zip = zip;\n    lodash.zipObject = zipObject;\n    lodash.zipObjectDeep = zipObjectDeep;\n    lodash.zipWith = zipWith;\n\n    // Add aliases.\n    lodash.entries = toPairs;\n    lodash.entriesIn = toPairsIn;\n    lodash.extend = assignIn;\n    lodash.extendWith = assignInWith;\n\n    // Add methods to `lodash.prototype`.\n    mixin(lodash, lodash);\n\n    /*------------------------------------------------------------------------*/\n\n    // Add methods that return unwrapped values in chain sequences.\n    lodash.add = add;\n    lodash.attempt = attempt;\n    lodash.camelCase = camelCase;\n    lodash.capitalize = capitalize;\n    lodash.ceil = ceil;\n    lodash.clamp = clamp;\n    lodash.clone = clone;\n    lodash.cloneDeep = cloneDeep;\n    lodash.cloneDeepWith = cloneDeepWith;\n    lodash.cloneWith = cloneWith;\n    lodash.conformsTo = conformsTo;\n    lodash.deburr = deburr;\n    lodash.defaultTo = defaultTo;\n    lodash.divide = divide;\n    lodash.endsWith = endsWith;\n    lodash.eq = eq;\n    lodash.escape = escape;\n    lodash.escapeRegExp = escapeRegExp;\n    lodash.every = every;\n    lodash.find = find;\n    lodash.findIndex = findIndex;\n    lodash.findKey = findKey;\n    lodash.findLast = findLast;\n    lodash.findLastIndex = findLastIndex;\n    lodash.findLastKey = findLastKey;\n    lodash.floor = floor;\n    lodash.forEach = forEach;\n    lodash.forEachRight = forEachRight;\n    lodash.forIn = forIn;\n    lodash.forInRight = forInRight;\n    lodash.forOwn = forOwn;\n    lodash.forOwnRight = forOwnRight;\n    lodash.get = get;\n    lodash.gt = gt;\n    lodash.gte = gte;\n    lodash.has = has;\n    lodash.hasIn = hasIn;\n    lodash.head = head;\n    lodash.identity = identity;\n    lodash.includes = includes;\n    lodash.indexOf = indexOf;\n    lodash.inRange = inRange;\n    lodash.invoke = invoke;\n    lodash.isArguments = isArguments;\n    lodash.isArray = isArray;\n    lodash.isArrayBuffer = isArrayBuffer;\n    lodash.isArrayLike = isArrayLike;\n    lodash.isArrayLikeObject = isArrayLikeObject;\n    lodash.isBoolean = isBoolean;\n    lodash.isBuffer = isBuffer;\n    lodash.isDate = isDate;\n    lodash.isElement = isElement;\n    lodash.isEmpty = isEmpty;\n    lodash.isEqual = isEqual;\n    lodash.isEqualWith = isEqualWith;\n    lodash.isError = isError;\n    lodash.isFinite = isFinite;\n    lodash.isFunction = isFunction;\n    lodash.isInteger = isInteger;\n    lodash.isLength = isLength;\n    lodash.isMap = isMap;\n    lodash.isMatch = isMatch;\n    lodash.isMatchWith = isMatchWith;\n    lodash.isNaN = isNaN;\n    lodash.isNative = isNative;\n    lodash.isNil = isNil;\n    lodash.isNull = isNull;\n    lodash.isNumber = isNumber;\n    lodash.isObject = isObject;\n    lodash.isObjectLike = isObjectLike;\n    lodash.isPlainObject = isPlainObject;\n    lodash.isRegExp = isRegExp;\n    lodash.isSafeInteger = isSafeInteger;\n    lodash.isSet = isSet;\n    lodash.isString = isString;\n    lodash.isSymbol = isSymbol;\n    lodash.isTypedArray = isTypedArray;\n    lodash.isUndefined = isUndefined;\n    lodash.isWeakMap = isWeakMap;\n    lodash.isWeakSet = isWeakSet;\n    lodash.join = join;\n    lodash.kebabCase = kebabCase;\n    lodash.last = last;\n    lodash.lastIndexOf = lastIndexOf;\n    lodash.lowerCase = lowerCase;\n    lodash.lowerFirst = lowerFirst;\n    lodash.lt = lt;\n    lodash.lte = lte;\n    lodash.max = max;\n    lodash.maxBy = maxBy;\n    lodash.mean = mean;\n    lodash.meanBy = meanBy;\n    lodash.min = min;\n    lodash.minBy = minBy;\n    lodash.stubArray = stubArray;\n    lodash.stubFalse = stubFalse;\n    lodash.stubObject = stubObject;\n    lodash.stubString = stubString;\n    lodash.stubTrue = stubTrue;\n    lodash.multiply = multiply;\n    lodash.nth = nth;\n    lodash.noConflict = noConflict;\n    lodash.noop = noop;\n    lodash.now = now;\n    lodash.pad = pad;\n    lodash.padEnd = padEnd;\n    lodash.padStart = padStart;\n    lodash.parseInt = parseInt;\n    lodash.random = random;\n    lodash.reduce = reduce;\n    lodash.reduceRight = reduceRight;\n    lodash.repeat = repeat;\n    lodash.replace = replace;\n    lodash.result = result;\n    lodash.round = round;\n    lodash.runInContext = runInContext;\n    lodash.sample = sample;\n    lodash.size = size;\n    lodash.snakeCase = snakeCase;\n    lodash.some = some;\n    lodash.sortedIndex = sortedIndex;\n    lodash.sortedIndexBy = sortedIndexBy;\n    lodash.sortedIndexOf = sortedIndexOf;\n    lodash.sortedLastIndex = sortedLastIndex;\n    lodash.sortedLastIndexBy = sortedLastIndexBy;\n    lodash.sortedLastIndexOf = sortedLastIndexOf;\n    lodash.startCase = startCase;\n    lodash.startsWith = startsWith;\n    lodash.subtract = subtract;\n    lodash.sum = sum;\n    lodash.sumBy = sumBy;\n    lodash.template = template;\n    lodash.times = times;\n    lodash.toFinite = toFinite;\n    lodash.toInteger = toInteger;\n    lodash.toLength = toLength;\n    lodash.toLower = toLower;\n    lodash.toNumber = toNumber;\n    lodash.toSafeInteger = toSafeInteger;\n    lodash.toString = toString;\n    lodash.toUpper = toUpper;\n    lodash.trim = trim;\n    lodash.trimEnd = trimEnd;\n    lodash.trimStart = trimStart;\n    lodash.truncate = truncate;\n    lodash.unescape = unescape;\n    lodash.uniqueId = uniqueId;\n    lodash.upperCase = upperCase;\n    lodash.upperFirst = upperFirst;\n\n    // Add aliases.\n    lodash.each = forEach;\n    lodash.eachRight = forEachRight;\n    lodash.first = head;\n\n    mixin(lodash, (function() {\n      var source = {};\n      baseForOwn(lodash, function(func, methodName) {\n        if (!hasOwnProperty.call(lodash.prototype, methodName)) {\n          source[methodName] = func;\n        }\n      });\n      return source;\n    }()), { 'chain': false });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The semantic version number.\n     *\n     * @static\n     * @memberOf _\n     * @type {string}\n     */\n    lodash.VERSION = VERSION;\n\n    // Assign default placeholders.\n    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {\n      lodash[methodName].placeholder = lodash;\n    });\n\n    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.\n    arrayEach(['drop', 'take'], function(methodName, index) {\n      LazyWrapper.prototype[methodName] = function(n) {\n        var filtered = this.__filtered__;\n        if (filtered && !index) {\n          return new LazyWrapper(this);\n        }\n        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);\n\n        var result = this.clone();\n        if (filtered) {\n          result.__takeCount__ = nativeMin(n, result.__takeCount__);\n        } else {\n          result.__views__.push({\n            'size': nativeMin(n, MAX_ARRAY_LENGTH),\n            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')\n          });\n        }\n        return result;\n      };\n\n      LazyWrapper.prototype[methodName + 'Right'] = function(n) {\n        return this.reverse()[methodName](n).reverse();\n      };\n    });\n\n    // Add `LazyWrapper` methods that accept an `iteratee` value.\n    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {\n      var type = index + 1,\n          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;\n\n      LazyWrapper.prototype[methodName] = function(iteratee) {\n        var result = this.clone();\n        result.__iteratees__.push({\n          'iteratee': getIteratee(iteratee, 3),\n          'type': type\n        });\n        result.__filtered__ = result.__filtered__ || isFilter;\n        return result;\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.head` and `_.last`.\n    arrayEach(['head', 'last'], function(methodName, index) {\n      var takeName = 'take' + (index ? 'Right' : '');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this[takeName](1).value()[0];\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.\n    arrayEach(['initial', 'tail'], function(methodName, index) {\n      var dropName = 'drop' + (index ? '' : 'Right');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);\n      };\n    });\n\n    LazyWrapper.prototype.compact = function() {\n      return this.filter(identity);\n    };\n\n    LazyWrapper.prototype.find = function(predicate) {\n      return this.filter(predicate).head();\n    };\n\n    LazyWrapper.prototype.findLast = function(predicate) {\n      return this.reverse().find(predicate);\n    };\n\n    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {\n      if (typeof path == 'function') {\n        return new LazyWrapper(this);\n      }\n      return this.map(function(value) {\n        return baseInvoke(value, path, args);\n      });\n    });\n\n    LazyWrapper.prototype.reject = function(predicate) {\n      return this.filter(negate(getIteratee(predicate)));\n    };\n\n    LazyWrapper.prototype.slice = function(start, end) {\n      start = toInteger(start);\n\n      var result = this;\n      if (result.__filtered__ && (start > 0 || end < 0)) {\n        return new LazyWrapper(result);\n      }\n      if (start < 0) {\n        result = result.takeRight(-start);\n      } else if (start) {\n        result = result.drop(start);\n      }\n      if (end !== undefined) {\n        end = toInteger(end);\n        result = end < 0 ? result.dropRight(-end) : result.take(end - start);\n      }\n      return result;\n    };\n\n    LazyWrapper.prototype.takeRightWhile = function(predicate) {\n      return this.reverse().takeWhile(predicate).reverse();\n    };\n\n    LazyWrapper.prototype.toArray = function() {\n      return this.take(MAX_ARRAY_LENGTH);\n    };\n\n    // Add `LazyWrapper` methods to `lodash.prototype`.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),\n          isTaker = /^(?:head|last)$/.test(methodName),\n          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],\n          retUnwrapped = isTaker || /^find/.test(methodName);\n\n      if (!lodashFunc) {\n        return;\n      }\n      lodash.prototype[methodName] = function() {\n        var value = this.__wrapped__,\n            args = isTaker ? [1] : arguments,\n            isLazy = value instanceof LazyWrapper,\n            iteratee = args[0],\n            useLazy = isLazy || isArray(value);\n\n        var interceptor = function(value) {\n          var result = lodashFunc.apply(lodash, arrayPush([value], args));\n          return (isTaker && chainAll) ? result[0] : result;\n        };\n\n        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {\n          // Avoid lazy use if the iteratee has a \"length\" value other than `1`.\n          isLazy = useLazy = false;\n        }\n        var chainAll = this.__chain__,\n            isHybrid = !!this.__actions__.length,\n            isUnwrapped = retUnwrapped && !chainAll,\n            onlyLazy = isLazy && !isHybrid;\n\n        if (!retUnwrapped && useLazy) {\n          value = onlyLazy ? value : new LazyWrapper(this);\n          var result = func.apply(value, args);\n          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });\n          return new LodashWrapper(result, chainAll);\n        }\n        if (isUnwrapped && onlyLazy) {\n          return func.apply(this, args);\n        }\n        result = this.thru(interceptor);\n        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;\n      };\n    });\n\n    // Add `Array` methods to `lodash.prototype`.\n    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {\n      var func = arrayProto[methodName],\n          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',\n          retUnwrapped = /^(?:pop|shift)$/.test(methodName);\n\n      lodash.prototype[methodName] = function() {\n        var args = arguments;\n        if (retUnwrapped && !this.__chain__) {\n          var value = this.value();\n          return func.apply(isArray(value) ? value : [], args);\n        }\n        return this[chainName](function(value) {\n          return func.apply(isArray(value) ? value : [], args);\n        });\n      };\n    });\n\n    // Map minified method names to their real names.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var lodashFunc = lodash[methodName];\n      if (lodashFunc) {\n        var key = (lodashFunc.name + ''),\n            names = realNames[key] || (realNames[key] = []);\n\n        names.push({ 'name': methodName, 'func': lodashFunc });\n      }\n    });\n\n    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{\n      'name': 'wrapper',\n      'func': undefined\n    }];\n\n    // Add methods to `LazyWrapper`.\n    LazyWrapper.prototype.clone = lazyClone;\n    LazyWrapper.prototype.reverse = lazyReverse;\n    LazyWrapper.prototype.value = lazyValue;\n\n    // Add chain sequence methods to the `lodash` wrapper.\n    lodash.prototype.at = wrapperAt;\n    lodash.prototype.chain = wrapperChain;\n    lodash.prototype.commit = wrapperCommit;\n    lodash.prototype.next = wrapperNext;\n    lodash.prototype.plant = wrapperPlant;\n    lodash.prototype.reverse = wrapperReverse;\n    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;\n\n    // Add lazy aliases.\n    lodash.prototype.first = lodash.prototype.head;\n\n    if (symIterator) {\n      lodash.prototype[symIterator] = wrapperToIterator;\n    }\n    return lodash;\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  // Export lodash.\n  var _ = runInContext();\n\n  // Some AMD build optimizers, like r.js, check for condition patterns like:\n  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n    // Expose Lodash on the global object to prevent errors when Lodash is\n    // loaded by a script tag in the presence of an AMD loader.\n    // See http://requirejs.org/docs/errors.html#mismatch for more details.\n    // Use `_.noConflict` to remove Lodash from the global object.\n    root._ = _;\n\n    // Define as an anonymous module so, through path mapping, it can be\n    // referenced as the \"underscore\" module.\n    define(function() {\n      return _;\n    });\n  }\n  // Check for `exports` after `define` in case a build optimizer adds it.\n  else if (freeModule) {\n    // Export for Node.js.\n    (freeModule.exports = _)._ = _;\n    // Export for CommonJS support.\n    freeExports._ = _;\n  }\n  else {\n    // Export to the global object.\n    root._ = _;\n  }\n}.call(this));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/lodash.js\n// module id = 2\n// module chunks = 2","module.exports = function(module) {\n\tif(!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tmodule.children = [];\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 3\n// module chunks = 2","// The Regexper class manages the top-level behavior for the entire\n// application. This includes event handlers for all user interactions.\n\nimport util from './util.js';\nimport Parser from './parser/javascript.js';\nimport _ from 'lodash';\n\nexport default class Regexper {\n  constructor(root) {\n    this.root = root;\n    this.buggyHash = false;\n    this.form = root.querySelector('#regexp-form');\n    this.field = root.querySelector('#regexp-input');\n    this.error = root.querySelector('#error');\n    this.warnings = root.querySelector('#warnings');\n\n    this.links = this.form.querySelector('ul');\n    this.permalink = this.links.querySelector('a[data-action=\"permalink\"]');\n    this.download = this.links.querySelector('a[data-action=\"download\"]');\n\n    this.svgContainer = root.querySelector('#regexp-render');\n  }\n\n  // Event handler for key presses in the regular expression form field.\n  keypressListener(event) {\n    // Pressing Shift-Enter displays the expression.\n    if (event.shiftKey && event.keyCode === 13) {\n      event.returnValue = false;\n      if (event.preventDefault) {\n        event.preventDefault();\n      }\n\n      this.form.dispatchEvent(util.customEvent('submit'));\n    }\n  }\n\n  // Event handler for key presses while focused anywhere in the application.\n  documentKeypressListener(event) {\n    // Pressing escape will cancel a currently running render.\n    if (event.keyCode === 27 && this.running) {\n      this.running.cancel();\n    }\n  }\n\n  // Event handler for submission of the regular expression. Changes the URL\n  // hash which leads to the expression being rendered.\n  submitListener(event) {\n    event.returnValue = false;\n    if (event.preventDefault) {\n      event.preventDefault();\n    }\n\n    try {\n      this._setHash(this.field.value);\n    }\n    catch(e) {\n      // Failed to set the URL hash (probably because the expression is too\n      // long). Turn off display of the permalink and just show the expression.\n      this.permalinkEnabled = false;\n      this.showExpression(this.field.value);\n    }\n  }\n\n  // Event handler for URL hash changes. Starts rendering of the expression.\n  hashchangeListener() {\n    let expr = this._getHash();\n\n    if (expr instanceof Error) {\n      this.state = 'has-error';\n      this.error.innerHTML = 'Malformed expression in URL';\n      util.track('send', 'event', 'visualization', 'malformed URL');\n    } else {\n      this.permalinkEnabled = true;\n      this.showExpression(expr);\n    }\n  }\n\n  // Binds all event listeners.\n  bindListeners() {\n    this.field.addEventListener('keypress', this.keypressListener.bind(this));\n    this.form.addEventListener('submit', this.submitListener.bind(this));\n    this.root.addEventListener('keyup', this.documentKeypressListener.bind(this));\n    window.addEventListener('hashchange', this.hashchangeListener.bind(this));\n  }\n\n  // Detect if https://bugzilla.mozilla.org/show_bug.cgi?id=483304 is in effect\n  detectBuggyHash() {\n    if (typeof window.URL === 'function') {\n      try {\n        let url = new URL('http://regexper.com/#%25');\n        this.buggyHash = (url.hash === '#%');\n      }\n      catch(e) {\n        this.buggyHash = false;\n      }\n    }\n  }\n\n  // Set the URL hash. This method exists to facilitate automated testing\n  // (since changing the URL can throw off most JavaScript testing tools).\n  _setHash(hash) {\n    location.hash = encodeURIComponent(hash);\n  }\n\n  // Retrieve the current URL hash. This method is also mostly for supporting\n  // automated testing, but also does some basic error handling for malformed\n  // URLs.\n  _getHash() {\n    try {\n      let hash = location.hash.slice(1)\n      return this.buggyHash ? hash : decodeURIComponent(hash);\n    }\n    catch(e) {\n      return e;\n    }\n  }\n\n  // Currently state of the application. Useful values are:\n  //  - `''` - State of the application when the page initially loads\n  //  - `'is-loading'` - Displays the loading indicator\n  //  - `'has-error'` - Displays the error message\n  //  - `'has-results'` - Displays rendered results\n  set state(state) {\n    this.root.className = state;\n  }\n\n  get state() {\n    return this.root.className;\n  }\n\n  // Start the rendering of a regular expression.\n  //\n  // - __expression__ - Regular expression to display.\n  showExpression(expression) {\n    this.field.value = expression;\n    this.state = '';\n\n    if (expression !== '') {\n      this.renderRegexp(expression).catch(util.exposeError);\n    }\n  }\n\n  // Creates a blob URL for linking to a rendered regular expression image.\n  //\n  // - __content__ - SVG image markup.\n  buildBlobURL(content) {\n    // Blob object has to stick around for IE, so the instance is stored on the\n    // `window` object.\n    window.blob = new Blob([content], { type: 'image/svg+xml' });\n    return URL.createObjectURL(window.blob);\n  }\n\n  // Update the URLs of the 'download' and 'permalink' links.\n  updateLinks() {\n    let classes = _.without(this.links.className.split(' '), ['hide-download', 'hide-permalink']);\n\n    // Create the 'download' image URL.\n    try {\n      this.download.parentNode.style.display = null;\n      this.download.href = this.buildBlobURL(this.svgContainer.querySelector('.svg').innerHTML);\n    }\n    catch(e) {\n      // Blobs or URLs created from a blob URL don't work in the current\n      // browser. Giving up on the download link.\n      classes.push('hide-download');\n    }\n\n    // Create the 'permalink' URL.\n    if (this.permalinkEnabled) {\n      this.permalink.parentNode.style.display = null;\n      this.permalink.href = location.toString();\n    } else {\n      classes.push('hide-permalink');\n    }\n\n    this.links.className = classes.join(' ');\n  }\n\n  // Display any warnings that were generated while rendering a regular expression.\n  //\n  // - __warnings__ - Array of warning messages to display.\n  displayWarnings(warnings) {\n    this.warnings.innerHTML = _.map(warnings, warning => (\n      `<li class=\"inline-icon\">${util.icon(\"#warning\")}${warning}</li>`\n    )).join('');\n  }\n\n  // Render regular expression\n  //\n  // - __expression__ - Regular expression to render\n  renderRegexp(expression) {\n    let parseError = false,\n        startTime, endTime;\n\n    // When a render is already in progress, cancel it and try rendering again\n    // after a short delay (canceling a render is not instantaneous).\n    if (this.running) {\n      this.running.cancel();\n\n      return util.wait(10).then(() => this.renderRegexp(expression));\n    }\n\n    this.state = 'is-loading';\n    util.track('send', 'event', 'visualization', 'start');\n    startTime = new Date().getTime();\n\n    this.running = new Parser(this.svgContainer);\n\n    return this.running\n      // Parse the expression.\n      .parse(expression)\n      // Display any error messages from the parser and abort the render.\n      .catch(message => {\n        this.state = 'has-error';\n        this.error.innerHTML = '';\n        this.error.appendChild(document.createTextNode(message));\n\n        parseError = true;\n\n        throw message;\n      })\n      // When parsing is successful, render the parsed expression.\n      .then(parser => parser.render())\n      // Once rendering is complete:\n      //  - Update links\n      //  - Display any warnings\n      //  - Track the completion of the render and how long it took\n      .then(() => {\n        this.state = 'has-results';\n        this.updateLinks();\n        this.displayWarnings(this.running.warnings);\n        util.track('send', 'event', 'visualization', 'complete');\n\n        endTime = new Date().getTime();\n        util.track('send', 'timing', 'visualization', 'total time', endTime - startTime);\n      })\n      // Handle any errors that happened during the rendering pipeline.\n      // Swallows parse errors and render cancellations. Any other exceptions\n      // are allowed to continue on to be tracked by the global error handler.\n      .catch(message => {\n        if (message === 'Render cancelled') {\n          util.track('send', 'event', 'visualization', 'cancelled');\n          this.state = '';\n        } else if (parseError) {\n          util.track('send', 'event', 'visualization', 'parse error');\n        } else {\n          throw message;\n        }\n      })\n      // Finally, mark rendering as complete (and pass along any exceptions\n      // that were thrown).\n      .then(\n        () => {\n          this.running = false;\n        },\n        message => {\n          this.running = false;\n          throw message;\n        }\n      );\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/regexper.js","// Entry point for the JavaScript-flavor regular expression parsing and\n// rendering. Actual parsing code is in\n// [parser.js](./javascript/parser.html) and the grammar file. Rendering code\n// is contained in the various subclasses of\n// [Node](./javascript/node.html)\n\nimport Snap from 'snapsvg';\nimport _ from 'lodash';\n\nimport util from '../util.js';\nimport javascript from './javascript/parser.js';\nimport ParserState from './javascript/parser_state.js';\n\nexport default class Parser {\n  // - __container__ - DOM node that will contain the rendered expression\n  // - __options.keepContent__ - Boolean indicating if content of the container\n  //    should be preserved after rendering. Defaults to false (don't keep\n  //    contents)\n  constructor(container, options) {\n    this.options = options || {};\n    _.defaults(this.options, {\n      keepContent: false\n    });\n\n    this.container = container;\n\n    // The [ParserState](./javascript/parser_state.html) instance is used to\n    // communicate between the parser and a running render, and to update the\n    // progress bar for the running render.\n    this.state = new ParserState(this.container.querySelector('.progress div'));\n  }\n\n  // DOM node that will contain the rendered expression. Setting this will add\n  // the base markup necessary for rendering the expression, and set the\n  // `svg-container` class\n  set container(cont) {\n    this._container = cont;\n    this._container.innerHTML = [\n      document.querySelector('#svg-container-base').innerHTML,\n      this.options.keepContent ? this.container.innerHTML : ''\n    ].join('');\n    this._addClass('svg-container');\n  }\n\n  get container() {\n    return this._container;\n  }\n\n  // Helper method to simplify adding classes to the container.\n  _addClass(className) {\n    this.container.className = _(this.container.className.split(' '))\n      .union([className])\n      .join(' ');\n  }\n\n  // Helper method to simplify removing classes from the container.\n  _removeClass(className) {\n    this.container.className = _(this.container.className.split(' '))\n      .without(className)\n      .join(' ');\n  }\n\n  // Parse a regular expression into a tree of\n  // [Nodes](./javascript/node.html) that can then be used to render an SVG.\n  // - __expression__ - Regular expression to parse.\n  parse(expression) {\n    this._addClass('loading');\n\n    // Allow the browser to repaint before parsing so that the loading bar is\n    // displayed before the (possibly lengthy) parsing begins.\n    return util.tick().then(() => {\n      javascript.Parser.SyntaxNode.state = this.state;\n\n      this.parsed = javascript.parse(expression.replace(/\\n/g, '\\\\n'));\n      return this;\n    });\n  }\n\n  // Render the parsed expression to an SVG.\n  render() {\n    let svg = Snap(this.container.querySelector('svg'));\n\n    return this.parsed.render(svg.group())\n      // Once rendering is complete, the rendered expression is positioned and\n      // the SVG resized to create some padding around the image contents.\n      .then(result => {\n        let box = result.getBBox();\n\n        result.transform(Snap.matrix()\n          .translate(10 - box.x, 10 - box.y));\n        svg.attr({\n          width: box.width + 20,\n          height: box.height + 20\n        });\n      })\n      // Stop and remove loading indicator after render is totally complete.\n      .then(() => {\n        this._removeClass('loading');\n        this.container.removeChild(this.container.querySelector('.progress'));\n      });\n  }\n\n  // Cancels any currently in-progress render.\n  cancel() {\n    this.state.cancelRender = true;\n  }\n\n  // Returns any warnings that may have been set during the rendering process.\n  get warnings() {\n    return this.state.warnings;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/parser/javascript.js","/*** IMPORTS FROM imports-loader ***/\n(function() {\nvar fix = module.exports=0;\n\n// Snap.svg 0.4.0\n// \n// Copyright (c) 2013 – 2015 Adobe Systems Incorporated. All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n// http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// \n// build: 2015-04-07\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n// http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// ┌────────────────────────────────────────────────────────────┐ \\\\\n// │ Eve 0.4.2 - JavaScript Events Library                      │ \\\\\n// ├────────────────────────────────────────────────────────────┤ \\\\\n// │ Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/) │ \\\\\n// └────────────────────────────────────────────────────────────┘ \\\\\n\n(function (glob) {\n    var version = \"0.4.2\",\n        has = \"hasOwnProperty\",\n        separator = /[\\.\\/]/,\n        comaseparator = /\\s*,\\s*/,\n        wildcard = \"*\",\n        fun = function () {},\n        numsort = function (a, b) {\n            return a - b;\n        },\n        current_event,\n        stop,\n        events = {n: {}},\n        firstDefined = function () {\n            for (var i = 0, ii = this.length; i < ii; i++) {\n                if (typeof this[i] != \"undefined\") {\n                    return this[i];\n                }\n            }\n        },\n        lastDefined = function () {\n            var i = this.length;\n            while (--i) {\n                if (typeof this[i] != \"undefined\") {\n                    return this[i];\n                }\n            }\n        },\n    /*\\\n     * eve\n     [ method ]\n\n     * Fires event with given `name`, given scope and other parameters.\n\n     > Arguments\n\n     - name (string) name of the *event*, dot (`.`) or slash (`/`) separated\n     - scope (object) context for the event handlers\n     - varargs (...) the rest of arguments will be sent to event handlers\n\n     = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.\n    \\*/\n        eve = function (name, scope) {\n            name = String(name);\n            var e = events,\n                oldstop = stop,\n                args = Array.prototype.slice.call(arguments, 2),\n                listeners = eve.listeners(name),\n                z = 0,\n                f = false,\n                l,\n                indexed = [],\n                queue = {},\n                out = [],\n                ce = current_event,\n                errors = [];\n            out.firstDefined = firstDefined;\n            out.lastDefined = lastDefined;\n            current_event = name;\n            stop = 0;\n            for (var i = 0, ii = listeners.length; i < ii; i++) if (\"zIndex\" in listeners[i]) {\n                indexed.push(listeners[i].zIndex);\n                if (listeners[i].zIndex < 0) {\n                    queue[listeners[i].zIndex] = listeners[i];\n                }\n            }\n            indexed.sort(numsort);\n            while (indexed[z] < 0) {\n                l = queue[indexed[z++]];\n                out.push(l.apply(scope, args));\n                if (stop) {\n                    stop = oldstop;\n                    return out;\n                }\n            }\n            for (i = 0; i < ii; i++) {\n                l = listeners[i];\n                if (\"zIndex\" in l) {\n                    if (l.zIndex == indexed[z]) {\n                        out.push(l.apply(scope, args));\n                        if (stop) {\n                            break;\n                        }\n                        do {\n                            z++;\n                            l = queue[indexed[z]];\n                            l && out.push(l.apply(scope, args));\n                            if (stop) {\n                                break;\n                            }\n                        } while (l)\n                    } else {\n                        queue[l.zIndex] = l;\n                    }\n                } else {\n                    out.push(l.apply(scope, args));\n                    if (stop) {\n                        break;\n                    }\n                }\n            }\n            stop = oldstop;\n            current_event = ce;\n            return out;\n        };\n        // Undocumented. Debug only.\n        eve._events = events;\n    /*\\\n     * eve.listeners\n     [ method ]\n\n     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.\n\n     > Arguments\n\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated\n\n     = (array) array of event handlers\n    \\*/\n    eve.listeners = function (name) {\n        var names = name.split(separator),\n            e = events,\n            item,\n            items,\n            k,\n            i,\n            ii,\n            j,\n            jj,\n            nes,\n            es = [e],\n            out = [];\n        for (i = 0, ii = names.length; i < ii; i++) {\n            nes = [];\n            for (j = 0, jj = es.length; j < jj; j++) {\n                e = es[j].n;\n                items = [e[names[i]], e[wildcard]];\n                k = 2;\n                while (k--) {\n                    item = items[k];\n                    if (item) {\n                        nes.push(item);\n                        out = out.concat(item.f || []);\n                    }\n                }\n            }\n            es = nes;\n        }\n        return out;\n    };\n    \n    /*\\\n     * eve.on\n     [ method ]\n     **\n     * Binds given event handler with a given name. You can use wildcards “`*`” for the names:\n     | eve.on(\"*.under.*\", f);\n     | eve(\"mouse.under.floor\"); // triggers f\n     * Use @eve to trigger the listener.\n     **\n     > Arguments\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n     - f (function) event handler function\n     **\n     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment. \n     > Example:\n     | eve.on(\"mouse\", eatIt)(2);\n     | eve.on(\"mouse\", scream);\n     | eve.on(\"mouse\", catchIt)(1);\n     * This will ensure that `catchIt` function will be called before `eatIt`.\n     *\n     * If you want to put your handler before non-indexed handlers, specify a negative value.\n     * Note: I assume most of the time you don’t need to worry about z-index, but it’s nice to have this feature “just in case”.\n    \\*/\n    eve.on = function (name, f) {\n        name = String(name);\n        if (typeof f != \"function\") {\n            return function () {};\n        }\n        var names = name.split(comaseparator);\n        for (var i = 0, ii = names.length; i < ii; i++) {\n            (function (name) {\n                var names = name.split(separator),\n                    e = events,\n                    exist;\n                for (var i = 0, ii = names.length; i < ii; i++) {\n                    e = e.n;\n                    e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {n: {}});\n                }\n                e.f = e.f || [];\n                for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {\n                    exist = true;\n                    break;\n                }\n                !exist && e.f.push(f);\n            }(names[i]));\n        }\n        return function (zIndex) {\n            if (+zIndex == +zIndex) {\n                f.zIndex = +zIndex;\n            }\n        };\n    };\n    /*\\\n     * eve.f\n     [ method ]\n     **\n     * Returns function that will fire given event with optional arguments.\n     * Arguments that will be passed to the result function will be also\n     * concated to the list of final arguments.\n     | el.onclick = eve.f(\"click\", 1, 2);\n     | eve.on(\"click\", function (a, b, c) {\n     |     console.log(a, b, c); // 1, 2, [event object]\n     | });\n     > Arguments\n     - event (string) event name\n     - varargs (…) and any other arguments\n     = (function) possible event handler function\n    \\*/\n    eve.f = function (event) {\n        var attrs = [].slice.call(arguments, 1);\n        return function () {\n            eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));\n        };\n    };\n    /*\\\n     * eve.stop\n     [ method ]\n     **\n     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.\n    \\*/\n    eve.stop = function () {\n        stop = 1;\n    };\n    /*\\\n     * eve.nt\n     [ method ]\n     **\n     * Could be used inside event handler to figure out actual name of the event.\n     **\n     > Arguments\n     **\n     - subname (string) #optional subname of the event\n     **\n     = (string) name of the event, if `subname` is not specified\n     * or\n     = (boolean) `true`, if current event’s name contains `subname`\n    \\*/\n    eve.nt = function (subname) {\n        if (subname) {\n            return new RegExp(\"(?:\\\\.|\\\\/|^)\" + subname + \"(?:\\\\.|\\\\/|$)\").test(current_event);\n        }\n        return current_event;\n    };\n    /*\\\n     * eve.nts\n     [ method ]\n     **\n     * Could be used inside event handler to figure out actual name of the event.\n     **\n     **\n     = (array) names of the event\n    \\*/\n    eve.nts = function () {\n        return current_event.split(separator);\n    };\n    /*\\\n     * eve.off\n     [ method ]\n     **\n     * Removes given function from the list of event listeners assigned to given name.\n     * If no arguments specified all the events will be cleared.\n     **\n     > Arguments\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n     - f (function) event handler function\n    \\*/\n    /*\\\n     * eve.unbind\n     [ method ]\n     **\n     * See @eve.off\n    \\*/\n    eve.off = eve.unbind = function (name, f) {\n        if (!name) {\n            eve._events = events = {n: {}};\n            return;\n        }\n        var names = name.split(comaseparator);\n        if (names.length > 1) {\n            for (var i = 0, ii = names.length; i < ii; i++) {\n                eve.off(names[i], f);\n            }\n            return;\n        }\n        names = name.split(separator);\n        var e,\n            key,\n            splice,\n            i, ii, j, jj,\n            cur = [events];\n        for (i = 0, ii = names.length; i < ii; i++) {\n            for (j = 0; j < cur.length; j += splice.length - 2) {\n                splice = [j, 1];\n                e = cur[j].n;\n                if (names[i] != wildcard) {\n                    if (e[names[i]]) {\n                        splice.push(e[names[i]]);\n                    }\n                } else {\n                    for (key in e) if (e[has](key)) {\n                        splice.push(e[key]);\n                    }\n                }\n                cur.splice.apply(cur, splice);\n            }\n        }\n        for (i = 0, ii = cur.length; i < ii; i++) {\n            e = cur[i];\n            while (e.n) {\n                if (f) {\n                    if (e.f) {\n                        for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {\n                            e.f.splice(j, 1);\n                            break;\n                        }\n                        !e.f.length && delete e.f;\n                    }\n                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n                        var funcs = e.n[key].f;\n                        for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {\n                            funcs.splice(j, 1);\n                            break;\n                        }\n                        !funcs.length && delete e.n[key].f;\n                    }\n                } else {\n                    delete e.f;\n                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n                        delete e.n[key].f;\n                    }\n                }\n                e = e.n;\n            }\n        }\n    };\n    /*\\\n     * eve.once\n     [ method ]\n     **\n     * Binds given event handler with a given name to only run once then unbind itself.\n     | eve.once(\"login\", f);\n     | eve(\"login\"); // triggers f\n     | eve(\"login\"); // no listeners\n     * Use @eve to trigger the listener.\n     **\n     > Arguments\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n     - f (function) event handler function\n     **\n     = (function) same return function as @eve.on\n    \\*/\n    eve.once = function (name, f) {\n        var f2 = function () {\n            eve.unbind(name, f2);\n            return f.apply(this, arguments);\n        };\n        return eve.on(name, f2);\n    };\n    /*\\\n     * eve.version\n     [ property (string) ]\n     **\n     * Current version of the library.\n    \\*/\n    eve.version = version;\n    eve.toString = function () {\n        return \"You are running Eve \" + version;\n    };\n    (typeof module != \"undefined\" && module.exports) ? (module.exports = eve) : (typeof define === \"function\" && define.amd ? (define(\"eve\", [], function() { return eve; })) : (glob.eve = eve));\n})(this);\n\n(function (glob, factory) {\n    // AMD support\n    if (typeof define == \"function\" && define.amd) {\n        // Define as an anonymous module\n        define([\"eve\"], function (eve) {\n            return factory(glob, eve);\n        });\n    } else if (typeof exports != 'undefined') {\n        // Next for Node.js or CommonJS\n        var eve = require('eve');\n        module.exports = factory(glob, eve);\n    } else {\n        // Browser globals (glob is window)\n        // Snap adds itself to window\n        factory(glob, glob.eve);\n    }\n}(window || this, function (window, eve) {\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n// http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar mina = (function (eve) {\n    var animations = {},\n    requestAnimFrame = window.requestAnimationFrame       ||\n                       window.webkitRequestAnimationFrame ||\n                       window.mozRequestAnimationFrame    ||\n                       window.oRequestAnimationFrame      ||\n                       window.msRequestAnimationFrame     ||\n                       function (callback) {\n                           setTimeout(callback, 16);\n                       },\n    isArray = Array.isArray || function (a) {\n        return a instanceof Array ||\n            Object.prototype.toString.call(a) == \"[object Array]\";\n    },\n    idgen = 0,\n    idprefix = \"M\" + (+new Date).toString(36),\n    ID = function () {\n        return idprefix + (idgen++).toString(36);\n    },\n    diff = function (a, b, A, B) {\n        if (isArray(a)) {\n            res = [];\n            for (var i = 0, ii = a.length; i < ii; i++) {\n                res[i] = diff(a[i], b, A[i], B);\n            }\n            return res;\n        }\n        var dif = (A - a) / (B - b);\n        return function (bb) {\n            return a + dif * (bb - b);\n        };\n    },\n    timer = Date.now || function () {\n        return +new Date;\n    },\n    sta = function (val) {\n        var a = this;\n        if (val == null) {\n            return a.s;\n        }\n        var ds = a.s - val;\n        a.b += a.dur * ds;\n        a.B += a.dur * ds;\n        a.s = val;\n    },\n    speed = function (val) {\n        var a = this;\n        if (val == null) {\n            return a.spd;\n        }\n        a.spd = val;\n    },\n    duration = function (val) {\n        var a = this;\n        if (val == null) {\n            return a.dur;\n        }\n        a.s = a.s * val / a.dur;\n        a.dur = val;\n    },\n    stopit = function () {\n        var a = this;\n        delete animations[a.id];\n        a.update();\n        eve(\"mina.stop.\" + a.id, a);\n    },\n    pause = function () {\n        var a = this;\n        if (a.pdif) {\n            return;\n        }\n        delete animations[a.id];\n        a.update();\n        a.pdif = a.get() - a.b;\n    },\n    resume = function () {\n        var a = this;\n        if (!a.pdif) {\n            return;\n        }\n        a.b = a.get() - a.pdif;\n        delete a.pdif;\n        animations[a.id] = a;\n    },\n    update = function () {\n        var a = this,\n            res;\n        if (isArray(a.start)) {\n            res = [];\n            for (var j = 0, jj = a.start.length; j < jj; j++) {\n                res[j] = +a.start[j] +\n                    (a.end[j] - a.start[j]) * a.easing(a.s);\n            }\n        } else {\n            res = +a.start + (a.end - a.start) * a.easing(a.s);\n        }\n        a.set(res);\n    },\n    frame = function () {\n        var len = 0;\n        for (var i in animations) if (animations.hasOwnProperty(i)) {\n            var a = animations[i],\n                b = a.get(),\n                res;\n            len++;\n            a.s = (b - a.b) / (a.dur / a.spd);\n            if (a.s >= 1) {\n                delete animations[i];\n                a.s = 1;\n                len--;\n                (function (a) {\n                    setTimeout(function () {\n                        eve(\"mina.finish.\" + a.id, a);\n                    });\n                }(a));\n            }\n            a.update();\n        }\n        len && requestAnimFrame(frame);\n    },\n    /*\\\n     * mina\n     [ method ]\n     **\n     * Generic animation of numbers\n     **\n     - a (number) start _slave_ number\n     - A (number) end _slave_ number\n     - b (number) start _master_ number (start time in general case)\n     - B (number) end _master_ number (end time in gereal case)\n     - get (function) getter of _master_ number (see @mina.time)\n     - set (function) setter of _slave_ number\n     - easing (function) #optional easing function, default is @mina.linear\n     = (object) animation descriptor\n     o {\n     o         id (string) animation id,\n     o         start (number) start _slave_ number,\n     o         end (number) end _slave_ number,\n     o         b (number) start _master_ number,\n     o         s (number) animation status (0..1),\n     o         dur (number) animation duration,\n     o         spd (number) animation speed,\n     o         get (function) getter of _master_ number (see @mina.time),\n     o         set (function) setter of _slave_ number,\n     o         easing (function) easing function, default is @mina.linear,\n     o         status (function) status getter/setter,\n     o         speed (function) speed getter/setter,\n     o         duration (function) duration getter/setter,\n     o         stop (function) animation stopper\n     o         pause (function) pauses the animation\n     o         resume (function) resumes the animation\n     o         update (function) calles setter with the right value of the animation\n     o }\n    \\*/\n    mina = function (a, A, b, B, get, set, easing) {\n        var anim = {\n            id: ID(),\n            start: a,\n            end: A,\n            b: b,\n            s: 0,\n            dur: B - b,\n            spd: 1,\n            get: get,\n            set: set,\n            easing: easing || mina.linear,\n            status: sta,\n            speed: speed,\n            duration: duration,\n            stop: stopit,\n            pause: pause,\n            resume: resume,\n            update: update\n        };\n        animations[anim.id] = anim;\n        var len = 0, i;\n        for (i in animations) if (animations.hasOwnProperty(i)) {\n            len++;\n            if (len == 2) {\n                break;\n            }\n        }\n        len == 1 && requestAnimFrame(frame);\n        return anim;\n    };\n    /*\\\n     * mina.time\n     [ method ]\n     **\n     * Returns the current time. Equivalent to:\n     | function () {\n     |     return (new Date).getTime();\n     | }\n    \\*/\n    mina.time = timer;\n    /*\\\n     * mina.getById\n     [ method ]\n     **\n     * Returns an animation by its id\n     - id (string) animation's id\n     = (object) See @mina\n    \\*/\n    mina.getById = function (id) {\n        return animations[id] || null;\n    };\n\n    /*\\\n     * mina.linear\n     [ method ]\n     **\n     * Default linear easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/\n    mina.linear = function (n) {\n        return n;\n    };\n    /*\\\n     * mina.easeout\n     [ method ]\n     **\n     * Easeout easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/\n    mina.easeout = function (n) {\n        return Math.pow(n, 1.7);\n    };\n    /*\\\n     * mina.easein\n     [ method ]\n     **\n     * Easein easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/\n    mina.easein = function (n) {\n        return Math.pow(n, .48);\n    };\n    /*\\\n     * mina.easeinout\n     [ method ]\n     **\n     * Easeinout easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/\n    mina.easeinout = function (n) {\n        if (n == 1) {\n            return 1;\n        }\n        if (n == 0) {\n            return 0;\n        }\n        var q = .48 - n / 1.04,\n            Q = Math.sqrt(.1734 + q * q),\n            x = Q - q,\n            X = Math.pow(Math.abs(x), 1 / 3) * (x < 0 ? -1 : 1),\n            y = -Q - q,\n            Y = Math.pow(Math.abs(y), 1 / 3) * (y < 0 ? -1 : 1),\n            t = X + Y + .5;\n        return (1 - t) * 3 * t * t + t * t * t;\n    };\n    /*\\\n     * mina.backin\n     [ method ]\n     **\n     * Backin easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/\n    mina.backin = function (n) {\n        if (n == 1) {\n            return 1;\n        }\n        var s = 1.70158;\n        return n * n * ((s + 1) * n - s);\n    };\n    /*\\\n     * mina.backout\n     [ method ]\n     **\n     * Backout easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/\n    mina.backout = function (n) {\n        if (n == 0) {\n            return 0;\n        }\n        n = n - 1;\n        var s = 1.70158;\n        return n * n * ((s + 1) * n + s) + 1;\n    };\n    /*\\\n     * mina.elastic\n     [ method ]\n     **\n     * Elastic easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/\n    mina.elastic = function (n) {\n        if (n == !!n) {\n            return n;\n        }\n        return Math.pow(2, -10 * n) * Math.sin((n - .075) *\n            (2 * Math.PI) / .3) + 1;\n    };\n    /*\\\n     * mina.bounce\n     [ method ]\n     **\n     * Bounce easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/\n    mina.bounce = function (n) {\n        var s = 7.5625,\n            p = 2.75,\n            l;\n        if (n < (1 / p)) {\n            l = s * n * n;\n        } else {\n            if (n < (2 / p)) {\n                n -= (1.5 / p);\n                l = s * n * n + .75;\n            } else {\n                if (n < (2.5 / p)) {\n                    n -= (2.25 / p);\n                    l = s * n * n + .9375;\n                } else {\n                    n -= (2.625 / p);\n                    l = s * n * n + .984375;\n                }\n            }\n        }\n        return l;\n    };\n    window.mina = mina;\n    return mina;\n})(typeof eve == \"undefined\" ? function () {} : eve);\n// Copyright (c) 2013 - 2015 Adobe Systems Incorporated. All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n// http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar Snap = (function(root) {\nSnap.version = \"0.4.0\";\n/*\\\n * Snap\n [ method ]\n **\n * Creates a drawing surface or wraps existing SVG element.\n **\n - width (number|string) width of surface\n - height (number|string) height of surface\n * or\n - DOM (SVGElement) element to be wrapped into Snap structure\n * or\n - array (array) array of elements (will return set of elements)\n * or\n - query (string) CSS query selector\n = (object) @Element\n\\*/\nfunction Snap(w, h) {\n    if (w) {\n        if (w.nodeType) {\n            return wrap(w);\n        }\n        if (is(w, \"array\") && Snap.set) {\n            return Snap.set.apply(Snap, w);\n        }\n        if (w instanceof Element) {\n            return w;\n        }\n        if (h == null) {\n            w = glob.doc.querySelector(String(w));\n            return wrap(w);\n        }\n    }\n    w = w == null ? \"100%\" : w;\n    h = h == null ? \"100%\" : h;\n    return new Paper(w, h);\n}\nSnap.toString = function () {\n    return \"Snap v\" + this.version;\n};\nSnap._ = {};\nvar glob = {\n    win: root.window,\n    doc: root.window.document\n};\nSnap._.glob = glob;\nvar has = \"hasOwnProperty\",\n    Str = String,\n    toFloat = parseFloat,\n    toInt = parseInt,\n    math = Math,\n    mmax = math.max,\n    mmin = math.min,\n    abs = math.abs,\n    pow = math.pow,\n    PI = math.PI,\n    round = math.round,\n    E = \"\",\n    S = \" \",\n    objectToString = Object.prototype.toString,\n    ISURL = /^url\\(['\"]?([^\\)]+?)['\"]?\\)$/i,\n    colourRegExp = /^\\s*((#[a-f\\d]{6})|(#[a-f\\d]{3})|rgba?\\(\\s*([\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?(?:\\s*,\\s*[\\d\\.]+%?)?)\\s*\\)|hsba?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+(?:%?\\s*,\\s*[\\d\\.]+)?%?)\\s*\\)|hsla?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+(?:%?\\s*,\\s*[\\d\\.]+)?%?)\\s*\\))\\s*$/i,\n    bezierrg = /^(?:cubic-)?bezier\\(([^,]+),([^,]+),([^,]+),([^\\)]+)\\)/,\n    reURLValue = /^url\\(#?([^)]+)\\)$/,\n    separator = Snap._.separator = /[,\\s]+/,\n    whitespace = /[\\s]/g,\n    commaSpaces = /[\\s]*,[\\s]*/,\n    hsrg = {hs: 1, rg: 1},\n    pathCommand = /([a-z])[\\s,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\s]*,?[\\s]*)+)/ig,\n    tCommand = /([rstm])[\\s,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\s]*,?[\\s]*)+)/ig,\n    pathValues = /(-?\\d*\\.?\\d*(?:e[\\-+]?\\\\d+)?)[\\s]*,?[\\s]*/ig,\n    idgen = 0,\n    idprefix = \"S\" + (+new Date).toString(36),\n    ID = function (el) {\n        return (el && el.type ? el.type : E) + idprefix + (idgen++).toString(36);\n    },\n    xlink = \"http://www.w3.org/1999/xlink\",\n    xmlns = \"http://www.w3.org/2000/svg\",\n    hub = {},\n    URL = Snap.url = function (url) {\n        return \"url('#\" + url + \"')\";\n    };\n\nfunction $(el, attr) {\n    if (attr) {\n        if (el == \"#text\") {\n            el = glob.doc.createTextNode(attr.text || attr[\"#text\"] || \"\");\n        }\n        if (el == \"#comment\") {\n            el = glob.doc.createComment(attr.text || attr[\"#text\"] || \"\");\n        }\n        if (typeof el == \"string\") {\n            el = $(el);\n        }\n        if (typeof attr == \"string\") {\n            if (el.nodeType == 1) {\n                if (attr.substring(0, 6) == \"xlink:\") {\n                    return el.getAttributeNS(xlink, attr.substring(6));\n                }\n                if (attr.substring(0, 4) == \"xml:\") {\n                    return el.getAttributeNS(xmlns, attr.substring(4));\n                }\n                return el.getAttribute(attr);\n            } else if (attr == \"text\") {\n                return el.nodeValue;\n            } else {\n                return null;\n            }\n        }\n        if (el.nodeType == 1) {\n            for (var key in attr) if (attr[has](key)) {\n                var val = Str(attr[key]);\n                if (val) {\n                    if (key.substring(0, 6) == \"xlink:\") {\n                        el.setAttributeNS(xlink, key.substring(6), val);\n                    } else if (key.substring(0, 4) == \"xml:\") {\n                        el.setAttributeNS(xmlns, key.substring(4), val);\n                    } else {\n                        el.setAttribute(key, val);\n                    }\n                } else {\n                    el.removeAttribute(key);\n                }\n            }\n        } else if (\"text\" in attr) {\n            el.nodeValue = attr.text;\n        }\n    } else {\n        el = glob.doc.createElementNS(xmlns, el);\n    }\n    return el;\n}\nSnap._.$ = $;\nSnap._.id = ID;\nfunction getAttrs(el) {\n    var attrs = el.attributes,\n        name,\n        out = {};\n    for (var i = 0; i < attrs.length; i++) {\n        if (attrs[i].namespaceURI == xlink) {\n            name = \"xlink:\";\n        } else {\n            name = \"\";\n        }\n        name += attrs[i].name;\n        out[name] = attrs[i].textContent;\n    }\n    return out;\n}\nfunction is(o, type) {\n    type = Str.prototype.toLowerCase.call(type);\n    if (type == \"finite\") {\n        return isFinite(o);\n    }\n    if (type == \"array\" &&\n        (o instanceof Array || Array.isArray && Array.isArray(o))) {\n        return true;\n    }\n    return  (type == \"null\" && o === null) ||\n            (type == typeof o && o !== null) ||\n            (type == \"object\" && o === Object(o)) ||\n            objectToString.call(o).slice(8, -1).toLowerCase() == type;\n}\n/*\\\n * Snap.format\n [ method ]\n **\n * Replaces construction of type `{<name>}` to the corresponding argument\n **\n - token (string) string to format\n - json (object) object which properties are used as a replacement\n = (string) formatted string\n > Usage\n | // this draws a rectangular shape equivalent to \"M10,20h40v50h-40z\"\n | paper.path(Snap.format(\"M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z\", {\n |     x: 10,\n |     y: 20,\n |     dim: {\n |         width: 40,\n |         height: 50,\n |         \"negative width\": -40\n |     }\n | }));\n\\*/\nSnap.format = (function () {\n    var tokenRegex = /\\{([^\\}]+)\\}/g,\n        objNotationRegex = /(?:(?:^|\\.)(.+?)(?=\\[|\\.|$|\\()|\\[('|\")(.+?)\\2\\])(\\(\\))?/g, // matches .xxxxx or [\"xxxxx\"] to run over object properties\n        replacer = function (all, key, obj) {\n            var res = obj;\n            key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {\n                name = name || quotedName;\n                if (res) {\n                    if (name in res) {\n                        res = res[name];\n                    }\n                    typeof res == \"function\" && isFunc && (res = res());\n                }\n            });\n            res = (res == null || res == obj ? all : res) + \"\";\n            return res;\n        };\n    return function (str, obj) {\n        return Str(str).replace(tokenRegex, function (all, key) {\n            return replacer(all, key, obj);\n        });\n    };\n})();\nfunction clone(obj) {\n    if (typeof obj == \"function\" || Object(obj) !== obj) {\n        return obj;\n    }\n    var res = new obj.constructor;\n    for (var key in obj) if (obj[has](key)) {\n        res[key] = clone(obj[key]);\n    }\n    return res;\n}\nSnap._.clone = clone;\nfunction repush(array, item) {\n    for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {\n        return array.push(array.splice(i, 1)[0]);\n    }\n}\nfunction cacher(f, scope, postprocessor) {\n    function newf() {\n        var arg = Array.prototype.slice.call(arguments, 0),\n            args = arg.join(\"\\u2400\"),\n            cache = newf.cache = newf.cache || {},\n            count = newf.count = newf.count || [];\n        if (cache[has](args)) {\n            repush(count, args);\n            return postprocessor ? postprocessor(cache[args]) : cache[args];\n        }\n        count.length >= 1e3 && delete cache[count.shift()];\n        count.push(args);\n        cache[args] = f.apply(scope, arg);\n        return postprocessor ? postprocessor(cache[args]) : cache[args];\n    }\n    return newf;\n}\nSnap._.cacher = cacher;\nfunction angle(x1, y1, x2, y2, x3, y3) {\n    if (x3 == null) {\n        var x = x1 - x2,\n            y = y1 - y2;\n        if (!x && !y) {\n            return 0;\n        }\n        return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;\n    } else {\n        return angle(x1, y1, x3, y3) - angle(x2, y2, x3, y3);\n    }\n}\nfunction rad(deg) {\n    return deg % 360 * PI / 180;\n}\nfunction deg(rad) {\n    return rad * 180 / PI % 360;\n}\nfunction x_y() {\n    return this.x + S + this.y;\n}\nfunction x_y_w_h() {\n    return this.x + S + this.y + S + this.width + \" \\xd7 \" + this.height;\n}\n\n/*\\\n * Snap.rad\n [ method ]\n **\n * Transform angle to radians\n - deg (number) angle in degrees\n = (number) angle in radians\n\\*/\nSnap.rad = rad;\n/*\\\n * Snap.deg\n [ method ]\n **\n * Transform angle to degrees\n - rad (number) angle in radians\n = (number) angle in degrees\n\\*/\nSnap.deg = deg;\n/*\\\n * Snap.sin\n [ method ]\n **\n * Equivalent to `Math.sin()` only works with degrees, not radians.\n - angle (number) angle in degrees\n = (number) sin\n\\*/\nSnap.sin = function (angle) {\n    return math.sin(Snap.rad(angle));\n};\n/*\\\n * Snap.tan\n [ method ]\n **\n * Equivalent to `Math.tan()` only works with degrees, not radians.\n - angle (number) angle in degrees\n = (number) tan\n\\*/\nSnap.tan = function (angle) {\n    return math.tan(Snap.rad(angle));\n};\n/*\\\n * Snap.cos\n [ method ]\n **\n * Equivalent to `Math.cos()` only works with degrees, not radians.\n - angle (number) angle in degrees\n = (number) cos\n\\*/\nSnap.cos = function (angle) {\n    return math.cos(Snap.rad(angle));\n};\n/*\\\n * Snap.asin\n [ method ]\n **\n * Equivalent to `Math.asin()` only works with degrees, not radians.\n - num (number) value\n = (number) asin in degrees\n\\*/\nSnap.asin = function (num) {\n    return Snap.deg(math.asin(num));\n};\n/*\\\n * Snap.acos\n [ method ]\n **\n * Equivalent to `Math.acos()` only works with degrees, not radians.\n - num (number) value\n = (number) acos in degrees\n\\*/\nSnap.acos = function (num) {\n    return Snap.deg(math.acos(num));\n};\n/*\\\n * Snap.atan\n [ method ]\n **\n * Equivalent to `Math.atan()` only works with degrees, not radians.\n - num (number) value\n = (number) atan in degrees\n\\*/\nSnap.atan = function (num) {\n    return Snap.deg(math.atan(num));\n};\n/*\\\n * Snap.atan2\n [ method ]\n **\n * Equivalent to `Math.atan2()` only works with degrees, not radians.\n - num (number) value\n = (number) atan2 in degrees\n\\*/\nSnap.atan2 = function (num) {\n    return Snap.deg(math.atan2(num));\n};\n/*\\\n * Snap.angle\n [ method ]\n **\n * Returns an angle between two or three points\n > Parameters\n - x1 (number) x coord of first point\n - y1 (number) y coord of first point\n - x2 (number) x coord of second point\n - y2 (number) y coord of second point\n - x3 (number) #optional x coord of third point\n - y3 (number) #optional y coord of third point\n = (number) angle in degrees\n\\*/\nSnap.angle = angle;\n/*\\\n * Snap.len\n [ method ]\n **\n * Returns distance between two points\n > Parameters\n - x1 (number) x coord of first point\n - y1 (number) y coord of first point\n - x2 (number) x coord of second point\n - y2 (number) y coord of second point\n = (number) distance\n\\*/\nSnap.len = function (x1, y1, x2, y2) {\n    return Math.sqrt(Snap.len2(x1, y1, x2, y2));\n};\n/*\\\n * Snap.len2\n [ method ]\n **\n * Returns squared distance between two points\n > Parameters\n - x1 (number) x coord of first point\n - y1 (number) y coord of first point\n - x2 (number) x coord of second point\n - y2 (number) y coord of second point\n = (number) distance\n\\*/\nSnap.len2 = function (x1, y1, x2, y2) {\n    return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\n};\n/*\\\n * Snap.closestPoint\n [ method ]\n **\n * Returns closest point to a given one on a given path.\n > Parameters\n - path (Element) path element\n - x (number) x coord of a point\n - y (number) y coord of a point\n = (object) in format\n {\n    x (number) x coord of the point on the path\n    y (number) y coord of the point on the path\n    length (number) length of the path to the point\n    distance (number) distance from the given point to the path\n }\n\\*/\n// Copied from http://bl.ocks.org/mbostock/8027637\nSnap.closestPoint = function (path, x, y) {\n    function distance2(p) {\n        var dx = p.x - x,\n            dy = p.y - y;\n        return dx * dx + dy * dy;\n    }\n    var pathNode = path.node,\n        pathLength = pathNode.getTotalLength(),\n        precision = pathLength / pathNode.pathSegList.numberOfItems * .125,\n        best,\n        bestLength,\n        bestDistance = Infinity;\n\n    // linear scan for coarse approximation\n    for (var scan, scanLength = 0, scanDistance; scanLength <= pathLength; scanLength += precision) {\n        if ((scanDistance = distance2(scan = pathNode.getPointAtLength(scanLength))) < bestDistance) {\n            best = scan, bestLength = scanLength, bestDistance = scanDistance;\n        }\n    }\n\n    // binary search for precise estimate\n    precision *= .5;\n    while (precision > .5) {\n        var before,\n            after,\n            beforeLength,\n            afterLength,\n            beforeDistance,\n            afterDistance;\n        if ((beforeLength = bestLength - precision) >= 0 && (beforeDistance = distance2(before = pathNode.getPointAtLength(beforeLength))) < bestDistance) {\n            best = before, bestLength = beforeLength, bestDistance = beforeDistance;\n        } else if ((afterLength = bestLength + precision) <= pathLength && (afterDistance = distance2(after = pathNode.getPointAtLength(afterLength))) < bestDistance) {\n            best = after, bestLength = afterLength, bestDistance = afterDistance;\n        } else {\n            precision *= .5;\n        }\n    }\n\n    best = {\n        x: best.x,\n        y: best.y,\n        length: bestLength,\n        distance: Math.sqrt(bestDistance)\n    };\n    return best;\n}\n/*\\\n * Snap.is\n [ method ]\n **\n * Handy replacement for the `typeof` operator\n - o (…) any object or primitive\n - type (string) name of the type, e.g., `string`, `function`, `number`, etc.\n = (boolean) `true` if given value is of given type\n\\*/\nSnap.is = is;\n/*\\\n * Snap.snapTo\n [ method ]\n **\n * Snaps given value to given grid\n - values (array|number) given array of values or step of the grid\n - value (number) value to adjust\n - tolerance (number) #optional maximum distance to the target value that would trigger the snap. Default is `10`.\n = (number) adjusted value\n\\*/\nSnap.snapTo = function (values, value, tolerance) {\n    tolerance = is(tolerance, \"finite\") ? tolerance : 10;\n    if (is(values, \"array\")) {\n        var i = values.length;\n        while (i--) if (abs(values[i] - value) <= tolerance) {\n            return values[i];\n        }\n    } else {\n        values = +values;\n        var rem = value % values;\n        if (rem < tolerance) {\n            return value - rem;\n        }\n        if (rem > values - tolerance) {\n            return value - rem + values;\n        }\n    }\n    return value;\n};\n// Colour\n/*\\\n * Snap.getRGB\n [ method ]\n **\n * Parses color string as RGB object\n - color (string) color string in one of the following formats:\n # <ul>\n #     <li>Color name (<code>red</code>, <code>green</code>, <code>cornflowerblue</code>, etc)</li>\n #     <li>#••• — shortened HTML color: (<code>#000</code>, <code>#fc0</code>, etc.)</li>\n #     <li>#•••••• — full length HTML color: (<code>#000000</code>, <code>#bd2300</code>)</li>\n #     <li>rgb(•••, •••, •••) — red, green and blue channels values: (<code>rgb(200,&nbsp;100,&nbsp;0)</code>)</li>\n #     <li>rgba(•••, •••, •••, •••) — also with opacity</li>\n #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>)</li>\n #     <li>rgba(•••%, •••%, •••%, •••%) — also with opacity</li>\n #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>)</li>\n #     <li>hsba(•••, •••, •••, •••) — also with opacity</li>\n #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>\n #     <li>hsba(•••%, •••%, •••%, •••%) — also with opacity</li>\n #     <li>hsl(•••, •••, •••) — hue, saturation and luminosity values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;0.5)</code>)</li>\n #     <li>hsla(•••, •••, •••, •••) — also with opacity</li>\n #     <li>hsl(•••%, •••%, •••%) — same as above, but in %</li>\n #     <li>hsla(•••%, •••%, •••%, •••%) — also with opacity</li>\n # </ul>\n * Note that `%` can be used any time: `rgb(20%, 255, 50%)`.\n = (object) RGB object in the following format:\n o {\n o     r (number) red,\n o     g (number) green,\n o     b (number) blue,\n o     hex (string) color in HTML/CSS format: #••••••,\n o     error (boolean) true if string can't be parsed\n o }\n\\*/\nSnap.getRGB = cacher(function (colour) {\n    if (!colour || !!((colour = Str(colour)).indexOf(\"-\") + 1)) {\n        return {r: -1, g: -1, b: -1, hex: \"none\", error: 1, toString: rgbtoString};\n    }\n    if (colour == \"none\") {\n        return {r: -1, g: -1, b: -1, hex: \"none\", toString: rgbtoString};\n    }\n    !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == \"#\") && (colour = toHex(colour));\n    if (!colour) {\n        return {r: -1, g: -1, b: -1, hex: \"none\", error: 1, toString: rgbtoString};\n    }\n    var res,\n        red,\n        green,\n        blue,\n        opacity,\n        t,\n        values,\n        rgb = colour.match(colourRegExp);\n    if (rgb) {\n        if (rgb[2]) {\n            blue = toInt(rgb[2].substring(5), 16);\n            green = toInt(rgb[2].substring(3, 5), 16);\n            red = toInt(rgb[2].substring(1, 3), 16);\n        }\n        if (rgb[3]) {\n            blue = toInt((t = rgb[3].charAt(3)) + t, 16);\n            green = toInt((t = rgb[3].charAt(2)) + t, 16);\n            red = toInt((t = rgb[3].charAt(1)) + t, 16);\n        }\n        if (rgb[4]) {\n            values = rgb[4].split(commaSpaces);\n            red = toFloat(values[0]);\n            values[0].slice(-1) == \"%\" && (red *= 2.55);\n            green = toFloat(values[1]);\n            values[1].slice(-1) == \"%\" && (green *= 2.55);\n            blue = toFloat(values[2]);\n            values[2].slice(-1) == \"%\" && (blue *= 2.55);\n            rgb[1].toLowerCase().slice(0, 4) == \"rgba\" && (opacity = toFloat(values[3]));\n            values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n        }\n        if (rgb[5]) {\n            values = rgb[5].split(commaSpaces);\n            red = toFloat(values[0]);\n            values[0].slice(-1) == \"%\" && (red /= 100);\n            green = toFloat(values[1]);\n            values[1].slice(-1) == \"%\" && (green /= 100);\n            blue = toFloat(values[2]);\n            values[2].slice(-1) == \"%\" && (blue /= 100);\n            (values[0].slice(-3) == \"deg\" || values[0].slice(-1) == \"\\xb0\") && (red /= 360);\n            rgb[1].toLowerCase().slice(0, 4) == \"hsba\" && (opacity = toFloat(values[3]));\n            values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n            return Snap.hsb2rgb(red, green, blue, opacity);\n        }\n        if (rgb[6]) {\n            values = rgb[6].split(commaSpaces);\n            red = toFloat(values[0]);\n            values[0].slice(-1) == \"%\" && (red /= 100);\n            green = toFloat(values[1]);\n            values[1].slice(-1) == \"%\" && (green /= 100);\n            blue = toFloat(values[2]);\n            values[2].slice(-1) == \"%\" && (blue /= 100);\n            (values[0].slice(-3) == \"deg\" || values[0].slice(-1) == \"\\xb0\") && (red /= 360);\n            rgb[1].toLowerCase().slice(0, 4) == \"hsla\" && (opacity = toFloat(values[3]));\n            values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n            return Snap.hsl2rgb(red, green, blue, opacity);\n        }\n        red = mmin(math.round(red), 255);\n        green = mmin(math.round(green), 255);\n        blue = mmin(math.round(blue), 255);\n        opacity = mmin(mmax(opacity, 0), 1);\n        rgb = {r: red, g: green, b: blue, toString: rgbtoString};\n        rgb.hex = \"#\" + (16777216 | blue | (green << 8) | (red << 16)).toString(16).slice(1);\n        rgb.opacity = is(opacity, \"finite\") ? opacity : 1;\n        return rgb;\n    }\n    return {r: -1, g: -1, b: -1, hex: \"none\", error: 1, toString: rgbtoString};\n}, Snap);\n/*\\\n * Snap.hsb\n [ method ]\n **\n * Converts HSB values to a hex representation of the color\n - h (number) hue\n - s (number) saturation\n - b (number) value or brightness\n = (string) hex representation of the color\n\\*/\nSnap.hsb = cacher(function (h, s, b) {\n    return Snap.hsb2rgb(h, s, b).hex;\n});\n/*\\\n * Snap.hsl\n [ method ]\n **\n * Converts HSL values to a hex representation of the color\n - h (number) hue\n - s (number) saturation\n - l (number) luminosity\n = (string) hex representation of the color\n\\*/\nSnap.hsl = cacher(function (h, s, l) {\n    return Snap.hsl2rgb(h, s, l).hex;\n});\n/*\\\n * Snap.rgb\n [ method ]\n **\n * Converts RGB values to a hex representation of the color\n - r (number) red\n - g (number) green\n - b (number) blue\n = (string) hex representation of the color\n\\*/\nSnap.rgb = cacher(function (r, g, b, o) {\n    if (is(o, \"finite\")) {\n        var round = math.round;\n        return \"rgba(\" + [round(r), round(g), round(b), +o.toFixed(2)] + \")\";\n    }\n    return \"#\" + (16777216 | b | (g << 8) | (r << 16)).toString(16).slice(1);\n});\nvar toHex = function (color) {\n    var i = glob.doc.getElementsByTagName(\"head\")[0] || glob.doc.getElementsByTagName(\"svg\")[0],\n        red = \"rgb(255, 0, 0)\";\n    toHex = cacher(function (color) {\n        if (color.toLowerCase() == \"red\") {\n            return red;\n        }\n        i.style.color = red;\n        i.style.color = color;\n        var out = glob.doc.defaultView.getComputedStyle(i, E).getPropertyValue(\"color\");\n        return out == red ? null : out;\n    });\n    return toHex(color);\n},\nhsbtoString = function () {\n    return \"hsb(\" + [this.h, this.s, this.b] + \")\";\n},\nhsltoString = function () {\n    return \"hsl(\" + [this.h, this.s, this.l] + \")\";\n},\nrgbtoString = function () {\n    return this.opacity == 1 || this.opacity == null ?\n            this.hex :\n            \"rgba(\" + [this.r, this.g, this.b, this.opacity] + \")\";\n},\nprepareRGB = function (r, g, b) {\n    if (g == null && is(r, \"object\") && \"r\" in r && \"g\" in r && \"b\" in r) {\n        b = r.b;\n        g = r.g;\n        r = r.r;\n    }\n    if (g == null && is(r, string)) {\n        var clr = Snap.getRGB(r);\n        r = clr.r;\n        g = clr.g;\n        b = clr.b;\n    }\n    if (r > 1 || g > 1 || b > 1) {\n        r /= 255;\n        g /= 255;\n        b /= 255;\n    }\n    \n    return [r, g, b];\n},\npackageRGB = function (r, g, b, o) {\n    r = math.round(r * 255);\n    g = math.round(g * 255);\n    b = math.round(b * 255);\n    var rgb = {\n        r: r,\n        g: g,\n        b: b,\n        opacity: is(o, \"finite\") ? o : 1,\n        hex: Snap.rgb(r, g, b),\n        toString: rgbtoString\n    };\n    is(o, \"finite\") && (rgb.opacity = o);\n    return rgb;\n};\n/*\\\n * Snap.color\n [ method ]\n **\n * Parses the color string and returns an object featuring the color's component values\n - clr (string) color string in one of the supported formats (see @Snap.getRGB)\n = (object) Combined RGB/HSB object in the following format:\n o {\n o     r (number) red,\n o     g (number) green,\n o     b (number) blue,\n o     hex (string) color in HTML/CSS format: #••••••,\n o     error (boolean) `true` if string can't be parsed,\n o     h (number) hue,\n o     s (number) saturation,\n o     v (number) value (brightness),\n o     l (number) lightness\n o }\n\\*/\nSnap.color = function (clr) {\n    var rgb;\n    if (is(clr, \"object\") && \"h\" in clr && \"s\" in clr && \"b\" in clr) {\n        rgb = Snap.hsb2rgb(clr);\n        clr.r = rgb.r;\n        clr.g = rgb.g;\n        clr.b = rgb.b;\n        clr.opacity = 1;\n        clr.hex = rgb.hex;\n    } else if (is(clr, \"object\") && \"h\" in clr && \"s\" in clr && \"l\" in clr) {\n        rgb = Snap.hsl2rgb(clr);\n        clr.r = rgb.r;\n        clr.g = rgb.g;\n        clr.b = rgb.b;\n        clr.opacity = 1;\n        clr.hex = rgb.hex;\n    } else {\n        if (is(clr, \"string\")) {\n            clr = Snap.getRGB(clr);\n        }\n        if (is(clr, \"object\") && \"r\" in clr && \"g\" in clr && \"b\" in clr && !(\"error\" in clr)) {\n            rgb = Snap.rgb2hsl(clr);\n            clr.h = rgb.h;\n            clr.s = rgb.s;\n            clr.l = rgb.l;\n            rgb = Snap.rgb2hsb(clr);\n            clr.v = rgb.b;\n        } else {\n            clr = {hex: \"none\"};\n            clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;\n            clr.error = 1;\n        }\n    }\n    clr.toString = rgbtoString;\n    return clr;\n};\n/*\\\n * Snap.hsb2rgb\n [ method ]\n **\n * Converts HSB values to an RGB object\n - h (number) hue\n - s (number) saturation\n - v (number) value or brightness\n = (object) RGB object in the following format:\n o {\n o     r (number) red,\n o     g (number) green,\n o     b (number) blue,\n o     hex (string) color in HTML/CSS format: #••••••\n o }\n\\*/\nSnap.hsb2rgb = function (h, s, v, o) {\n    if (is(h, \"object\") && \"h\" in h && \"s\" in h && \"b\" in h) {\n        v = h.b;\n        s = h.s;\n        o = h.o;\n        h = h.h;\n    }\n    h *= 360;\n    var R, G, B, X, C;\n    h = (h % 360) / 60;\n    C = v * s;\n    X = C * (1 - abs(h % 2 - 1));\n    R = G = B = v - C;\n\n    h = ~~h;\n    R += [C, X, 0, 0, X, C][h];\n    G += [X, C, C, X, 0, 0][h];\n    B += [0, 0, X, C, C, X][h];\n    return packageRGB(R, G, B, o);\n};\n/*\\\n * Snap.hsl2rgb\n [ method ]\n **\n * Converts HSL values to an RGB object\n - h (number) hue\n - s (number) saturation\n - l (number) luminosity\n = (object) RGB object in the following format:\n o {\n o     r (number) red,\n o     g (number) green,\n o     b (number) blue,\n o     hex (string) color in HTML/CSS format: #••••••\n o }\n\\*/\nSnap.hsl2rgb = function (h, s, l, o) {\n    if (is(h, \"object\") && \"h\" in h && \"s\" in h && \"l\" in h) {\n        l = h.l;\n        s = h.s;\n        h = h.h;\n    }\n    if (h > 1 || s > 1 || l > 1) {\n        h /= 360;\n        s /= 100;\n        l /= 100;\n    }\n    h *= 360;\n    var R, G, B, X, C;\n    h = (h % 360) / 60;\n    C = 2 * s * (l < .5 ? l : 1 - l);\n    X = C * (1 - abs(h % 2 - 1));\n    R = G = B = l - C / 2;\n\n    h = ~~h;\n    R += [C, X, 0, 0, X, C][h];\n    G += [X, C, C, X, 0, 0][h];\n    B += [0, 0, X, C, C, X][h];\n    return packageRGB(R, G, B, o);\n};\n/*\\\n * Snap.rgb2hsb\n [ method ]\n **\n * Converts RGB values to an HSB object\n - r (number) red\n - g (number) green\n - b (number) blue\n = (object) HSB object in the following format:\n o {\n o     h (number) hue,\n o     s (number) saturation,\n o     b (number) brightness\n o }\n\\*/\nSnap.rgb2hsb = function (r, g, b) {\n    b = prepareRGB(r, g, b);\n    r = b[0];\n    g = b[1];\n    b = b[2];\n\n    var H, S, V, C;\n    V = mmax(r, g, b);\n    C = V - mmin(r, g, b);\n    H = (C == 0 ? null :\n         V == r ? (g - b) / C :\n         V == g ? (b - r) / C + 2 :\n                  (r - g) / C + 4\n        );\n    H = ((H + 360) % 6) * 60 / 360;\n    S = C == 0 ? 0 : C / V;\n    return {h: H, s: S, b: V, toString: hsbtoString};\n};\n/*\\\n * Snap.rgb2hsl\n [ method ]\n **\n * Converts RGB values to an HSL object\n - r (number) red\n - g (number) green\n - b (number) blue\n = (object) HSL object in the following format:\n o {\n o     h (number) hue,\n o     s (number) saturation,\n o     l (number) luminosity\n o }\n\\*/\nSnap.rgb2hsl = function (r, g, b) {\n    b = prepareRGB(r, g, b);\n    r = b[0];\n    g = b[1];\n    b = b[2];\n\n    var H, S, L, M, m, C;\n    M = mmax(r, g, b);\n    m = mmin(r, g, b);\n    C = M - m;\n    H = (C == 0 ? null :\n         M == r ? (g - b) / C :\n         M == g ? (b - r) / C + 2 :\n                  (r - g) / C + 4);\n    H = ((H + 360) % 6) * 60 / 360;\n    L = (M + m) / 2;\n    S = (C == 0 ? 0 :\n         L < .5 ? C / (2 * L) :\n                  C / (2 - 2 * L));\n    return {h: H, s: S, l: L, toString: hsltoString};\n};\n\n// Transformations\n/*\\\n * Snap.parsePathString\n [ method ]\n **\n * Utility method\n **\n * Parses given path string into an array of arrays of path segments\n - pathString (string|array) path string or array of segments (in the last case it is returned straight away)\n = (array) array of segments\n\\*/\nSnap.parsePathString = function (pathString) {\n    if (!pathString) {\n        return null;\n    }\n    var pth = Snap.path(pathString);\n    if (pth.arr) {\n        return Snap.path.clone(pth.arr);\n    }\n    \n    var paramCounts = {a: 7, c: 6, o: 2, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, u: 3, z: 0},\n        data = [];\n    if (is(pathString, \"array\") && is(pathString[0], \"array\")) { // rough assumption\n        data = Snap.path.clone(pathString);\n    }\n    if (!data.length) {\n        Str(pathString).replace(pathCommand, function (a, b, c) {\n            var params = [],\n                name = b.toLowerCase();\n            c.replace(pathValues, function (a, b) {\n                b && params.push(+b);\n            });\n            if (name == \"m\" && params.length > 2) {\n                data.push([b].concat(params.splice(0, 2)));\n                name = \"l\";\n                b = b == \"m\" ? \"l\" : \"L\";\n            }\n            if (name == \"o\" && params.length == 1) {\n                data.push([b, params[0]]);\n            }\n            if (name == \"r\") {\n                data.push([b].concat(params));\n            } else while (params.length >= paramCounts[name]) {\n                data.push([b].concat(params.splice(0, paramCounts[name])));\n                if (!paramCounts[name]) {\n                    break;\n                }\n            }\n        });\n    }\n    data.toString = Snap.path.toString;\n    pth.arr = Snap.path.clone(data);\n    return data;\n};\n/*\\\n * Snap.parseTransformString\n [ method ]\n **\n * Utility method\n **\n * Parses given transform string into an array of transformations\n - TString (string|array) transform string or array of transformations (in the last case it is returned straight away)\n = (array) array of transformations\n\\*/\nvar parseTransformString = Snap.parseTransformString = function (TString) {\n    if (!TString) {\n        return null;\n    }\n    var paramCounts = {r: 3, s: 4, t: 2, m: 6},\n        data = [];\n    if (is(TString, \"array\") && is(TString[0], \"array\")) { // rough assumption\n        data = Snap.path.clone(TString);\n    }\n    if (!data.length) {\n        Str(TString).replace(tCommand, function (a, b, c) {\n            var params = [],\n                name = b.toLowerCase();\n            c.replace(pathValues, function (a, b) {\n                b && params.push(+b);\n            });\n            data.push([b].concat(params));\n        });\n    }\n    data.toString = Snap.path.toString;\n    return data;\n};\nfunction svgTransform2string(tstr) {\n    var res = [];\n    tstr = tstr.replace(/(?:^|\\s)(\\w+)\\(([^)]+)\\)/g, function (all, name, params) {\n        params = params.split(/\\s*,\\s*|\\s+/);\n        if (name == \"rotate\" && params.length == 1) {\n            params.push(0, 0);\n        }\n        if (name == \"scale\") {\n            if (params.length > 2) {\n                params = params.slice(0, 2);\n            } else if (params.length == 2) {\n                params.push(0, 0);\n            }\n            if (params.length == 1) {\n                params.push(params[0], 0, 0);\n            }\n        }\n        if (name == \"skewX\") {\n            res.push([\"m\", 1, 0, math.tan(rad(params[0])), 1, 0, 0]);\n        } else if (name == \"skewY\") {\n            res.push([\"m\", 1, math.tan(rad(params[0])), 0, 1, 0, 0]);\n        } else {\n            res.push([name.charAt(0)].concat(params));\n        }\n        return all;\n    });\n    return res;\n}\nSnap._.svgTransform2string = svgTransform2string;\nSnap._.rgTransform = /^[a-z][\\s]*-?\\.?\\d/i;\nfunction transform2matrix(tstr, bbox) {\n    var tdata = parseTransformString(tstr),\n        m = new Snap.Matrix;\n    if (tdata) {\n        for (var i = 0, ii = tdata.length; i < ii; i++) {\n            var t = tdata[i],\n                tlen = t.length,\n                command = Str(t[0]).toLowerCase(),\n                absolute = t[0] != command,\n                inver = absolute ? m.invert() : 0,\n                x1,\n                y1,\n                x2,\n                y2,\n                bb;\n            if (command == \"t\" && tlen == 2){\n                m.translate(t[1], 0);\n            } else if (command == \"t\" && tlen == 3) {\n                if (absolute) {\n                    x1 = inver.x(0, 0);\n                    y1 = inver.y(0, 0);\n                    x2 = inver.x(t[1], t[2]);\n                    y2 = inver.y(t[1], t[2]);\n                    m.translate(x2 - x1, y2 - y1);\n                } else {\n                    m.translate(t[1], t[2]);\n                }\n            } else if (command == \"r\") {\n                if (tlen == 2) {\n                    bb = bb || bbox;\n                    m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);\n                } else if (tlen == 4) {\n                    if (absolute) {\n                        x2 = inver.x(t[2], t[3]);\n                        y2 = inver.y(t[2], t[3]);\n                        m.rotate(t[1], x2, y2);\n                    } else {\n                        m.rotate(t[1], t[2], t[3]);\n                    }\n                }\n            } else if (command == \"s\") {\n                if (tlen == 2 || tlen == 3) {\n                    bb = bb || bbox;\n                    m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);\n                } else if (tlen == 4) {\n                    if (absolute) {\n                        x2 = inver.x(t[2], t[3]);\n                        y2 = inver.y(t[2], t[3]);\n                        m.scale(t[1], t[1], x2, y2);\n                    } else {\n                        m.scale(t[1], t[1], t[2], t[3]);\n                    }\n                } else if (tlen == 5) {\n                    if (absolute) {\n                        x2 = inver.x(t[3], t[4]);\n                        y2 = inver.y(t[3], t[4]);\n                        m.scale(t[1], t[2], x2, y2);\n                    } else {\n                        m.scale(t[1], t[2], t[3], t[4]);\n                    }\n                }\n            } else if (command == \"m\" && tlen == 7) {\n                m.add(t[1], t[2], t[3], t[4], t[5], t[6]);\n            }\n        }\n    }\n    return m;\n}\nSnap._.transform2matrix = transform2matrix;\nSnap._unit2px = unit2px;\nvar contains = glob.doc.contains || glob.doc.compareDocumentPosition ?\n    function (a, b) {\n        var adown = a.nodeType == 9 ? a.documentElement : a,\n            bup = b && b.parentNode;\n            return a == bup || !!(bup && bup.nodeType == 1 && (\n                adown.contains ?\n                    adown.contains(bup) :\n                    a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16\n            ));\n    } :\n    function (a, b) {\n        if (b) {\n            while (b) {\n                b = b.parentNode;\n                if (b == a) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\nfunction getSomeDefs(el) {\n    var p = (el.node.ownerSVGElement && wrap(el.node.ownerSVGElement)) ||\n            (el.node.parentNode && wrap(el.node.parentNode)) ||\n            Snap.select(\"svg\") ||\n            Snap(0, 0),\n        pdefs = p.select(\"defs\"),\n        defs  = pdefs == null ? false : pdefs.node;\n    if (!defs) {\n        defs = make(\"defs\", p.node).node;\n    }\n    return defs;\n}\nfunction getSomeSVG(el) {\n    return el.node.ownerSVGElement && wrap(el.node.ownerSVGElement) || Snap.select(\"svg\");\n}\nSnap._.getSomeDefs = getSomeDefs;\nSnap._.getSomeSVG = getSomeSVG;\nfunction unit2px(el, name, value) {\n    var svg = getSomeSVG(el).node,\n        out = {},\n        mgr = svg.querySelector(\".svg---mgr\");\n    if (!mgr) {\n        mgr = $(\"rect\");\n        $(mgr, {x: -9e9, y: -9e9, width: 10, height: 10, \"class\": \"svg---mgr\", fill: \"none\"});\n        svg.appendChild(mgr);\n    }\n    function getW(val) {\n        if (val == null) {\n            return E;\n        }\n        if (val == +val) {\n            return val;\n        }\n        $(mgr, {width: val});\n        try {\n            return mgr.getBBox().width;\n        } catch (e) {\n            return 0;\n        }\n    }\n    function getH(val) {\n        if (val == null) {\n            return E;\n        }\n        if (val == +val) {\n            return val;\n        }\n        $(mgr, {height: val});\n        try {\n            return mgr.getBBox().height;\n        } catch (e) {\n            return 0;\n        }\n    }\n    function set(nam, f) {\n        if (name == null) {\n            out[nam] = f(el.attr(nam) || 0);\n        } else if (nam == name) {\n            out = f(value == null ? el.attr(nam) || 0 : value);\n        }\n    }\n    switch (el.type) {\n        case \"rect\":\n            set(\"rx\", getW);\n            set(\"ry\", getH);\n        case \"image\":\n            set(\"width\", getW);\n            set(\"height\", getH);\n        case \"text\":\n            set(\"x\", getW);\n            set(\"y\", getH);\n        break;\n        case \"circle\":\n            set(\"cx\", getW);\n            set(\"cy\", getH);\n            set(\"r\", getW);\n        break;\n        case \"ellipse\":\n            set(\"cx\", getW);\n            set(\"cy\", getH);\n            set(\"rx\", getW);\n            set(\"ry\", getH);\n        break;\n        case \"line\":\n            set(\"x1\", getW);\n            set(\"x2\", getW);\n            set(\"y1\", getH);\n            set(\"y2\", getH);\n        break;\n        case \"marker\":\n            set(\"refX\", getW);\n            set(\"markerWidth\", getW);\n            set(\"refY\", getH);\n            set(\"markerHeight\", getH);\n        break;\n        case \"radialGradient\":\n            set(\"fx\", getW);\n            set(\"fy\", getH);\n        break;\n        case \"tspan\":\n            set(\"dx\", getW);\n            set(\"dy\", getH);\n        break;\n        default:\n            set(name, getW);\n    }\n    svg.removeChild(mgr);\n    return out;\n}\n/*\\\n * Snap.select\n [ method ]\n **\n * Wraps a DOM element specified by CSS selector as @Element\n - query (string) CSS selector of the element\n = (Element) the current element\n\\*/\nSnap.select = function (query) {\n    query = Str(query).replace(/([^\\\\]):/g, \"$1\\\\:\");\n    return wrap(glob.doc.querySelector(query));\n};\n/*\\\n * Snap.selectAll\n [ method ]\n **\n * Wraps DOM elements specified by CSS selector as set or array of @Element\n - query (string) CSS selector of the element\n = (Element) the current element\n\\*/\nSnap.selectAll = function (query) {\n    var nodelist = glob.doc.querySelectorAll(query),\n        set = (Snap.set || Array)();\n    for (var i = 0; i < nodelist.length; i++) {\n        set.push(wrap(nodelist[i]));\n    }\n    return set;\n};\n\nfunction add2group(list) {\n    if (!is(list, \"array\")) {\n        list = Array.prototype.slice.call(arguments, 0);\n    }\n    var i = 0,\n        j = 0,\n        node = this.node;\n    while (this[i]) delete this[i++];\n    for (i = 0; i < list.length; i++) {\n        if (list[i].type == \"set\") {\n            list[i].forEach(function (el) {\n                node.appendChild(el.node);\n            });\n        } else {\n            node.appendChild(list[i].node);\n        }\n    }\n    var children = node.childNodes;\n    for (i = 0; i < children.length; i++) {\n        this[j++] = wrap(children[i]);\n    }\n    return this;\n}\n// Hub garbage collector every 10s\nsetInterval(function () {\n    for (var key in hub) if (hub[has](key)) {\n        var el = hub[key],\n            node = el.node;\n        if (el.type != \"svg\" && !node.ownerSVGElement || el.type == \"svg\" && (!node.parentNode || \"ownerSVGElement\" in node.parentNode && !node.ownerSVGElement)) {\n            delete hub[key];\n        }\n    }\n}, 1e4);\nfunction Element(el) {\n    if (el.snap in hub) {\n        return hub[el.snap];\n    }\n    var svg;\n    try {\n        svg = el.ownerSVGElement;\n    } catch(e) {}\n    /*\\\n     * Element.node\n     [ property (object) ]\n     **\n     * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.\n     > Usage\n     | // draw a circle at coordinate 10,10 with radius of 10\n     | var c = paper.circle(10, 10, 10);\n     | c.node.onclick = function () {\n     |     c.attr(\"fill\", \"red\");\n     | };\n    \\*/\n    this.node = el;\n    if (svg) {\n        this.paper = new Paper(svg);\n    }\n    /*\\\n     * Element.type\n     [ property (string) ]\n     **\n     * SVG tag name of the given element.\n    \\*/\n    this.type = el.tagName || el.nodeName;\n    var id = this.id = ID(this);\n    this.anims = {};\n    this._ = {\n        transform: []\n    };\n    el.snap = id;\n    hub[id] = this;\n    if (this.type == \"g\") {\n        this.add = add2group;\n    }\n    if (this.type in {g: 1, mask: 1, pattern: 1, symbol: 1}) {\n        for (var method in Paper.prototype) if (Paper.prototype[has](method)) {\n            this[method] = Paper.prototype[method];\n        }\n    }\n}\n   /*\\\n     * Element.attr\n     [ method ]\n     **\n     * Gets or sets given attributes of the element.\n     **\n     - params (object) contains key-value pairs of attributes you want to set\n     * or\n     - param (string) name of the attribute\n     = (Element) the current element\n     * or\n     = (string) value of attribute\n     > Usage\n     | el.attr({\n     |     fill: \"#fc0\",\n     |     stroke: \"#000\",\n     |     strokeWidth: 2, // CamelCase...\n     |     \"fill-opacity\": 0.5, // or dash-separated names\n     |     width: \"*=2\" // prefixed values\n     | });\n     | console.log(el.attr(\"fill\")); // #fc0\n     * Prefixed values in format `\"+=10\"` supported. All four operations\n     * (`+`, `-`, `*` and `/`) could be used. Optionally you can use units for `+`\n     * and `-`: `\"+=2em\"`.\n    \\*/\n    Element.prototype.attr = function (params, value) {\n        var el = this,\n            node = el.node;\n        if (!params) {\n            if (node.nodeType != 1) {\n                return {\n                    text: node.nodeValue\n                };\n            }\n            var attr = node.attributes,\n                out = {};\n            for (var i = 0, ii = attr.length; i < ii; i++) {\n                out[attr[i].nodeName] = attr[i].nodeValue;\n            }\n            return out;\n        }\n        if (is(params, \"string\")) {\n            if (arguments.length > 1) {\n                var json = {};\n                json[params] = value;\n                params = json;\n            } else {\n                return eve(\"snap.util.getattr.\" + params, el).firstDefined();\n            }\n        }\n        for (var att in params) {\n            if (params[has](att)) {\n                eve(\"snap.util.attr.\" + att, el, params[att]);\n            }\n        }\n        return el;\n    };\n/*\\\n * Snap.parse\n [ method ]\n **\n * Parses SVG fragment and converts it into a @Fragment\n **\n - svg (string) SVG string\n = (Fragment) the @Fragment\n\\*/\nSnap.parse = function (svg) {\n    var f = glob.doc.createDocumentFragment(),\n        full = true,\n        div = glob.doc.createElement(\"div\");\n    svg = Str(svg);\n    if (!svg.match(/^\\s*<\\s*svg(?:\\s|>)/)) {\n        svg = \"<svg>\" + svg + \"</svg>\";\n        full = false;\n    }\n    div.innerHTML = svg;\n    svg = div.getElementsByTagName(\"svg\")[0];\n    if (svg) {\n        if (full) {\n            f = svg;\n        } else {\n            while (svg.firstChild) {\n                f.appendChild(svg.firstChild);\n            }\n        }\n    }\n    return new Fragment(f);\n};\nfunction Fragment(frag) {\n    this.node = frag;\n}\n/*\\\n * Snap.fragment\n [ method ]\n **\n * Creates a DOM fragment from a given list of elements or strings\n **\n - varargs (…) SVG string\n = (Fragment) the @Fragment\n\\*/\nSnap.fragment = function () {\n    var args = Array.prototype.slice.call(arguments, 0),\n        f = glob.doc.createDocumentFragment();\n    for (var i = 0, ii = args.length; i < ii; i++) {\n        var item = args[i];\n        if (item.node && item.node.nodeType) {\n            f.appendChild(item.node);\n        }\n        if (item.nodeType) {\n            f.appendChild(item);\n        }\n        if (typeof item == \"string\") {\n            f.appendChild(Snap.parse(item).node);\n        }\n    }\n    return new Fragment(f);\n};\n\nfunction make(name, parent) {\n    var res = $(name);\n    parent.appendChild(res);\n    var el = wrap(res);\n    return el;\n}\nfunction Paper(w, h) {\n    var res,\n        desc,\n        defs,\n        proto = Paper.prototype;\n    if (w && w.tagName == \"svg\") {\n        if (w.snap in hub) {\n            return hub[w.snap];\n        }\n        var doc = w.ownerDocument;\n        res = new Element(w);\n        desc = w.getElementsByTagName(\"desc\")[0];\n        defs = w.getElementsByTagName(\"defs\")[0];\n        if (!desc) {\n            desc = $(\"desc\");\n            desc.appendChild(doc.createTextNode(\"Created with Snap\"));\n            res.node.appendChild(desc);\n        }\n        if (!defs) {\n            defs = $(\"defs\");\n            res.node.appendChild(defs);\n        }\n        res.defs = defs;\n        for (var key in proto) if (proto[has](key)) {\n            res[key] = proto[key];\n        }\n        res.paper = res.root = res;\n    } else {\n        res = make(\"svg\", glob.doc.body);\n        $(res.node, {\n            height: h,\n            version: 1.1,\n            width: w,\n            xmlns: xmlns\n        });\n    }\n    return res;\n}\nfunction wrap(dom) {\n    if (!dom) {\n        return dom;\n    }\n    if (dom instanceof Element || dom instanceof Fragment) {\n        return dom;\n    }\n    if (dom.tagName && dom.tagName.toLowerCase() == \"svg\") {\n        return new Paper(dom);\n    }\n    if (dom.tagName && dom.tagName.toLowerCase() == \"object\" && dom.type == \"image/svg+xml\") {\n        return new Paper(dom.contentDocument.getElementsByTagName(\"svg\")[0]);\n    }\n    return new Element(dom);\n}\n\nSnap._.make = make;\nSnap._.wrap = wrap;\n/*\\\n * Paper.el\n [ method ]\n **\n * Creates an element on paper with a given name and no attributes\n **\n - name (string) tag name\n - attr (object) attributes\n = (Element) the current element\n > Usage\n | var c = paper.circle(10, 10, 10); // is the same as...\n | var c = paper.el(\"circle\").attr({\n |     cx: 10,\n |     cy: 10,\n |     r: 10\n | });\n | // and the same as\n | var c = paper.el(\"circle\", {\n |     cx: 10,\n |     cy: 10,\n |     r: 10\n | });\n\\*/\nPaper.prototype.el = function (name, attr) {\n    var el = make(name, this.node);\n    attr && el.attr(attr);\n    return el;\n};\n/*\\\n * Element.children\n [ method ]\n **\n * Returns array of all the children of the element.\n = (array) array of Elements\n\\*/\nElement.prototype.children = function () {\n    var out = [],\n        ch = this.node.childNodes;\n    for (var i = 0, ii = ch.length; i < ii; i++) {\n        out[i] = Snap(ch[i]);\n    }\n    return out;\n};\nfunction jsonFiller(root, o) {\n    for (var i = 0, ii = root.length; i < ii; i++) {\n        var item = {\n                type: root[i].type,\n                attr: root[i].attr()\n            },\n            children = root[i].children();\n        o.push(item);\n        if (children.length) {\n            jsonFiller(children, item.childNodes = []);\n        }\n    }\n}\n/*\\\n * Element.toJSON\n [ method ]\n **\n * Returns object representation of the given element and all its children.\n = (object) in format\n o {\n o     type (string) this.type,\n o     attr (object) attributes map,\n o     childNodes (array) optional array of children in the same format\n o }\n\\*/\nElement.prototype.toJSON = function () {\n    var out = [];\n    jsonFiller([this], out);\n    return out[0];\n};\n// default\neve.on(\"snap.util.getattr\", function () {\n    var att = eve.nt();\n    att = att.substring(att.lastIndexOf(\".\") + 1);\n    var css = att.replace(/[A-Z]/g, function (letter) {\n        return \"-\" + letter.toLowerCase();\n    });\n    if (cssAttr[has](css)) {\n        return this.node.ownerDocument.defaultView.getComputedStyle(this.node, null).getPropertyValue(css);\n    } else {\n        return $(this.node, att);\n    }\n});\nvar cssAttr = {\n    \"alignment-baseline\": 0,\n    \"baseline-shift\": 0,\n    \"clip\": 0,\n    \"clip-path\": 0,\n    \"clip-rule\": 0,\n    \"color\": 0,\n    \"color-interpolation\": 0,\n    \"color-interpolation-filters\": 0,\n    \"color-profile\": 0,\n    \"color-rendering\": 0,\n    \"cursor\": 0,\n    \"direction\": 0,\n    \"display\": 0,\n    \"dominant-baseline\": 0,\n    \"enable-background\": 0,\n    \"fill\": 0,\n    \"fill-opacity\": 0,\n    \"fill-rule\": 0,\n    \"filter\": 0,\n    \"flood-color\": 0,\n    \"flood-opacity\": 0,\n    \"font\": 0,\n    \"font-family\": 0,\n    \"font-size\": 0,\n    \"font-size-adjust\": 0,\n    \"font-stretch\": 0,\n    \"font-style\": 0,\n    \"font-variant\": 0,\n    \"font-weight\": 0,\n    \"glyph-orientation-horizontal\": 0,\n    \"glyph-orientation-vertical\": 0,\n    \"image-rendering\": 0,\n    \"kerning\": 0,\n    \"letter-spacing\": 0,\n    \"lighting-color\": 0,\n    \"marker\": 0,\n    \"marker-end\": 0,\n    \"marker-mid\": 0,\n    \"marker-start\": 0,\n    \"mask\": 0,\n    \"opacity\": 0,\n    \"overflow\": 0,\n    \"pointer-events\": 0,\n    \"shape-rendering\": 0,\n    \"stop-color\": 0,\n    \"stop-opacity\": 0,\n    \"stroke\": 0,\n    \"stroke-dasharray\": 0,\n    \"stroke-dashoffset\": 0,\n    \"stroke-linecap\": 0,\n    \"stroke-linejoin\": 0,\n    \"stroke-miterlimit\": 0,\n    \"stroke-opacity\": 0,\n    \"stroke-width\": 0,\n    \"text-anchor\": 0,\n    \"text-decoration\": 0,\n    \"text-rendering\": 0,\n    \"unicode-bidi\": 0,\n    \"visibility\": 0,\n    \"word-spacing\": 0,\n    \"writing-mode\": 0\n};\n\neve.on(\"snap.util.attr\", function (value) {\n    var att = eve.nt(),\n        attr = {};\n    att = att.substring(att.lastIndexOf(\".\") + 1);\n    attr[att] = value;\n    var style = att.replace(/-(\\w)/gi, function (all, letter) {\n            return letter.toUpperCase();\n        }),\n        css = att.replace(/[A-Z]/g, function (letter) {\n            return \"-\" + letter.toLowerCase();\n        });\n    if (cssAttr[has](css)) {\n        this.node.style[style] = value == null ? E : value;\n    } else {\n        $(this.node, attr);\n    }\n});\n(function (proto) {}(Paper.prototype));\n\n// simple ajax\n/*\\\n * Snap.ajax\n [ method ]\n **\n * Simple implementation of Ajax\n **\n - url (string) URL\n - postData (object|string) data for post request\n - callback (function) callback\n - scope (object) #optional scope of callback\n * or\n - url (string) URL\n - callback (function) callback\n - scope (object) #optional scope of callback\n = (XMLHttpRequest) the XMLHttpRequest object, just in case\n\\*/\nSnap.ajax = function (url, postData, callback, scope){\n    var req = new XMLHttpRequest,\n        id = ID();\n    if (req) {\n        if (is(postData, \"function\")) {\n            scope = callback;\n            callback = postData;\n            postData = null;\n        } else if (is(postData, \"object\")) {\n            var pd = [];\n            for (var key in postData) if (postData.hasOwnProperty(key)) {\n                pd.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(postData[key]));\n            }\n            postData = pd.join(\"&\");\n        }\n        req.open((postData ? \"POST\" : \"GET\"), url, true);\n        if (postData) {\n            req.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n            req.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");\n        }\n        if (callback) {\n            eve.once(\"snap.ajax.\" + id + \".0\", callback);\n            eve.once(\"snap.ajax.\" + id + \".200\", callback);\n            eve.once(\"snap.ajax.\" + id + \".304\", callback);\n        }\n        req.onreadystatechange = function() {\n            if (req.readyState != 4) return;\n            eve(\"snap.ajax.\" + id + \".\" + req.status, scope, req);\n        };\n        if (req.readyState == 4) {\n            return req;\n        }\n        req.send(postData);\n        return req;\n    }\n};\n/*\\\n * Snap.load\n [ method ]\n **\n * Loads external SVG file as a @Fragment (see @Snap.ajax for more advanced AJAX)\n **\n - url (string) URL\n - callback (function) callback\n - scope (object) #optional scope of callback\n\\*/\nSnap.load = function (url, callback, scope) {\n    Snap.ajax(url, function (req) {\n        var f = Snap.parse(req.responseText);\n        scope ? callback.call(scope, f) : callback(f);\n    });\n};\nvar getOffset = function (elem) {\n    var box = elem.getBoundingClientRect(),\n        doc = elem.ownerDocument,\n        body = doc.body,\n        docElem = doc.documentElement,\n        clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,\n        top  = box.top  + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop ) - clientTop,\n        left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;\n    return {\n        y: top,\n        x: left\n    };\n};\n/*\\\n * Snap.getElementByPoint\n [ method ]\n **\n * Returns you topmost element under given point.\n **\n = (object) Snap element object\n - x (number) x coordinate from the top left corner of the window\n - y (number) y coordinate from the top left corner of the window\n > Usage\n | Snap.getElementByPoint(mouseX, mouseY).attr({stroke: \"#f00\"});\n\\*/\nSnap.getElementByPoint = function (x, y) {\n    var paper = this,\n        svg = paper.canvas,\n        target = glob.doc.elementFromPoint(x, y);\n    if (glob.win.opera && target.tagName == \"svg\") {\n        var so = getOffset(target),\n            sr = target.createSVGRect();\n        sr.x = x - so.x;\n        sr.y = y - so.y;\n        sr.width = sr.height = 1;\n        var hits = target.getIntersectionList(sr, null);\n        if (hits.length) {\n            target = hits[hits.length - 1];\n        }\n    }\n    if (!target) {\n        return null;\n    }\n    return wrap(target);\n};\n/*\\\n * Snap.plugin\n [ method ]\n **\n * Let you write plugins. You pass in a function with five arguments, like this:\n | Snap.plugin(function (Snap, Element, Paper, global, Fragment) {\n |     Snap.newmethod = function () {};\n |     Element.prototype.newmethod = function () {};\n |     Paper.prototype.newmethod = function () {};\n | });\n * Inside the function you have access to all main objects (and their\n * prototypes). This allow you to extend anything you want.\n **\n - f (function) your plugin body\n\\*/\nSnap.plugin = function (f) {\n    f(Snap, Element, Paper, glob, Fragment);\n};\nglob.win.Snap = Snap;\nreturn Snap;\n}(window || this));\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n    var elproto = Element.prototype,\n        is = Snap.is,\n        Str = String,\n        unit2px = Snap._unit2px,\n        $ = Snap._.$,\n        make = Snap._.make,\n        getSomeDefs = Snap._.getSomeDefs,\n        has = \"hasOwnProperty\",\n        wrap = Snap._.wrap;\n    /*\\\n     * Element.getBBox\n     [ method ]\n     **\n     * Returns the bounding box descriptor for the given element\n     **\n     = (object) bounding box descriptor:\n     o {\n     o     cx: (number) x of the center,\n     o     cy: (number) x of the center,\n     o     h: (number) height,\n     o     height: (number) height,\n     o     path: (string) path command for the box,\n     o     r0: (number) radius of a circle that fully encloses the box,\n     o     r1: (number) radius of the smallest circle that can be enclosed,\n     o     r2: (number) radius of the largest circle that can be enclosed,\n     o     vb: (string) box as a viewbox command,\n     o     w: (number) width,\n     o     width: (number) width,\n     o     x2: (number) x of the right side,\n     o     x: (number) x of the left side,\n     o     y2: (number) y of the bottom edge,\n     o     y: (number) y of the top edge\n     o }\n    \\*/\n    elproto.getBBox = function (isWithoutTransform) {\n        if (!Snap.Matrix || !Snap.path) {\n            return this.node.getBBox();\n        }\n        var el = this,\n            m = new Snap.Matrix;\n        if (el.removed) {\n            return Snap._.box();\n        }\n        while (el.type == \"use\") {\n            if (!isWithoutTransform) {\n                m = m.add(el.transform().localMatrix.translate(el.attr(\"x\") || 0, el.attr(\"y\") || 0));\n            }\n            if (el.original) {\n                el = el.original;\n            } else {\n                var href = el.attr(\"xlink:href\");\n                el = el.original = el.node.ownerDocument.getElementById(href.substring(href.indexOf(\"#\") + 1));\n            }\n        }\n        var _ = el._,\n            pathfinder = Snap.path.get[el.type] || Snap.path.get.deflt;\n        try {\n            if (isWithoutTransform) {\n                _.bboxwt = pathfinder ? Snap.path.getBBox(el.realPath = pathfinder(el)) : Snap._.box(el.node.getBBox());\n                return Snap._.box(_.bboxwt);\n            } else {\n                el.realPath = pathfinder(el);\n                el.matrix = el.transform().localMatrix;\n                _.bbox = Snap.path.getBBox(Snap.path.map(el.realPath, m.add(el.matrix)));\n                return Snap._.box(_.bbox);\n            }\n        } catch (e) {\n            // Firefox doesn’t give you bbox of hidden element\n            return Snap._.box();\n        }\n    };\n    var propString = function () {\n        return this.string;\n    };\n    function extractTransform(el, tstr) {\n        if (tstr == null) {\n            var doReturn = true;\n            if (el.type == \"linearGradient\" || el.type == \"radialGradient\") {\n                tstr = el.node.getAttribute(\"gradientTransform\");\n            } else if (el.type == \"pattern\") {\n                tstr = el.node.getAttribute(\"patternTransform\");\n            } else {\n                tstr = el.node.getAttribute(\"transform\");\n            }\n            if (!tstr) {\n                return new Snap.Matrix;\n            }\n            tstr = Snap._.svgTransform2string(tstr);\n        } else {\n            if (!Snap._.rgTransform.test(tstr)) {\n                tstr = Snap._.svgTransform2string(tstr);\n            } else {\n                tstr = Str(tstr).replace(/\\.{3}|\\u2026/g, el._.transform || E);\n            }\n            if (is(tstr, \"array\")) {\n                tstr = Snap.path ? Snap.path.toString.call(tstr) : Str(tstr);\n            }\n            el._.transform = tstr;\n        }\n        var m = Snap._.transform2matrix(tstr, el.getBBox(1));\n        if (doReturn) {\n            return m;\n        } else {\n            el.matrix = m;\n        }\n    }\n    /*\\\n     * Element.transform\n     [ method ]\n     **\n     * Gets or sets transformation of the element\n     **\n     - tstr (string) transform string in Snap or SVG format\n     = (Element) the current element\n     * or\n     = (object) transformation descriptor:\n     o {\n     o     string (string) transform string,\n     o     globalMatrix (Matrix) matrix of all transformations applied to element or its parents,\n     o     localMatrix (Matrix) matrix of transformations applied only to the element,\n     o     diffMatrix (Matrix) matrix of difference between global and local transformations,\n     o     global (string) global transformation as string,\n     o     local (string) local transformation as string,\n     o     toString (function) returns `string` property\n     o }\n    \\*/\n    elproto.transform = function (tstr) {\n        var _ = this._;\n        if (tstr == null) {\n            var papa = this,\n                global = new Snap.Matrix(this.node.getCTM()),\n                local = extractTransform(this),\n                ms = [local],\n                m = new Snap.Matrix,\n                i,\n                localString = local.toTransformString(),\n                string = Str(local) == Str(this.matrix) ?\n                            Str(_.transform) : localString;\n            while (papa.type != \"svg\" && (papa = papa.parent())) {\n                ms.push(extractTransform(papa));\n            }\n            i = ms.length;\n            while (i--) {\n                m.add(ms[i]);\n            }\n            return {\n                string: string,\n                globalMatrix: global,\n                totalMatrix: m,\n                localMatrix: local,\n                diffMatrix: global.clone().add(local.invert()),\n                global: global.toTransformString(),\n                total: m.toTransformString(),\n                local: localString,\n                toString: propString\n            };\n        }\n        if (tstr instanceof Snap.Matrix) {\n            this.matrix = tstr;\n            this._.transform = tstr.toTransformString();\n        } else {\n            extractTransform(this, tstr);\n        }\n\n        if (this.node) {\n            if (this.type == \"linearGradient\" || this.type == \"radialGradient\") {\n                $(this.node, {gradientTransform: this.matrix});\n            } else if (this.type == \"pattern\") {\n                $(this.node, {patternTransform: this.matrix});\n            } else {\n                $(this.node, {transform: this.matrix});\n            }\n        }\n\n        return this;\n    };\n    /*\\\n     * Element.parent\n     [ method ]\n     **\n     * Returns the element's parent\n     **\n     = (Element) the parent element\n    \\*/\n    elproto.parent = function () {\n        return wrap(this.node.parentNode);\n    };\n    /*\\\n     * Element.append\n     [ method ]\n     **\n     * Appends the given element to current one\n     **\n     - el (Element|Set) element to append\n     = (Element) the parent element\n    \\*/\n    /*\\\n     * Element.add\n     [ method ]\n     **\n     * See @Element.append\n    \\*/\n    elproto.append = elproto.add = function (el) {\n        if (el) {\n            if (el.type == \"set\") {\n                var it = this;\n                el.forEach(function (el) {\n                    it.add(el);\n                });\n                return this;\n            }\n            el = wrap(el);\n            this.node.appendChild(el.node);\n            el.paper = this.paper;\n        }\n        return this;\n    };\n    /*\\\n     * Element.appendTo\n     [ method ]\n     **\n     * Appends the current element to the given one\n     **\n     - el (Element) parent element to append to\n     = (Element) the child element\n    \\*/\n    elproto.appendTo = function (el) {\n        if (el) {\n            el = wrap(el);\n            el.append(this);\n        }\n        return this;\n    };\n    /*\\\n     * Element.prepend\n     [ method ]\n     **\n     * Prepends the given element to the current one\n     **\n     - el (Element) element to prepend\n     = (Element) the parent element\n    \\*/\n    elproto.prepend = function (el) {\n        if (el) {\n            if (el.type == \"set\") {\n                var it = this,\n                    first;\n                el.forEach(function (el) {\n                    if (first) {\n                        first.after(el);\n                    } else {\n                        it.prepend(el);\n                    }\n                    first = el;\n                });\n                return this;\n            }\n            el = wrap(el);\n            var parent = el.parent();\n            this.node.insertBefore(el.node, this.node.firstChild);\n            this.add && this.add();\n            el.paper = this.paper;\n            this.parent() && this.parent().add();\n            parent && parent.add();\n        }\n        return this;\n    };\n    /*\\\n     * Element.prependTo\n     [ method ]\n     **\n     * Prepends the current element to the given one\n     **\n     - el (Element) parent element to prepend to\n     = (Element) the child element\n    \\*/\n    elproto.prependTo = function (el) {\n        el = wrap(el);\n        el.prepend(this);\n        return this;\n    };\n    /*\\\n     * Element.before\n     [ method ]\n     **\n     * Inserts given element before the current one\n     **\n     - el (Element) element to insert\n     = (Element) the parent element\n    \\*/\n    elproto.before = function (el) {\n        if (el.type == \"set\") {\n            var it = this;\n            el.forEach(function (el) {\n                var parent = el.parent();\n                it.node.parentNode.insertBefore(el.node, it.node);\n                parent && parent.add();\n            });\n            this.parent().add();\n            return this;\n        }\n        el = wrap(el);\n        var parent = el.parent();\n        this.node.parentNode.insertBefore(el.node, this.node);\n        this.parent() && this.parent().add();\n        parent && parent.add();\n        el.paper = this.paper;\n        return this;\n    };\n    /*\\\n     * Element.after\n     [ method ]\n     **\n     * Inserts given element after the current one\n     **\n     - el (Element) element to insert\n     = (Element) the parent element\n    \\*/\n    elproto.after = function (el) {\n        el = wrap(el);\n        var parent = el.parent();\n        if (this.node.nextSibling) {\n            this.node.parentNode.insertBefore(el.node, this.node.nextSibling);\n        } else {\n            this.node.parentNode.appendChild(el.node);\n        }\n        this.parent() && this.parent().add();\n        parent && parent.add();\n        el.paper = this.paper;\n        return this;\n    };\n    /*\\\n     * Element.insertBefore\n     [ method ]\n     **\n     * Inserts the element after the given one\n     **\n     - el (Element) element next to whom insert to\n     = (Element) the parent element\n    \\*/\n    elproto.insertBefore = function (el) {\n        el = wrap(el);\n        var parent = this.parent();\n        el.node.parentNode.insertBefore(this.node, el.node);\n        this.paper = el.paper;\n        parent && parent.add();\n        el.parent() && el.parent().add();\n        return this;\n    };\n    /*\\\n     * Element.insertAfter\n     [ method ]\n     **\n     * Inserts the element after the given one\n     **\n     - el (Element) element next to whom insert to\n     = (Element) the parent element\n    \\*/\n    elproto.insertAfter = function (el) {\n        el = wrap(el);\n        var parent = this.parent();\n        el.node.parentNode.insertBefore(this.node, el.node.nextSibling);\n        this.paper = el.paper;\n        parent && parent.add();\n        el.parent() && el.parent().add();\n        return this;\n    };\n    /*\\\n     * Element.remove\n     [ method ]\n     **\n     * Removes element from the DOM\n     = (Element) the detached element\n    \\*/\n    elproto.remove = function () {\n        var parent = this.parent();\n        this.node.parentNode && this.node.parentNode.removeChild(this.node);\n        delete this.paper;\n        this.removed = true;\n        parent && parent.add();\n        return this;\n    };\n    /*\\\n     * Element.select\n     [ method ]\n     **\n     * Gathers the nested @Element matching the given set of CSS selectors\n     **\n     - query (string) CSS selector\n     = (Element) result of query selection\n    \\*/\n    elproto.select = function (query) {\n        query = Str(query).replace(/([^\\\\]):/g, \"$1\\\\:\");\n        return wrap(this.node.querySelector(query));\n    };\n    /*\\\n     * Element.selectAll\n     [ method ]\n     **\n     * Gathers nested @Element objects matching the given set of CSS selectors\n     **\n     - query (string) CSS selector\n     = (Set|array) result of query selection\n    \\*/\n    elproto.selectAll = function (query) {\n        var nodelist = this.node.querySelectorAll(query),\n            set = (Snap.set || Array)();\n        for (var i = 0; i < nodelist.length; i++) {\n            set.push(wrap(nodelist[i]));\n        }\n        return set;\n    };\n    /*\\\n     * Element.asPX\n     [ method ]\n     **\n     * Returns given attribute of the element as a `px` value (not %, em, etc.)\n     **\n     - attr (string) attribute name\n     - value (string) #optional attribute value\n     = (Element) result of query selection\n    \\*/\n    elproto.asPX = function (attr, value) {\n        if (value == null) {\n            value = this.attr(attr);\n        }\n        return +unit2px(this, attr, value);\n    };\n    // SIERRA Element.use(): I suggest adding a note about how to access the original element the returned <use> instantiates. It's a part of SVG with which ordinary web developers may be least familiar.\n    /*\\\n     * Element.use\n     [ method ]\n     **\n     * Creates a `<use>` element linked to the current element\n     **\n     = (Element) the `<use>` element\n    \\*/\n    elproto.use = function () {\n        var use,\n            id = this.node.id;\n        if (!id) {\n            id = this.id;\n            $(this.node, {\n                id: id\n            });\n        }\n        if (this.type == \"linearGradient\" || this.type == \"radialGradient\" ||\n            this.type == \"pattern\") {\n            use = make(this.type, this.node.parentNode);\n        } else {\n            use = make(\"use\", this.node.parentNode);\n        }\n        $(use.node, {\n            \"xlink:href\": \"#\" + id\n        });\n        use.original = this;\n        return use;\n    };\n    function fixids(el) {\n        var els = el.selectAll(\"*\"),\n            it,\n            url = /^\\s*url\\((\"|'|)(.*)\\1\\)\\s*$/,\n            ids = [],\n            uses = {};\n        function urltest(it, name) {\n            var val = $(it.node, name);\n            val = val && val.match(url);\n            val = val && val[2];\n            if (val && val.charAt() == \"#\") {\n                val = val.substring(1);\n            } else {\n                return;\n            }\n            if (val) {\n                uses[val] = (uses[val] || []).concat(function (id) {\n                    var attr = {};\n                    attr[name] = URL(id);\n                    $(it.node, attr);\n                });\n            }\n        }\n        function linktest(it) {\n            var val = $(it.node, \"xlink:href\");\n            if (val && val.charAt() == \"#\") {\n                val = val.substring(1);\n            } else {\n                return;\n            }\n            if (val) {\n                uses[val] = (uses[val] || []).concat(function (id) {\n                    it.attr(\"xlink:href\", \"#\" + id);\n                });\n            }\n        }\n        for (var i = 0, ii = els.length; i < ii; i++) {\n            it = els[i];\n            urltest(it, \"fill\");\n            urltest(it, \"stroke\");\n            urltest(it, \"filter\");\n            urltest(it, \"mask\");\n            urltest(it, \"clip-path\");\n            linktest(it);\n            var oldid = $(it.node, \"id\");\n            if (oldid) {\n                $(it.node, {id: it.id});\n                ids.push({\n                    old: oldid,\n                    id: it.id\n                });\n            }\n        }\n        for (i = 0, ii = ids.length; i < ii; i++) {\n            var fs = uses[ids[i].old];\n            if (fs) {\n                for (var j = 0, jj = fs.length; j < jj; j++) {\n                    fs[j](ids[i].id);\n                }\n            }\n        }\n    }\n    /*\\\n     * Element.clone\n     [ method ]\n     **\n     * Creates a clone of the element and inserts it after the element\n     **\n     = (Element) the clone\n    \\*/\n    elproto.clone = function () {\n        var clone = wrap(this.node.cloneNode(true));\n        if ($(clone.node, \"id\")) {\n            $(clone.node, {id: clone.id});\n        }\n        fixids(clone);\n        clone.insertAfter(this);\n        return clone;\n    };\n    /*\\\n     * Element.toDefs\n     [ method ]\n     **\n     * Moves element to the shared `<defs>` area\n     **\n     = (Element) the element\n    \\*/\n    elproto.toDefs = function () {\n        var defs = getSomeDefs(this);\n        defs.appendChild(this.node);\n        return this;\n    };\n    /*\\\n     * Element.toPattern\n     [ method ]\n     **\n     * Creates a `<pattern>` element from the current element\n     **\n     * To create a pattern you have to specify the pattern rect:\n     - x (string|number)\n     - y (string|number)\n     - width (string|number)\n     - height (string|number)\n     = (Element) the `<pattern>` element\n     * You can use pattern later on as an argument for `fill` attribute:\n     | var p = paper.path(\"M10-5-10,15M15,0,0,15M0-5-20,15\").attr({\n     |         fill: \"none\",\n     |         stroke: \"#bada55\",\n     |         strokeWidth: 5\n     |     }).pattern(0, 0, 10, 10),\n     |     c = paper.circle(200, 200, 100);\n     | c.attr({\n     |     fill: p\n     | });\n    \\*/\n    elproto.pattern = elproto.toPattern = function (x, y, width, height) {\n        var p = make(\"pattern\", getSomeDefs(this));\n        if (x == null) {\n            x = this.getBBox();\n        }\n        if (is(x, \"object\") && \"x\" in x) {\n            y = x.y;\n            width = x.width;\n            height = x.height;\n            x = x.x;\n        }\n        $(p.node, {\n            x: x,\n            y: y,\n            width: width,\n            height: height,\n            patternUnits: \"userSpaceOnUse\",\n            id: p.id,\n            viewBox: [x, y, width, height].join(\" \")\n        });\n        p.node.appendChild(this.node);\n        return p;\n    };\n// SIERRA Element.marker(): clarify what a reference point is. E.g., helps you offset the object from its edge such as when centering it over a path.\n// SIERRA Element.marker(): I suggest the method should accept default reference point values.  Perhaps centered with (refX = width/2) and (refY = height/2)? Also, couldn't it assume the element's current _width_ and _height_? And please specify what _x_ and _y_ mean: offsets? If so, from where?  Couldn't they also be assigned default values?\n    /*\\\n     * Element.marker\n     [ method ]\n     **\n     * Creates a `<marker>` element from the current element\n     **\n     * To create a marker you have to specify the bounding rect and reference point:\n     - x (number)\n     - y (number)\n     - width (number)\n     - height (number)\n     - refX (number)\n     - refY (number)\n     = (Element) the `<marker>` element\n     * You can specify the marker later as an argument for `marker-start`, `marker-end`, `marker-mid`, and `marker` attributes. The `marker` attribute places the marker at every point along the path, and `marker-mid` places them at every point except the start and end.\n    \\*/\n    // TODO add usage for markers\n    elproto.marker = function (x, y, width, height, refX, refY) {\n        var p = make(\"marker\", getSomeDefs(this));\n        if (x == null) {\n            x = this.getBBox();\n        }\n        if (is(x, \"object\") && \"x\" in x) {\n            y = x.y;\n            width = x.width;\n            height = x.height;\n            refX = x.refX || x.cx;\n            refY = x.refY || x.cy;\n            x = x.x;\n        }\n        $(p.node, {\n            viewBox: [x, y, width, height].join(\" \"),\n            markerWidth: width,\n            markerHeight: height,\n            orient: \"auto\",\n            refX: refX || 0,\n            refY: refY || 0,\n            id: p.id\n        });\n        p.node.appendChild(this.node);\n        return p;\n    };\n    // animation\n    function slice(from, to, f) {\n        return function (arr) {\n            var res = arr.slice(from, to);\n            if (res.length == 1) {\n                res = res[0];\n            }\n            return f ? f(res) : res;\n        };\n    }\n    var Animation = function (attr, ms, easing, callback) {\n        if (typeof easing == \"function\" && !easing.length) {\n            callback = easing;\n            easing = mina.linear;\n        }\n        this.attr = attr;\n        this.dur = ms;\n        easing && (this.easing = easing);\n        callback && (this.callback = callback);\n    };\n    Snap._.Animation = Animation;\n    /*\\\n     * Snap.animation\n     [ method ]\n     **\n     * Creates an animation object\n     **\n     - attr (object) attributes of final destination\n     - duration (number) duration of the animation, in milliseconds\n     - easing (function) #optional one of easing functions of @mina or custom one\n     - callback (function) #optional callback function that fires when animation ends\n     = (object) animation object\n    \\*/\n    Snap.animation = function (attr, ms, easing, callback) {\n        return new Animation(attr, ms, easing, callback);\n    };\n    /*\\\n     * Element.inAnim\n     [ method ]\n     **\n     * Returns a set of animations that may be able to manipulate the current element\n     **\n     = (object) in format:\n     o {\n     o     anim (object) animation object,\n     o     mina (object) @mina object,\n     o     curStatus (number) 0..1 — status of the animation: 0 — just started, 1 — just finished,\n     o     status (function) gets or sets the status of the animation,\n     o     stop (function) stops the animation\n     o }\n    \\*/\n    elproto.inAnim = function () {\n        var el = this,\n            res = [];\n        for (var id in el.anims) if (el.anims[has](id)) {\n            (function (a) {\n                res.push({\n                    anim: new Animation(a._attrs, a.dur, a.easing, a._callback),\n                    mina: a,\n                    curStatus: a.status(),\n                    status: function (val) {\n                        return a.status(val);\n                    },\n                    stop: function () {\n                        a.stop();\n                    }\n                });\n            }(el.anims[id]));\n        }\n        return res;\n    };\n    /*\\\n     * Snap.animate\n     [ method ]\n     **\n     * Runs generic animation of one number into another with a caring function\n     **\n     - from (number|array) number or array of numbers\n     - to (number|array) number or array of numbers\n     - setter (function) caring function that accepts one number argument\n     - duration (number) duration, in milliseconds\n     - easing (function) #optional easing function from @mina or custom\n     - callback (function) #optional callback function to execute when animation ends\n     = (object) animation object in @mina format\n     o {\n     o     id (string) animation id, consider it read-only,\n     o     duration (function) gets or sets the duration of the animation,\n     o     easing (function) easing,\n     o     speed (function) gets or sets the speed of the animation,\n     o     status (function) gets or sets the status of the animation,\n     o     stop (function) stops the animation\n     o }\n     | var rect = Snap().rect(0, 0, 10, 10);\n     | Snap.animate(0, 10, function (val) {\n     |     rect.attr({\n     |         x: val\n     |     });\n     | }, 1000);\n     | // in given context is equivalent to\n     | rect.animate({x: 10}, 1000);\n    \\*/\n    Snap.animate = function (from, to, setter, ms, easing, callback) {\n        if (typeof easing == \"function\" && !easing.length) {\n            callback = easing;\n            easing = mina.linear;\n        }\n        var now = mina.time(),\n            anim = mina(from, to, now, now + ms, mina.time, setter, easing);\n        callback && eve.once(\"mina.finish.\" + anim.id, callback);\n        return anim;\n    };\n    /*\\\n     * Element.stop\n     [ method ]\n     **\n     * Stops all the animations for the current element\n     **\n     = (Element) the current element\n    \\*/\n    elproto.stop = function () {\n        var anims = this.inAnim();\n        for (var i = 0, ii = anims.length; i < ii; i++) {\n            anims[i].stop();\n        }\n        return this;\n    };\n    /*\\\n     * Element.animate\n     [ method ]\n     **\n     * Animates the given attributes of the element\n     **\n     - attrs (object) key-value pairs of destination attributes\n     - duration (number) duration of the animation in milliseconds\n     - easing (function) #optional easing function from @mina or custom\n     - callback (function) #optional callback function that executes when the animation ends\n     = (Element) the current element\n    \\*/\n    elproto.animate = function (attrs, ms, easing, callback) {\n        if (typeof easing == \"function\" && !easing.length) {\n            callback = easing;\n            easing = mina.linear;\n        }\n        if (attrs instanceof Animation) {\n            callback = attrs.callback;\n            easing = attrs.easing;\n            ms = easing.dur;\n            attrs = attrs.attr;\n        }\n        var fkeys = [], tkeys = [], keys = {}, from, to, f, eq,\n            el = this;\n        for (var key in attrs) if (attrs[has](key)) {\n            if (el.equal) {\n                eq = el.equal(key, Str(attrs[key]));\n                from = eq.from;\n                to = eq.to;\n                f = eq.f;\n            } else {\n                from = +el.attr(key);\n                to = +attrs[key];\n            }\n            var len = is(from, \"array\") ? from.length : 1;\n            keys[key] = slice(fkeys.length, fkeys.length + len, f);\n            fkeys = fkeys.concat(from);\n            tkeys = tkeys.concat(to);\n        }\n        var now = mina.time(),\n            anim = mina(fkeys, tkeys, now, now + ms, mina.time, function (val) {\n                var attr = {};\n                for (var key in keys) if (keys[has](key)) {\n                    attr[key] = keys[key](val);\n                }\n                el.attr(attr);\n            }, easing);\n        el.anims[anim.id] = anim;\n        anim._attrs = attrs;\n        anim._callback = callback;\n        eve(\"snap.animcreated.\" + el.id, anim);\n        eve.once(\"mina.finish.\" + anim.id, function () {\n            delete el.anims[anim.id];\n            callback && callback.call(el);\n        });\n        eve.once(\"mina.stop.\" + anim.id, function () {\n            delete el.anims[anim.id];\n        });\n        return el;\n    };\n    var eldata = {};\n    /*\\\n     * Element.data\n     [ method ]\n     **\n     * Adds or retrieves given value associated with given key. (Don’t confuse\n     * with `data-` attributes)\n     *\n     * See also @Element.removeData\n     - key (string) key to store data\n     - value (any) #optional value to store\n     = (object) @Element\n     * or, if value is not specified:\n     = (any) value\n     > Usage\n     | for (var i = 0, i < 5, i++) {\n     |     paper.circle(10 + 15 * i, 10, 10)\n     |          .attr({fill: \"#000\"})\n     |          .data(\"i\", i)\n     |          .click(function () {\n     |             alert(this.data(\"i\"));\n     |          });\n     | }\n    \\*/\n    elproto.data = function (key, value) {\n        var data = eldata[this.id] = eldata[this.id] || {};\n        if (arguments.length == 0){\n            eve(\"snap.data.get.\" + this.id, this, data, null);\n            return data;\n        }\n        if (arguments.length == 1) {\n            if (Snap.is(key, \"object\")) {\n                for (var i in key) if (key[has](i)) {\n                    this.data(i, key[i]);\n                }\n                return this;\n            }\n            eve(\"snap.data.get.\" + this.id, this, data[key], key);\n            return data[key];\n        }\n        data[key] = value;\n        eve(\"snap.data.set.\" + this.id, this, value, key);\n        return this;\n    };\n    /*\\\n     * Element.removeData\n     [ method ]\n     **\n     * Removes value associated with an element by given key.\n     * If key is not provided, removes all the data of the element.\n     - key (string) #optional key\n     = (object) @Element\n    \\*/\n    elproto.removeData = function (key) {\n        if (key == null) {\n            eldata[this.id] = {};\n        } else {\n            eldata[this.id] && delete eldata[this.id][key];\n        }\n        return this;\n    };\n    /*\\\n     * Element.outerSVG\n     [ method ]\n     **\n     * Returns SVG code for the element, equivalent to HTML's `outerHTML`.\n     *\n     * See also @Element.innerSVG\n     = (string) SVG code for the element\n    \\*/\n    /*\\\n     * Element.toString\n     [ method ]\n     **\n     * See @Element.outerSVG\n    \\*/\n    elproto.outerSVG = elproto.toString = toString(1);\n    /*\\\n     * Element.innerSVG\n     [ method ]\n     **\n     * Returns SVG code for the element's contents, equivalent to HTML's `innerHTML`\n     = (string) SVG code for the element\n    \\*/\n    elproto.innerSVG = toString();\n    function toString(type) {\n        return function () {\n            var res = type ? \"<\" + this.type : \"\",\n                attr = this.node.attributes,\n                chld = this.node.childNodes;\n            if (type) {\n                for (var i = 0, ii = attr.length; i < ii; i++) {\n                    res += \" \" + attr[i].name + '=\"' +\n                            attr[i].value.replace(/\"/g, '\\\\\"') + '\"';\n                }\n            }\n            if (chld.length) {\n                type && (res += \">\");\n                for (i = 0, ii = chld.length; i < ii; i++) {\n                    if (chld[i].nodeType == 3) {\n                        res += chld[i].nodeValue;\n                    } else if (chld[i].nodeType == 1) {\n                        res += wrap(chld[i]).toString();\n                    }\n                }\n                type && (res += \"</\" + this.type + \">\");\n            } else {\n                type && (res += \"/>\");\n            }\n            return res;\n        };\n    }\n    elproto.toDataURL = function () {\n        if (window && window.btoa) {\n            var bb = this.getBBox(),\n                svg = Snap.format('<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"{width}\" height=\"{height}\" viewBox=\"{x} {y} {width} {height}\">{contents}</svg>', {\n                x: +bb.x.toFixed(3),\n                y: +bb.y.toFixed(3),\n                width: +bb.width.toFixed(3),\n                height: +bb.height.toFixed(3),\n                contents: this.outerSVG()\n            });\n            return \"data:image/svg+xml;base64,\" + btoa(unescape(encodeURIComponent(svg)));\n        }\n    };\n    /*\\\n     * Fragment.select\n     [ method ]\n     **\n     * See @Element.select\n    \\*/\n    Fragment.prototype.select = elproto.select;\n    /*\\\n     * Fragment.selectAll\n     [ method ]\n     **\n     * See @Element.selectAll\n    \\*/\n    Fragment.prototype.selectAll = elproto.selectAll;\n});\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n// http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n    var objectToString = Object.prototype.toString,\n        Str = String,\n        math = Math,\n        E = \"\";\n    function Matrix(a, b, c, d, e, f) {\n        if (b == null && objectToString.call(a) == \"[object SVGMatrix]\") {\n            this.a = a.a;\n            this.b = a.b;\n            this.c = a.c;\n            this.d = a.d;\n            this.e = a.e;\n            this.f = a.f;\n            return;\n        }\n        if (a != null) {\n            this.a = +a;\n            this.b = +b;\n            this.c = +c;\n            this.d = +d;\n            this.e = +e;\n            this.f = +f;\n        } else {\n            this.a = 1;\n            this.b = 0;\n            this.c = 0;\n            this.d = 1;\n            this.e = 0;\n            this.f = 0;\n        }\n    }\n    (function (matrixproto) {\n        /*\\\n         * Matrix.add\n         [ method ]\n         **\n         * Adds the given matrix to existing one\n         - a (number)\n         - b (number)\n         - c (number)\n         - d (number)\n         - e (number)\n         - f (number)\n         * or\n         - matrix (object) @Matrix\n        \\*/\n        matrixproto.add = function (a, b, c, d, e, f) {\n            var out = [[], [], []],\n                m = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]],\n                matrix = [[a, c, e], [b, d, f], [0, 0, 1]],\n                x, y, z, res;\n\n            if (a && a instanceof Matrix) {\n                matrix = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]];\n            }\n\n            for (x = 0; x < 3; x++) {\n                for (y = 0; y < 3; y++) {\n                    res = 0;\n                    for (z = 0; z < 3; z++) {\n                        res += m[x][z] * matrix[z][y];\n                    }\n                    out[x][y] = res;\n                }\n            }\n            this.a = out[0][0];\n            this.b = out[1][0];\n            this.c = out[0][1];\n            this.d = out[1][1];\n            this.e = out[0][2];\n            this.f = out[1][2];\n            return this;\n        };\n        /*\\\n         * Matrix.invert\n         [ method ]\n         **\n         * Returns an inverted version of the matrix\n         = (object) @Matrix\n        \\*/\n        matrixproto.invert = function () {\n            var me = this,\n                x = me.a * me.d - me.b * me.c;\n            return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);\n        };\n        /*\\\n         * Matrix.clone\n         [ method ]\n         **\n         * Returns a copy of the matrix\n         = (object) @Matrix\n        \\*/\n        matrixproto.clone = function () {\n            return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);\n        };\n        /*\\\n         * Matrix.translate\n         [ method ]\n         **\n         * Translate the matrix\n         - x (number) horizontal offset distance\n         - y (number) vertical offset distance\n        \\*/\n        matrixproto.translate = function (x, y) {\n            return this.add(1, 0, 0, 1, x, y);\n        };\n        /*\\\n         * Matrix.scale\n         [ method ]\n         **\n         * Scales the matrix\n         - x (number) amount to be scaled, with `1` resulting in no change\n         - y (number) #optional amount to scale along the vertical axis. (Otherwise `x` applies to both axes.)\n         - cx (number) #optional horizontal origin point from which to scale\n         - cy (number) #optional vertical origin point from which to scale\n         * Default cx, cy is the middle point of the element.\n        \\*/\n        matrixproto.scale = function (x, y, cx, cy) {\n            y == null && (y = x);\n            (cx || cy) && this.add(1, 0, 0, 1, cx, cy);\n            this.add(x, 0, 0, y, 0, 0);\n            (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);\n            return this;\n        };\n        /*\\\n         * Matrix.rotate\n         [ method ]\n         **\n         * Rotates the matrix\n         - a (number) angle of rotation, in degrees\n         - x (number) horizontal origin point from which to rotate\n         - y (number) vertical origin point from which to rotate\n        \\*/\n        matrixproto.rotate = function (a, x, y) {\n            a = Snap.rad(a);\n            x = x || 0;\n            y = y || 0;\n            var cos = +math.cos(a).toFixed(9),\n                sin = +math.sin(a).toFixed(9);\n            this.add(cos, sin, -sin, cos, x, y);\n            return this.add(1, 0, 0, 1, -x, -y);\n        };\n        /*\\\n         * Matrix.x\n         [ method ]\n         **\n         * Returns x coordinate for given point after transformation described by the matrix. See also @Matrix.y\n         - x (number)\n         - y (number)\n         = (number) x\n        \\*/\n        matrixproto.x = function (x, y) {\n            return x * this.a + y * this.c + this.e;\n        };\n        /*\\\n         * Matrix.y\n         [ method ]\n         **\n         * Returns y coordinate for given point after transformation described by the matrix. See also @Matrix.x\n         - x (number)\n         - y (number)\n         = (number) y\n        \\*/\n        matrixproto.y = function (x, y) {\n            return x * this.b + y * this.d + this.f;\n        };\n        matrixproto.get = function (i) {\n            return +this[Str.fromCharCode(97 + i)].toFixed(4);\n        };\n        matrixproto.toString = function () {\n            return \"matrix(\" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + \")\";\n        };\n        matrixproto.offset = function () {\n            return [this.e.toFixed(4), this.f.toFixed(4)];\n        };\n        function norm(a) {\n            return a[0] * a[0] + a[1] * a[1];\n        }\n        function normalize(a) {\n            var mag = math.sqrt(norm(a));\n            a[0] && (a[0] /= mag);\n            a[1] && (a[1] /= mag);\n        }\n        /*\\\n         * Matrix.determinant\n         [ method ]\n         **\n         * Finds determinant of the given matrix.\n         = (number) determinant\n        \\*/\n        matrixproto.determinant = function () {\n            return this.a * this.d - this.b * this.c;\n        };\n        /*\\\n         * Matrix.split\n         [ method ]\n         **\n         * Splits matrix into primitive transformations\n         = (object) in format:\n         o dx (number) translation by x\n         o dy (number) translation by y\n         o scalex (number) scale by x\n         o scaley (number) scale by y\n         o shear (number) shear\n         o rotate (number) rotation in deg\n         o isSimple (boolean) could it be represented via simple transformations\n        \\*/\n        matrixproto.split = function () {\n            var out = {};\n            // translation\n            out.dx = this.e;\n            out.dy = this.f;\n\n            // scale and shear\n            var row = [[this.a, this.c], [this.b, this.d]];\n            out.scalex = math.sqrt(norm(row[0]));\n            normalize(row[0]);\n\n            out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];\n            row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];\n\n            out.scaley = math.sqrt(norm(row[1]));\n            normalize(row[1]);\n            out.shear /= out.scaley;\n\n            if (this.determinant() < 0) {\n                out.scalex = -out.scalex;\n            }\n\n            // rotation\n            var sin = -row[0][1],\n                cos = row[1][1];\n            if (cos < 0) {\n                out.rotate = Snap.deg(math.acos(cos));\n                if (sin < 0) {\n                    out.rotate = 360 - out.rotate;\n                }\n            } else {\n                out.rotate = Snap.deg(math.asin(sin));\n            }\n\n            out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);\n            out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;\n            out.noRotation = !+out.shear.toFixed(9) && !out.rotate;\n            return out;\n        };\n        /*\\\n         * Matrix.toTransformString\n         [ method ]\n         **\n         * Returns transform string that represents given matrix\n         = (string) transform string\n        \\*/\n        matrixproto.toTransformString = function (shorter) {\n            var s = shorter || this.split();\n            if (!+s.shear.toFixed(9)) {\n                s.scalex = +s.scalex.toFixed(4);\n                s.scaley = +s.scaley.toFixed(4);\n                s.rotate = +s.rotate.toFixed(4);\n                return  (s.dx || s.dy ? \"t\" + [+s.dx.toFixed(4), +s.dy.toFixed(4)] : E) + \n                        (s.scalex != 1 || s.scaley != 1 ? \"s\" + [s.scalex, s.scaley, 0, 0] : E) +\n                        (s.rotate ? \"r\" + [+s.rotate.toFixed(4), 0, 0] : E);\n            } else {\n                return \"m\" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];\n            }\n        };\n    })(Matrix.prototype);\n    /*\\\n     * Snap.Matrix\n     [ method ]\n     **\n     * Matrix constructor, extend on your own risk.\n     * To create matrices use @Snap.matrix.\n    \\*/\n    Snap.Matrix = Matrix;\n    /*\\\n     * Snap.matrix\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns a matrix based on the given parameters\n     - a (number)\n     - b (number)\n     - c (number)\n     - d (number)\n     - e (number)\n     - f (number)\n     * or\n     - svgMatrix (SVGMatrix)\n     = (object) @Matrix\n    \\*/\n    Snap.matrix = function (a, b, c, d, e, f) {\n        return new Matrix(a, b, c, d, e, f);\n    };\n});\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n// http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n    var has = \"hasOwnProperty\",\n        make = Snap._.make,\n        wrap = Snap._.wrap,\n        is = Snap.is,\n        getSomeDefs = Snap._.getSomeDefs,\n        reURLValue = /^url\\(#?([^)]+)\\)$/,\n        $ = Snap._.$,\n        URL = Snap.url,\n        Str = String,\n        separator = Snap._.separator,\n        E = \"\";\n    // Attributes event handlers\n    eve.on(\"snap.util.attr.mask\", function (value) {\n        if (value instanceof Element || value instanceof Fragment) {\n            eve.stop();\n            if (value instanceof Fragment && value.node.childNodes.length == 1) {\n                value = value.node.firstChild;\n                getSomeDefs(this).appendChild(value);\n                value = wrap(value);\n            }\n            if (value.type == \"mask\") {\n                var mask = value;\n            } else {\n                mask = make(\"mask\", getSomeDefs(this));\n                mask.node.appendChild(value.node);\n            }\n            !mask.node.id && $(mask.node, {\n                id: mask.id\n            });\n            $(this.node, {\n                mask: URL(mask.id)\n            });\n        }\n    });\n    (function (clipIt) {\n        eve.on(\"snap.util.attr.clip\", clipIt);\n        eve.on(\"snap.util.attr.clip-path\", clipIt);\n        eve.on(\"snap.util.attr.clipPath\", clipIt);\n    }(function (value) {\n        if (value instanceof Element || value instanceof Fragment) {\n            eve.stop();\n            if (value.type == \"clipPath\") {\n                var clip = value;\n            } else {\n                clip = make(\"clipPath\", getSomeDefs(this));\n                clip.node.appendChild(value.node);\n                !clip.node.id && $(clip.node, {\n                    id: clip.id\n                });\n            }\n            $(this.node, {\n                \"clip-path\": URL(clip.node.id || clip.id)\n            });\n        }\n    }));\n    function fillStroke(name) {\n        return function (value) {\n            eve.stop();\n            if (value instanceof Fragment && value.node.childNodes.length == 1 &&\n                (value.node.firstChild.tagName == \"radialGradient\" ||\n                value.node.firstChild.tagName == \"linearGradient\" ||\n                value.node.firstChild.tagName == \"pattern\")) {\n                value = value.node.firstChild;\n                getSomeDefs(this).appendChild(value);\n                value = wrap(value);\n            }\n            if (value instanceof Element) {\n                if (value.type == \"radialGradient\" || value.type == \"linearGradient\"\n                   || value.type == \"pattern\") {\n                    if (!value.node.id) {\n                        $(value.node, {\n                            id: value.id\n                        });\n                    }\n                    var fill = URL(value.node.id);\n                } else {\n                    fill = value.attr(name);\n                }\n            } else {\n                fill = Snap.color(value);\n                if (fill.error) {\n                    var grad = Snap(getSomeDefs(this).ownerSVGElement).gradient(value);\n                    if (grad) {\n                        if (!grad.node.id) {\n                            $(grad.node, {\n                                id: grad.id\n                            });\n                        }\n                        fill = URL(grad.node.id);\n                    } else {\n                        fill = value;\n                    }\n                } else {\n                    fill = Str(fill);\n                }\n            }\n            var attrs = {};\n            attrs[name] = fill;\n            $(this.node, attrs);\n            this.node.style[name] = E;\n        };\n    }\n    eve.on(\"snap.util.attr.fill\", fillStroke(\"fill\"));\n    eve.on(\"snap.util.attr.stroke\", fillStroke(\"stroke\"));\n    var gradrg = /^([lr])(?:\\(([^)]*)\\))?(.*)$/i;\n    eve.on(\"snap.util.grad.parse\", function parseGrad(string) {\n        string = Str(string);\n        var tokens = string.match(gradrg);\n        if (!tokens) {\n            return null;\n        }\n        var type = tokens[1],\n            params = tokens[2],\n            stops = tokens[3];\n        params = params.split(/\\s*,\\s*/).map(function (el) {\n            return +el == el ? +el : el;\n        });\n        if (params.length == 1 && params[0] == 0) {\n            params = [];\n        }\n        stops = stops.split(\"-\");\n        stops = stops.map(function (el) {\n            el = el.split(\":\");\n            var out = {\n                color: el[0]\n            };\n            if (el[1]) {\n                out.offset = parseFloat(el[1]);\n            }\n            return out;\n        });\n        return {\n            type: type,\n            params: params,\n            stops: stops\n        };\n    });\n\n    eve.on(\"snap.util.attr.d\", function (value) {\n        eve.stop();\n        if (is(value, \"array\") && is(value[0], \"array\")) {\n            value = Snap.path.toString.call(value);\n        }\n        value = Str(value);\n        if (value.match(/[ruo]/i)) {\n            value = Snap.path.toAbsolute(value);\n        }\n        $(this.node, {d: value});\n    })(-1);\n    eve.on(\"snap.util.attr.#text\", function (value) {\n        eve.stop();\n        value = Str(value);\n        var txt = glob.doc.createTextNode(value);\n        while (this.node.firstChild) {\n            this.node.removeChild(this.node.firstChild);\n        }\n        this.node.appendChild(txt);\n    })(-1);\n    eve.on(\"snap.util.attr.path\", function (value) {\n        eve.stop();\n        this.attr({d: value});\n    })(-1);\n    eve.on(\"snap.util.attr.class\", function (value) {\n        eve.stop();\n        this.node.className.baseVal = value;\n    })(-1);\n    eve.on(\"snap.util.attr.viewBox\", function (value) {\n        var vb;\n        if (is(value, \"object\") && \"x\" in value) {\n            vb = [value.x, value.y, value.width, value.height].join(\" \");\n        } else if (is(value, \"array\")) {\n            vb = value.join(\" \");\n        } else {\n            vb = value;\n        }\n        $(this.node, {\n            viewBox: vb\n        });\n        eve.stop();\n    })(-1);\n    eve.on(\"snap.util.attr.transform\", function (value) {\n        this.transform(value);\n        eve.stop();\n    })(-1);\n    eve.on(\"snap.util.attr.r\", function (value) {\n        if (this.type == \"rect\") {\n            eve.stop();\n            $(this.node, {\n                rx: value,\n                ry: value\n            });\n        }\n    })(-1);\n    eve.on(\"snap.util.attr.textpath\", function (value) {\n        eve.stop();\n        if (this.type == \"text\") {\n            var id, tp, node;\n            if (!value && this.textPath) {\n                tp = this.textPath;\n                while (tp.node.firstChild) {\n                    this.node.appendChild(tp.node.firstChild);\n                }\n                tp.remove();\n                delete this.textPath;\n                return;\n            }\n            if (is(value, \"string\")) {\n                var defs = getSomeDefs(this),\n                    path = wrap(defs.parentNode).path(value);\n                defs.appendChild(path.node);\n                id = path.id;\n                path.attr({id: id});\n            } else {\n                value = wrap(value);\n                if (value instanceof Element) {\n                    id = value.attr(\"id\");\n                    if (!id) {\n                        id = value.id;\n                        value.attr({id: id});\n                    }\n                }\n            }\n            if (id) {\n                tp = this.textPath;\n                node = this.node;\n                if (tp) {\n                    tp.attr({\"xlink:href\": \"#\" + id});\n                } else {\n                    tp = $(\"textPath\", {\n                        \"xlink:href\": \"#\" + id\n                    });\n                    while (node.firstChild) {\n                        tp.appendChild(node.firstChild);\n                    }\n                    node.appendChild(tp);\n                    this.textPath = wrap(tp);\n                }\n            }\n        }\n    })(-1);\n    eve.on(\"snap.util.attr.text\", function (value) {\n        if (this.type == \"text\") {\n            var i = 0,\n                node = this.node,\n                tuner = function (chunk) {\n                    var out = $(\"tspan\");\n                    if (is(chunk, \"array\")) {\n                        for (var i = 0; i < chunk.length; i++) {\n                            out.appendChild(tuner(chunk[i]));\n                        }\n                    } else {\n                        out.appendChild(glob.doc.createTextNode(chunk));\n                    }\n                    out.normalize && out.normalize();\n                    return out;\n                };\n            while (node.firstChild) {\n                node.removeChild(node.firstChild);\n            }\n            var tuned = tuner(value);\n            while (tuned.firstChild) {\n                node.appendChild(tuned.firstChild);\n            }\n        }\n        eve.stop();\n    })(-1);\n    function setFontSize(value) {\n        eve.stop();\n        if (value == +value) {\n            value += \"px\";\n        }\n        this.node.style.fontSize = value;\n    }\n    eve.on(\"snap.util.attr.fontSize\", setFontSize)(-1);\n    eve.on(\"snap.util.attr.font-size\", setFontSize)(-1);\n\n\n    eve.on(\"snap.util.getattr.transform\", function () {\n        eve.stop();\n        return this.transform();\n    })(-1);\n    eve.on(\"snap.util.getattr.textpath\", function () {\n        eve.stop();\n        return this.textPath;\n    })(-1);\n    // Markers\n    (function () {\n        function getter(end) {\n            return function () {\n                eve.stop();\n                var style = glob.doc.defaultView.getComputedStyle(this.node, null).getPropertyValue(\"marker-\" + end);\n                if (style == \"none\") {\n                    return style;\n                } else {\n                    return Snap(glob.doc.getElementById(style.match(reURLValue)[1]));\n                }\n            };\n        }\n        function setter(end) {\n            return function (value) {\n                eve.stop();\n                var name = \"marker\" + end.charAt(0).toUpperCase() + end.substring(1);\n                if (value == \"\" || !value) {\n                    this.node.style[name] = \"none\";\n                    return;\n                }\n                if (value.type == \"marker\") {\n                    var id = value.node.id;\n                    if (!id) {\n                        $(value.node, {id: value.id});\n                    }\n                    this.node.style[name] = URL(id);\n                    return;\n                }\n            };\n        }\n        eve.on(\"snap.util.getattr.marker-end\", getter(\"end\"))(-1);\n        eve.on(\"snap.util.getattr.markerEnd\", getter(\"end\"))(-1);\n        eve.on(\"snap.util.getattr.marker-start\", getter(\"start\"))(-1);\n        eve.on(\"snap.util.getattr.markerStart\", getter(\"start\"))(-1);\n        eve.on(\"snap.util.getattr.marker-mid\", getter(\"mid\"))(-1);\n        eve.on(\"snap.util.getattr.markerMid\", getter(\"mid\"))(-1);\n        eve.on(\"snap.util.attr.marker-end\", setter(\"end\"))(-1);\n        eve.on(\"snap.util.attr.markerEnd\", setter(\"end\"))(-1);\n        eve.on(\"snap.util.attr.marker-start\", setter(\"start\"))(-1);\n        eve.on(\"snap.util.attr.markerStart\", setter(\"start\"))(-1);\n        eve.on(\"snap.util.attr.marker-mid\", setter(\"mid\"))(-1);\n        eve.on(\"snap.util.attr.markerMid\", setter(\"mid\"))(-1);\n    }());\n    eve.on(\"snap.util.getattr.r\", function () {\n        if (this.type == \"rect\" && $(this.node, \"rx\") == $(this.node, \"ry\")) {\n            eve.stop();\n            return $(this.node, \"rx\");\n        }\n    })(-1);\n    function textExtract(node) {\n        var out = [];\n        var children = node.childNodes;\n        for (var i = 0, ii = children.length; i < ii; i++) {\n            var chi = children[i];\n            if (chi.nodeType == 3) {\n                out.push(chi.nodeValue);\n            }\n            if (chi.tagName == \"tspan\") {\n                if (chi.childNodes.length == 1 && chi.firstChild.nodeType == 3) {\n                    out.push(chi.firstChild.nodeValue);\n                } else {\n                    out.push(textExtract(chi));\n                }\n            }\n        }\n        return out;\n    }\n    eve.on(\"snap.util.getattr.text\", function () {\n        if (this.type == \"text\" || this.type == \"tspan\") {\n            eve.stop();\n            var out = textExtract(this.node);\n            return out.length == 1 ? out[0] : out;\n        }\n    })(-1);\n    eve.on(\"snap.util.getattr.#text\", function () {\n        return this.node.textContent;\n    })(-1);\n    eve.on(\"snap.util.getattr.viewBox\", function () {\n        eve.stop();\n        var vb = $(this.node, \"viewBox\");\n        if (vb) {\n            vb = vb.split(separator);\n            return Snap._.box(+vb[0], +vb[1], +vb[2], +vb[3]);\n        } else {\n            return;\n        }\n    })(-1);\n    eve.on(\"snap.util.getattr.points\", function () {\n        var p = $(this.node, \"points\");\n        eve.stop();\n        if (p) {\n            return p.split(separator);\n        } else {\n            return;\n        }\n    })(-1);\n    eve.on(\"snap.util.getattr.path\", function () {\n        var p = $(this.node, \"d\");\n        eve.stop();\n        return p;\n    })(-1);\n    eve.on(\"snap.util.getattr.class\", function () {\n        return this.node.className.baseVal;\n    })(-1);\n    function getFontSize() {\n        eve.stop();\n        return this.node.style.fontSize;\n    }\n    eve.on(\"snap.util.getattr.fontSize\", getFontSize)(-1);\n    eve.on(\"snap.util.getattr.font-size\", getFontSize)(-1);\n});\n\n// Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n    var rgNotSpace = /\\S+/g,\n        rgBadSpace = /[\\t\\r\\n\\f]/g,\n        rgTrim = /(^\\s+|\\s+$)/g,\n        Str = String,\n        elproto = Element.prototype;\n    /*\\\n     * Element.addClass\n     [ method ]\n     **\n     * Adds given class name or list of class names to the element.\n     - value (string) class name or space separated list of class names\n     **\n     = (Element) original element.\n    \\*/\n    elproto.addClass = function (value) {\n        var classes = Str(value || \"\").match(rgNotSpace) || [],\n            elem = this.node,\n            className = elem.className.baseVal,\n            curClasses = className.match(rgNotSpace) || [],\n            j,\n            pos,\n            clazz,\n            finalValue;\n\n        if (classes.length) {\n            j = 0;\n            while ((clazz = classes[j++])) {\n                pos = curClasses.indexOf(clazz);\n                if (!~pos) {\n                    curClasses.push(clazz);\n                }\n            }\n\n            finalValue = curClasses.join(\" \");\n            if (className != finalValue) {\n                elem.className.baseVal = finalValue;\n            }\n        }\n        return this;\n    };\n    /*\\\n     * Element.removeClass\n     [ method ]\n     **\n     * Removes given class name or list of class names from the element.\n     - value (string) class name or space separated list of class names\n     **\n     = (Element) original element.\n    \\*/\n    elproto.removeClass = function (value) {\n        var classes = Str(value || \"\").match(rgNotSpace) || [],\n            elem = this.node,\n            className = elem.className.baseVal,\n            curClasses = className.match(rgNotSpace) || [],\n            j,\n            pos,\n            clazz,\n            finalValue;\n        if (curClasses.length) {\n            j = 0;\n            while ((clazz = classes[j++])) {\n                pos = curClasses.indexOf(clazz);\n                if (~pos) {\n                    curClasses.splice(pos, 1);\n                }\n            }\n\n            finalValue = curClasses.join(\" \");\n            if (className != finalValue) {\n                elem.className.baseVal = finalValue;\n            }\n        }\n        return this;\n    };\n    /*\\\n     * Element.hasClass\n     [ method ]\n     **\n     * Checks if the element has a given class name in the list of class names applied to it.\n     - value (string) class name\n     **\n     = (boolean) `true` if the element has given class\n    \\*/\n    elproto.hasClass = function (value) {\n        var elem = this.node,\n            className = elem.className.baseVal,\n            curClasses = className.match(rgNotSpace) || [];\n        return !!~curClasses.indexOf(value);\n    };\n    /*\\\n     * Element.toggleClass\n     [ method ]\n     **\n     * Add or remove one or more classes from the element, depending on either\n     * the class’s presence or the value of the `flag` argument.\n     - value (string) class name or space separated list of class names\n     - flag (boolean) value to determine whether the class should be added or removed\n     **\n     = (Element) original element.\n    \\*/\n    elproto.toggleClass = function (value, flag) {\n        if (flag != null) {\n            if (flag) {\n                return this.addClass(value);\n            } else {\n                return this.removeClass(value);\n            }\n        }\n        var classes = (value || \"\").match(rgNotSpace) || [],\n            elem = this.node,\n            className = elem.className.baseVal,\n            curClasses = className.match(rgNotSpace) || [],\n            j,\n            pos,\n            clazz,\n            finalValue;\n        j = 0;\n        while ((clazz = classes[j++])) {\n            pos = curClasses.indexOf(clazz);\n            if (~pos) {\n                curClasses.splice(pos, 1);\n            } else {\n                curClasses.push(clazz);\n            }\n        }\n\n        finalValue = curClasses.join(\" \");\n        if (className != finalValue) {\n            elem.className.baseVal = finalValue;\n        }\n        return this;\n    };\n});\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n// http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n    var operators = {\n            \"+\": function (x, y) {\n                    return x + y;\n                },\n            \"-\": function (x, y) {\n                    return x - y;\n                },\n            \"/\": function (x, y) {\n                    return x / y;\n                },\n            \"*\": function (x, y) {\n                    return x * y;\n                }\n        },\n        Str = String,\n        reUnit = /[a-z]+$/i,\n        reAddon = /^\\s*([+\\-\\/*])\\s*=\\s*([\\d.eE+\\-]+)\\s*([^\\d\\s]+)?\\s*$/;\n    function getNumber(val) {\n        return val;\n    }\n    function getUnit(unit) {\n        return function (val) {\n            return +val.toFixed(3) + unit;\n        };\n    }\n    eve.on(\"snap.util.attr\", function (val) {\n        var plus = Str(val).match(reAddon);\n        if (plus) {\n            var evnt = eve.nt(),\n                name = evnt.substring(evnt.lastIndexOf(\".\") + 1),\n                a = this.attr(name),\n                atr = {};\n            eve.stop();\n            var unit = plus[3] || \"\",\n                aUnit = a.match(reUnit),\n                op = operators[plus[1]];\n            if (aUnit && aUnit == unit) {\n                val = op(parseFloat(a), +plus[2]);\n            } else {\n                a = this.asPX(name);\n                val = op(this.asPX(name), this.asPX(name, plus[2] + unit));\n            }\n            if (isNaN(a) || isNaN(val)) {\n                return;\n            }\n            atr[name] = val;\n            this.attr(atr);\n        }\n    })(-10);\n    eve.on(\"snap.util.equal\", function (name, b) {\n        var A, B, a = Str(this.attr(name) || \"\"),\n            el = this,\n            bplus = Str(b).match(reAddon);\n        if (bplus) {\n            eve.stop();\n            var unit = bplus[3] || \"\",\n                aUnit = a.match(reUnit),\n                op = operators[bplus[1]];\n            if (aUnit && aUnit == unit) {\n                return {\n                    from: parseFloat(a),\n                    to: op(parseFloat(a), +bplus[2]),\n                    f: getUnit(aUnit)\n                };\n            } else {\n                a = this.asPX(name);\n                return {\n                    from: a,\n                    to: op(a, this.asPX(name, bplus[2] + unit)),\n                    f: getNumber\n                };\n            }\n        }\n    })(-10);\n});\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n// http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n    var proto = Paper.prototype,\n        is = Snap.is;\n    /*\\\n     * Paper.rect\n     [ method ]\n     *\n     * Draws a rectangle\n     **\n     - x (number) x coordinate of the top left corner\n     - y (number) y coordinate of the top left corner\n     - width (number) width\n     - height (number) height\n     - rx (number) #optional horizontal radius for rounded corners, default is 0\n     - ry (number) #optional vertical radius for rounded corners, default is rx or 0\n     = (object) the `rect` element\n     **\n     > Usage\n     | // regular rectangle\n     | var c = paper.rect(10, 10, 50, 50);\n     | // rectangle with rounded corners\n     | var c = paper.rect(40, 40, 50, 50, 10);\n    \\*/\n    proto.rect = function (x, y, w, h, rx, ry) {\n        var attr;\n        if (ry == null) {\n            ry = rx;\n        }\n        if (is(x, \"object\") && x == \"[object Object]\") {\n            attr = x;\n        } else if (x != null) {\n            attr = {\n                x: x,\n                y: y,\n                width: w,\n                height: h\n            };\n            if (rx != null) {\n                attr.rx = rx;\n                attr.ry = ry;\n            }\n        }\n        return this.el(\"rect\", attr);\n    };\n    /*\\\n     * Paper.circle\n     [ method ]\n     **\n     * Draws a circle\n     **\n     - x (number) x coordinate of the centre\n     - y (number) y coordinate of the centre\n     - r (number) radius\n     = (object) the `circle` element\n     **\n     > Usage\n     | var c = paper.circle(50, 50, 40);\n    \\*/\n    proto.circle = function (cx, cy, r) {\n        var attr;\n        if (is(cx, \"object\") && cx == \"[object Object]\") {\n            attr = cx;\n        } else if (cx != null) {\n            attr = {\n                cx: cx,\n                cy: cy,\n                r: r\n            };\n        }\n        return this.el(\"circle\", attr);\n    };\n\n    var preload = (function () {\n        function onerror() {\n            this.parentNode.removeChild(this);\n        }\n        return function (src, f) {\n            var img = glob.doc.createElement(\"img\"),\n                body = glob.doc.body;\n            img.style.cssText = \"position:absolute;left:-9999em;top:-9999em\";\n            img.onload = function () {\n                f.call(img);\n                img.onload = img.onerror = null;\n                body.removeChild(img);\n            };\n            img.onerror = onerror;\n            body.appendChild(img);\n            img.src = src;\n        };\n    }());\n\n    /*\\\n     * Paper.image\n     [ method ]\n     **\n     * Places an image on the surface\n     **\n     - src (string) URI of the source image\n     - x (number) x offset position\n     - y (number) y offset position\n     - width (number) width of the image\n     - height (number) height of the image\n     = (object) the `image` element\n     * or\n     = (object) Snap element object with type `image`\n     **\n     > Usage\n     | var c = paper.image(\"apple.png\", 10, 10, 80, 80);\n    \\*/\n    proto.image = function (src, x, y, width, height) {\n        var el = this.el(\"image\");\n        if (is(src, \"object\") && \"src\" in src) {\n            el.attr(src);\n        } else if (src != null) {\n            var set = {\n                \"xlink:href\": src,\n                preserveAspectRatio: \"none\"\n            };\n            if (x != null && y != null) {\n                set.x = x;\n                set.y = y;\n            }\n            if (width != null && height != null) {\n                set.width = width;\n                set.height = height;\n            } else {\n                preload(src, function () {\n                    Snap._.$(el.node, {\n                        width: this.offsetWidth,\n                        height: this.offsetHeight\n                    });\n                });\n            }\n            Snap._.$(el.node, set);\n        }\n        return el;\n    };\n    /*\\\n     * Paper.ellipse\n     [ method ]\n     **\n     * Draws an ellipse\n     **\n     - x (number) x coordinate of the centre\n     - y (number) y coordinate of the centre\n     - rx (number) horizontal radius\n     - ry (number) vertical radius\n     = (object) the `ellipse` element\n     **\n     > Usage\n     | var c = paper.ellipse(50, 50, 40, 20);\n    \\*/\n    proto.ellipse = function (cx, cy, rx, ry) {\n        var attr;\n        if (is(cx, \"object\") && cx == \"[object Object]\") {\n            attr = cx;\n        } else if (cx != null) {\n            attr ={\n                cx: cx,\n                cy: cy,\n                rx: rx,\n                ry: ry\n            };\n        }\n        return this.el(\"ellipse\", attr);\n    };\n    // SIERRA Paper.path(): Unclear from the link what a Catmull-Rom curveto is, and why it would make life any easier.\n    /*\\\n     * Paper.path\n     [ method ]\n     **\n     * Creates a `<path>` element using the given string as the path's definition\n     - pathString (string) #optional path string in SVG format\n     * Path string consists of one-letter commands, followed by comma seprarated arguments in numerical form. Example:\n     | \"M10,20L30,40\"\n     * This example features two commands: `M`, with arguments `(10, 20)` and `L` with arguments `(30, 40)`. Uppercase letter commands express coordinates in absolute terms, while lowercase commands express them in relative terms from the most recently declared coordinates.\n     *\n     # <p>Here is short list of commands available, for more details see <a href=\"http://www.w3.org/TR/SVG/paths.html#PathData\" title=\"Details of a path's data attribute's format are described in the SVG specification.\">SVG path string format</a> or <a href=\"https://developer.mozilla.org/en/SVG/Tutorial/Paths\">article about path strings at MDN</a>.</p>\n     # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>\n     # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>\n     # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>\n     # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>\n     # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>\n     # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>\n     # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>\n     # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>\n     # <tr><td>Q</td><td>quadratic Bézier curveto</td><td>(x1 y1 x y)+</td></tr>\n     # <tr><td>T</td><td>smooth quadratic Bézier curveto</td><td>(x y)+</td></tr>\n     # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>\n     # <tr><td>R</td><td><a href=\"http://en.wikipedia.org/wiki/Catmull–Rom_spline#Catmull.E2.80.93Rom_spline\">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>\n     * * _Catmull-Rom curveto_ is a not standard SVG command and added to make life easier.\n     * Note: there is a special case when a path consists of only three commands: `M10,10R…z`. In this case the path connects back to its starting point.\n     > Usage\n     | var c = paper.path(\"M10 10L90 90\");\n     | // draw a diagonal line:\n     | // move to 10,10, line to 90,90\n    \\*/\n    proto.path = function (d) {\n        var attr;\n        if (is(d, \"object\") && !is(d, \"array\")) {\n            attr = d;\n        } else if (d) {\n            attr = {d: d};\n        }\n        return this.el(\"path\", attr);\n    };\n    /*\\\n     * Paper.g\n     [ method ]\n     **\n     * Creates a group element\n     **\n     - varargs (…) #optional elements to nest within the group\n     = (object) the `g` element\n     **\n     > Usage\n     | var c1 = paper.circle(),\n     |     c2 = paper.rect(),\n     |     g = paper.g(c2, c1); // note that the order of elements is different\n     * or\n     | var c1 = paper.circle(),\n     |     c2 = paper.rect(),\n     |     g = paper.g();\n     | g.add(c2, c1);\n    \\*/\n    /*\\\n     * Paper.group\n     [ method ]\n     **\n     * See @Paper.g\n    \\*/\n    proto.group = proto.g = function (first) {\n        var attr,\n            el = this.el(\"g\");\n        if (arguments.length == 1 && first && !first.type) {\n            el.attr(first);\n        } else if (arguments.length) {\n            el.add(Array.prototype.slice.call(arguments, 0));\n        }\n        return el;\n    };\n    /*\\\n     * Paper.svg\n     [ method ]\n     **\n     * Creates a nested SVG element.\n     - x (number) @optional X of the element\n     - y (number) @optional Y of the element\n     - width (number) @optional width of the element\n     - height (number) @optional height of the element\n     - vbx (number) @optional viewbox X\n     - vby (number) @optional viewbox Y\n     - vbw (number) @optional viewbox width\n     - vbh (number) @optional viewbox height\n     **\n     = (object) the `svg` element\n     **\n    \\*/\n    proto.svg = function (x, y, width, height, vbx, vby, vbw, vbh) {\n        var attrs = {};\n        if (is(x, \"object\") && y == null) {\n            attrs = x;\n        } else {\n            if (x != null) {\n                attrs.x = x;\n            }\n            if (y != null) {\n                attrs.y = y;\n            }\n            if (width != null) {\n                attrs.width = width;\n            }\n            if (height != null) {\n                attrs.height = height;\n            }\n            if (vbx != null && vby != null && vbw != null && vbh != null) {\n                attrs.viewBox = [vbx, vby, vbw, vbh];\n            }\n        }\n        return this.el(\"svg\", attrs);\n    };\n    /*\\\n     * Paper.mask\n     [ method ]\n     **\n     * Equivalent in behaviour to @Paper.g, except it’s a mask.\n     **\n     = (object) the `mask` element\n     **\n    \\*/\n    proto.mask = function (first) {\n        var attr,\n            el = this.el(\"mask\");\n        if (arguments.length == 1 && first && !first.type) {\n            el.attr(first);\n        } else if (arguments.length) {\n            el.add(Array.prototype.slice.call(arguments, 0));\n        }\n        return el;\n    };\n    /*\\\n     * Paper.ptrn\n     [ method ]\n     **\n     * Equivalent in behaviour to @Paper.g, except it’s a pattern.\n     - x (number) @optional X of the element\n     - y (number) @optional Y of the element\n     - width (number) @optional width of the element\n     - height (number) @optional height of the element\n     - vbx (number) @optional viewbox X\n     - vby (number) @optional viewbox Y\n     - vbw (number) @optional viewbox width\n     - vbh (number) @optional viewbox height\n     **\n     = (object) the `pattern` element\n     **\n    \\*/\n    proto.ptrn = function (x, y, width, height, vx, vy, vw, vh) {\n        if (is(x, \"object\")) {\n            var attr = x;\n        } else {\n            attr = {patternUnits: \"userSpaceOnUse\"};\n            if (x) {\n                attr.x = x;\n            }\n            if (y) {\n                attr.y = y;\n            }\n            if (width != null) {\n                attr.width = width;\n            }\n            if (height != null) {\n                attr.height = height;\n            }\n            if (vx != null && vy != null && vw != null && vh != null) {\n                attr.viewBox = [vx, vy, vw, vh];\n            } else {\n                attr.viewBox = [x || 0, y || 0, width || 0, height || 0];\n            }\n        }\n        return this.el(\"pattern\", attr);\n    };\n    /*\\\n     * Paper.use\n     [ method ]\n     **\n     * Creates a <use> element.\n     - id (string) @optional id of element to link\n     * or\n     - id (Element) @optional element to link\n     **\n     = (object) the `use` element\n     **\n    \\*/\n    proto.use = function (id) {\n        if (id != null) {\n            if (id instanceof Element) {\n                if (!id.attr(\"id\")) {\n                    id.attr({id: Snap._.id(id)});\n                }\n                id = id.attr(\"id\");\n            }\n            if (String(id).charAt() == \"#\") {\n                id = id.substring(1);\n            }\n            return this.el(\"use\", {\"xlink:href\": \"#\" + id});\n        } else {\n            return Element.prototype.use.call(this);\n        }\n    };\n    /*\\\n     * Paper.symbol\n     [ method ]\n     **\n     * Creates a <symbol> element.\n     - vbx (number) @optional viewbox X\n     - vby (number) @optional viewbox Y\n     - vbw (number) @optional viewbox width\n     - vbh (number) @optional viewbox height\n     = (object) the `symbol` element\n     **\n    \\*/\n    proto.symbol = function (vx, vy, vw, vh) {\n        var attr = {};\n        if (vx != null && vy != null && vw != null && vh != null) {\n            attr.viewBox = [vx, vy, vw, vh];\n        }\n\n        return this.el(\"symbol\", attr);\n    };\n    /*\\\n     * Paper.text\n     [ method ]\n     **\n     * Draws a text string\n     **\n     - x (number) x coordinate position\n     - y (number) y coordinate position\n     - text (string|array) The text string to draw or array of strings to nest within separate `<tspan>` elements\n     = (object) the `text` element\n     **\n     > Usage\n     | var t1 = paper.text(50, 50, \"Snap\");\n     | var t2 = paper.text(50, 50, [\"S\",\"n\",\"a\",\"p\"]);\n     | // Text path usage\n     | t1.attr({textpath: \"M10,10L100,100\"});\n     | // or\n     | var pth = paper.path(\"M10,10L100,100\");\n     | t1.attr({textpath: pth});\n    \\*/\n    proto.text = function (x, y, text) {\n        var attr = {};\n        if (is(x, \"object\")) {\n            attr = x;\n        } else if (x != null) {\n            attr = {\n                x: x,\n                y: y,\n                text: text || \"\"\n            };\n        }\n        return this.el(\"text\", attr);\n    };\n    /*\\\n     * Paper.line\n     [ method ]\n     **\n     * Draws a line\n     **\n     - x1 (number) x coordinate position of the start\n     - y1 (number) y coordinate position of the start\n     - x2 (number) x coordinate position of the end\n     - y2 (number) y coordinate position of the end\n     = (object) the `line` element\n     **\n     > Usage\n     | var t1 = paper.line(50, 50, 100, 100);\n    \\*/\n    proto.line = function (x1, y1, x2, y2) {\n        var attr = {};\n        if (is(x1, \"object\")) {\n            attr = x1;\n        } else if (x1 != null) {\n            attr = {\n                x1: x1,\n                x2: x2,\n                y1: y1,\n                y2: y2\n            };\n        }\n        return this.el(\"line\", attr);\n    };\n    /*\\\n     * Paper.polyline\n     [ method ]\n     **\n     * Draws a polyline\n     **\n     - points (array) array of points\n     * or\n     - varargs (…) points\n     = (object) the `polyline` element\n     **\n     > Usage\n     | var p1 = paper.polyline([10, 10, 100, 100]);\n     | var p2 = paper.polyline(10, 10, 100, 100);\n    \\*/\n    proto.polyline = function (points) {\n        if (arguments.length > 1) {\n            points = Array.prototype.slice.call(arguments, 0);\n        }\n        var attr = {};\n        if (is(points, \"object\") && !is(points, \"array\")) {\n            attr = points;\n        } else if (points != null) {\n            attr = {points: points};\n        }\n        return this.el(\"polyline\", attr);\n    };\n    /*\\\n     * Paper.polygon\n     [ method ]\n     **\n     * Draws a polygon. See @Paper.polyline\n    \\*/\n    proto.polygon = function (points) {\n        if (arguments.length > 1) {\n            points = Array.prototype.slice.call(arguments, 0);\n        }\n        var attr = {};\n        if (is(points, \"object\") && !is(points, \"array\")) {\n            attr = points;\n        } else if (points != null) {\n            attr = {points: points};\n        }\n        return this.el(\"polygon\", attr);\n    };\n    // gradients\n    (function () {\n        var $ = Snap._.$;\n        // gradients' helpers\n        function Gstops() {\n            return this.selectAll(\"stop\");\n        }\n        function GaddStop(color, offset) {\n            var stop = $(\"stop\"),\n                attr = {\n                    offset: +offset + \"%\"\n                };\n            color = Snap.color(color);\n            attr[\"stop-color\"] = color.hex;\n            if (color.opacity < 1) {\n                attr[\"stop-opacity\"] = color.opacity;\n            }\n            $(stop, attr);\n            this.node.appendChild(stop);\n            return this;\n        }\n        function GgetBBox() {\n            if (this.type == \"linearGradient\") {\n                var x1 = $(this.node, \"x1\") || 0,\n                    x2 = $(this.node, \"x2\") || 1,\n                    y1 = $(this.node, \"y1\") || 0,\n                    y2 = $(this.node, \"y2\") || 0;\n                return Snap._.box(x1, y1, math.abs(x2 - x1), math.abs(y2 - y1));\n            } else {\n                var cx = this.node.cx || .5,\n                    cy = this.node.cy || .5,\n                    r = this.node.r || 0;\n                return Snap._.box(cx - r, cy - r, r * 2, r * 2);\n            }\n        }\n        function gradient(defs, str) {\n            var grad = eve(\"snap.util.grad.parse\", null, str).firstDefined(),\n                el;\n            if (!grad) {\n                return null;\n            }\n            grad.params.unshift(defs);\n            if (grad.type.toLowerCase() == \"l\") {\n                el = gradientLinear.apply(0, grad.params);\n            } else {\n                el = gradientRadial.apply(0, grad.params);\n            }\n            if (grad.type != grad.type.toLowerCase()) {\n                $(el.node, {\n                    gradientUnits: \"userSpaceOnUse\"\n                });\n            }\n            var stops = grad.stops,\n                len = stops.length,\n                start = 0,\n                j = 0;\n            function seed(i, end) {\n                var step = (end - start) / (i - j);\n                for (var k = j; k < i; k++) {\n                    stops[k].offset = +(+start + step * (k - j)).toFixed(2);\n                }\n                j = i;\n                start = end;\n            }\n            len--;\n            for (var i = 0; i < len; i++) if (\"offset\" in stops[i]) {\n                seed(i, stops[i].offset);\n            }\n            stops[len].offset = stops[len].offset || 100;\n            seed(len, stops[len].offset);\n            for (i = 0; i <= len; i++) {\n                var stop = stops[i];\n                el.addStop(stop.color, stop.offset);\n            }\n            return el;\n        }\n        function gradientLinear(defs, x1, y1, x2, y2) {\n            var el = Snap._.make(\"linearGradient\", defs);\n            el.stops = Gstops;\n            el.addStop = GaddStop;\n            el.getBBox = GgetBBox;\n            if (x1 != null) {\n                $(el.node, {\n                    x1: x1,\n                    y1: y1,\n                    x2: x2,\n                    y2: y2\n                });\n            }\n            return el;\n        }\n        function gradientRadial(defs, cx, cy, r, fx, fy) {\n            var el = Snap._.make(\"radialGradient\", defs);\n            el.stops = Gstops;\n            el.addStop = GaddStop;\n            el.getBBox = GgetBBox;\n            if (cx != null) {\n                $(el.node, {\n                    cx: cx,\n                    cy: cy,\n                    r: r\n                });\n            }\n            if (fx != null && fy != null) {\n                $(el.node, {\n                    fx: fx,\n                    fy: fy\n                });\n            }\n            return el;\n        }\n        /*\\\n         * Paper.gradient\n         [ method ]\n         **\n         * Creates a gradient element\n         **\n         - gradient (string) gradient descriptor\n         > Gradient Descriptor\n         * The gradient descriptor is an expression formatted as\n         * follows: `<type>(<coords>)<colors>`.  The `<type>` can be\n         * either linear or radial.  The uppercase `L` or `R` letters\n         * indicate absolute coordinates offset from the SVG surface.\n         * Lowercase `l` or `r` letters indicate coordinates\n         * calculated relative to the element to which the gradient is\n         * applied.  Coordinates specify a linear gradient vector as\n         * `x1`, `y1`, `x2`, `y2`, or a radial gradient as `cx`, `cy`,\n         * `r` and optional `fx`, `fy` specifying a focal point away\n         * from the center of the circle. Specify `<colors>` as a list\n         * of dash-separated CSS color values.  Each color may be\n         * followed by a custom offset value, separated with a colon\n         * character.\n         > Examples\n         * Linear gradient, relative from top-left corner to bottom-right\n         * corner, from black through red to white:\n         | var g = paper.gradient(\"l(0, 0, 1, 1)#000-#f00-#fff\");\n         * Linear gradient, absolute from (0, 0) to (100, 100), from black\n         * through red at 25% to white:\n         | var g = paper.gradient(\"L(0, 0, 100, 100)#000-#f00:25-#fff\");\n         * Radial gradient, relative from the center of the element with radius\n         * half the width, from black to white:\n         | var g = paper.gradient(\"r(0.5, 0.5, 0.5)#000-#fff\");\n         * To apply the gradient:\n         | paper.circle(50, 50, 40).attr({\n         |     fill: g\n         | });\n         = (object) the `gradient` element\n        \\*/\n        proto.gradient = function (str) {\n            return gradient(this.defs, str);\n        };\n        proto.gradientLinear = function (x1, y1, x2, y2) {\n            return gradientLinear(this.defs, x1, y1, x2, y2);\n        };\n        proto.gradientRadial = function (cx, cy, r, fx, fy) {\n            return gradientRadial(this.defs, cx, cy, r, fx, fy);\n        };\n        /*\\\n         * Paper.toString\n         [ method ]\n         **\n         * Returns SVG code for the @Paper\n         = (string) SVG code for the @Paper\n        \\*/\n        proto.toString = function () {\n            var doc = this.node.ownerDocument,\n                f = doc.createDocumentFragment(),\n                d = doc.createElement(\"div\"),\n                svg = this.node.cloneNode(true),\n                res;\n            f.appendChild(d);\n            d.appendChild(svg);\n            Snap._.$(svg, {xmlns: \"http://www.w3.org/2000/svg\"});\n            res = d.innerHTML;\n            f.removeChild(f.firstChild);\n            return res;\n        };\n        /*\\\n         * Paper.toDataURL\n         [ method ]\n         **\n         * Returns SVG code for the @Paper as Data URI string.\n         = (string) Data URI string\n        \\*/\n        proto.toDataURL = function () {\n            if (window && window.btoa) {\n                return \"data:image/svg+xml;base64,\" + btoa(unescape(encodeURIComponent(this)));\n            }\n        };\n        /*\\\n         * Paper.clear\n         [ method ]\n         **\n         * Removes all child nodes of the paper, except <defs>.\n        \\*/\n        proto.clear = function () {\n            var node = this.node.firstChild,\n                next;\n            while (node) {\n                next = node.nextSibling;\n                if (node.tagName != \"defs\") {\n                    node.parentNode.removeChild(node);\n                } else {\n                    proto.clear.call({node: node});\n                }\n                node = next;\n            }\n        };\n    }());\n});\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n// http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob) {\n    var elproto = Element.prototype,\n        is = Snap.is,\n        clone = Snap._.clone,\n        has = \"hasOwnProperty\",\n        p2s = /,?([a-z]),?/gi,\n        toFloat = parseFloat,\n        math = Math,\n        PI = math.PI,\n        mmin = math.min,\n        mmax = math.max,\n        pow = math.pow,\n        abs = math.abs;\n    function paths(ps) {\n        var p = paths.ps = paths.ps || {};\n        if (p[ps]) {\n            p[ps].sleep = 100;\n        } else {\n            p[ps] = {\n                sleep: 100\n            };\n        }\n        setTimeout(function () {\n            for (var key in p) if (p[has](key) && key != ps) {\n                p[key].sleep--;\n                !p[key].sleep && delete p[key];\n            }\n        });\n        return p[ps];\n    }\n    function box(x, y, width, height) {\n        if (x == null) {\n            x = y = width = height = 0;\n        }\n        if (y == null) {\n            y = x.y;\n            width = x.width;\n            height = x.height;\n            x = x.x;\n        }\n        return {\n            x: x,\n            y: y,\n            width: width,\n            w: width,\n            height: height,\n            h: height,\n            x2: x + width,\n            y2: y + height,\n            cx: x + width / 2,\n            cy: y + height / 2,\n            r1: math.min(width, height) / 2,\n            r2: math.max(width, height) / 2,\n            r0: math.sqrt(width * width + height * height) / 2,\n            path: rectPath(x, y, width, height),\n            vb: [x, y, width, height].join(\" \")\n        };\n    }\n    function toString() {\n        return this.join(\",\").replace(p2s, \"$1\");\n    }\n    function pathClone(pathArray) {\n        var res = clone(pathArray);\n        res.toString = toString;\n        return res;\n    }\n    function getPointAtSegmentLength(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {\n        if (length == null) {\n            return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);\n        } else {\n            return findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y,\n                getTotLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));\n        }\n    }\n    function getLengthFactory(istotal, subpath) {\n        function O(val) {\n            return +(+val).toFixed(3);\n        }\n        return Snap._.cacher(function (path, length, onlystart) {\n            if (path instanceof Element) {\n                path = path.attr(\"d\");\n            }\n            path = path2curve(path);\n            var x, y, p, l, sp = \"\", subpaths = {}, point,\n                len = 0;\n            for (var i = 0, ii = path.length; i < ii; i++) {\n                p = path[i];\n                if (p[0] == \"M\") {\n                    x = +p[1];\n                    y = +p[2];\n                } else {\n                    l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);\n                    if (len + l > length) {\n                        if (subpath && !subpaths.start) {\n                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);\n                            sp += [\n                                \"C\" + O(point.start.x),\n                                O(point.start.y),\n                                O(point.m.x),\n                                O(point.m.y),\n                                O(point.x),\n                                O(point.y)\n                            ];\n                            if (onlystart) {return sp;}\n                            subpaths.start = sp;\n                            sp = [\n                                \"M\" + O(point.x),\n                                O(point.y) + \"C\" + O(point.n.x),\n                                O(point.n.y),\n                                O(point.end.x),\n                                O(point.end.y),\n                                O(p[5]),\n                                O(p[6])\n                            ].join();\n                            len += l;\n                            x = +p[5];\n                            y = +p[6];\n                            continue;\n                        }\n                        if (!istotal && !subpath) {\n                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);\n                            return point;\n                        }\n                    }\n                    len += l;\n                    x = +p[5];\n                    y = +p[6];\n                }\n                sp += p.shift() + p;\n            }\n            subpaths.end = sp;\n            point = istotal ? len : subpath ? subpaths : findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);\n            return point;\n        }, null, Snap._.clone);\n    }\n    var getTotalLength = getLengthFactory(1),\n        getPointAtLength = getLengthFactory(),\n        getSubpathsAtLength = getLengthFactory(0, 1);\n    function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {\n        var t1 = 1 - t,\n            t13 = pow(t1, 3),\n            t12 = pow(t1, 2),\n            t2 = t * t,\n            t3 = t2 * t,\n            x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,\n            y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,\n            mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),\n            my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),\n            nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),\n            ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),\n            ax = t1 * p1x + t * c1x,\n            ay = t1 * p1y + t * c1y,\n            cx = t1 * c2x + t * p2x,\n            cy = t1 * c2y + t * p2y,\n            alpha = (90 - math.atan2(mx - nx, my - ny) * 180 / PI);\n        // (mx > nx || my < ny) && (alpha += 180);\n        return {\n            x: x,\n            y: y,\n            m: {x: mx, y: my},\n            n: {x: nx, y: ny},\n            start: {x: ax, y: ay},\n            end: {x: cx, y: cy},\n            alpha: alpha\n        };\n    }\n    function bezierBBox(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {\n        if (!Snap.is(p1x, \"array\")) {\n            p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];\n        }\n        var bbox = curveDim.apply(null, p1x);\n        return box(\n            bbox.min.x,\n            bbox.min.y,\n            bbox.max.x - bbox.min.x,\n            bbox.max.y - bbox.min.y\n        );\n    }\n    function isPointInsideBBox(bbox, x, y) {\n        return  x >= bbox.x &&\n                x <= bbox.x + bbox.width &&\n                y >= bbox.y &&\n                y <= bbox.y + bbox.height;\n    }\n    function isBBoxIntersect(bbox1, bbox2) {\n        bbox1 = box(bbox1);\n        bbox2 = box(bbox2);\n        return isPointInsideBBox(bbox2, bbox1.x, bbox1.y)\n            || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y)\n            || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2)\n            || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2)\n            || isPointInsideBBox(bbox1, bbox2.x, bbox2.y)\n            || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y)\n            || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2)\n            || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2)\n            || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x\n                || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)\n            && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y\n                || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);\n    }\n    function base3(t, p1, p2, p3, p4) {\n        var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,\n            t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;\n        return t * t2 - 3 * p1 + 3 * p2;\n    }\n    function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {\n        if (z == null) {\n            z = 1;\n        }\n        z = z > 1 ? 1 : z < 0 ? 0 : z;\n        var z2 = z / 2,\n            n = 12,\n            Tvalues = [-.1252,.1252,-.3678,.3678,-.5873,.5873,-.7699,.7699,-.9041,.9041,-.9816,.9816],\n            Cvalues = [0.2491,0.2491,0.2335,0.2335,0.2032,0.2032,0.1601,0.1601,0.1069,0.1069,0.0472,0.0472],\n            sum = 0;\n        for (var i = 0; i < n; i++) {\n            var ct = z2 * Tvalues[i] + z2,\n                xbase = base3(ct, x1, x2, x3, x4),\n                ybase = base3(ct, y1, y2, y3, y4),\n                comb = xbase * xbase + ybase * ybase;\n            sum += Cvalues[i] * math.sqrt(comb);\n        }\n        return z2 * sum;\n    }\n    function getTotLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {\n        if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {\n            return;\n        }\n        var t = 1,\n            step = t / 2,\n            t2 = t - step,\n            l,\n            e = .01;\n        l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);\n        while (abs(l - ll) > e) {\n            step /= 2;\n            t2 += (l < ll ? 1 : -1) * step;\n            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);\n        }\n        return t2;\n    }\n    function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {\n        if (\n            mmax(x1, x2) < mmin(x3, x4) ||\n            mmin(x1, x2) > mmax(x3, x4) ||\n            mmax(y1, y2) < mmin(y3, y4) ||\n            mmin(y1, y2) > mmax(y3, y4)\n        ) {\n            return;\n        }\n        var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n            ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n            denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n\n        if (!denominator) {\n            return;\n        }\n        var px = nx / denominator,\n            py = ny / denominator,\n            px2 = +px.toFixed(2),\n            py2 = +py.toFixed(2);\n        if (\n            px2 < +mmin(x1, x2).toFixed(2) ||\n            px2 > +mmax(x1, x2).toFixed(2) ||\n            px2 < +mmin(x3, x4).toFixed(2) ||\n            px2 > +mmax(x3, x4).toFixed(2) ||\n            py2 < +mmin(y1, y2).toFixed(2) ||\n            py2 > +mmax(y1, y2).toFixed(2) ||\n            py2 < +mmin(y3, y4).toFixed(2) ||\n            py2 > +mmax(y3, y4).toFixed(2)\n        ) {\n            return;\n        }\n        return {x: px, y: py};\n    }\n    function inter(bez1, bez2) {\n        return interHelper(bez1, bez2);\n    }\n    function interCount(bez1, bez2) {\n        return interHelper(bez1, bez2, 1);\n    }\n    function interHelper(bez1, bez2, justCount) {\n        var bbox1 = bezierBBox(bez1),\n            bbox2 = bezierBBox(bez2);\n        if (!isBBoxIntersect(bbox1, bbox2)) {\n            return justCount ? 0 : [];\n        }\n        var l1 = bezlen.apply(0, bez1),\n            l2 = bezlen.apply(0, bez2),\n            n1 = ~~(l1 / 8),\n            n2 = ~~(l2 / 8),\n            dots1 = [],\n            dots2 = [],\n            xy = {},\n            res = justCount ? 0 : [];\n        for (var i = 0; i < n1 + 1; i++) {\n            var p = findDotsAtSegment.apply(0, bez1.concat(i / n1));\n            dots1.push({x: p.x, y: p.y, t: i / n1});\n        }\n        for (i = 0; i < n2 + 1; i++) {\n            p = findDotsAtSegment.apply(0, bez2.concat(i / n2));\n            dots2.push({x: p.x, y: p.y, t: i / n2});\n        }\n        for (i = 0; i < n1; i++) {\n            for (var j = 0; j < n2; j++) {\n                var di = dots1[i],\n                    di1 = dots1[i + 1],\n                    dj = dots2[j],\n                    dj1 = dots2[j + 1],\n                    ci = abs(di1.x - di.x) < .001 ? \"y\" : \"x\",\n                    cj = abs(dj1.x - dj.x) < .001 ? \"y\" : \"x\",\n                    is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);\n                if (is) {\n                    if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {\n                        continue;\n                    }\n                    xy[is.x.toFixed(4)] = is.y.toFixed(4);\n                    var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),\n                        t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);\n                    if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {\n                        if (justCount) {\n                            res++;\n                        } else {\n                            res.push({\n                                x: is.x,\n                                y: is.y,\n                                t1: t1,\n                                t2: t2\n                            });\n                        }\n                    }\n                }\n            }\n        }\n        return res;\n    }\n    function pathIntersection(path1, path2) {\n        return interPathHelper(path1, path2);\n    }\n    function pathIntersectionNumber(path1, path2) {\n        return interPathHelper(path1, path2, 1);\n    }\n    function interPathHelper(path1, path2, justCount) {\n        path1 = path2curve(path1);\n        path2 = path2curve(path2);\n        var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,\n            res = justCount ? 0 : [];\n        for (var i = 0, ii = path1.length; i < ii; i++) {\n            var pi = path1[i];\n            if (pi[0] == \"M\") {\n                x1 = x1m = pi[1];\n                y1 = y1m = pi[2];\n            } else {\n                if (pi[0] == \"C\") {\n                    bez1 = [x1, y1].concat(pi.slice(1));\n                    x1 = bez1[6];\n                    y1 = bez1[7];\n                } else {\n                    bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];\n                    x1 = x1m;\n                    y1 = y1m;\n                }\n                for (var j = 0, jj = path2.length; j < jj; j++) {\n                    var pj = path2[j];\n                    if (pj[0] == \"M\") {\n                        x2 = x2m = pj[1];\n                        y2 = y2m = pj[2];\n                    } else {\n                        if (pj[0] == \"C\") {\n                            bez2 = [x2, y2].concat(pj.slice(1));\n                            x2 = bez2[6];\n                            y2 = bez2[7];\n                        } else {\n                            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];\n                            x2 = x2m;\n                            y2 = y2m;\n                        }\n                        var intr = interHelper(bez1, bez2, justCount);\n                        if (justCount) {\n                            res += intr;\n                        } else {\n                            for (var k = 0, kk = intr.length; k < kk; k++) {\n                                intr[k].segment1 = i;\n                                intr[k].segment2 = j;\n                                intr[k].bez1 = bez1;\n                                intr[k].bez2 = bez2;\n                            }\n                            res = res.concat(intr);\n                        }\n                    }\n                }\n            }\n        }\n        return res;\n    }\n    function isPointInsidePath(path, x, y) {\n        var bbox = pathBBox(path);\n        return isPointInsideBBox(bbox, x, y) &&\n               interPathHelper(path, [[\"M\", x, y], [\"H\", bbox.x2 + 10]], 1) % 2 == 1;\n    }\n    function pathBBox(path) {\n        var pth = paths(path);\n        if (pth.bbox) {\n            return clone(pth.bbox);\n        }\n        if (!path) {\n            return box();\n        }\n        path = path2curve(path);\n        var x = 0, \n            y = 0,\n            X = [],\n            Y = [],\n            p;\n        for (var i = 0, ii = path.length; i < ii; i++) {\n            p = path[i];\n            if (p[0] == \"M\") {\n                x = p[1];\n                y = p[2];\n                X.push(x);\n                Y.push(y);\n            } else {\n                var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);\n                X = X.concat(dim.min.x, dim.max.x);\n                Y = Y.concat(dim.min.y, dim.max.y);\n                x = p[5];\n                y = p[6];\n            }\n        }\n        var xmin = mmin.apply(0, X),\n            ymin = mmin.apply(0, Y),\n            xmax = mmax.apply(0, X),\n            ymax = mmax.apply(0, Y),\n            bb = box(xmin, ymin, xmax - xmin, ymax - ymin);\n        pth.bbox = clone(bb);\n        return bb;\n    }\n    function rectPath(x, y, w, h, r) {\n        if (r) {\n            return [\n                [\"M\", +x + (+r), y],\n                [\"l\", w - r * 2, 0],\n                [\"a\", r, r, 0, 0, 1, r, r],\n                [\"l\", 0, h - r * 2],\n                [\"a\", r, r, 0, 0, 1, -r, r],\n                [\"l\", r * 2 - w, 0],\n                [\"a\", r, r, 0, 0, 1, -r, -r],\n                [\"l\", 0, r * 2 - h],\n                [\"a\", r, r, 0, 0, 1, r, -r],\n                [\"z\"]\n            ];\n        }\n        var res = [[\"M\", x, y], [\"l\", w, 0], [\"l\", 0, h], [\"l\", -w, 0], [\"z\"]];\n        res.toString = toString;\n        return res;\n    }\n    function ellipsePath(x, y, rx, ry, a) {\n        if (a == null && ry == null) {\n            ry = rx;\n        }\n        x = +x;\n        y = +y;\n        rx = +rx;\n        ry = +ry;\n        if (a != null) {\n            var rad = Math.PI / 180,\n                x1 = x + rx * Math.cos(-ry * rad),\n                x2 = x + rx * Math.cos(-a * rad),\n                y1 = y + rx * Math.sin(-ry * rad),\n                y2 = y + rx * Math.sin(-a * rad),\n                res = [[\"M\", x1, y1], [\"A\", rx, rx, 0, +(a - ry > 180), 0, x2, y2]];\n        } else {\n            res = [\n                [\"M\", x, y],\n                [\"m\", 0, -ry],\n                [\"a\", rx, ry, 0, 1, 1, 0, 2 * ry],\n                [\"a\", rx, ry, 0, 1, 1, 0, -2 * ry],\n                [\"z\"]\n            ];\n        }\n        res.toString = toString;\n        return res;\n    }\n    var unit2px = Snap._unit2px,\n        getPath = {\n        path: function (el) {\n            return el.attr(\"path\");\n        },\n        circle: function (el) {\n            var attr = unit2px(el);\n            return ellipsePath(attr.cx, attr.cy, attr.r);\n        },\n        ellipse: function (el) {\n            var attr = unit2px(el);\n            return ellipsePath(attr.cx || 0, attr.cy || 0, attr.rx, attr.ry);\n        },\n        rect: function (el) {\n            var attr = unit2px(el);\n            return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height, attr.rx, attr.ry);\n        },\n        image: function (el) {\n            var attr = unit2px(el);\n            return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height);\n        },\n        line: function (el) {\n            return \"M\" + [el.attr(\"x1\") || 0, el.attr(\"y1\") || 0, el.attr(\"x2\"), el.attr(\"y2\")];\n        },\n        polyline: function (el) {\n            return \"M\" + el.attr(\"points\");\n        },\n        polygon: function (el) {\n            return \"M\" + el.attr(\"points\") + \"z\";\n        },\n        deflt: function (el) {\n            var bbox = el.node.getBBox();\n            return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);\n        }\n    };\n    function pathToRelative(pathArray) {\n        var pth = paths(pathArray),\n            lowerCase = String.prototype.toLowerCase;\n        if (pth.rel) {\n            return pathClone(pth.rel);\n        }\n        if (!Snap.is(pathArray, \"array\") || !Snap.is(pathArray && pathArray[0], \"array\")) {\n            pathArray = Snap.parsePathString(pathArray);\n        }\n        var res = [],\n            x = 0,\n            y = 0,\n            mx = 0,\n            my = 0,\n            start = 0;\n        if (pathArray[0][0] == \"M\") {\n            x = pathArray[0][1];\n            y = pathArray[0][2];\n            mx = x;\n            my = y;\n            start++;\n            res.push([\"M\", x, y]);\n        }\n        for (var i = start, ii = pathArray.length; i < ii; i++) {\n            var r = res[i] = [],\n                pa = pathArray[i];\n            if (pa[0] != lowerCase.call(pa[0])) {\n                r[0] = lowerCase.call(pa[0]);\n                switch (r[0]) {\n                    case \"a\":\n                        r[1] = pa[1];\n                        r[2] = pa[2];\n                        r[3] = pa[3];\n                        r[4] = pa[4];\n                        r[5] = pa[5];\n                        r[6] = +(pa[6] - x).toFixed(3);\n                        r[7] = +(pa[7] - y).toFixed(3);\n                        break;\n                    case \"v\":\n                        r[1] = +(pa[1] - y).toFixed(3);\n                        break;\n                    case \"m\":\n                        mx = pa[1];\n                        my = pa[2];\n                    default:\n                        for (var j = 1, jj = pa.length; j < jj; j++) {\n                            r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);\n                        }\n                }\n            } else {\n                r = res[i] = [];\n                if (pa[0] == \"m\") {\n                    mx = pa[1] + x;\n                    my = pa[2] + y;\n                }\n                for (var k = 0, kk = pa.length; k < kk; k++) {\n                    res[i][k] = pa[k];\n                }\n            }\n            var len = res[i].length;\n            switch (res[i][0]) {\n                case \"z\":\n                    x = mx;\n                    y = my;\n                    break;\n                case \"h\":\n                    x += +res[i][len - 1];\n                    break;\n                case \"v\":\n                    y += +res[i][len - 1];\n                    break;\n                default:\n                    x += +res[i][len - 2];\n                    y += +res[i][len - 1];\n            }\n        }\n        res.toString = toString;\n        pth.rel = pathClone(res);\n        return res;\n    }\n    function pathToAbsolute(pathArray) {\n        var pth = paths(pathArray);\n        if (pth.abs) {\n            return pathClone(pth.abs);\n        }\n        if (!is(pathArray, \"array\") || !is(pathArray && pathArray[0], \"array\")) { // rough assumption\n            pathArray = Snap.parsePathString(pathArray);\n        }\n        if (!pathArray || !pathArray.length) {\n            return [[\"M\", 0, 0]];\n        }\n        var res = [],\n            x = 0,\n            y = 0,\n            mx = 0,\n            my = 0,\n            start = 0,\n            pa0;\n        if (pathArray[0][0] == \"M\") {\n            x = +pathArray[0][1];\n            y = +pathArray[0][2];\n            mx = x;\n            my = y;\n            start++;\n            res[0] = [\"M\", x, y];\n        }\n        var crz = pathArray.length == 3 &&\n            pathArray[0][0] == \"M\" &&\n            pathArray[1][0].toUpperCase() == \"R\" &&\n            pathArray[2][0].toUpperCase() == \"Z\";\n        for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {\n            res.push(r = []);\n            pa = pathArray[i];\n            pa0 = pa[0];\n            if (pa0 != pa0.toUpperCase()) {\n                r[0] = pa0.toUpperCase();\n                switch (r[0]) {\n                    case \"A\":\n                        r[1] = pa[1];\n                        r[2] = pa[2];\n                        r[3] = pa[3];\n                        r[4] = pa[4];\n                        r[5] = pa[5];\n                        r[6] = +pa[6] + x;\n                        r[7] = +pa[7] + y;\n                        break;\n                    case \"V\":\n                        r[1] = +pa[1] + y;\n                        break;\n                    case \"H\":\n                        r[1] = +pa[1] + x;\n                        break;\n                    case \"R\":\n                        var dots = [x, y].concat(pa.slice(1));\n                        for (var j = 2, jj = dots.length; j < jj; j++) {\n                            dots[j] = +dots[j] + x;\n                            dots[++j] = +dots[j] + y;\n                        }\n                        res.pop();\n                        res = res.concat(catmullRom2bezier(dots, crz));\n                        break;\n                    case \"O\":\n                        res.pop();\n                        dots = ellipsePath(x, y, pa[1], pa[2]);\n                        dots.push(dots[0]);\n                        res = res.concat(dots);\n                        break;\n                    case \"U\":\n                        res.pop();\n                        res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));\n                        r = [\"U\"].concat(res[res.length - 1].slice(-2));\n                        break;\n                    case \"M\":\n                        mx = +pa[1] + x;\n                        my = +pa[2] + y;\n                    default:\n                        for (j = 1, jj = pa.length; j < jj; j++) {\n                            r[j] = +pa[j] + ((j % 2) ? x : y);\n                        }\n                }\n            } else if (pa0 == \"R\") {\n                dots = [x, y].concat(pa.slice(1));\n                res.pop();\n                res = res.concat(catmullRom2bezier(dots, crz));\n                r = [\"R\"].concat(pa.slice(-2));\n            } else if (pa0 == \"O\") {\n                res.pop();\n                dots = ellipsePath(x, y, pa[1], pa[2]);\n                dots.push(dots[0]);\n                res = res.concat(dots);\n            } else if (pa0 == \"U\") {\n                res.pop();\n                res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));\n                r = [\"U\"].concat(res[res.length - 1].slice(-2));\n            } else {\n                for (var k = 0, kk = pa.length; k < kk; k++) {\n                    r[k] = pa[k];\n                }\n            }\n            pa0 = pa0.toUpperCase();\n            if (pa0 != \"O\") {\n                switch (r[0]) {\n                    case \"Z\":\n                        x = +mx;\n                        y = +my;\n                        break;\n                    case \"H\":\n                        x = r[1];\n                        break;\n                    case \"V\":\n                        y = r[1];\n                        break;\n                    case \"M\":\n                        mx = r[r.length - 2];\n                        my = r[r.length - 1];\n                    default:\n                        x = r[r.length - 2];\n                        y = r[r.length - 1];\n                }\n            }\n        }\n        res.toString = toString;\n        pth.abs = pathClone(res);\n        return res;\n    }\n    function l2c(x1, y1, x2, y2) {\n        return [x1, y1, x2, y2, x2, y2];\n    }\n    function q2c(x1, y1, ax, ay, x2, y2) {\n        var _13 = 1 / 3,\n            _23 = 2 / 3;\n        return [\n                _13 * x1 + _23 * ax,\n                _13 * y1 + _23 * ay,\n                _13 * x2 + _23 * ax,\n                _13 * y2 + _23 * ay,\n                x2,\n                y2\n            ];\n    }\n    function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n        // for more information of where this math came from visit:\n        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n        var _120 = PI * 120 / 180,\n            rad = PI / 180 * (+angle || 0),\n            res = [],\n            xy,\n            rotate = Snap._.cacher(function (x, y, rad) {\n                var X = x * math.cos(rad) - y * math.sin(rad),\n                    Y = x * math.sin(rad) + y * math.cos(rad);\n                return {x: X, y: Y};\n            });\n        if (!recursive) {\n            xy = rotate(x1, y1, -rad);\n            x1 = xy.x;\n            y1 = xy.y;\n            xy = rotate(x2, y2, -rad);\n            x2 = xy.x;\n            y2 = xy.y;\n            var cos = math.cos(PI / 180 * angle),\n                sin = math.sin(PI / 180 * angle),\n                x = (x1 - x2) / 2,\n                y = (y1 - y2) / 2;\n            var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);\n            if (h > 1) {\n                h = math.sqrt(h);\n                rx = h * rx;\n                ry = h * ry;\n            }\n            var rx2 = rx * rx,\n                ry2 = ry * ry,\n                k = (large_arc_flag == sweep_flag ? -1 : 1) *\n                    math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),\n                cx = k * rx * y / ry + (x1 + x2) / 2,\n                cy = k * -ry * x / rx + (y1 + y2) / 2,\n                f1 = math.asin(((y1 - cy) / ry).toFixed(9)),\n                f2 = math.asin(((y2 - cy) / ry).toFixed(9));\n\n            f1 = x1 < cx ? PI - f1 : f1;\n            f2 = x2 < cx ? PI - f2 : f2;\n            f1 < 0 && (f1 = PI * 2 + f1);\n            f2 < 0 && (f2 = PI * 2 + f2);\n            if (sweep_flag && f1 > f2) {\n                f1 = f1 - PI * 2;\n            }\n            if (!sweep_flag && f2 > f1) {\n                f2 = f2 - PI * 2;\n            }\n        } else {\n            f1 = recursive[0];\n            f2 = recursive[1];\n            cx = recursive[2];\n            cy = recursive[3];\n        }\n        var df = f2 - f1;\n        if (abs(df) > _120) {\n            var f2old = f2,\n                x2old = x2,\n                y2old = y2;\n            f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n            x2 = cx + rx * math.cos(f2);\n            y2 = cy + ry * math.sin(f2);\n            res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n        }\n        df = f2 - f1;\n        var c1 = math.cos(f1),\n            s1 = math.sin(f1),\n            c2 = math.cos(f2),\n            s2 = math.sin(f2),\n            t = math.tan(df / 4),\n            hx = 4 / 3 * rx * t,\n            hy = 4 / 3 * ry * t,\n            m1 = [x1, y1],\n            m2 = [x1 + hx * s1, y1 - hy * c1],\n            m3 = [x2 + hx * s2, y2 - hy * c2],\n            m4 = [x2, y2];\n        m2[0] = 2 * m1[0] - m2[0];\n        m2[1] = 2 * m1[1] - m2[1];\n        if (recursive) {\n            return [m2, m3, m4].concat(res);\n        } else {\n            res = [m2, m3, m4].concat(res).join().split(\",\");\n            var newres = [];\n            for (var i = 0, ii = res.length; i < ii; i++) {\n                newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;\n            }\n            return newres;\n        }\n    }\n    function findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {\n        var t1 = 1 - t;\n        return {\n            x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,\n            y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y\n        };\n    }\n    \n    // Returns bounding box of cubic bezier curve.\n    // Source: http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html\n    // Original version: NISHIO Hirokazu\n    // Modifications: https://github.com/timo22345\n    function curveDim(x0, y0, x1, y1, x2, y2, x3, y3) {\n        var tvalues = [],\n            bounds = [[], []],\n            a, b, c, t, t1, t2, b2ac, sqrtb2ac;\n        for (var i = 0; i < 2; ++i) {\n            if (i == 0) {\n                b = 6 * x0 - 12 * x1 + 6 * x2;\n                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n                c = 3 * x1 - 3 * x0;\n            } else {\n                b = 6 * y0 - 12 * y1 + 6 * y2;\n                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n                c = 3 * y1 - 3 * y0;\n            }\n            if (abs(a) < 1e-12) {\n                if (abs(b) < 1e-12) {\n                    continue;\n                }\n                t = -c / b;\n                if (0 < t && t < 1) {\n                    tvalues.push(t);\n                }\n                continue;\n            }\n            b2ac = b * b - 4 * c * a;\n            sqrtb2ac = math.sqrt(b2ac);\n            if (b2ac < 0) {\n                continue;\n            }\n            t1 = (-b + sqrtb2ac) / (2 * a);\n            if (0 < t1 && t1 < 1) {\n                tvalues.push(t1);\n            }\n            t2 = (-b - sqrtb2ac) / (2 * a);\n            if (0 < t2 && t2 < 1) {\n                tvalues.push(t2);\n            }\n        }\n\n        var x, y, j = tvalues.length,\n            jlen = j,\n            mt;\n        while (j--) {\n            t = tvalues[j];\n            mt = 1 - t;\n            bounds[0][j] = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);\n            bounds[1][j] = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);\n        }\n\n        bounds[0][jlen] = x0;\n        bounds[1][jlen] = y0;\n        bounds[0][jlen + 1] = x3;\n        bounds[1][jlen + 1] = y3;\n        bounds[0].length = bounds[1].length = jlen + 2;\n\n\n        return {\n          min: {x: mmin.apply(0, bounds[0]), y: mmin.apply(0, bounds[1])},\n          max: {x: mmax.apply(0, bounds[0]), y: mmax.apply(0, bounds[1])}\n        };\n    }\n\n    function path2curve(path, path2) {\n        var pth = !path2 && paths(path);\n        if (!path2 && pth.curve) {\n            return pathClone(pth.curve);\n        }\n        var p = pathToAbsolute(path),\n            p2 = path2 && pathToAbsolute(path2),\n            attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},\n            attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},\n            processPath = function (path, d, pcom) {\n                var nx, ny;\n                if (!path) {\n                    return [\"C\", d.x, d.y, d.x, d.y, d.x, d.y];\n                }\n                !(path[0] in {T: 1, Q: 1}) && (d.qx = d.qy = null);\n                switch (path[0]) {\n                    case \"M\":\n                        d.X = path[1];\n                        d.Y = path[2];\n                        break;\n                    case \"A\":\n                        path = [\"C\"].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));\n                        break;\n                    case \"S\":\n                        if (pcom == \"C\" || pcom == \"S\") { // In \"S\" case we have to take into account, if the previous command is C/S.\n                            nx = d.x * 2 - d.bx;          // And reflect the previous\n                            ny = d.y * 2 - d.by;          // command's control point relative to the current point.\n                        }\n                        else {                            // or some else or nothing\n                            nx = d.x;\n                            ny = d.y;\n                        }\n                        path = [\"C\", nx, ny].concat(path.slice(1));\n                        break;\n                    case \"T\":\n                        if (pcom == \"Q\" || pcom == \"T\") { // In \"T\" case we have to take into account, if the previous command is Q/T.\n                            d.qx = d.x * 2 - d.qx;        // And make a reflection similar\n                            d.qy = d.y * 2 - d.qy;        // to case \"S\".\n                        }\n                        else {                            // or something else or nothing\n                            d.qx = d.x;\n                            d.qy = d.y;\n                        }\n                        path = [\"C\"].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));\n                        break;\n                    case \"Q\":\n                        d.qx = path[1];\n                        d.qy = path[2];\n                        path = [\"C\"].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));\n                        break;\n                    case \"L\":\n                        path = [\"C\"].concat(l2c(d.x, d.y, path[1], path[2]));\n                        break;\n                    case \"H\":\n                        path = [\"C\"].concat(l2c(d.x, d.y, path[1], d.y));\n                        break;\n                    case \"V\":\n                        path = [\"C\"].concat(l2c(d.x, d.y, d.x, path[1]));\n                        break;\n                    case \"Z\":\n                        path = [\"C\"].concat(l2c(d.x, d.y, d.X, d.Y));\n                        break;\n                }\n                return path;\n            },\n            fixArc = function (pp, i) {\n                if (pp[i].length > 7) {\n                    pp[i].shift();\n                    var pi = pp[i];\n                    while (pi.length) {\n                        pcoms1[i] = \"A\"; // if created multiple C:s, their original seg is saved\n                        p2 && (pcoms2[i] = \"A\"); // the same as above\n                        pp.splice(i++, 0, [\"C\"].concat(pi.splice(0, 6)));\n                    }\n                    pp.splice(i, 1);\n                    ii = mmax(p.length, p2 && p2.length || 0);\n                }\n            },\n            fixM = function (path1, path2, a1, a2, i) {\n                if (path1 && path2 && path1[i][0] == \"M\" && path2[i][0] != \"M\") {\n                    path2.splice(i, 0, [\"M\", a2.x, a2.y]);\n                    a1.bx = 0;\n                    a1.by = 0;\n                    a1.x = path1[i][1];\n                    a1.y = path1[i][2];\n                    ii = mmax(p.length, p2 && p2.length || 0);\n                }\n            },\n            pcoms1 = [], // path commands of original path p\n            pcoms2 = [], // path commands of original path p2\n            pfirst = \"\", // temporary holder for original path command\n            pcom = \"\"; // holder for previous path command of original path\n        for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {\n            p[i] && (pfirst = p[i][0]); // save current path command\n\n            if (pfirst != \"C\") // C is not saved yet, because it may be result of conversion\n            {\n                pcoms1[i] = pfirst; // Save current path command\n                i && ( pcom = pcoms1[i - 1]); // Get previous path command pcom\n            }\n            p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\n\n            if (pcoms1[i] != \"A\" && pfirst == \"C\") pcoms1[i] = \"C\"; // A is the only command\n            // which may produce multiple C:s\n            // so we have to make sure that C is also C in original path\n\n            fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1\n\n            if (p2) { // the same procedures is done to p2\n                p2[i] && (pfirst = p2[i][0]);\n                if (pfirst != \"C\") {\n                    pcoms2[i] = pfirst;\n                    i && (pcom = pcoms2[i - 1]);\n                }\n                p2[i] = processPath(p2[i], attrs2, pcom);\n\n                if (pcoms2[i] != \"A\" && pfirst == \"C\") {\n                    pcoms2[i] = \"C\";\n                }\n\n                fixArc(p2, i);\n            }\n            fixM(p, p2, attrs, attrs2, i);\n            fixM(p2, p, attrs2, attrs, i);\n            var seg = p[i],\n                seg2 = p2 && p2[i],\n                seglen = seg.length,\n                seg2len = p2 && seg2.length;\n            attrs.x = seg[seglen - 2];\n            attrs.y = seg[seglen - 1];\n            attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;\n            attrs.by = toFloat(seg[seglen - 3]) || attrs.y;\n            attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);\n            attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);\n            attrs2.x = p2 && seg2[seg2len - 2];\n            attrs2.y = p2 && seg2[seg2len - 1];\n        }\n        if (!p2) {\n            pth.curve = pathClone(p);\n        }\n        return p2 ? [p, p2] : p;\n    }\n    function mapPath(path, matrix) {\n        if (!matrix) {\n            return path;\n        }\n        var x, y, i, j, ii, jj, pathi;\n        path = path2curve(path);\n        for (i = 0, ii = path.length; i < ii; i++) {\n            pathi = path[i];\n            for (j = 1, jj = pathi.length; j < jj; j += 2) {\n                x = matrix.x(pathi[j], pathi[j + 1]);\n                y = matrix.y(pathi[j], pathi[j + 1]);\n                pathi[j] = x;\n                pathi[j + 1] = y;\n            }\n        }\n        return path;\n    }\n\n    // http://schepers.cc/getting-to-the-point\n    function catmullRom2bezier(crp, z) {\n        var d = [];\n        for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {\n            var p = [\n                        {x: +crp[i - 2], y: +crp[i - 1]},\n                        {x: +crp[i],     y: +crp[i + 1]},\n                        {x: +crp[i + 2], y: +crp[i + 3]},\n                        {x: +crp[i + 4], y: +crp[i + 5]}\n                    ];\n            if (z) {\n                if (!i) {\n                    p[0] = {x: +crp[iLen - 2], y: +crp[iLen - 1]};\n                } else if (iLen - 4 == i) {\n                    p[3] = {x: +crp[0], y: +crp[1]};\n                } else if (iLen - 2 == i) {\n                    p[2] = {x: +crp[0], y: +crp[1]};\n                    p[3] = {x: +crp[2], y: +crp[3]};\n                }\n            } else {\n                if (iLen - 4 == i) {\n                    p[3] = p[2];\n                } else if (!i) {\n                    p[0] = {x: +crp[i], y: +crp[i + 1]};\n                }\n            }\n            d.push([\"C\",\n                  (-p[0].x + 6 * p[1].x + p[2].x) / 6,\n                  (-p[0].y + 6 * p[1].y + p[2].y) / 6,\n                  (p[1].x + 6 * p[2].x - p[3].x) / 6,\n                  (p[1].y + 6*p[2].y - p[3].y) / 6,\n                  p[2].x,\n                  p[2].y\n            ]);\n        }\n\n        return d;\n    }\n\n    // export\n    Snap.path = paths;\n\n    /*\\\n     * Snap.path.getTotalLength\n     [ method ]\n     **\n     * Returns the length of the given path in pixels\n     **\n     - path (string) SVG path string\n     **\n     = (number) length\n    \\*/\n    Snap.path.getTotalLength = getTotalLength;\n    /*\\\n     * Snap.path.getPointAtLength\n     [ method ]\n     **\n     * Returns the coordinates of the point located at the given length along the given path\n     **\n     - path (string) SVG path string\n     - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps\n     **\n     = (object) representation of the point:\n     o {\n     o     x: (number) x coordinate,\n     o     y: (number) y coordinate,\n     o     alpha: (number) angle of derivative\n     o }\n    \\*/\n    Snap.path.getPointAtLength = getPointAtLength;\n    /*\\\n     * Snap.path.getSubpath\n     [ method ]\n     **\n     * Returns the subpath of a given path between given start and end lengths\n     **\n     - path (string) SVG path string\n     - from (number) length, in pixels, from the start of the path to the start of the segment\n     - to (number) length, in pixels, from the start of the path to the end of the segment\n     **\n     = (string) path string definition for the segment\n    \\*/\n    Snap.path.getSubpath = function (path, from, to) {\n        if (this.getTotalLength(path) - to < 1e-6) {\n            return getSubpathsAtLength(path, from).end;\n        }\n        var a = getSubpathsAtLength(path, to, 1);\n        return from ? getSubpathsAtLength(a, from).end : a;\n    };\n    /*\\\n     * Element.getTotalLength\n     [ method ]\n     **\n     * Returns the length of the path in pixels (only works for `path` elements)\n     = (number) length\n    \\*/\n    elproto.getTotalLength = function () {\n        if (this.node.getTotalLength) {\n            return this.node.getTotalLength();\n        }\n    };\n    // SIERRA Element.getPointAtLength()/Element.getTotalLength(): If a <path> is broken into different segments, is the jump distance to the new coordinates set by the _M_ or _m_ commands calculated as part of the path's total length?\n    /*\\\n     * Element.getPointAtLength\n     [ method ]\n     **\n     * Returns coordinates of the point located at the given length on the given path (only works for `path` elements)\n     **\n     - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps\n     **\n     = (object) representation of the point:\n     o {\n     o     x: (number) x coordinate,\n     o     y: (number) y coordinate,\n     o     alpha: (number) angle of derivative\n     o }\n    \\*/\n    elproto.getPointAtLength = function (length) {\n        return getPointAtLength(this.attr(\"d\"), length);\n    };\n    // SIERRA Element.getSubpath(): Similar to the problem for Element.getPointAtLength(). Unclear how this would work for a segmented path. Overall, the concept of _subpath_ and what I'm calling a _segment_ (series of non-_M_ or _Z_ commands) is unclear.\n    /*\\\n     * Element.getSubpath\n     [ method ]\n     **\n     * Returns subpath of a given element from given start and end lengths (only works for `path` elements)\n     **\n     - from (number) length, in pixels, from the start of the path to the start of the segment\n     - to (number) length, in pixels, from the start of the path to the end of the segment\n     **\n     = (string) path string definition for the segment\n    \\*/\n    elproto.getSubpath = function (from, to) {\n        return Snap.path.getSubpath(this.attr(\"d\"), from, to);\n    };\n    Snap._.box = box;\n    /*\\\n     * Snap.path.findDotsAtSegment\n     [ method ]\n     **\n     * Utility method\n     **\n     * Finds dot coordinates on the given cubic beziér curve at the given t\n     - p1x (number) x of the first point of the curve\n     - p1y (number) y of the first point of the curve\n     - c1x (number) x of the first anchor of the curve\n     - c1y (number) y of the first anchor of the curve\n     - c2x (number) x of the second anchor of the curve\n     - c2y (number) y of the second anchor of the curve\n     - p2x (number) x of the second point of the curve\n     - p2y (number) y of the second point of the curve\n     - t (number) position on the curve (0..1)\n     = (object) point information in format:\n     o {\n     o     x: (number) x coordinate of the point,\n     o     y: (number) y coordinate of the point,\n     o     m: {\n     o         x: (number) x coordinate of the left anchor,\n     o         y: (number) y coordinate of the left anchor\n     o     },\n     o     n: {\n     o         x: (number) x coordinate of the right anchor,\n     o         y: (number) y coordinate of the right anchor\n     o     },\n     o     start: {\n     o         x: (number) x coordinate of the start of the curve,\n     o         y: (number) y coordinate of the start of the curve\n     o     },\n     o     end: {\n     o         x: (number) x coordinate of the end of the curve,\n     o         y: (number) y coordinate of the end of the curve\n     o     },\n     o     alpha: (number) angle of the curve derivative at the point\n     o }\n    \\*/\n    Snap.path.findDotsAtSegment = findDotsAtSegment;\n    /*\\\n     * Snap.path.bezierBBox\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns the bounding box of a given cubic beziér curve\n     - p1x (number) x of the first point of the curve\n     - p1y (number) y of the first point of the curve\n     - c1x (number) x of the first anchor of the curve\n     - c1y (number) y of the first anchor of the curve\n     - c2x (number) x of the second anchor of the curve\n     - c2y (number) y of the second anchor of the curve\n     - p2x (number) x of the second point of the curve\n     - p2y (number) y of the second point of the curve\n     * or\n     - bez (array) array of six points for beziér curve\n     = (object) bounding box\n     o {\n     o     x: (number) x coordinate of the left top point of the box,\n     o     y: (number) y coordinate of the left top point of the box,\n     o     x2: (number) x coordinate of the right bottom point of the box,\n     o     y2: (number) y coordinate of the right bottom point of the box,\n     o     width: (number) width of the box,\n     o     height: (number) height of the box\n     o }\n    \\*/\n    Snap.path.bezierBBox = bezierBBox;\n    /*\\\n     * Snap.path.isPointInsideBBox\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns `true` if given point is inside bounding box\n     - bbox (string) bounding box\n     - x (string) x coordinate of the point\n     - y (string) y coordinate of the point\n     = (boolean) `true` if point is inside\n    \\*/\n    Snap.path.isPointInsideBBox = isPointInsideBBox;\n    Snap.closest = function (x, y, X, Y) {\n        var r = 100,\n            b = box(x - r / 2, y - r / 2, r, r),\n            inside = [],\n            getter = X[0].hasOwnProperty(\"x\") ? function (i) {\n                return {\n                    x: X[i].x,\n                    y: X[i].y\n                };\n            } : function (i) {\n                return {\n                    x: X[i],\n                    y: Y[i]\n                };\n            },\n            found = 0;\n        while (r <= 1e6 && !found) {\n            for (var i = 0, ii = X.length; i < ii; i++) {\n                var xy = getter(i);\n                if (isPointInsideBBox(b, xy.x, xy.y)) {\n                    found++;\n                    inside.push(xy);\n                    break;\n                }\n            }\n            if (!found) {\n                r *= 2;\n                b = box(x - r / 2, y - r / 2, r, r)\n            }\n        }\n        if (r == 1e6) {\n            return;\n        }\n        var len = Infinity,\n            res;\n        for (i = 0, ii = inside.length; i < ii; i++) {\n            var l = Snap.len(x, y, inside[i].x, inside[i].y);\n            if (len > l) {\n                len = l;\n                inside[i].len = l;\n                res = inside[i];\n            }\n        }\n        return res;\n    };\n    /*\\\n     * Snap.path.isBBoxIntersect\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns `true` if two bounding boxes intersect\n     - bbox1 (string) first bounding box\n     - bbox2 (string) second bounding box\n     = (boolean) `true` if bounding boxes intersect\n    \\*/\n    Snap.path.isBBoxIntersect = isBBoxIntersect;\n    /*\\\n     * Snap.path.intersection\n     [ method ]\n     **\n     * Utility method\n     **\n     * Finds intersections of two paths\n     - path1 (string) path string\n     - path2 (string) path string\n     = (array) dots of intersection\n     o [\n     o     {\n     o         x: (number) x coordinate of the point,\n     o         y: (number) y coordinate of the point,\n     o         t1: (number) t value for segment of path1,\n     o         t2: (number) t value for segment of path2,\n     o         segment1: (number) order number for segment of path1,\n     o         segment2: (number) order number for segment of path2,\n     o         bez1: (array) eight coordinates representing beziér curve for the segment of path1,\n     o         bez2: (array) eight coordinates representing beziér curve for the segment of path2\n     o     }\n     o ]\n    \\*/\n    Snap.path.intersection = pathIntersection;\n    Snap.path.intersectionNumber = pathIntersectionNumber;\n    /*\\\n     * Snap.path.isPointInside\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns `true` if given point is inside a given closed path.\n     *\n     * Note: fill mode doesn’t affect the result of this method.\n     - path (string) path string\n     - x (number) x of the point\n     - y (number) y of the point\n     = (boolean) `true` if point is inside the path\n    \\*/\n    Snap.path.isPointInside = isPointInsidePath;\n    /*\\\n     * Snap.path.getBBox\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns the bounding box of a given path\n     - path (string) path string\n     = (object) bounding box\n     o {\n     o     x: (number) x coordinate of the left top point of the box,\n     o     y: (number) y coordinate of the left top point of the box,\n     o     x2: (number) x coordinate of the right bottom point of the box,\n     o     y2: (number) y coordinate of the right bottom point of the box,\n     o     width: (number) width of the box,\n     o     height: (number) height of the box\n     o }\n    \\*/\n    Snap.path.getBBox = pathBBox;\n    Snap.path.get = getPath;\n    /*\\\n     * Snap.path.toRelative\n     [ method ]\n     **\n     * Utility method\n     **\n     * Converts path coordinates into relative values\n     - path (string) path string\n     = (array) path string\n    \\*/\n    Snap.path.toRelative = pathToRelative;\n    /*\\\n     * Snap.path.toAbsolute\n     [ method ]\n     **\n     * Utility method\n     **\n     * Converts path coordinates into absolute values\n     - path (string) path string\n     = (array) path string\n    \\*/\n    Snap.path.toAbsolute = pathToAbsolute;\n    /*\\\n     * Snap.path.toCubic\n     [ method ]\n     **\n     * Utility method\n     **\n     * Converts path to a new path where all segments are cubic beziér curves\n     - pathString (string|array) path string or array of segments\n     = (array) array of segments\n    \\*/\n    Snap.path.toCubic = path2curve;\n    /*\\\n     * Snap.path.map\n     [ method ]\n     **\n     * Transform the path string with the given matrix\n     - path (string) path string\n     - matrix (object) see @Matrix\n     = (string) transformed path string\n    \\*/\n    Snap.path.map = mapPath;\n    Snap.path.toString = toString;\n    Snap.path.clone = pathClone;\n});\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n// http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob) {\n    var mmax = Math.max,\n        mmin = Math.min;\n\n    // Set\n    var Set = function (items) {\n        this.items = [];\n\tthis.bindings = {};\n        this.length = 0;\n        this.type = \"set\";\n        if (items) {\n            for (var i = 0, ii = items.length; i < ii; i++) {\n                if (items[i]) {\n                    this[this.items.length] = this.items[this.items.length] = items[i];\n                    this.length++;\n                }\n            }\n        }\n    },\n    setproto = Set.prototype;\n    /*\\\n     * Set.push\n     [ method ]\n     **\n     * Adds each argument to the current set\n     = (object) original element\n    \\*/\n    setproto.push = function () {\n        var item,\n            len;\n        for (var i = 0, ii = arguments.length; i < ii; i++) {\n            item = arguments[i];\n            if (item) {\n                len = this.items.length;\n                this[len] = this.items[len] = item;\n                this.length++;\n            }\n        }\n        return this;\n    };\n    /*\\\n     * Set.pop\n     [ method ]\n     **\n     * Removes last element and returns it\n     = (object) element\n    \\*/\n    setproto.pop = function () {\n        this.length && delete this[this.length--];\n        return this.items.pop();\n    };\n    /*\\\n     * Set.forEach\n     [ method ]\n     **\n     * Executes given function for each element in the set\n     *\n     * If the function returns `false`, the loop stops running.\n     **\n     - callback (function) function to run\n     - thisArg (object) context object for the callback\n     = (object) Set object\n    \\*/\n    setproto.forEach = function (callback, thisArg) {\n        for (var i = 0, ii = this.items.length; i < ii; i++) {\n            if (callback.call(thisArg, this.items[i], i) === false) {\n                return this;\n            }\n        }\n        return this;\n    };\n    /*\\\n     * Set.animate\n     [ method ]\n     **\n     * Animates each element in set in sync.\n     *\n     **\n     - attrs (object) key-value pairs of destination attributes\n     - duration (number) duration of the animation in milliseconds\n     - easing (function) #optional easing function from @mina or custom\n     - callback (function) #optional callback function that executes when the animation ends\n     * or\n     - animation (array) array of animation parameter for each element in set in format `[attrs, duration, easing, callback]`\n     > Usage\n     | // animate all elements in set to radius 10\n     | set.animate({r: 10}, 500, mina.easein);\n     | // or\n     | // animate first element to radius 10, but second to radius 20 and in different time\n     | set.animate([{r: 10}, 500, mina.easein], [{r: 20}, 1500, mina.easein]);\n     = (Element) the current element\n    \\*/\n    setproto.animate = function (attrs, ms, easing, callback) {\n        if (typeof easing == \"function\" && !easing.length) {\n            callback = easing;\n            easing = mina.linear;\n        }\n        if (attrs instanceof Snap._.Animation) {\n            callback = attrs.callback;\n            easing = attrs.easing;\n            ms = easing.dur;\n            attrs = attrs.attr;\n        }\n        var args = arguments;\n        if (Snap.is(attrs, \"array\") && Snap.is(args[args.length - 1], \"array\")) {\n            var each = true;\n        }\n        var begin,\n            handler = function () {\n                if (begin) {\n                    this.b = begin;\n                } else {\n                    begin = this.b;\n                }\n            },\n            cb = 0,\n            set = this,\n            callbacker = callback && function () {\n                if (++cb == set.length) {\n                    callback.call(this);\n                }\n            };\n        return this.forEach(function (el, i) {\n            eve.once(\"snap.animcreated.\" + el.id, handler);\n            if (each) {\n                args[i] && el.animate.apply(el, args[i]);\n            } else {\n                el.animate(attrs, ms, easing, callbacker);\n            }\n        });\n    };\n    setproto.remove = function () {\n        while (this.length) {\n            this.pop().remove();\n        }\n        return this;\n    };\n    /*\\\n     * Set.bind\n     [ method ]\n     **\n     * Specifies how to handle a specific attribute when applied\n     * to a set.\n     *\n     **\n     - attr (string) attribute name\n     - callback (function) function to run\n     * or\n     - attr (string) attribute name\n     - element (Element) specific element in the set to apply the attribute to\n     * or\n     - attr (string) attribute name\n     - element (Element) specific element in the set to apply the attribute to\n     - eattr (string) attribute on the element to bind the attribute to\n     = (object) Set object\n    \\*/\n    setproto.bind = function (attr, a, b) {\n        var data = {};\n        if (typeof a == \"function\") {\n            this.bindings[attr] = a;\n        } else {\n            var aname = b || attr;\n            this.bindings[attr] = function (v) {\n                data[aname] = v;\n                a.attr(data);\n            };\n        }\n        return this;\n    };\n    setproto.attr = function (value) {\n        var unbound = {};\n        for (var k in value) {\n            if (this.bindings[k]) {\n                this.bindings[k](value[k]);\n            } else {\n                unbound[k] = value[k];\n            }\n        }\n        for (var i = 0, ii = this.items.length; i < ii; i++) {\n            this.items[i].attr(unbound);\n        }\n        return this;\n    };\n    /*\\\n     * Set.clear\n     [ method ]\n     **\n     * Removes all elements from the set\n    \\*/\n    setproto.clear = function () {\n        while (this.length) {\n            this.pop();\n        }\n    };\n    /*\\\n     * Set.splice\n     [ method ]\n     **\n     * Removes range of elements from the set\n     **\n     - index (number) position of the deletion\n     - count (number) number of element to remove\n     - insertion… (object) #optional elements to insert\n     = (object) set elements that were deleted\n    \\*/\n    setproto.splice = function (index, count, insertion) {\n        index = index < 0 ? mmax(this.length + index, 0) : index;\n        count = mmax(0, mmin(this.length - index, count));\n        var tail = [],\n            todel = [],\n            args = [],\n            i;\n        for (i = 2; i < arguments.length; i++) {\n            args.push(arguments[i]);\n        }\n        for (i = 0; i < count; i++) {\n            todel.push(this[index + i]);\n        }\n        for (; i < this.length - index; i++) {\n            tail.push(this[index + i]);\n        }\n        var arglen = args.length;\n        for (i = 0; i < arglen + tail.length; i++) {\n            this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];\n        }\n        i = this.items.length = this.length -= count - arglen;\n        while (this[i]) {\n            delete this[i++];\n        }\n        return new Set(todel);\n    };\n    /*\\\n     * Set.exclude\n     [ method ]\n     **\n     * Removes given element from the set\n     **\n     - element (object) element to remove\n     = (boolean) `true` if object was found and removed from the set\n    \\*/\n    setproto.exclude = function (el) {\n        for (var i = 0, ii = this.length; i < ii; i++) if (this[i] == el) {\n            this.splice(i, 1);\n            return true;\n        }\n        return false;\n    };\n    setproto.insertAfter = function (el) {\n        var i = this.items.length;\n        while (i--) {\n            this.items[i].insertAfter(el);\n        }\n        return this;\n    };\n    setproto.getBBox = function () {\n        var x = [],\n            y = [],\n            x2 = [],\n            y2 = [];\n        for (var i = this.items.length; i--;) if (!this.items[i].removed) {\n            var box = this.items[i].getBBox();\n            x.push(box.x);\n            y.push(box.y);\n            x2.push(box.x + box.width);\n            y2.push(box.y + box.height);\n        }\n        x = mmin.apply(0, x);\n        y = mmin.apply(0, y);\n        x2 = mmax.apply(0, x2);\n        y2 = mmax.apply(0, y2);\n        return {\n            x: x,\n            y: y,\n            x2: x2,\n            y2: y2,\n            width: x2 - x,\n            height: y2 - y,\n            cx: x + (x2 - x) / 2,\n            cy: y + (y2 - y) / 2\n        };\n    };\n    setproto.clone = function (s) {\n        s = new Set;\n        for (var i = 0, ii = this.items.length; i < ii; i++) {\n            s.push(this.items[i].clone());\n        }\n        return s;\n    };\n    setproto.toString = function () {\n        return \"Snap\\u2018s set\";\n    };\n    setproto.type = \"set\";\n    // export\n    Snap.Set = Set;\n    Snap.set = function () {\n        var set = new Set;\n        if (arguments.length) {\n            set.push.apply(set, Array.prototype.slice.call(arguments, 0));\n        }\n        return set;\n    };\n});\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n// http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob) {\n    var names = {},\n        reUnit = /[a-z]+$/i,\n        Str = String;\n    names.stroke = names.fill = \"colour\";\n    function getEmpty(item) {\n        var l = item[0];\n        switch (l.toLowerCase()) {\n            case \"t\": return [l, 0, 0];\n            case \"m\": return [l, 1, 0, 0, 1, 0, 0];\n            case \"r\": if (item.length == 4) {\n                return [l, 0, item[2], item[3]];\n            } else {\n                return [l, 0];\n            }\n            case \"s\": if (item.length == 5) {\n                return [l, 1, 1, item[3], item[4]];\n            } else if (item.length == 3) {\n                return [l, 1, 1];\n            } else {\n                return [l, 1];\n            }\n        }\n    }\n    function equaliseTransform(t1, t2, getBBox) {\n        t2 = Str(t2).replace(/\\.{3}|\\u2026/g, t1);\n        t1 = Snap.parseTransformString(t1) || [];\n        t2 = Snap.parseTransformString(t2) || [];\n        var maxlength = Math.max(t1.length, t2.length),\n            from = [],\n            to = [],\n            i = 0, j, jj,\n            tt1, tt2;\n        for (; i < maxlength; i++) {\n            tt1 = t1[i] || getEmpty(t2[i]);\n            tt2 = t2[i] || getEmpty(tt1);\n            if ((tt1[0] != tt2[0]) ||\n                (tt1[0].toLowerCase() == \"r\" && (tt1[2] != tt2[2] || tt1[3] != tt2[3])) ||\n                (tt1[0].toLowerCase() == \"s\" && (tt1[3] != tt2[3] || tt1[4] != tt2[4]))\n                ) {\n                    t1 = Snap._.transform2matrix(t1, getBBox());\n                    t2 = Snap._.transform2matrix(t2, getBBox());\n                    from = [[\"m\", t1.a, t1.b, t1.c, t1.d, t1.e, t1.f]];\n                    to = [[\"m\", t2.a, t2.b, t2.c, t2.d, t2.e, t2.f]];\n                    break;\n            }\n            from[i] = [];\n            to[i] = [];\n            for (j = 0, jj = Math.max(tt1.length, tt2.length); j < jj; j++) {\n                j in tt1 && (from[i][j] = tt1[j]);\n                j in tt2 && (to[i][j] = tt2[j]);\n            }\n        }\n        return {\n            from: path2array(from),\n            to: path2array(to),\n            f: getPath(from)\n        };\n    }\n    function getNumber(val) {\n        return val;\n    }\n    function getUnit(unit) {\n        return function (val) {\n            return +val.toFixed(3) + unit;\n        };\n    }\n    function getViewBox(val) {\n        return val.join(\" \");\n    }\n    function getColour(clr) {\n        return Snap.rgb(clr[0], clr[1], clr[2]);\n    }\n    function getPath(path) {\n        var k = 0, i, ii, j, jj, out, a, b = [];\n        for (i = 0, ii = path.length; i < ii; i++) {\n            out = \"[\";\n            a = ['\"' + path[i][0] + '\"'];\n            for (j = 1, jj = path[i].length; j < jj; j++) {\n                a[j] = \"val[\" + (k++) + \"]\";\n            }\n            out += a + \"]\";\n            b[i] = out;\n        }\n        return Function(\"val\", \"return Snap.path.toString.call([\" + b + \"])\");\n    }\n    function path2array(path) {\n        var out = [];\n        for (var i = 0, ii = path.length; i < ii; i++) {\n            for (var j = 1, jj = path[i].length; j < jj; j++) {\n                out.push(path[i][j]);\n            }\n        }\n        return out;\n    }\n    function isNumeric(obj) {\n        return isFinite(parseFloat(obj));\n    }\n    function arrayEqual(arr1, arr2) {\n        if (!Snap.is(arr1, \"array\") || !Snap.is(arr2, \"array\")) {\n            return false;\n        }\n        return arr1.toString() == arr2.toString();\n    }\n    Element.prototype.equal = function (name, b) {\n        return eve(\"snap.util.equal\", this, name, b).firstDefined();\n    };\n    eve.on(\"snap.util.equal\", function (name, b) {\n        var A, B, a = Str(this.attr(name) || \"\"),\n            el = this;\n        if (isNumeric(a) && isNumeric(b)) {\n            return {\n                from: parseFloat(a),\n                to: parseFloat(b),\n                f: getNumber\n            };\n        }\n        if (names[name] == \"colour\") {\n            A = Snap.color(a);\n            B = Snap.color(b);\n            return {\n                from: [A.r, A.g, A.b, A.opacity],\n                to: [B.r, B.g, B.b, B.opacity],\n                f: getColour\n            };\n        }\n        if (name == \"viewBox\") {\n            A = this.attr(name).vb.split(\" \").map(Number);\n            B = b.split(\" \").map(Number);\n            return {\n                from: A,\n                to: B,\n                f: getViewBox\n            };\n        }\n        if (name == \"transform\" || name == \"gradientTransform\" || name == \"patternTransform\") {\n            if (b instanceof Snap.Matrix) {\n                b = b.toTransformString();\n            }\n            if (!Snap._.rgTransform.test(b)) {\n                b = Snap._.svgTransform2string(b);\n            }\n            return equaliseTransform(a, b, function () {\n                return el.getBBox(1);\n            });\n        }\n        if (name == \"d\" || name == \"path\") {\n            A = Snap.path.toCubic(a, b);\n            return {\n                from: path2array(A[0]),\n                to: path2array(A[1]),\n                f: getPath(A[0])\n            };\n        }\n        if (name == \"points\") {\n            A = Str(a).split(Snap._.separator);\n            B = Str(b).split(Snap._.separator);\n            return {\n                from: A,\n                to: B,\n                f: function (val) { return val; }\n            };\n        }\n        var aUnit = a.match(reUnit),\n            bUnit = Str(b).match(reUnit);\n        if (aUnit && arrayEqual(aUnit, bUnit)) {\n            return {\n                from: parseFloat(a),\n                to: parseFloat(b),\n                f: getUnit(aUnit)\n            };\n        } else {\n            return {\n                from: this.asPX(name),\n                to: this.asPX(name, b),\n                f: getNumber\n            };\n        }\n    });\n});\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n// http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob) {\n    var elproto = Element.prototype,\n    has = \"hasOwnProperty\",\n    supportsTouch = \"createTouch\" in glob.doc,\n    events = [\n        \"click\", \"dblclick\", \"mousedown\", \"mousemove\", \"mouseout\",\n        \"mouseover\", \"mouseup\", \"touchstart\", \"touchmove\", \"touchend\",\n        \"touchcancel\"\n    ],\n    touchMap = {\n        mousedown: \"touchstart\",\n        mousemove: \"touchmove\",\n        mouseup: \"touchend\"\n    },\n    getScroll = function (xy, el) {\n        var name = xy == \"y\" ? \"scrollTop\" : \"scrollLeft\",\n            doc = el && el.node ? el.node.ownerDocument : glob.doc;\n        return doc[name in doc.documentElement ? \"documentElement\" : \"body\"][name];\n    },\n    preventDefault = function () {\n        this.returnValue = false;\n    },\n    preventTouch = function () {\n        return this.originalEvent.preventDefault();\n    },\n    stopPropagation = function () {\n        this.cancelBubble = true;\n    },\n    stopTouch = function () {\n        return this.originalEvent.stopPropagation();\n    },\n    addEvent = function (obj, type, fn, element) {\n        var realName = supportsTouch && touchMap[type] ? touchMap[type] : type,\n            f = function (e) {\n                var scrollY = getScroll(\"y\", element),\n                    scrollX = getScroll(\"x\", element);\n                if (supportsTouch && touchMap[has](type)) {\n                    for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {\n                        if (e.targetTouches[i].target == obj || obj.contains(e.targetTouches[i].target)) {\n                            var olde = e;\n                            e = e.targetTouches[i];\n                            e.originalEvent = olde;\n                            e.preventDefault = preventTouch;\n                            e.stopPropagation = stopTouch;\n                            break;\n                        }\n                    }\n                }\n                var x = e.clientX + scrollX,\n                    y = e.clientY + scrollY;\n                return fn.call(element, e, x, y);\n            };\n\n        if (type !== realName) {\n            obj.addEventListener(type, f, false);\n        }\n\n        obj.addEventListener(realName, f, false);\n\n        return function () {\n            if (type !== realName) {\n                obj.removeEventListener(type, f, false);\n            }\n\n            obj.removeEventListener(realName, f, false);\n            return true;\n        };\n    },\n    drag = [],\n    dragMove = function (e) {\n        var x = e.clientX,\n            y = e.clientY,\n            scrollY = getScroll(\"y\"),\n            scrollX = getScroll(\"x\"),\n            dragi,\n            j = drag.length;\n        while (j--) {\n            dragi = drag[j];\n            if (supportsTouch) {\n                var i = e.touches && e.touches.length,\n                    touch;\n                while (i--) {\n                    touch = e.touches[i];\n                    if (touch.identifier == dragi.el._drag.id || dragi.el.node.contains(touch.target)) {\n                        x = touch.clientX;\n                        y = touch.clientY;\n                        (e.originalEvent ? e.originalEvent : e).preventDefault();\n                        break;\n                    }\n                }\n            } else {\n                e.preventDefault();\n            }\n            var node = dragi.el.node,\n                o,\n                next = node.nextSibling,\n                parent = node.parentNode,\n                display = node.style.display;\n            // glob.win.opera && parent.removeChild(node);\n            // node.style.display = \"none\";\n            // o = dragi.el.paper.getElementByPoint(x, y);\n            // node.style.display = display;\n            // glob.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));\n            // o && eve(\"snap.drag.over.\" + dragi.el.id, dragi.el, o);\n            x += scrollX;\n            y += scrollY;\n            eve(\"snap.drag.move.\" + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);\n        }\n    },\n    dragUp = function (e) {\n        Snap.unmousemove(dragMove).unmouseup(dragUp);\n        var i = drag.length,\n            dragi;\n        while (i--) {\n            dragi = drag[i];\n            dragi.el._drag = {};\n            eve(\"snap.drag.end.\" + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);\n            eve.off(\"snap.drag.*.\" + dragi.el.id);\n        }\n        drag = [];\n    };\n    /*\\\n     * Element.click\n     [ method ]\n     **\n     * Adds a click event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.unclick\n     [ method ]\n     **\n     * Removes a click event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    \n    /*\\\n     * Element.dblclick\n     [ method ]\n     **\n     * Adds a double click event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.undblclick\n     [ method ]\n     **\n     * Removes a double click event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    \n    /*\\\n     * Element.mousedown\n     [ method ]\n     **\n     * Adds a mousedown event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.unmousedown\n     [ method ]\n     **\n     * Removes a mousedown event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    \n    /*\\\n     * Element.mousemove\n     [ method ]\n     **\n     * Adds a mousemove event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.unmousemove\n     [ method ]\n     **\n     * Removes a mousemove event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    \n    /*\\\n     * Element.mouseout\n     [ method ]\n     **\n     * Adds a mouseout event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.unmouseout\n     [ method ]\n     **\n     * Removes a mouseout event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    \n    /*\\\n     * Element.mouseover\n     [ method ]\n     **\n     * Adds a mouseover event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.unmouseover\n     [ method ]\n     **\n     * Removes a mouseover event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    \n    /*\\\n     * Element.mouseup\n     [ method ]\n     **\n     * Adds a mouseup event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.unmouseup\n     [ method ]\n     **\n     * Removes a mouseup event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    \n    /*\\\n     * Element.touchstart\n     [ method ]\n     **\n     * Adds a touchstart event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.untouchstart\n     [ method ]\n     **\n     * Removes a touchstart event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    \n    /*\\\n     * Element.touchmove\n     [ method ]\n     **\n     * Adds a touchmove event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.untouchmove\n     [ method ]\n     **\n     * Removes a touchmove event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    \n    /*\\\n     * Element.touchend\n     [ method ]\n     **\n     * Adds a touchend event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.untouchend\n     [ method ]\n     **\n     * Removes a touchend event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    \n    /*\\\n     * Element.touchcancel\n     [ method ]\n     **\n     * Adds a touchcancel event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.untouchcancel\n     [ method ]\n     **\n     * Removes a touchcancel event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    for (var i = events.length; i--;) {\n        (function (eventName) {\n            Snap[eventName] = elproto[eventName] = function (fn, scope) {\n                if (Snap.is(fn, \"function\")) {\n                    this.events = this.events || [];\n                    this.events.push({\n                        name: eventName,\n                        f: fn,\n                        unbind: addEvent(this.node || document, eventName, fn, scope || this)\n                    });\n                } else {\n                    for (var i = 0, ii = this.events.length; i < ii; i++) if (this.events[i].name == eventName) {\n                        try {\n                            this.events[i].f.call(this);\n                        } catch (e) {}\n                    }\n                }\n                return this;\n            };\n            Snap[\"un\" + eventName] =\n            elproto[\"un\" + eventName] = function (fn) {\n                var events = this.events || [],\n                    l = events.length;\n                while (l--) if (events[l].name == eventName &&\n                               (events[l].f == fn || !fn)) {\n                    events[l].unbind();\n                    events.splice(l, 1);\n                    !events.length && delete this.events;\n                    return this;\n                }\n                return this;\n            };\n        })(events[i]);\n    }\n    /*\\\n     * Element.hover\n     [ method ]\n     **\n     * Adds hover event handlers to the element\n     - f_in (function) handler for hover in\n     - f_out (function) handler for hover out\n     - icontext (object) #optional context for hover in handler\n     - ocontext (object) #optional context for hover out handler\n     = (object) @Element\n    \\*/\n    elproto.hover = function (f_in, f_out, scope_in, scope_out) {\n        return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);\n    };\n    /*\\\n     * Element.unhover\n     [ method ]\n     **\n     * Removes hover event handlers from the element\n     - f_in (function) handler for hover in\n     - f_out (function) handler for hover out\n     = (object) @Element\n    \\*/\n    elproto.unhover = function (f_in, f_out) {\n        return this.unmouseover(f_in).unmouseout(f_out);\n    };\n    var draggable = [];\n    // SIERRA unclear what _context_ refers to for starting, ending, moving the drag gesture.\n    // SIERRA Element.drag(): _x position of the mouse_: Where are the x/y values offset from?\n    // SIERRA Element.drag(): much of this member's doc appears to be duplicated for some reason.\n    // SIERRA Unclear about this sentence: _Additionally following drag events will be triggered: drag.start.<id> on start, drag.end.<id> on end and drag.move.<id> on every move._ Is there a global _drag_ object to which you can assign handlers keyed by an element's ID?\n    /*\\\n     * Element.drag\n     [ method ]\n     **\n     * Adds event handlers for an element's drag gesture\n     **\n     - onmove (function) handler for moving\n     - onstart (function) handler for drag start\n     - onend (function) handler for drag end\n     - mcontext (object) #optional context for moving handler\n     - scontext (object) #optional context for drag start handler\n     - econtext (object) #optional context for drag end handler\n     * Additionaly following `drag` events are triggered: `drag.start.<id>` on start, \n     * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element is dragged over another element \n     * `drag.over.<id>` fires as well.\n     *\n     * Start event and start handler are called in specified context or in context of the element with following parameters:\n     o x (number) x position of the mouse\n     o y (number) y position of the mouse\n     o event (object) DOM event object\n     * Move event and move handler are called in specified context or in context of the element with following parameters:\n     o dx (number) shift by x from the start point\n     o dy (number) shift by y from the start point\n     o x (number) x position of the mouse\n     o y (number) y position of the mouse\n     o event (object) DOM event object\n     * End event and end handler are called in specified context or in context of the element with following parameters:\n     o event (object) DOM event object\n     = (object) @Element\n    \\*/\n    elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {\n        var el = this;\n        if (!arguments.length) {\n            var origTransform;\n            return el.drag(function (dx, dy) {\n                this.attr({\n                    transform: origTransform + (origTransform ? \"T\" : \"t\") + [dx, dy]\n                });\n            }, function () {\n                origTransform = this.transform().local;\n            });\n        }\n        function start(e, x, y) {\n            (e.originalEvent || e).preventDefault();\n            el._drag.x = x;\n            el._drag.y = y;\n            el._drag.id = e.identifier;\n            !drag.length && Snap.mousemove(dragMove).mouseup(dragUp);\n            drag.push({el: el, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope});\n            onstart && eve.on(\"snap.drag.start.\" + el.id, onstart);\n            onmove && eve.on(\"snap.drag.move.\" + el.id, onmove);\n            onend && eve.on(\"snap.drag.end.\" + el.id, onend);\n            eve(\"snap.drag.start.\" + el.id, start_scope || move_scope || el, x, y, e);\n        }\n        function init(e, x, y) {\n            eve(\"snap.draginit.\" + el.id, el, e, x, y);\n        }\n        eve.on(\"snap.draginit.\" + el.id, start);\n        el._drag = {};\n        draggable.push({el: el, start: start, init: init});\n        el.mousedown(init);\n        return el;\n    };\n    /*\n     * Element.onDragOver\n     [ method ]\n     **\n     * Shortcut to assign event handler for `drag.over.<id>` event, where `id` is the element's `id` (see @Element.id)\n     - f (function) handler for event, first argument would be the element you are dragging over\n    \\*/\n    // elproto.onDragOver = function (f) {\n    //     f ? eve.on(\"snap.drag.over.\" + this.id, f) : eve.unbind(\"snap.drag.over.\" + this.id);\n    // };\n    /*\\\n     * Element.undrag\n     [ method ]\n     **\n     * Removes all drag event handlers from the given element\n    \\*/\n    elproto.undrag = function () {\n        var i = draggable.length;\n        while (i--) if (draggable[i].el == this) {\n            this.unmousedown(draggable[i].init);\n            draggable.splice(i, 1);\n            eve.unbind(\"snap.drag.*.\" + this.id);\n            eve.unbind(\"snap.draginit.\" + this.id);\n        }\n        !draggable.length && Snap.unmousemove(dragMove).unmouseup(dragUp);\n        return this;\n    };\n});\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n// http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob) {\n    var elproto = Element.prototype,\n        pproto = Paper.prototype,\n        rgurl = /^\\s*url\\((.+)\\)/,\n        Str = String,\n        $ = Snap._.$;\n    Snap.filter = {};\n    /*\\\n     * Paper.filter\n     [ method ]\n     **\n     * Creates a `<filter>` element\n     **\n     - filstr (string) SVG fragment of filter provided as a string\n     = (object) @Element\n     * Note: It is recommended to use filters embedded into the page inside an empty SVG element.\n     > Usage\n     | var f = paper.filter('<feGaussianBlur stdDeviation=\"2\"/>'),\n     |     c = paper.circle(10, 10, 10).attr({\n     |         filter: f\n     |     });\n    \\*/\n    pproto.filter = function (filstr) {\n        var paper = this;\n        if (paper.type != \"svg\") {\n            paper = paper.paper;\n        }\n        var f = Snap.parse(Str(filstr)),\n            id = Snap._.id(),\n            width = paper.node.offsetWidth,\n            height = paper.node.offsetHeight,\n            filter = $(\"filter\");\n        $(filter, {\n            id: id,\n            filterUnits: \"userSpaceOnUse\"\n        });\n        filter.appendChild(f.node);\n        paper.defs.appendChild(filter);\n        return new Element(filter);\n    };\n    \n    eve.on(\"snap.util.getattr.filter\", function () {\n        eve.stop();\n        var p = $(this.node, \"filter\");\n        if (p) {\n            var match = Str(p).match(rgurl);\n            return match && Snap.select(match[1]);\n        }\n    });\n    eve.on(\"snap.util.attr.filter\", function (value) {\n        if (value instanceof Element && value.type == \"filter\") {\n            eve.stop();\n            var id = value.node.id;\n            if (!id) {\n                $(value.node, {id: value.id});\n                id = value.id;\n            }\n            $(this.node, {\n                filter: Snap.url(id)\n            });\n        }\n        if (!value || value == \"none\") {\n            eve.stop();\n            this.node.removeAttribute(\"filter\");\n        }\n    });\n    /*\\\n     * Snap.filter.blur\n     [ method ]\n     **\n     * Returns an SVG markup string for the blur filter\n     **\n     - x (number) amount of horizontal blur, in pixels\n     - y (number) #optional amount of vertical blur, in pixels\n     = (string) filter representation\n     > Usage\n     | var f = paper.filter(Snap.filter.blur(5, 10)),\n     |     c = paper.circle(10, 10, 10).attr({\n     |         filter: f\n     |     });\n    \\*/\n    Snap.filter.blur = function (x, y) {\n        if (x == null) {\n            x = 2;\n        }\n        var def = y == null ? x : [x, y];\n        return Snap.format('\\<feGaussianBlur stdDeviation=\"{def}\"/>', {\n            def: def\n        });\n    };\n    Snap.filter.blur.toString = function () {\n        return this();\n    };\n    /*\\\n     * Snap.filter.shadow\n     [ method ]\n     **\n     * Returns an SVG markup string for the shadow filter\n     **\n     - dx (number) #optional horizontal shift of the shadow, in pixels\n     - dy (number) #optional vertical shift of the shadow, in pixels\n     - blur (number) #optional amount of blur\n     - color (string) #optional color of the shadow\n     - opacity (number) #optional `0..1` opacity of the shadow\n     * or\n     - dx (number) #optional horizontal shift of the shadow, in pixels\n     - dy (number) #optional vertical shift of the shadow, in pixels\n     - color (string) #optional color of the shadow\n     - opacity (number) #optional `0..1` opacity of the shadow\n     * which makes blur default to `4`. Or\n     - dx (number) #optional horizontal shift of the shadow, in pixels\n     - dy (number) #optional vertical shift of the shadow, in pixels\n     - opacity (number) #optional `0..1` opacity of the shadow\n     = (string) filter representation\n     > Usage\n     | var f = paper.filter(Snap.filter.shadow(0, 2, 3)),\n     |     c = paper.circle(10, 10, 10).attr({\n     |         filter: f\n     |     });\n    \\*/\n    Snap.filter.shadow = function (dx, dy, blur, color, opacity) {\n        if (typeof blur == \"string\") {\n            color = blur;\n            opacity = color;\n            blur = 4;\n        }\n        if (typeof color != \"string\") {\n            opacity = color;\n            color = \"#000\";\n        }\n        color = color || \"#000\";\n        if (blur == null) {\n            blur = 4;\n        }\n        if (opacity == null) {\n            opacity = 1;\n        }\n        if (dx == null) {\n            dx = 0;\n            dy = 2;\n        }\n        if (dy == null) {\n            dy = dx;\n        }\n        color = Snap.color(color);\n        return Snap.format('<feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"{blur}\"/><feOffset dx=\"{dx}\" dy=\"{dy}\" result=\"offsetblur\"/><feFlood flood-color=\"{color}\"/><feComposite in2=\"offsetblur\" operator=\"in\"/><feComponentTransfer><feFuncA type=\"linear\" slope=\"{opacity}\"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in=\"SourceGraphic\"/></feMerge>', {\n            color: color,\n            dx: dx,\n            dy: dy,\n            blur: blur,\n            opacity: opacity\n        });\n    };\n    Snap.filter.shadow.toString = function () {\n        return this();\n    };\n    /*\\\n     * Snap.filter.grayscale\n     [ method ]\n     **\n     * Returns an SVG markup string for the grayscale filter\n     **\n     - amount (number) amount of filter (`0..1`)\n     = (string) filter representation\n    \\*/\n    Snap.filter.grayscale = function (amount) {\n        if (amount == null) {\n            amount = 1;\n        }\n        return Snap.format('<feColorMatrix type=\"matrix\" values=\"{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {b} {h} 0 0 0 0 0 1 0\"/>', {\n            a: 0.2126 + 0.7874 * (1 - amount),\n            b: 0.7152 - 0.7152 * (1 - amount),\n            c: 0.0722 - 0.0722 * (1 - amount),\n            d: 0.2126 - 0.2126 * (1 - amount),\n            e: 0.7152 + 0.2848 * (1 - amount),\n            f: 0.0722 - 0.0722 * (1 - amount),\n            g: 0.2126 - 0.2126 * (1 - amount),\n            h: 0.0722 + 0.9278 * (1 - amount)\n        });\n    };\n    Snap.filter.grayscale.toString = function () {\n        return this();\n    };\n    /*\\\n     * Snap.filter.sepia\n     [ method ]\n     **\n     * Returns an SVG markup string for the sepia filter\n     **\n     - amount (number) amount of filter (`0..1`)\n     = (string) filter representation\n    \\*/\n    Snap.filter.sepia = function (amount) {\n        if (amount == null) {\n            amount = 1;\n        }\n        return Snap.format('<feColorMatrix type=\"matrix\" values=\"{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {h} {i} 0 0 0 0 0 1 0\"/>', {\n            a: 0.393 + 0.607 * (1 - amount),\n            b: 0.769 - 0.769 * (1 - amount),\n            c: 0.189 - 0.189 * (1 - amount),\n            d: 0.349 - 0.349 * (1 - amount),\n            e: 0.686 + 0.314 * (1 - amount),\n            f: 0.168 - 0.168 * (1 - amount),\n            g: 0.272 - 0.272 * (1 - amount),\n            h: 0.534 - 0.534 * (1 - amount),\n            i: 0.131 + 0.869 * (1 - amount)\n        });\n    };\n    Snap.filter.sepia.toString = function () {\n        return this();\n    };\n    /*\\\n     * Snap.filter.saturate\n     [ method ]\n     **\n     * Returns an SVG markup string for the saturate filter\n     **\n     - amount (number) amount of filter (`0..1`)\n     = (string) filter representation\n    \\*/\n    Snap.filter.saturate = function (amount) {\n        if (amount == null) {\n            amount = 1;\n        }\n        return Snap.format('<feColorMatrix type=\"saturate\" values=\"{amount}\"/>', {\n            amount: 1 - amount\n        });\n    };\n    Snap.filter.saturate.toString = function () {\n        return this();\n    };\n    /*\\\n     * Snap.filter.hueRotate\n     [ method ]\n     **\n     * Returns an SVG markup string for the hue-rotate filter\n     **\n     - angle (number) angle of rotation\n     = (string) filter representation\n    \\*/\n    Snap.filter.hueRotate = function (angle) {\n        angle = angle || 0;\n        return Snap.format('<feColorMatrix type=\"hueRotate\" values=\"{angle}\"/>', {\n            angle: angle\n        });\n    };\n    Snap.filter.hueRotate.toString = function () {\n        return this();\n    };\n    /*\\\n     * Snap.filter.invert\n     [ method ]\n     **\n     * Returns an SVG markup string for the invert filter\n     **\n     - amount (number) amount of filter (`0..1`)\n     = (string) filter representation\n    \\*/\n    Snap.filter.invert = function (amount) {\n        if (amount == null) {\n            amount = 1;\n        }\n//        <feColorMatrix type=\"matrix\" values=\"-1 0 0 0 1  0 -1 0 0 1  0 0 -1 0 1  0 0 0 1 0\" color-interpolation-filters=\"sRGB\"/>\n        return Snap.format('<feComponentTransfer><feFuncR type=\"table\" tableValues=\"{amount} {amount2}\"/><feFuncG type=\"table\" tableValues=\"{amount} {amount2}\"/><feFuncB type=\"table\" tableValues=\"{amount} {amount2}\"/></feComponentTransfer>', {\n            amount: amount,\n            amount2: 1 - amount\n        });\n    };\n    Snap.filter.invert.toString = function () {\n        return this();\n    };\n    /*\\\n     * Snap.filter.brightness\n     [ method ]\n     **\n     * Returns an SVG markup string for the brightness filter\n     **\n     - amount (number) amount of filter (`0..1`)\n     = (string) filter representation\n    \\*/\n    Snap.filter.brightness = function (amount) {\n        if (amount == null) {\n            amount = 1;\n        }\n        return Snap.format('<feComponentTransfer><feFuncR type=\"linear\" slope=\"{amount}\"/><feFuncG type=\"linear\" slope=\"{amount}\"/><feFuncB type=\"linear\" slope=\"{amount}\"/></feComponentTransfer>', {\n            amount: amount\n        });\n    };\n    Snap.filter.brightness.toString = function () {\n        return this();\n    };\n    /*\\\n     * Snap.filter.contrast\n     [ method ]\n     **\n     * Returns an SVG markup string for the contrast filter\n     **\n     - amount (number) amount of filter (`0..1`)\n     = (string) filter representation\n    \\*/\n    Snap.filter.contrast = function (amount) {\n        if (amount == null) {\n            amount = 1;\n        }\n        return Snap.format('<feComponentTransfer><feFuncR type=\"linear\" slope=\"{amount}\" intercept=\"{amount2}\"/><feFuncG type=\"linear\" slope=\"{amount}\" intercept=\"{amount2}\"/><feFuncB type=\"linear\" slope=\"{amount}\" intercept=\"{amount2}\"/></feComponentTransfer>', {\n            amount: amount,\n            amount2: .5 - amount / 2\n        });\n    };\n    Snap.filter.contrast.toString = function () {\n        return this();\n    };\n});\n\n// Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n    var box = Snap._.box,\n        is = Snap.is,\n        firstLetter = /^[^a-z]*([tbmlrc])/i,\n        toString = function () {\n            return \"T\" + this.dx + \",\" + this.dy;\n        };\n    /*\\\n     * Element.getAlign\n     [ method ]\n     **\n     * Returns shift needed to align the element relatively to given element.\n     * If no elements specified, parent `<svg>` container will be used.\n     - el (object) @optional alignment element\n     - way (string) one of six values: `\"top\"`, `\"middle\"`, `\"bottom\"`, `\"left\"`, `\"center\"`, `\"right\"`\n     = (object|string) Object in format `{dx: , dy: }` also has a string representation as a transformation string\n     > Usage\n     | el.transform(el.getAlign(el2, \"top\"));\n     * or\n     | var dy = el.getAlign(el2, \"top\").dy;\n    \\*/\n    Element.prototype.getAlign = function (el, way) {\n        if (way == null && is(el, \"string\")) {\n            way = el;\n            el = null;\n        }\n        el = el || this.paper;\n        var bx = el.getBBox ? el.getBBox() : box(el),\n            bb = this.getBBox(),\n            out = {};\n        way = way && way.match(firstLetter);\n        way = way ? way[1].toLowerCase() : \"c\";\n        switch (way) {\n            case \"t\":\n                out.dx = 0;\n                out.dy = bx.y - bb.y;\n            break;\n            case \"b\":\n                out.dx = 0;\n                out.dy = bx.y2 - bb.y2;\n            break;\n            case \"m\":\n                out.dx = 0;\n                out.dy = bx.cy - bb.cy;\n            break;\n            case \"l\":\n                out.dx = bx.x - bb.x;\n                out.dy = 0;\n            break;\n            case \"r\":\n                out.dx = bx.x2 - bb.x2;\n                out.dy = 0;\n            break;\n            default:\n                out.dx = bx.cx - bb.cx;\n                out.dy = 0;\n            break;\n        }\n        out.toString = toString;\n        return out;\n    };\n    /*\\\n     * Element.align\n     [ method ]\n     **\n     * Aligns the element relatively to given one via transformation.\n     * If no elements specified, parent `<svg>` container will be used.\n     - el (object) @optional alignment element\n     - way (string) one of six values: `\"top\"`, `\"middle\"`, `\"bottom\"`, `\"left\"`, `\"center\"`, `\"right\"`\n     = (object) this element\n     > Usage\n     | el.align(el2, \"top\");\n     * or\n     | el.align(\"middle\");\n    \\*/\n    Element.prototype.align = function (el, way) {\n        return this.transform(\"...\" + this.getAlign(el, way));\n    };\n});\n\nreturn Snap;\n}));\n}.call(window));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/snapsvg/dist/snap.svg.js\n// module id = 6\n// module chunks = 2","// Sets up the parser generated by canopy to use the\n// [Node](./javascript/node.html) subclasses in the generated tree. This is all\n// a bit of a hack that is dependent on how canopy creates nodes in its parse\n// tree.\nimport parser from './grammar.peg';\n\nimport Node from './node.js';\nimport Root from './root.js';\nimport Regexp from './regexp.js';\nimport Match from './match.js';\nimport MatchFragment from './match_fragment.js';\nimport Anchor from './anchor.js';\nimport Subexp from './subexp.js';\nimport Charset from './charset.js';\nimport CharsetEscape from './charset_escape.js';\nimport CharsetRange from './charset_range.js';\nimport Literal from './literal.js';\nimport Escape from './escape.js';\nimport AnyCharacter from './any_character.js';\nimport Repeat from './repeat.js';\nimport RepeatAny from './repeat_any.js';\nimport RepeatOptional from './repeat_optional.js';\nimport RepeatRequired from './repeat_required.js';\nimport RepeatSpec from './repeat_spec.js';\n\n// Canopy creates an instance of SyntaxNode for each element in the tree, then\n// adds any necessary fields to that instance. In this case, we're replacing\n// the default class with the Node class.\nparser.Parser.SyntaxNode      = Node;\n\n// Once the SyntaxNode instance is created, the specific node type object is\n// overlayed onto it. This causes the module attribute on the Node to be set,\n// which updates the Node instance into the more specific \"subclass\" that is\n// used for rendering.\nparser.Parser.Root            = { module: Root };\nparser.Parser.Regexp          = { module: Regexp };\nparser.Parser.Match           = { module: Match };\nparser.Parser.MatchFragment   = { module: MatchFragment };\nparser.Parser.Anchor          = { module: Anchor };\nparser.Parser.Subexp          = { module: Subexp };\nparser.Parser.Charset         = { module: Charset };\nparser.Parser.CharsetEscape   = { module: CharsetEscape };\nparser.Parser.CharsetRange    = { module: CharsetRange };\nparser.Parser.Literal         = { module: Literal };\nparser.Parser.Escape          = { module: Escape };\nparser.Parser.AnyCharacter    = { module: AnyCharacter };\nparser.Parser.Repeat          = { module: Repeat };\nparser.Parser.RepeatAny       = { module: RepeatAny };\nparser.Parser.RepeatOptional  = { module: RepeatOptional };\nparser.Parser.RepeatRequired  = { module: RepeatRequired };\nparser.Parser.RepeatSpec      = { module: RepeatSpec };\n\nexport default parser;\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/parser/javascript/parser.js","(function() {\n  var extend = function (destination, source) {\n    if (!destination || !source) return destination;\n    for (var key in source) {\n      if (destination[key] !== source[key])\n        destination[key] = source[key];\n    }\n    return destination;\n  };\n  \n  var find = function (root, objectName) {\n    var parts = objectName.split('.'),\n        part;\n    \n    while (part = parts.shift()) {\n      root = root[part];\n      if (root === undefined)\n        throw new Error('Cannot find object named ' + objectName);\n    }\n    return root;\n  };\n  \n  var formatError = function (error) {\n    var lines  = error.input.split(/\\n/g),\n        lineNo = 0,\n        offset = 0;\n    \n    while (offset < error.offset + 1) {\n      offset += lines[lineNo].length + 1;\n      lineNo += 1;\n    }\n    var message = 'Line ' + lineNo + ': expected ' + error.expected + '\\n',\n        line    = lines[lineNo - 1];\n    \n    message += line + '\\n';\n    offset  -= line.length + 1;\n    \n    while (offset < error.offset) {\n      message += ' ';\n      offset  += 1;\n    }\n    return message + '^';\n  };\n  \n  var Grammar = {\n    __consume__root: function(input) {\n      var address0 = null, index0 = this._offset;\n      this._nodeCache[\"root\"] = this._nodeCache[\"root\"] || {};\n      var cached = this._nodeCache[\"root\"][index0];\n      if (cached) {\n        this._offset += cached.textValue.length;\n        return cached;\n      }\n      var index1 = this._offset;\n      var index2 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n      var address1 = null;\n      var slice0 = null;\n      if (this._input.length > this._offset) {\n        slice0 = this._input.substring(this._offset, this._offset + 1);\n      } else {\n        slice0 = null;\n      }\n      if (slice0 === \"/\") {\n        var klass0 = this.constructor.SyntaxNode;\n        var type0 = null;\n        address1 = new klass0(\"/\", this._offset, []);\n        if (typeof type0 === \"object\") {\n          extend(address1, type0);\n        }\n        this._offset += 1;\n      } else {\n        address1 = null;\n        var slice1 = null;\n        if (this._input.length > this._offset) {\n          slice1 = this._input.substring(this._offset, this._offset + 1);\n        } else {\n          slice1 = null;\n        }\n        if (!this.error || this.error.offset <= this._offset) {\n          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"/\\\"\"};\n        }\n      }\n      if (address1) {\n        elements0.push(address1);\n        text0 += address1.textValue;\n        var address2 = null;\n        address2 = this.__consume__regexp();\n        if (address2) {\n          elements0.push(address2);\n          text0 += address2.textValue;\n          labelled0.regexp = address2;\n          var address3 = null;\n          var slice2 = null;\n          if (this._input.length > this._offset) {\n            slice2 = this._input.substring(this._offset, this._offset + 1);\n          } else {\n            slice2 = null;\n          }\n          if (slice2 === \"/\") {\n            var klass1 = this.constructor.SyntaxNode;\n            var type1 = null;\n            address3 = new klass1(\"/\", this._offset, []);\n            if (typeof type1 === \"object\") {\n              extend(address3, type1);\n            }\n            this._offset += 1;\n          } else {\n            address3 = null;\n            var slice3 = null;\n            if (this._input.length > this._offset) {\n              slice3 = this._input.substring(this._offset, this._offset + 1);\n            } else {\n              slice3 = null;\n            }\n            if (!this.error || this.error.offset <= this._offset) {\n              this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"/\\\"\"};\n            }\n          }\n          if (address3) {\n            elements0.push(address3);\n            text0 += address3.textValue;\n            var address4 = null;\n            var remaining0 = 0, index3 = this._offset, elements1 = [], text1 = \"\", address5 = true;\n            while (address5) {\n              var slice4 = null;\n              if (this._input.length > this._offset) {\n                slice4 = this._input.substring(this._offset, this._offset + 1);\n              } else {\n                slice4 = null;\n              }\n              if (slice4 && /^[igm]/.test(slice4)) {\n                var klass2 = this.constructor.SyntaxNode;\n                var type2 = null;\n                address5 = new klass2(slice4, this._offset, []);\n                if (typeof type2 === \"object\") {\n                  extend(address5, type2);\n                }\n                this._offset += 1;\n              } else {\n                address5 = null;\n                var slice5 = null;\n                if (this._input.length > this._offset) {\n                  slice5 = this._input.substring(this._offset, this._offset + 1);\n                } else {\n                  slice5 = null;\n                }\n                if (!this.error || this.error.offset <= this._offset) {\n                  this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[igm]\"};\n                }\n              }\n              if (address5) {\n                elements1.push(address5);\n                text1 += address5.textValue;\n                remaining0 -= 1;\n              }\n            }\n            if (remaining0 <= 0) {\n              this._offset = index3;\n              var klass3 = this.constructor.SyntaxNode;\n              var type3 = null;\n              address4 = new klass3(text1, this._offset, elements1);\n              if (typeof type3 === \"object\") {\n                extend(address4, type3);\n              }\n              this._offset += text1.length;\n            } else {\n              address4 = null;\n            }\n            if (address4) {\n              elements0.push(address4);\n              text0 += address4.textValue;\n              labelled0.flags = address4;\n            } else {\n              elements0 = null;\n              this._offset = index2;\n            }\n          } else {\n            elements0 = null;\n            this._offset = index2;\n          }\n        } else {\n          elements0 = null;\n          this._offset = index2;\n        }\n      } else {\n        elements0 = null;\n        this._offset = index2;\n      }\n      if (elements0) {\n        this._offset = index2;\n        var klass4 = this.constructor.SyntaxNode;\n        var type4 = null;\n        address0 = new klass4(text0, this._offset, elements0, labelled0);\n        if (typeof type4 === \"object\") {\n          extend(address0, type4);\n        }\n        this._offset += text0.length;\n      } else {\n        address0 = null;\n      }\n      if (address0) {\n        var type5 = find(this.constructor, \"Root\");\n        if (typeof type5 === \"object\") {\n          extend(address0, type5);\n        }\n      } else {\n        this._offset = index1;\n        var index4 = this._offset, elements2 = [], labelled1 = {}, text2 = \"\";\n        var address6 = null;\n        address6 = this.__consume__regexp();\n        if (address6) {\n          elements2.push(address6);\n          text2 += address6.textValue;\n          labelled1.regexp = address6;\n          var address7 = null;\n          var index5 = this._offset;\n          var slice6 = null;\n          if (this._input.length > this._offset) {\n            slice6 = this._input.substring(this._offset, this._offset + 0);\n          } else {\n            slice6 = null;\n          }\n          if (slice6 === \"\") {\n            var klass5 = this.constructor.SyntaxNode;\n            var type6 = null;\n            address7 = new klass5(\"\", this._offset, []);\n            if (typeof type6 === \"object\") {\n              extend(address7, type6);\n            }\n            this._offset += 0;\n          } else {\n            address7 = null;\n            var slice7 = null;\n            if (this._input.length > this._offset) {\n              slice7 = this._input.substring(this._offset, this._offset + 1);\n            } else {\n              slice7 = null;\n            }\n            if (!this.error || this.error.offset <= this._offset) {\n              this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"\\\"\"};\n            }\n          }\n          if (address7) {\n          } else {\n            this._offset = index5;\n            var klass6 = this.constructor.SyntaxNode;\n            var type7 = null;\n            address7 = new klass6(\"\", this._offset, []);\n            if (typeof type7 === \"object\") {\n              extend(address7, type7);\n            }\n            this._offset += 0;\n          }\n          if (address7) {\n            elements2.push(address7);\n            text2 += address7.textValue;\n            labelled1.flags = address7;\n          } else {\n            elements2 = null;\n            this._offset = index4;\n          }\n        } else {\n          elements2 = null;\n          this._offset = index4;\n        }\n        if (elements2) {\n          this._offset = index4;\n          var klass7 = this.constructor.SyntaxNode;\n          var type8 = null;\n          address0 = new klass7(text2, this._offset, elements2, labelled1);\n          if (typeof type8 === \"object\") {\n            extend(address0, type8);\n          }\n          this._offset += text2.length;\n        } else {\n          address0 = null;\n        }\n        if (address0) {\n          var type9 = find(this.constructor, \"Root\");\n          if (typeof type9 === \"object\") {\n            extend(address0, type9);\n          }\n        } else {\n          this._offset = index1;\n        }\n      }\n      return this._nodeCache[\"root\"][index0] = address0;\n    },\n    __consume__regexp: function(input) {\n      var address0 = null, index0 = this._offset;\n      this._nodeCache[\"regexp\"] = this._nodeCache[\"regexp\"] || {};\n      var cached = this._nodeCache[\"regexp\"][index0];\n      if (cached) {\n        this._offset += cached.textValue.length;\n        return cached;\n      }\n      var index1 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n      var address1 = null;\n      address1 = this.__consume__match();\n      if (address1) {\n        elements0.push(address1);\n        text0 += address1.textValue;\n        labelled0.match = address1;\n        var address2 = null;\n        var remaining0 = 0, index2 = this._offset, elements1 = [], text1 = \"\", address3 = true;\n        while (address3) {\n          var index3 = this._offset, elements2 = [], labelled1 = {}, text2 = \"\";\n          var address4 = null;\n          var slice0 = null;\n          if (this._input.length > this._offset) {\n            slice0 = this._input.substring(this._offset, this._offset + 1);\n          } else {\n            slice0 = null;\n          }\n          if (slice0 === \"|\") {\n            var klass0 = this.constructor.SyntaxNode;\n            var type0 = null;\n            address4 = new klass0(\"|\", this._offset, []);\n            if (typeof type0 === \"object\") {\n              extend(address4, type0);\n            }\n            this._offset += 1;\n          } else {\n            address4 = null;\n            var slice1 = null;\n            if (this._input.length > this._offset) {\n              slice1 = this._input.substring(this._offset, this._offset + 1);\n            } else {\n              slice1 = null;\n            }\n            if (!this.error || this.error.offset <= this._offset) {\n              this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"|\\\"\"};\n            }\n          }\n          if (address4) {\n            elements2.push(address4);\n            text2 += address4.textValue;\n            var address5 = null;\n            address5 = this.__consume__match();\n            if (address5) {\n              elements2.push(address5);\n              text2 += address5.textValue;\n              labelled1.match = address5;\n            } else {\n              elements2 = null;\n              this._offset = index3;\n            }\n          } else {\n            elements2 = null;\n            this._offset = index3;\n          }\n          if (elements2) {\n            this._offset = index3;\n            var klass1 = this.constructor.SyntaxNode;\n            var type1 = null;\n            address3 = new klass1(text2, this._offset, elements2, labelled1);\n            if (typeof type1 === \"object\") {\n              extend(address3, type1);\n            }\n            this._offset += text2.length;\n          } else {\n            address3 = null;\n          }\n          if (address3) {\n            elements1.push(address3);\n            text1 += address3.textValue;\n            remaining0 -= 1;\n          }\n        }\n        if (remaining0 <= 0) {\n          this._offset = index2;\n          var klass2 = this.constructor.SyntaxNode;\n          var type2 = null;\n          address2 = new klass2(text1, this._offset, elements1);\n          if (typeof type2 === \"object\") {\n            extend(address2, type2);\n          }\n          this._offset += text1.length;\n        } else {\n          address2 = null;\n        }\n        if (address2) {\n          elements0.push(address2);\n          text0 += address2.textValue;\n          labelled0.alternates = address2;\n        } else {\n          elements0 = null;\n          this._offset = index1;\n        }\n      } else {\n        elements0 = null;\n        this._offset = index1;\n      }\n      if (elements0) {\n        this._offset = index1;\n        var klass3 = this.constructor.SyntaxNode;\n        var type3 = find(this.constructor, \"Regexp\");\n        address0 = new klass3(text0, this._offset, elements0, labelled0);\n        if (typeof type3 === \"object\") {\n          extend(address0, type3);\n        }\n        this._offset += text0.length;\n      } else {\n        address0 = null;\n      }\n      return this._nodeCache[\"regexp\"][index0] = address0;\n    },\n    __consume__match: function(input) {\n      var address0 = null, index0 = this._offset;\n      this._nodeCache[\"match\"] = this._nodeCache[\"match\"] || {};\n      var cached = this._nodeCache[\"match\"][index0];\n      if (cached) {\n        this._offset += cached.textValue.length;\n        return cached;\n      }\n      var index1 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n      var address1 = null;\n      var index2 = this._offset;\n      address1 = this.__consume__repeat();\n      this._offset = index2;\n      if (!(address1)) {\n        var klass0 = this.constructor.SyntaxNode;\n        var type0 = null;\n        address1 = new klass0(\"\", this._offset, []);\n        if (typeof type0 === \"object\") {\n          extend(address1, type0);\n        }\n        this._offset += 0;\n      } else {\n        address1 = null;\n      }\n      if (address1) {\n        elements0.push(address1);\n        text0 += address1.textValue;\n        var address2 = null;\n        var remaining0 = 0, index3 = this._offset, elements1 = [], text1 = \"\", address3 = true;\n        while (address3) {\n          address3 = this.__consume__match_fragment();\n          if (address3) {\n            elements1.push(address3);\n            text1 += address3.textValue;\n            remaining0 -= 1;\n          }\n        }\n        if (remaining0 <= 0) {\n          this._offset = index3;\n          var klass1 = this.constructor.SyntaxNode;\n          var type1 = null;\n          address2 = new klass1(text1, this._offset, elements1);\n          if (typeof type1 === \"object\") {\n            extend(address2, type1);\n          }\n          this._offset += text1.length;\n        } else {\n          address2 = null;\n        }\n        if (address2) {\n          elements0.push(address2);\n          text0 += address2.textValue;\n          labelled0.parts = address2;\n        } else {\n          elements0 = null;\n          this._offset = index1;\n        }\n      } else {\n        elements0 = null;\n        this._offset = index1;\n      }\n      if (elements0) {\n        this._offset = index1;\n        var klass2 = this.constructor.SyntaxNode;\n        var type2 = find(this.constructor, \"Match\");\n        address0 = new klass2(text0, this._offset, elements0, labelled0);\n        if (typeof type2 === \"object\") {\n          extend(address0, type2);\n        }\n        this._offset += text0.length;\n      } else {\n        address0 = null;\n      }\n      return this._nodeCache[\"match\"][index0] = address0;\n    },\n    __consume__anchor: function(input) {\n      var address0 = null, index0 = this._offset;\n      this._nodeCache[\"anchor\"] = this._nodeCache[\"anchor\"] || {};\n      var cached = this._nodeCache[\"anchor\"][index0];\n      if (cached) {\n        this._offset += cached.textValue.length;\n        return cached;\n      }\n      var index1 = this._offset;\n      var slice0 = null;\n      if (this._input.length > this._offset) {\n        slice0 = this._input.substring(this._offset, this._offset + 1);\n      } else {\n        slice0 = null;\n      }\n      if (slice0 === \"^\") {\n        var klass0 = this.constructor.SyntaxNode;\n        var type0 = null;\n        address0 = new klass0(\"^\", this._offset, []);\n        if (typeof type0 === \"object\") {\n          extend(address0, type0);\n        }\n        this._offset += 1;\n      } else {\n        address0 = null;\n        var slice1 = null;\n        if (this._input.length > this._offset) {\n          slice1 = this._input.substring(this._offset, this._offset + 1);\n        } else {\n          slice1 = null;\n        }\n        if (!this.error || this.error.offset <= this._offset) {\n          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"^\\\"\"};\n        }\n      }\n      if (address0) {\n        var type1 = find(this.constructor, \"Anchor\");\n        if (typeof type1 === \"object\") {\n          extend(address0, type1);\n        }\n      } else {\n        this._offset = index1;\n        var slice2 = null;\n        if (this._input.length > this._offset) {\n          slice2 = this._input.substring(this._offset, this._offset + 1);\n        } else {\n          slice2 = null;\n        }\n        if (slice2 === \"$\") {\n          var klass1 = this.constructor.SyntaxNode;\n          var type2 = null;\n          address0 = new klass1(\"$\", this._offset, []);\n          if (typeof type2 === \"object\") {\n            extend(address0, type2);\n          }\n          this._offset += 1;\n        } else {\n          address0 = null;\n          var slice3 = null;\n          if (this._input.length > this._offset) {\n            slice3 = this._input.substring(this._offset, this._offset + 1);\n          } else {\n            slice3 = null;\n          }\n          if (!this.error || this.error.offset <= this._offset) {\n            this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"$\\\"\"};\n          }\n        }\n        if (address0) {\n          var type3 = find(this.constructor, \"Anchor\");\n          if (typeof type3 === \"object\") {\n            extend(address0, type3);\n          }\n        } else {\n          this._offset = index1;\n        }\n      }\n      return this._nodeCache[\"anchor\"][index0] = address0;\n    },\n    __consume__match_fragment: function(input) {\n      var address0 = null, index0 = this._offset;\n      this._nodeCache[\"match_fragment\"] = this._nodeCache[\"match_fragment\"] || {};\n      var cached = this._nodeCache[\"match_fragment\"][index0];\n      if (cached) {\n        this._offset += cached.textValue.length;\n        return cached;\n      }\n      var index1 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n      var address1 = null;\n      var index2 = this._offset;\n      address1 = this.__consume__anchor();\n      if (address1) {\n      } else {\n        this._offset = index2;\n        address1 = this.__consume__subexp();\n        if (address1) {\n        } else {\n          this._offset = index2;\n          address1 = this.__consume__charset();\n          if (address1) {\n          } else {\n            this._offset = index2;\n            address1 = this.__consume__terminal();\n            if (address1) {\n            } else {\n              this._offset = index2;\n            }\n          }\n        }\n      }\n      if (address1) {\n        elements0.push(address1);\n        text0 += address1.textValue;\n        labelled0.content = address1;\n        var address2 = null;\n        var index3 = this._offset;\n        address2 = this.__consume__repeat();\n        if (address2) {\n        } else {\n          this._offset = index3;\n          var klass0 = this.constructor.SyntaxNode;\n          var type0 = null;\n          address2 = new klass0(\"\", this._offset, []);\n          if (typeof type0 === \"object\") {\n            extend(address2, type0);\n          }\n          this._offset += 0;\n        }\n        if (address2) {\n          elements0.push(address2);\n          text0 += address2.textValue;\n          labelled0.repeat = address2;\n        } else {\n          elements0 = null;\n          this._offset = index1;\n        }\n      } else {\n        elements0 = null;\n        this._offset = index1;\n      }\n      if (elements0) {\n        this._offset = index1;\n        var klass1 = this.constructor.SyntaxNode;\n        var type1 = find(this.constructor, \"MatchFragment\");\n        address0 = new klass1(text0, this._offset, elements0, labelled0);\n        if (typeof type1 === \"object\") {\n          extend(address0, type1);\n        }\n        this._offset += text0.length;\n      } else {\n        address0 = null;\n      }\n      return this._nodeCache[\"match_fragment\"][index0] = address0;\n    },\n    __consume__repeat: function(input) {\n      var address0 = null, index0 = this._offset;\n      this._nodeCache[\"repeat\"] = this._nodeCache[\"repeat\"] || {};\n      var cached = this._nodeCache[\"repeat\"][index0];\n      if (cached) {\n        this._offset += cached.textValue.length;\n        return cached;\n      }\n      var index1 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n      var address1 = null;\n      var index2 = this._offset;\n      address1 = this.__consume__repeat_any();\n      if (address1) {\n      } else {\n        this._offset = index2;\n        address1 = this.__consume__repeat_required();\n        if (address1) {\n        } else {\n          this._offset = index2;\n          address1 = this.__consume__repeat_optional();\n          if (address1) {\n          } else {\n            this._offset = index2;\n            address1 = this.__consume__repeat_spec();\n            if (address1) {\n            } else {\n              this._offset = index2;\n            }\n          }\n        }\n      }\n      if (address1) {\n        elements0.push(address1);\n        text0 += address1.textValue;\n        labelled0.spec = address1;\n        var address2 = null;\n        var index3 = this._offset;\n        var slice0 = null;\n        if (this._input.length > this._offset) {\n          slice0 = this._input.substring(this._offset, this._offset + 1);\n        } else {\n          slice0 = null;\n        }\n        if (slice0 === \"?\") {\n          var klass0 = this.constructor.SyntaxNode;\n          var type0 = null;\n          address2 = new klass0(\"?\", this._offset, []);\n          if (typeof type0 === \"object\") {\n            extend(address2, type0);\n          }\n          this._offset += 1;\n        } else {\n          address2 = null;\n          var slice1 = null;\n          if (this._input.length > this._offset) {\n            slice1 = this._input.substring(this._offset, this._offset + 1);\n          } else {\n            slice1 = null;\n          }\n          if (!this.error || this.error.offset <= this._offset) {\n            this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"?\\\"\"};\n          }\n        }\n        if (address2) {\n        } else {\n          this._offset = index3;\n          var klass1 = this.constructor.SyntaxNode;\n          var type1 = null;\n          address2 = new klass1(\"\", this._offset, []);\n          if (typeof type1 === \"object\") {\n            extend(address2, type1);\n          }\n          this._offset += 0;\n        }\n        if (address2) {\n          elements0.push(address2);\n          text0 += address2.textValue;\n          labelled0.greedy = address2;\n        } else {\n          elements0 = null;\n          this._offset = index1;\n        }\n      } else {\n        elements0 = null;\n        this._offset = index1;\n      }\n      if (elements0) {\n        this._offset = index1;\n        var klass2 = this.constructor.SyntaxNode;\n        var type2 = find(this.constructor, \"Repeat\");\n        address0 = new klass2(text0, this._offset, elements0, labelled0);\n        if (typeof type2 === \"object\") {\n          extend(address0, type2);\n        }\n        this._offset += text0.length;\n      } else {\n        address0 = null;\n      }\n      return this._nodeCache[\"repeat\"][index0] = address0;\n    },\n    __consume__repeat_any: function(input) {\n      var address0 = null, index0 = this._offset;\n      this._nodeCache[\"repeat_any\"] = this._nodeCache[\"repeat_any\"] || {};\n      var cached = this._nodeCache[\"repeat_any\"][index0];\n      if (cached) {\n        this._offset += cached.textValue.length;\n        return cached;\n      }\n      var slice0 = null;\n      if (this._input.length > this._offset) {\n        slice0 = this._input.substring(this._offset, this._offset + 1);\n      } else {\n        slice0 = null;\n      }\n      if (slice0 === \"*\") {\n        var klass0 = this.constructor.SyntaxNode;\n        var type0 = find(this.constructor, \"RepeatAny\");\n        address0 = new klass0(\"*\", this._offset, []);\n        if (typeof type0 === \"object\") {\n          extend(address0, type0);\n        }\n        this._offset += 1;\n      } else {\n        address0 = null;\n        var slice1 = null;\n        if (this._input.length > this._offset) {\n          slice1 = this._input.substring(this._offset, this._offset + 1);\n        } else {\n          slice1 = null;\n        }\n        if (!this.error || this.error.offset <= this._offset) {\n          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"*\\\"\"};\n        }\n      }\n      return this._nodeCache[\"repeat_any\"][index0] = address0;\n    },\n    __consume__repeat_required: function(input) {\n      var address0 = null, index0 = this._offset;\n      this._nodeCache[\"repeat_required\"] = this._nodeCache[\"repeat_required\"] || {};\n      var cached = this._nodeCache[\"repeat_required\"][index0];\n      if (cached) {\n        this._offset += cached.textValue.length;\n        return cached;\n      }\n      var slice0 = null;\n      if (this._input.length > this._offset) {\n        slice0 = this._input.substring(this._offset, this._offset + 1);\n      } else {\n        slice0 = null;\n      }\n      if (slice0 === \"+\") {\n        var klass0 = this.constructor.SyntaxNode;\n        var type0 = find(this.constructor, \"RepeatRequired\");\n        address0 = new klass0(\"+\", this._offset, []);\n        if (typeof type0 === \"object\") {\n          extend(address0, type0);\n        }\n        this._offset += 1;\n      } else {\n        address0 = null;\n        var slice1 = null;\n        if (this._input.length > this._offset) {\n          slice1 = this._input.substring(this._offset, this._offset + 1);\n        } else {\n          slice1 = null;\n        }\n        if (!this.error || this.error.offset <= this._offset) {\n          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"+\\\"\"};\n        }\n      }\n      return this._nodeCache[\"repeat_required\"][index0] = address0;\n    },\n    __consume__repeat_optional: function(input) {\n      var address0 = null, index0 = this._offset;\n      this._nodeCache[\"repeat_optional\"] = this._nodeCache[\"repeat_optional\"] || {};\n      var cached = this._nodeCache[\"repeat_optional\"][index0];\n      if (cached) {\n        this._offset += cached.textValue.length;\n        return cached;\n      }\n      var slice0 = null;\n      if (this._input.length > this._offset) {\n        slice0 = this._input.substring(this._offset, this._offset + 1);\n      } else {\n        slice0 = null;\n      }\n      if (slice0 === \"?\") {\n        var klass0 = this.constructor.SyntaxNode;\n        var type0 = find(this.constructor, \"RepeatOptional\");\n        address0 = new klass0(\"?\", this._offset, []);\n        if (typeof type0 === \"object\") {\n          extend(address0, type0);\n        }\n        this._offset += 1;\n      } else {\n        address0 = null;\n        var slice1 = null;\n        if (this._input.length > this._offset) {\n          slice1 = this._input.substring(this._offset, this._offset + 1);\n        } else {\n          slice1 = null;\n        }\n        if (!this.error || this.error.offset <= this._offset) {\n          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"?\\\"\"};\n        }\n      }\n      return this._nodeCache[\"repeat_optional\"][index0] = address0;\n    },\n    __consume__repeat_spec: function(input) {\n      var address0 = null, index0 = this._offset;\n      this._nodeCache[\"repeat_spec\"] = this._nodeCache[\"repeat_spec\"] || {};\n      var cached = this._nodeCache[\"repeat_spec\"][index0];\n      if (cached) {\n        this._offset += cached.textValue.length;\n        return cached;\n      }\n      var index1 = this._offset;\n      var index2 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n      var address1 = null;\n      var slice0 = null;\n      if (this._input.length > this._offset) {\n        slice0 = this._input.substring(this._offset, this._offset + 1);\n      } else {\n        slice0 = null;\n      }\n      if (slice0 === \"{\") {\n        var klass0 = this.constructor.SyntaxNode;\n        var type0 = null;\n        address1 = new klass0(\"{\", this._offset, []);\n        if (typeof type0 === \"object\") {\n          extend(address1, type0);\n        }\n        this._offset += 1;\n      } else {\n        address1 = null;\n        var slice1 = null;\n        if (this._input.length > this._offset) {\n          slice1 = this._input.substring(this._offset, this._offset + 1);\n        } else {\n          slice1 = null;\n        }\n        if (!this.error || this.error.offset <= this._offset) {\n          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"{\\\"\"};\n        }\n      }\n      if (address1) {\n        elements0.push(address1);\n        text0 += address1.textValue;\n        var address2 = null;\n        var remaining0 = 1, index3 = this._offset, elements1 = [], text1 = \"\", address3 = true;\n        while (address3) {\n          var slice2 = null;\n          if (this._input.length > this._offset) {\n            slice2 = this._input.substring(this._offset, this._offset + 1);\n          } else {\n            slice2 = null;\n          }\n          if (slice2 && /^[0-9]/.test(slice2)) {\n            var klass1 = this.constructor.SyntaxNode;\n            var type1 = null;\n            address3 = new klass1(slice2, this._offset, []);\n            if (typeof type1 === \"object\") {\n              extend(address3, type1);\n            }\n            this._offset += 1;\n          } else {\n            address3 = null;\n            var slice3 = null;\n            if (this._input.length > this._offset) {\n              slice3 = this._input.substring(this._offset, this._offset + 1);\n            } else {\n              slice3 = null;\n            }\n            if (!this.error || this.error.offset <= this._offset) {\n              this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[0-9]\"};\n            }\n          }\n          if (address3) {\n            elements1.push(address3);\n            text1 += address3.textValue;\n            remaining0 -= 1;\n          }\n        }\n        if (remaining0 <= 0) {\n          this._offset = index3;\n          var klass2 = this.constructor.SyntaxNode;\n          var type2 = null;\n          address2 = new klass2(text1, this._offset, elements1);\n          if (typeof type2 === \"object\") {\n            extend(address2, type2);\n          }\n          this._offset += text1.length;\n        } else {\n          address2 = null;\n        }\n        if (address2) {\n          elements0.push(address2);\n          text0 += address2.textValue;\n          labelled0.min = address2;\n          var address4 = null;\n          var slice4 = null;\n          if (this._input.length > this._offset) {\n            slice4 = this._input.substring(this._offset, this._offset + 1);\n          } else {\n            slice4 = null;\n          }\n          if (slice4 === \",\") {\n            var klass3 = this.constructor.SyntaxNode;\n            var type3 = null;\n            address4 = new klass3(\",\", this._offset, []);\n            if (typeof type3 === \"object\") {\n              extend(address4, type3);\n            }\n            this._offset += 1;\n          } else {\n            address4 = null;\n            var slice5 = null;\n            if (this._input.length > this._offset) {\n              slice5 = this._input.substring(this._offset, this._offset + 1);\n            } else {\n              slice5 = null;\n            }\n            if (!this.error || this.error.offset <= this._offset) {\n              this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\",\\\"\"};\n            }\n          }\n          if (address4) {\n            elements0.push(address4);\n            text0 += address4.textValue;\n            var address5 = null;\n            var remaining1 = 1, index4 = this._offset, elements2 = [], text2 = \"\", address6 = true;\n            while (address6) {\n              var slice6 = null;\n              if (this._input.length > this._offset) {\n                slice6 = this._input.substring(this._offset, this._offset + 1);\n              } else {\n                slice6 = null;\n              }\n              if (slice6 && /^[0-9]/.test(slice6)) {\n                var klass4 = this.constructor.SyntaxNode;\n                var type4 = null;\n                address6 = new klass4(slice6, this._offset, []);\n                if (typeof type4 === \"object\") {\n                  extend(address6, type4);\n                }\n                this._offset += 1;\n              } else {\n                address6 = null;\n                var slice7 = null;\n                if (this._input.length > this._offset) {\n                  slice7 = this._input.substring(this._offset, this._offset + 1);\n                } else {\n                  slice7 = null;\n                }\n                if (!this.error || this.error.offset <= this._offset) {\n                  this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[0-9]\"};\n                }\n              }\n              if (address6) {\n                elements2.push(address6);\n                text2 += address6.textValue;\n                remaining1 -= 1;\n              }\n            }\n            if (remaining1 <= 0) {\n              this._offset = index4;\n              var klass5 = this.constructor.SyntaxNode;\n              var type5 = null;\n              address5 = new klass5(text2, this._offset, elements2);\n              if (typeof type5 === \"object\") {\n                extend(address5, type5);\n              }\n              this._offset += text2.length;\n            } else {\n              address5 = null;\n            }\n            if (address5) {\n              elements0.push(address5);\n              text0 += address5.textValue;\n              labelled0.max = address5;\n              var address7 = null;\n              var slice8 = null;\n              if (this._input.length > this._offset) {\n                slice8 = this._input.substring(this._offset, this._offset + 1);\n              } else {\n                slice8 = null;\n              }\n              if (slice8 === \"}\") {\n                var klass6 = this.constructor.SyntaxNode;\n                var type6 = null;\n                address7 = new klass6(\"}\", this._offset, []);\n                if (typeof type6 === \"object\") {\n                  extend(address7, type6);\n                }\n                this._offset += 1;\n              } else {\n                address7 = null;\n                var slice9 = null;\n                if (this._input.length > this._offset) {\n                  slice9 = this._input.substring(this._offset, this._offset + 1);\n                } else {\n                  slice9 = null;\n                }\n                if (!this.error || this.error.offset <= this._offset) {\n                  this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"}\\\"\"};\n                }\n              }\n              if (address7) {\n                elements0.push(address7);\n                text0 += address7.textValue;\n              } else {\n                elements0 = null;\n                this._offset = index2;\n              }\n            } else {\n              elements0 = null;\n              this._offset = index2;\n            }\n          } else {\n            elements0 = null;\n            this._offset = index2;\n          }\n        } else {\n          elements0 = null;\n          this._offset = index2;\n        }\n      } else {\n        elements0 = null;\n        this._offset = index2;\n      }\n      if (elements0) {\n        this._offset = index2;\n        var klass7 = this.constructor.SyntaxNode;\n        var type7 = null;\n        address0 = new klass7(text0, this._offset, elements0, labelled0);\n        if (typeof type7 === \"object\") {\n          extend(address0, type7);\n        }\n        this._offset += text0.length;\n      } else {\n        address0 = null;\n      }\n      if (address0) {\n        var type8 = find(this.constructor, \"RepeatSpec\");\n        if (typeof type8 === \"object\") {\n          extend(address0, type8);\n        }\n      } else {\n        this._offset = index1;\n        var index5 = this._offset, elements3 = [], labelled1 = {}, text3 = \"\";\n        var address8 = null;\n        var slice10 = null;\n        if (this._input.length > this._offset) {\n          slice10 = this._input.substring(this._offset, this._offset + 1);\n        } else {\n          slice10 = null;\n        }\n        if (slice10 === \"{\") {\n          var klass8 = this.constructor.SyntaxNode;\n          var type9 = null;\n          address8 = new klass8(\"{\", this._offset, []);\n          if (typeof type9 === \"object\") {\n            extend(address8, type9);\n          }\n          this._offset += 1;\n        } else {\n          address8 = null;\n          var slice11 = null;\n          if (this._input.length > this._offset) {\n            slice11 = this._input.substring(this._offset, this._offset + 1);\n          } else {\n            slice11 = null;\n          }\n          if (!this.error || this.error.offset <= this._offset) {\n            this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"{\\\"\"};\n          }\n        }\n        if (address8) {\n          elements3.push(address8);\n          text3 += address8.textValue;\n          var address9 = null;\n          var remaining2 = 1, index6 = this._offset, elements4 = [], text4 = \"\", address10 = true;\n          while (address10) {\n            var slice12 = null;\n            if (this._input.length > this._offset) {\n              slice12 = this._input.substring(this._offset, this._offset + 1);\n            } else {\n              slice12 = null;\n            }\n            if (slice12 && /^[0-9]/.test(slice12)) {\n              var klass9 = this.constructor.SyntaxNode;\n              var type10 = null;\n              address10 = new klass9(slice12, this._offset, []);\n              if (typeof type10 === \"object\") {\n                extend(address10, type10);\n              }\n              this._offset += 1;\n            } else {\n              address10 = null;\n              var slice13 = null;\n              if (this._input.length > this._offset) {\n                slice13 = this._input.substring(this._offset, this._offset + 1);\n              } else {\n                slice13 = null;\n              }\n              if (!this.error || this.error.offset <= this._offset) {\n                this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[0-9]\"};\n              }\n            }\n            if (address10) {\n              elements4.push(address10);\n              text4 += address10.textValue;\n              remaining2 -= 1;\n            }\n          }\n          if (remaining2 <= 0) {\n            this._offset = index6;\n            var klass10 = this.constructor.SyntaxNode;\n            var type11 = null;\n            address9 = new klass10(text4, this._offset, elements4);\n            if (typeof type11 === \"object\") {\n              extend(address9, type11);\n            }\n            this._offset += text4.length;\n          } else {\n            address9 = null;\n          }\n          if (address9) {\n            elements3.push(address9);\n            text3 += address9.textValue;\n            labelled1.min = address9;\n            var address11 = null;\n            var slice14 = null;\n            if (this._input.length > this._offset) {\n              slice14 = this._input.substring(this._offset, this._offset + 2);\n            } else {\n              slice14 = null;\n            }\n            if (slice14 === \",}\") {\n              var klass11 = this.constructor.SyntaxNode;\n              var type12 = null;\n              address11 = new klass11(\",}\", this._offset, []);\n              if (typeof type12 === \"object\") {\n                extend(address11, type12);\n              }\n              this._offset += 2;\n            } else {\n              address11 = null;\n              var slice15 = null;\n              if (this._input.length > this._offset) {\n                slice15 = this._input.substring(this._offset, this._offset + 1);\n              } else {\n                slice15 = null;\n              }\n              if (!this.error || this.error.offset <= this._offset) {\n                this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\",}\\\"\"};\n              }\n            }\n            if (address11) {\n              elements3.push(address11);\n              text3 += address11.textValue;\n            } else {\n              elements3 = null;\n              this._offset = index5;\n            }\n          } else {\n            elements3 = null;\n            this._offset = index5;\n          }\n        } else {\n          elements3 = null;\n          this._offset = index5;\n        }\n        if (elements3) {\n          this._offset = index5;\n          var klass12 = this.constructor.SyntaxNode;\n          var type13 = null;\n          address0 = new klass12(text3, this._offset, elements3, labelled1);\n          if (typeof type13 === \"object\") {\n            extend(address0, type13);\n          }\n          this._offset += text3.length;\n        } else {\n          address0 = null;\n        }\n        if (address0) {\n          var type14 = find(this.constructor, \"RepeatSpec\");\n          if (typeof type14 === \"object\") {\n            extend(address0, type14);\n          }\n        } else {\n          this._offset = index1;\n          var index7 = this._offset, elements5 = [], labelled2 = {}, text5 = \"\";\n          var address12 = null;\n          var slice16 = null;\n          if (this._input.length > this._offset) {\n            slice16 = this._input.substring(this._offset, this._offset + 1);\n          } else {\n            slice16 = null;\n          }\n          if (slice16 === \"{\") {\n            var klass13 = this.constructor.SyntaxNode;\n            var type15 = null;\n            address12 = new klass13(\"{\", this._offset, []);\n            if (typeof type15 === \"object\") {\n              extend(address12, type15);\n            }\n            this._offset += 1;\n          } else {\n            address12 = null;\n            var slice17 = null;\n            if (this._input.length > this._offset) {\n              slice17 = this._input.substring(this._offset, this._offset + 1);\n            } else {\n              slice17 = null;\n            }\n            if (!this.error || this.error.offset <= this._offset) {\n              this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"{\\\"\"};\n            }\n          }\n          if (address12) {\n            elements5.push(address12);\n            text5 += address12.textValue;\n            var address13 = null;\n            var remaining3 = 1, index8 = this._offset, elements6 = [], text6 = \"\", address14 = true;\n            while (address14) {\n              var slice18 = null;\n              if (this._input.length > this._offset) {\n                slice18 = this._input.substring(this._offset, this._offset + 1);\n              } else {\n                slice18 = null;\n              }\n              if (slice18 && /^[0-9]/.test(slice18)) {\n                var klass14 = this.constructor.SyntaxNode;\n                var type16 = null;\n                address14 = new klass14(slice18, this._offset, []);\n                if (typeof type16 === \"object\") {\n                  extend(address14, type16);\n                }\n                this._offset += 1;\n              } else {\n                address14 = null;\n                var slice19 = null;\n                if (this._input.length > this._offset) {\n                  slice19 = this._input.substring(this._offset, this._offset + 1);\n                } else {\n                  slice19 = null;\n                }\n                if (!this.error || this.error.offset <= this._offset) {\n                  this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[0-9]\"};\n                }\n              }\n              if (address14) {\n                elements6.push(address14);\n                text6 += address14.textValue;\n                remaining3 -= 1;\n              }\n            }\n            if (remaining3 <= 0) {\n              this._offset = index8;\n              var klass15 = this.constructor.SyntaxNode;\n              var type17 = null;\n              address13 = new klass15(text6, this._offset, elements6);\n              if (typeof type17 === \"object\") {\n                extend(address13, type17);\n              }\n              this._offset += text6.length;\n            } else {\n              address13 = null;\n            }\n            if (address13) {\n              elements5.push(address13);\n              text5 += address13.textValue;\n              labelled2.exact = address13;\n              var address15 = null;\n              var slice20 = null;\n              if (this._input.length > this._offset) {\n                slice20 = this._input.substring(this._offset, this._offset + 1);\n              } else {\n                slice20 = null;\n              }\n              if (slice20 === \"}\") {\n                var klass16 = this.constructor.SyntaxNode;\n                var type18 = null;\n                address15 = new klass16(\"}\", this._offset, []);\n                if (typeof type18 === \"object\") {\n                  extend(address15, type18);\n                }\n                this._offset += 1;\n              } else {\n                address15 = null;\n                var slice21 = null;\n                if (this._input.length > this._offset) {\n                  slice21 = this._input.substring(this._offset, this._offset + 1);\n                } else {\n                  slice21 = null;\n                }\n                if (!this.error || this.error.offset <= this._offset) {\n                  this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"}\\\"\"};\n                }\n              }\n              if (address15) {\n                elements5.push(address15);\n                text5 += address15.textValue;\n              } else {\n                elements5 = null;\n                this._offset = index7;\n              }\n            } else {\n              elements5 = null;\n              this._offset = index7;\n            }\n          } else {\n            elements5 = null;\n            this._offset = index7;\n          }\n          if (elements5) {\n            this._offset = index7;\n            var klass17 = this.constructor.SyntaxNode;\n            var type19 = null;\n            address0 = new klass17(text5, this._offset, elements5, labelled2);\n            if (typeof type19 === \"object\") {\n              extend(address0, type19);\n            }\n            this._offset += text5.length;\n          } else {\n            address0 = null;\n          }\n          if (address0) {\n            var type20 = find(this.constructor, \"RepeatSpec\");\n            if (typeof type20 === \"object\") {\n              extend(address0, type20);\n            }\n          } else {\n            this._offset = index1;\n          }\n        }\n      }\n      return this._nodeCache[\"repeat_spec\"][index0] = address0;\n    },\n    __consume__subexp: function(input) {\n      var address0 = null, index0 = this._offset;\n      this._nodeCache[\"subexp\"] = this._nodeCache[\"subexp\"] || {};\n      var cached = this._nodeCache[\"subexp\"][index0];\n      if (cached) {\n        this._offset += cached.textValue.length;\n        return cached;\n      }\n      var index1 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n      var address1 = null;\n      var slice0 = null;\n      if (this._input.length > this._offset) {\n        slice0 = this._input.substring(this._offset, this._offset + 1);\n      } else {\n        slice0 = null;\n      }\n      if (slice0 === \"(\") {\n        var klass0 = this.constructor.SyntaxNode;\n        var type0 = null;\n        address1 = new klass0(\"(\", this._offset, []);\n        if (typeof type0 === \"object\") {\n          extend(address1, type0);\n        }\n        this._offset += 1;\n      } else {\n        address1 = null;\n        var slice1 = null;\n        if (this._input.length > this._offset) {\n          slice1 = this._input.substring(this._offset, this._offset + 1);\n        } else {\n          slice1 = null;\n        }\n        if (!this.error || this.error.offset <= this._offset) {\n          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"(\\\"\"};\n        }\n      }\n      if (address1) {\n        elements0.push(address1);\n        text0 += address1.textValue;\n        var address2 = null;\n        var index2 = this._offset;\n        var index3 = this._offset;\n        var slice2 = null;\n        if (this._input.length > this._offset) {\n          slice2 = this._input.substring(this._offset, this._offset + 2);\n        } else {\n          slice2 = null;\n        }\n        if (slice2 === \"?:\") {\n          var klass1 = this.constructor.SyntaxNode;\n          var type1 = null;\n          address2 = new klass1(\"?:\", this._offset, []);\n          if (typeof type1 === \"object\") {\n            extend(address2, type1);\n          }\n          this._offset += 2;\n        } else {\n          address2 = null;\n          var slice3 = null;\n          if (this._input.length > this._offset) {\n            slice3 = this._input.substring(this._offset, this._offset + 1);\n          } else {\n            slice3 = null;\n          }\n          if (!this.error || this.error.offset <= this._offset) {\n            this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"?:\\\"\"};\n          }\n        }\n        if (address2) {\n        } else {\n          this._offset = index3;\n          var slice4 = null;\n          if (this._input.length > this._offset) {\n            slice4 = this._input.substring(this._offset, this._offset + 2);\n          } else {\n            slice4 = null;\n          }\n          if (slice4 === \"?=\") {\n            var klass2 = this.constructor.SyntaxNode;\n            var type2 = null;\n            address2 = new klass2(\"?=\", this._offset, []);\n            if (typeof type2 === \"object\") {\n              extend(address2, type2);\n            }\n            this._offset += 2;\n          } else {\n            address2 = null;\n            var slice5 = null;\n            if (this._input.length > this._offset) {\n              slice5 = this._input.substring(this._offset, this._offset + 1);\n            } else {\n              slice5 = null;\n            }\n            if (!this.error || this.error.offset <= this._offset) {\n              this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"?=\\\"\"};\n            }\n          }\n          if (address2) {\n          } else {\n            this._offset = index3;\n            var slice6 = null;\n            if (this._input.length > this._offset) {\n              slice6 = this._input.substring(this._offset, this._offset + 2);\n            } else {\n              slice6 = null;\n            }\n            if (slice6 === \"?!\") {\n              var klass3 = this.constructor.SyntaxNode;\n              var type3 = null;\n              address2 = new klass3(\"?!\", this._offset, []);\n              if (typeof type3 === \"object\") {\n                extend(address2, type3);\n              }\n              this._offset += 2;\n            } else {\n              address2 = null;\n              var slice7 = null;\n              if (this._input.length > this._offset) {\n                slice7 = this._input.substring(this._offset, this._offset + 1);\n              } else {\n                slice7 = null;\n              }\n              if (!this.error || this.error.offset <= this._offset) {\n                this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"?!\\\"\"};\n              }\n            }\n            if (address2) {\n            } else {\n              this._offset = index3;\n            }\n          }\n        }\n        if (address2) {\n        } else {\n          this._offset = index2;\n          var klass4 = this.constructor.SyntaxNode;\n          var type4 = null;\n          address2 = new klass4(\"\", this._offset, []);\n          if (typeof type4 === \"object\") {\n            extend(address2, type4);\n          }\n          this._offset += 0;\n        }\n        if (address2) {\n          elements0.push(address2);\n          text0 += address2.textValue;\n          labelled0.capture = address2;\n          var address3 = null;\n          address3 = this.__consume__regexp();\n          if (address3) {\n            elements0.push(address3);\n            text0 += address3.textValue;\n            labelled0.regexp = address3;\n            var address4 = null;\n            var slice8 = null;\n            if (this._input.length > this._offset) {\n              slice8 = this._input.substring(this._offset, this._offset + 1);\n            } else {\n              slice8 = null;\n            }\n            if (slice8 === \")\") {\n              var klass5 = this.constructor.SyntaxNode;\n              var type5 = null;\n              address4 = new klass5(\")\", this._offset, []);\n              if (typeof type5 === \"object\") {\n                extend(address4, type5);\n              }\n              this._offset += 1;\n            } else {\n              address4 = null;\n              var slice9 = null;\n              if (this._input.length > this._offset) {\n                slice9 = this._input.substring(this._offset, this._offset + 1);\n              } else {\n                slice9 = null;\n              }\n              if (!this.error || this.error.offset <= this._offset) {\n                this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\")\\\"\"};\n              }\n            }\n            if (address4) {\n              elements0.push(address4);\n              text0 += address4.textValue;\n            } else {\n              elements0 = null;\n              this._offset = index1;\n            }\n          } else {\n            elements0 = null;\n            this._offset = index1;\n          }\n        } else {\n          elements0 = null;\n          this._offset = index1;\n        }\n      } else {\n        elements0 = null;\n        this._offset = index1;\n      }\n      if (elements0) {\n        this._offset = index1;\n        var klass6 = this.constructor.SyntaxNode;\n        var type6 = find(this.constructor, \"Subexp\");\n        address0 = new klass6(text0, this._offset, elements0, labelled0);\n        if (typeof type6 === \"object\") {\n          extend(address0, type6);\n        }\n        this._offset += text0.length;\n      } else {\n        address0 = null;\n      }\n      return this._nodeCache[\"subexp\"][index0] = address0;\n    },\n    __consume__charset: function(input) {\n      var address0 = null, index0 = this._offset;\n      this._nodeCache[\"charset\"] = this._nodeCache[\"charset\"] || {};\n      var cached = this._nodeCache[\"charset\"][index0];\n      if (cached) {\n        this._offset += cached.textValue.length;\n        return cached;\n      }\n      var index1 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n      var address1 = null;\n      var slice0 = null;\n      if (this._input.length > this._offset) {\n        slice0 = this._input.substring(this._offset, this._offset + 1);\n      } else {\n        slice0 = null;\n      }\n      if (slice0 === \"[\") {\n        var klass0 = this.constructor.SyntaxNode;\n        var type0 = null;\n        address1 = new klass0(\"[\", this._offset, []);\n        if (typeof type0 === \"object\") {\n          extend(address1, type0);\n        }\n        this._offset += 1;\n      } else {\n        address1 = null;\n        var slice1 = null;\n        if (this._input.length > this._offset) {\n          slice1 = this._input.substring(this._offset, this._offset + 1);\n        } else {\n          slice1 = null;\n        }\n        if (!this.error || this.error.offset <= this._offset) {\n          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"[\\\"\"};\n        }\n      }\n      if (address1) {\n        elements0.push(address1);\n        text0 += address1.textValue;\n        var address2 = null;\n        var index2 = this._offset;\n        var slice2 = null;\n        if (this._input.length > this._offset) {\n          slice2 = this._input.substring(this._offset, this._offset + 1);\n        } else {\n          slice2 = null;\n        }\n        if (slice2 === \"^\") {\n          var klass1 = this.constructor.SyntaxNode;\n          var type1 = null;\n          address2 = new klass1(\"^\", this._offset, []);\n          if (typeof type1 === \"object\") {\n            extend(address2, type1);\n          }\n          this._offset += 1;\n        } else {\n          address2 = null;\n          var slice3 = null;\n          if (this._input.length > this._offset) {\n            slice3 = this._input.substring(this._offset, this._offset + 1);\n          } else {\n            slice3 = null;\n          }\n          if (!this.error || this.error.offset <= this._offset) {\n            this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"^\\\"\"};\n          }\n        }\n        if (address2) {\n        } else {\n          this._offset = index2;\n          var klass2 = this.constructor.SyntaxNode;\n          var type2 = null;\n          address2 = new klass2(\"\", this._offset, []);\n          if (typeof type2 === \"object\") {\n            extend(address2, type2);\n          }\n          this._offset += 0;\n        }\n        if (address2) {\n          elements0.push(address2);\n          text0 += address2.textValue;\n          labelled0.invert = address2;\n          var address3 = null;\n          var remaining0 = 0, index3 = this._offset, elements1 = [], text1 = \"\", address4 = true;\n          while (address4) {\n            var index4 = this._offset;\n            address4 = this.__consume__charset_range();\n            if (address4) {\n            } else {\n              this._offset = index4;\n              address4 = this.__consume__charset_terminal();\n              if (address4) {\n              } else {\n                this._offset = index4;\n              }\n            }\n            if (address4) {\n              elements1.push(address4);\n              text1 += address4.textValue;\n              remaining0 -= 1;\n            }\n          }\n          if (remaining0 <= 0) {\n            this._offset = index3;\n            var klass3 = this.constructor.SyntaxNode;\n            var type3 = null;\n            address3 = new klass3(text1, this._offset, elements1);\n            if (typeof type3 === \"object\") {\n              extend(address3, type3);\n            }\n            this._offset += text1.length;\n          } else {\n            address3 = null;\n          }\n          if (address3) {\n            elements0.push(address3);\n            text0 += address3.textValue;\n            labelled0.parts = address3;\n            var address5 = null;\n            var slice4 = null;\n            if (this._input.length > this._offset) {\n              slice4 = this._input.substring(this._offset, this._offset + 1);\n            } else {\n              slice4 = null;\n            }\n            if (slice4 === \"]\") {\n              var klass4 = this.constructor.SyntaxNode;\n              var type4 = null;\n              address5 = new klass4(\"]\", this._offset, []);\n              if (typeof type4 === \"object\") {\n                extend(address5, type4);\n              }\n              this._offset += 1;\n            } else {\n              address5 = null;\n              var slice5 = null;\n              if (this._input.length > this._offset) {\n                slice5 = this._input.substring(this._offset, this._offset + 1);\n              } else {\n                slice5 = null;\n              }\n              if (!this.error || this.error.offset <= this._offset) {\n                this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"]\\\"\"};\n              }\n            }\n            if (address5) {\n              elements0.push(address5);\n              text0 += address5.textValue;\n            } else {\n              elements0 = null;\n              this._offset = index1;\n            }\n          } else {\n            elements0 = null;\n            this._offset = index1;\n          }\n        } else {\n          elements0 = null;\n          this._offset = index1;\n        }\n      } else {\n        elements0 = null;\n        this._offset = index1;\n      }\n      if (elements0) {\n        this._offset = index1;\n        var klass5 = this.constructor.SyntaxNode;\n        var type5 = find(this.constructor, \"Charset\");\n        address0 = new klass5(text0, this._offset, elements0, labelled0);\n        if (typeof type5 === \"object\") {\n          extend(address0, type5);\n        }\n        this._offset += text0.length;\n      } else {\n        address0 = null;\n      }\n      return this._nodeCache[\"charset\"][index0] = address0;\n    },\n    __consume__charset_range: function(input) {\n      var address0 = null, index0 = this._offset;\n      this._nodeCache[\"charset_range\"] = this._nodeCache[\"charset_range\"] || {};\n      var cached = this._nodeCache[\"charset_range\"][index0];\n      if (cached) {\n        this._offset += cached.textValue.length;\n        return cached;\n      }\n      var index1 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n      var address1 = null;\n      address1 = this.__consume__charset_range_terminal();\n      if (address1) {\n        elements0.push(address1);\n        text0 += address1.textValue;\n        labelled0.first = address1;\n        var address2 = null;\n        var slice0 = null;\n        if (this._input.length > this._offset) {\n          slice0 = this._input.substring(this._offset, this._offset + 1);\n        } else {\n          slice0 = null;\n        }\n        if (slice0 === \"-\") {\n          var klass0 = this.constructor.SyntaxNode;\n          var type0 = null;\n          address2 = new klass0(\"-\", this._offset, []);\n          if (typeof type0 === \"object\") {\n            extend(address2, type0);\n          }\n          this._offset += 1;\n        } else {\n          address2 = null;\n          var slice1 = null;\n          if (this._input.length > this._offset) {\n            slice1 = this._input.substring(this._offset, this._offset + 1);\n          } else {\n            slice1 = null;\n          }\n          if (!this.error || this.error.offset <= this._offset) {\n            this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"-\\\"\"};\n          }\n        }\n        if (address2) {\n          elements0.push(address2);\n          text0 += address2.textValue;\n          var address3 = null;\n          address3 = this.__consume__charset_range_terminal();\n          if (address3) {\n            elements0.push(address3);\n            text0 += address3.textValue;\n            labelled0.last = address3;\n          } else {\n            elements0 = null;\n            this._offset = index1;\n          }\n        } else {\n          elements0 = null;\n          this._offset = index1;\n        }\n      } else {\n        elements0 = null;\n        this._offset = index1;\n      }\n      if (elements0) {\n        this._offset = index1;\n        var klass1 = this.constructor.SyntaxNode;\n        var type1 = find(this.constructor, \"CharsetRange\");\n        address0 = new klass1(text0, this._offset, elements0, labelled0);\n        if (typeof type1 === \"object\") {\n          extend(address0, type1);\n        }\n        this._offset += text0.length;\n      } else {\n        address0 = null;\n      }\n      return this._nodeCache[\"charset_range\"][index0] = address0;\n    },\n    __consume__charset_terminal: function(input) {\n      var address0 = null, index0 = this._offset;\n      this._nodeCache[\"charset_terminal\"] = this._nodeCache[\"charset_terminal\"] || {};\n      var cached = this._nodeCache[\"charset_terminal\"][index0];\n      if (cached) {\n        this._offset += cached.textValue.length;\n        return cached;\n      }\n      var index1 = this._offset;\n      address0 = this.__consume__charset_escape();\n      var type0 = find(this.constructor, \"CharsetEscape\");\n      if (typeof type0 === \"object\") {\n        extend(address0, type0);\n      }\n      if (address0) {\n      } else {\n        this._offset = index1;\n        address0 = this.__consume__charset_literal();\n        var type1 = find(this.constructor, \"Literal\");\n        if (typeof type1 === \"object\") {\n          extend(address0, type1);\n        }\n        if (address0) {\n        } else {\n          this._offset = index1;\n        }\n      }\n      return this._nodeCache[\"charset_terminal\"][index0] = address0;\n    },\n    __consume__charset_range_terminal: function(input) {\n      var address0 = null, index0 = this._offset;\n      this._nodeCache[\"charset_range_terminal\"] = this._nodeCache[\"charset_range_terminal\"] || {};\n      var cached = this._nodeCache[\"charset_range_terminal\"][index0];\n      if (cached) {\n        this._offset += cached.textValue.length;\n        return cached;\n      }\n      var index1 = this._offset;\n      address0 = this.__consume__charset_range_escape();\n      var type0 = find(this.constructor, \"CharsetEscape\");\n      if (typeof type0 === \"object\") {\n        extend(address0, type0);\n      }\n      if (address0) {\n      } else {\n        this._offset = index1;\n        address0 = this.__consume__charset_literal();\n        var type1 = find(this.constructor, \"Literal\");\n        if (typeof type1 === \"object\") {\n          extend(address0, type1);\n        }\n        if (address0) {\n        } else {\n          this._offset = index1;\n        }\n      }\n      return this._nodeCache[\"charset_range_terminal\"][index0] = address0;\n    },\n    __consume__charset_escape: function(input) {\n      var address0 = null, index0 = this._offset;\n      this._nodeCache[\"charset_escape\"] = this._nodeCache[\"charset_escape\"] || {};\n      var cached = this._nodeCache[\"charset_escape\"][index0];\n      if (cached) {\n        this._offset += cached.textValue.length;\n        return cached;\n      }\n      var index1 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n      var address1 = null;\n      var slice0 = null;\n      if (this._input.length > this._offset) {\n        slice0 = this._input.substring(this._offset, this._offset + 1);\n      } else {\n        slice0 = null;\n      }\n      if (slice0 === \"\\\\\") {\n        var klass0 = this.constructor.SyntaxNode;\n        var type0 = null;\n        address1 = new klass0(\"\\\\\", this._offset, []);\n        if (typeof type0 === \"object\") {\n          extend(address1, type0);\n        }\n        this._offset += 1;\n      } else {\n        address1 = null;\n        var slice1 = null;\n        if (this._input.length > this._offset) {\n          slice1 = this._input.substring(this._offset, this._offset + 1);\n        } else {\n          slice1 = null;\n        }\n        if (!this.error || this.error.offset <= this._offset) {\n          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"\\\\\\\\\\\"\"};\n        }\n      }\n      if (address1) {\n        elements0.push(address1);\n        text0 += address1.textValue;\n        var address2 = null;\n        var index2 = this._offset;\n        var index3 = this._offset, elements1 = [], labelled1 = {}, text1 = \"\";\n        var address3 = null;\n        var slice2 = null;\n        if (this._input.length > this._offset) {\n          slice2 = this._input.substring(this._offset, this._offset + 1);\n        } else {\n          slice2 = null;\n        }\n        if (slice2 && /^[bdDfnrsStvwW]/.test(slice2)) {\n          var klass1 = this.constructor.SyntaxNode;\n          var type1 = null;\n          address3 = new klass1(slice2, this._offset, []);\n          if (typeof type1 === \"object\") {\n            extend(address3, type1);\n          }\n          this._offset += 1;\n        } else {\n          address3 = null;\n          var slice3 = null;\n          if (this._input.length > this._offset) {\n            slice3 = this._input.substring(this._offset, this._offset + 1);\n          } else {\n            slice3 = null;\n          }\n          if (!this.error || this.error.offset <= this._offset) {\n            this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[bdDfnrsStvwW]\"};\n          }\n        }\n        if (address3) {\n          elements1.push(address3);\n          text1 += address3.textValue;\n          labelled1.code = address3;\n          var address4 = null;\n          var index4 = this._offset;\n          var slice4 = null;\n          if (this._input.length > this._offset) {\n            slice4 = this._input.substring(this._offset, this._offset + 0);\n          } else {\n            slice4 = null;\n          }\n          if (slice4 === \"\") {\n            var klass2 = this.constructor.SyntaxNode;\n            var type2 = null;\n            address4 = new klass2(\"\", this._offset, []);\n            if (typeof type2 === \"object\") {\n              extend(address4, type2);\n            }\n            this._offset += 0;\n          } else {\n            address4 = null;\n            var slice5 = null;\n            if (this._input.length > this._offset) {\n              slice5 = this._input.substring(this._offset, this._offset + 1);\n            } else {\n              slice5 = null;\n            }\n            if (!this.error || this.error.offset <= this._offset) {\n              this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"\\\"\"};\n            }\n          }\n          if (address4) {\n          } else {\n            this._offset = index4;\n            var klass3 = this.constructor.SyntaxNode;\n            var type3 = null;\n            address4 = new klass3(\"\", this._offset, []);\n            if (typeof type3 === \"object\") {\n              extend(address4, type3);\n            }\n            this._offset += 0;\n          }\n          if (address4) {\n            elements1.push(address4);\n            text1 += address4.textValue;\n            labelled1.arg = address4;\n          } else {\n            elements1 = null;\n            this._offset = index3;\n          }\n        } else {\n          elements1 = null;\n          this._offset = index3;\n        }\n        if (elements1) {\n          this._offset = index3;\n          var klass4 = this.constructor.SyntaxNode;\n          var type4 = null;\n          address2 = new klass4(text1, this._offset, elements1, labelled1);\n          if (typeof type4 === \"object\") {\n            extend(address2, type4);\n          }\n          this._offset += text1.length;\n        } else {\n          address2 = null;\n        }\n        if (address2) {\n        } else {\n          this._offset = index2;\n          address2 = this.__consume__control_escape();\n          if (address2) {\n          } else {\n            this._offset = index2;\n            address2 = this.__consume__octal_escape();\n            if (address2) {\n            } else {\n              this._offset = index2;\n              address2 = this.__consume__hex_escape();\n              if (address2) {\n              } else {\n                this._offset = index2;\n                address2 = this.__consume__unicode_escape();\n                if (address2) {\n                } else {\n                  this._offset = index2;\n                  address2 = this.__consume__null_escape();\n                  if (address2) {\n                  } else {\n                    this._offset = index2;\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (address2) {\n          elements0.push(address2);\n          text0 += address2.textValue;\n          labelled0.esc = address2;\n        } else {\n          elements0 = null;\n          this._offset = index1;\n        }\n      } else {\n        elements0 = null;\n        this._offset = index1;\n      }\n      if (elements0) {\n        this._offset = index1;\n        var klass5 = this.constructor.SyntaxNode;\n        var type5 = null;\n        address0 = new klass5(text0, this._offset, elements0, labelled0);\n        if (typeof type5 === \"object\") {\n          extend(address0, type5);\n        }\n        this._offset += text0.length;\n      } else {\n        address0 = null;\n      }\n      return this._nodeCache[\"charset_escape\"][index0] = address0;\n    },\n    __consume__charset_range_escape: function(input) {\n      var address0 = null, index0 = this._offset;\n      this._nodeCache[\"charset_range_escape\"] = this._nodeCache[\"charset_range_escape\"] || {};\n      var cached = this._nodeCache[\"charset_range_escape\"][index0];\n      if (cached) {\n        this._offset += cached.textValue.length;\n        return cached;\n      }\n      var index1 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n      var address1 = null;\n      var slice0 = null;\n      if (this._input.length > this._offset) {\n        slice0 = this._input.substring(this._offset, this._offset + 1);\n      } else {\n        slice0 = null;\n      }\n      if (slice0 === \"\\\\\") {\n        var klass0 = this.constructor.SyntaxNode;\n        var type0 = null;\n        address1 = new klass0(\"\\\\\", this._offset, []);\n        if (typeof type0 === \"object\") {\n          extend(address1, type0);\n        }\n        this._offset += 1;\n      } else {\n        address1 = null;\n        var slice1 = null;\n        if (this._input.length > this._offset) {\n          slice1 = this._input.substring(this._offset, this._offset + 1);\n        } else {\n          slice1 = null;\n        }\n        if (!this.error || this.error.offset <= this._offset) {\n          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"\\\\\\\\\\\"\"};\n        }\n      }\n      if (address1) {\n        elements0.push(address1);\n        text0 += address1.textValue;\n        var address2 = null;\n        var index2 = this._offset;\n        var index3 = this._offset, elements1 = [], labelled1 = {}, text1 = \"\";\n        var address3 = null;\n        var slice2 = null;\n        if (this._input.length > this._offset) {\n          slice2 = this._input.substring(this._offset, this._offset + 1);\n        } else {\n          slice2 = null;\n        }\n        if (slice2 && /^[bfnrtv]/.test(slice2)) {\n          var klass1 = this.constructor.SyntaxNode;\n          var type1 = null;\n          address3 = new klass1(slice2, this._offset, []);\n          if (typeof type1 === \"object\") {\n            extend(address3, type1);\n          }\n          this._offset += 1;\n        } else {\n          address3 = null;\n          var slice3 = null;\n          if (this._input.length > this._offset) {\n            slice3 = this._input.substring(this._offset, this._offset + 1);\n          } else {\n            slice3 = null;\n          }\n          if (!this.error || this.error.offset <= this._offset) {\n            this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[bfnrtv]\"};\n          }\n        }\n        if (address3) {\n          elements1.push(address3);\n          text1 += address3.textValue;\n          labelled1.code = address3;\n          var address4 = null;\n          var index4 = this._offset;\n          var slice4 = null;\n          if (this._input.length > this._offset) {\n            slice4 = this._input.substring(this._offset, this._offset + 0);\n          } else {\n            slice4 = null;\n          }\n          if (slice4 === \"\") {\n            var klass2 = this.constructor.SyntaxNode;\n            var type2 = null;\n            address4 = new klass2(\"\", this._offset, []);\n            if (typeof type2 === \"object\") {\n              extend(address4, type2);\n            }\n            this._offset += 0;\n          } else {\n            address4 = null;\n            var slice5 = null;\n            if (this._input.length > this._offset) {\n              slice5 = this._input.substring(this._offset, this._offset + 1);\n            } else {\n              slice5 = null;\n            }\n            if (!this.error || this.error.offset <= this._offset) {\n              this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"\\\"\"};\n            }\n          }\n          if (address4) {\n          } else {\n            this._offset = index4;\n            var klass3 = this.constructor.SyntaxNode;\n            var type3 = null;\n            address4 = new klass3(\"\", this._offset, []);\n            if (typeof type3 === \"object\") {\n              extend(address4, type3);\n            }\n            this._offset += 0;\n          }\n          if (address4) {\n            elements1.push(address4);\n            text1 += address4.textValue;\n            labelled1.arg = address4;\n          } else {\n            elements1 = null;\n            this._offset = index3;\n          }\n        } else {\n          elements1 = null;\n          this._offset = index3;\n        }\n        if (elements1) {\n          this._offset = index3;\n          var klass4 = this.constructor.SyntaxNode;\n          var type4 = null;\n          address2 = new klass4(text1, this._offset, elements1, labelled1);\n          if (typeof type4 === \"object\") {\n            extend(address2, type4);\n          }\n          this._offset += text1.length;\n        } else {\n          address2 = null;\n        }\n        if (address2) {\n        } else {\n          this._offset = index2;\n          address2 = this.__consume__control_escape();\n          if (address2) {\n          } else {\n            this._offset = index2;\n            address2 = this.__consume__octal_escape();\n            if (address2) {\n            } else {\n              this._offset = index2;\n              address2 = this.__consume__hex_escape();\n              if (address2) {\n              } else {\n                this._offset = index2;\n                address2 = this.__consume__unicode_escape();\n                if (address2) {\n                } else {\n                  this._offset = index2;\n                  address2 = this.__consume__null_escape();\n                  if (address2) {\n                  } else {\n                    this._offset = index2;\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (address2) {\n          elements0.push(address2);\n          text0 += address2.textValue;\n          labelled0.esc = address2;\n        } else {\n          elements0 = null;\n          this._offset = index1;\n        }\n      } else {\n        elements0 = null;\n        this._offset = index1;\n      }\n      if (elements0) {\n        this._offset = index1;\n        var klass5 = this.constructor.SyntaxNode;\n        var type5 = null;\n        address0 = new klass5(text0, this._offset, elements0, labelled0);\n        if (typeof type5 === \"object\") {\n          extend(address0, type5);\n        }\n        this._offset += text0.length;\n      } else {\n        address0 = null;\n      }\n      return this._nodeCache[\"charset_range_escape\"][index0] = address0;\n    },\n    __consume__charset_literal: function(input) {\n      var address0 = null, index0 = this._offset;\n      this._nodeCache[\"charset_literal\"] = this._nodeCache[\"charset_literal\"] || {};\n      var cached = this._nodeCache[\"charset_literal\"][index0];\n      if (cached) {\n        this._offset += cached.textValue.length;\n        return cached;\n      }\n      var index1 = this._offset;\n      var index2 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n      var address1 = null;\n      var index3 = this._offset;\n      var slice0 = null;\n      if (this._input.length > this._offset) {\n        slice0 = this._input.substring(this._offset, this._offset + 0);\n      } else {\n        slice0 = null;\n      }\n      if (slice0 === \"\") {\n        var klass0 = this.constructor.SyntaxNode;\n        var type0 = null;\n        address1 = new klass0(\"\", this._offset, []);\n        if (typeof type0 === \"object\") {\n          extend(address1, type0);\n        }\n        this._offset += 0;\n      } else {\n        address1 = null;\n        var slice1 = null;\n        if (this._input.length > this._offset) {\n          slice1 = this._input.substring(this._offset, this._offset + 1);\n        } else {\n          slice1 = null;\n        }\n        if (!this.error || this.error.offset <= this._offset) {\n          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"\\\"\"};\n        }\n      }\n      if (address1) {\n      } else {\n        this._offset = index3;\n        var klass1 = this.constructor.SyntaxNode;\n        var type1 = null;\n        address1 = new klass1(\"\", this._offset, []);\n        if (typeof type1 === \"object\") {\n          extend(address1, type1);\n        }\n        this._offset += 0;\n      }\n      if (address1) {\n        elements0.push(address1);\n        text0 += address1.textValue;\n        var address2 = null;\n        var slice2 = null;\n        if (this._input.length > this._offset) {\n          slice2 = this._input.substring(this._offset, this._offset + 1);\n        } else {\n          slice2 = null;\n        }\n        if (slice2 && /^[^\\\\\\]]/.test(slice2)) {\n          var klass2 = this.constructor.SyntaxNode;\n          var type2 = null;\n          address2 = new klass2(slice2, this._offset, []);\n          if (typeof type2 === \"object\") {\n            extend(address2, type2);\n          }\n          this._offset += 1;\n        } else {\n          address2 = null;\n          var slice3 = null;\n          if (this._input.length > this._offset) {\n            slice3 = this._input.substring(this._offset, this._offset + 1);\n          } else {\n            slice3 = null;\n          }\n          if (!this.error || this.error.offset <= this._offset) {\n            this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[^\\\\\\\\\\\\]]\"};\n          }\n        }\n        if (address2) {\n          elements0.push(address2);\n          text0 += address2.textValue;\n          labelled0.literal = address2;\n        } else {\n          elements0 = null;\n          this._offset = index2;\n        }\n      } else {\n        elements0 = null;\n        this._offset = index2;\n      }\n      if (elements0) {\n        this._offset = index2;\n        var klass3 = this.constructor.SyntaxNode;\n        var type3 = null;\n        address0 = new klass3(text0, this._offset, elements0, labelled0);\n        if (typeof type3 === \"object\") {\n          extend(address0, type3);\n        }\n        this._offset += text0.length;\n      } else {\n        address0 = null;\n      }\n      if (address0) {\n      } else {\n        this._offset = index1;\n        var index4 = this._offset, elements1 = [], labelled1 = {}, text1 = \"\";\n        var address3 = null;\n        var slice4 = null;\n        if (this._input.length > this._offset) {\n          slice4 = this._input.substring(this._offset, this._offset + 1);\n        } else {\n          slice4 = null;\n        }\n        if (slice4 === \"\\\\\") {\n          var klass4 = this.constructor.SyntaxNode;\n          var type4 = null;\n          address3 = new klass4(\"\\\\\", this._offset, []);\n          if (typeof type4 === \"object\") {\n            extend(address3, type4);\n          }\n          this._offset += 1;\n        } else {\n          address3 = null;\n          var slice5 = null;\n          if (this._input.length > this._offset) {\n            slice5 = this._input.substring(this._offset, this._offset + 1);\n          } else {\n            slice5 = null;\n          }\n          if (!this.error || this.error.offset <= this._offset) {\n            this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"\\\\\\\\\\\"\"};\n          }\n        }\n        if (address3) {\n          elements1.push(address3);\n          text1 += address3.textValue;\n          labelled1.literal = address3;\n          var address4 = null;\n          var index5 = this._offset;\n          var slice6 = null;\n          if (this._input.length > this._offset) {\n            slice6 = this._input.substring(this._offset, this._offset + 1);\n          } else {\n            slice6 = null;\n          }\n          if (slice6 === \"c\") {\n            var klass5 = this.constructor.SyntaxNode;\n            var type5 = null;\n            address4 = new klass5(\"c\", this._offset, []);\n            if (typeof type5 === \"object\") {\n              extend(address4, type5);\n            }\n            this._offset += 1;\n          } else {\n            address4 = null;\n            var slice7 = null;\n            if (this._input.length > this._offset) {\n              slice7 = this._input.substring(this._offset, this._offset + 1);\n            } else {\n              slice7 = null;\n            }\n            if (!this.error || this.error.offset <= this._offset) {\n              this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"c\\\"\"};\n            }\n          }\n          this._offset = index5;\n          if (address4) {\n            var klass6 = this.constructor.SyntaxNode;\n            var type6 = null;\n            address4 = new klass6(\"\", this._offset, []);\n            if (typeof type6 === \"object\") {\n              extend(address4, type6);\n            }\n            this._offset += 0;\n          } else {\n            address4 = null;\n          }\n          if (address4) {\n            elements1.push(address4);\n            text1 += address4.textValue;\n          } else {\n            elements1 = null;\n            this._offset = index4;\n          }\n        } else {\n          elements1 = null;\n          this._offset = index4;\n        }\n        if (elements1) {\n          this._offset = index4;\n          var klass7 = this.constructor.SyntaxNode;\n          var type7 = null;\n          address0 = new klass7(text1, this._offset, elements1, labelled1);\n          if (typeof type7 === \"object\") {\n            extend(address0, type7);\n          }\n          this._offset += text1.length;\n        } else {\n          address0 = null;\n        }\n        if (address0) {\n        } else {\n          this._offset = index1;\n          var index6 = this._offset, elements2 = [], labelled2 = {}, text2 = \"\";\n          var address5 = null;\n          var slice8 = null;\n          if (this._input.length > this._offset) {\n            slice8 = this._input.substring(this._offset, this._offset + 1);\n          } else {\n            slice8 = null;\n          }\n          if (slice8 === \"\\\\\") {\n            var klass8 = this.constructor.SyntaxNode;\n            var type8 = null;\n            address5 = new klass8(\"\\\\\", this._offset, []);\n            if (typeof type8 === \"object\") {\n              extend(address5, type8);\n            }\n            this._offset += 1;\n          } else {\n            address5 = null;\n            var slice9 = null;\n            if (this._input.length > this._offset) {\n              slice9 = this._input.substring(this._offset, this._offset + 1);\n            } else {\n              slice9 = null;\n            }\n            if (!this.error || this.error.offset <= this._offset) {\n              this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"\\\\\\\\\\\"\"};\n            }\n          }\n          if (address5) {\n            elements2.push(address5);\n            text2 += address5.textValue;\n            var address6 = null;\n            var slice10 = null;\n            if (this._input.length > this._offset) {\n              slice10 = this._input.substring(this._offset, this._offset + 1);\n            } else {\n              slice10 = null;\n            }\n            if (slice10 && /^[^bdDfnrsStvwW]/.test(slice10)) {\n              var klass9 = this.constructor.SyntaxNode;\n              var type9 = null;\n              address6 = new klass9(slice10, this._offset, []);\n              if (typeof type9 === \"object\") {\n                extend(address6, type9);\n              }\n              this._offset += 1;\n            } else {\n              address6 = null;\n              var slice11 = null;\n              if (this._input.length > this._offset) {\n                slice11 = this._input.substring(this._offset, this._offset + 1);\n              } else {\n                slice11 = null;\n              }\n              if (!this.error || this.error.offset <= this._offset) {\n                this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[^bdDfnrsStvwW]\"};\n              }\n            }\n            if (address6) {\n              elements2.push(address6);\n              text2 += address6.textValue;\n              labelled2.literal = address6;\n            } else {\n              elements2 = null;\n              this._offset = index6;\n            }\n          } else {\n            elements2 = null;\n            this._offset = index6;\n          }\n          if (elements2) {\n            this._offset = index6;\n            var klass10 = this.constructor.SyntaxNode;\n            var type10 = null;\n            address0 = new klass10(text2, this._offset, elements2, labelled2);\n            if (typeof type10 === \"object\") {\n              extend(address0, type10);\n            }\n            this._offset += text2.length;\n          } else {\n            address0 = null;\n          }\n          if (address0) {\n          } else {\n            this._offset = index1;\n          }\n        }\n      }\n      return this._nodeCache[\"charset_literal\"][index0] = address0;\n    },\n    __consume__terminal: function(input) {\n      var address0 = null, index0 = this._offset;\n      this._nodeCache[\"terminal\"] = this._nodeCache[\"terminal\"] || {};\n      var cached = this._nodeCache[\"terminal\"][index0];\n      if (cached) {\n        this._offset += cached.textValue.length;\n        return cached;\n      }\n      var index1 = this._offset;\n      var slice0 = null;\n      if (this._input.length > this._offset) {\n        slice0 = this._input.substring(this._offset, this._offset + 1);\n      } else {\n        slice0 = null;\n      }\n      if (slice0 === \".\") {\n        var klass0 = this.constructor.SyntaxNode;\n        var type0 = find(this.constructor, \"AnyCharacter\");\n        address0 = new klass0(\".\", this._offset, []);\n        if (typeof type0 === \"object\") {\n          extend(address0, type0);\n        }\n        this._offset += 1;\n      } else {\n        address0 = null;\n        var slice1 = null;\n        if (this._input.length > this._offset) {\n          slice1 = this._input.substring(this._offset, this._offset + 1);\n        } else {\n          slice1 = null;\n        }\n        if (!this.error || this.error.offset <= this._offset) {\n          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\".\\\"\"};\n        }\n      }\n      if (address0) {\n      } else {\n        this._offset = index1;\n        address0 = this.__consume__escape();\n        var type1 = find(this.constructor, \"Escape\");\n        if (typeof type1 === \"object\") {\n          extend(address0, type1);\n        }\n        if (address0) {\n        } else {\n          this._offset = index1;\n          address0 = this.__consume__literal();\n          var type2 = find(this.constructor, \"Literal\");\n          if (typeof type2 === \"object\") {\n            extend(address0, type2);\n          }\n          if (address0) {\n          } else {\n            this._offset = index1;\n          }\n        }\n      }\n      return this._nodeCache[\"terminal\"][index0] = address0;\n    },\n    __consume__escape: function(input) {\n      var address0 = null, index0 = this._offset;\n      this._nodeCache[\"escape\"] = this._nodeCache[\"escape\"] || {};\n      var cached = this._nodeCache[\"escape\"][index0];\n      if (cached) {\n        this._offset += cached.textValue.length;\n        return cached;\n      }\n      var index1 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n      var address1 = null;\n      var slice0 = null;\n      if (this._input.length > this._offset) {\n        slice0 = this._input.substring(this._offset, this._offset + 1);\n      } else {\n        slice0 = null;\n      }\n      if (slice0 === \"\\\\\") {\n        var klass0 = this.constructor.SyntaxNode;\n        var type0 = null;\n        address1 = new klass0(\"\\\\\", this._offset, []);\n        if (typeof type0 === \"object\") {\n          extend(address1, type0);\n        }\n        this._offset += 1;\n      } else {\n        address1 = null;\n        var slice1 = null;\n        if (this._input.length > this._offset) {\n          slice1 = this._input.substring(this._offset, this._offset + 1);\n        } else {\n          slice1 = null;\n        }\n        if (!this.error || this.error.offset <= this._offset) {\n          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"\\\\\\\\\\\"\"};\n        }\n      }\n      if (address1) {\n        elements0.push(address1);\n        text0 += address1.textValue;\n        var address2 = null;\n        var index2 = this._offset;\n        var index3 = this._offset, elements1 = [], labelled1 = {}, text1 = \"\";\n        var address3 = null;\n        var slice2 = null;\n        if (this._input.length > this._offset) {\n          slice2 = this._input.substring(this._offset, this._offset + 1);\n        } else {\n          slice2 = null;\n        }\n        if (slice2 && /^[bBdDfnrsStvwW1-9]/.test(slice2)) {\n          var klass1 = this.constructor.SyntaxNode;\n          var type1 = null;\n          address3 = new klass1(slice2, this._offset, []);\n          if (typeof type1 === \"object\") {\n            extend(address3, type1);\n          }\n          this._offset += 1;\n        } else {\n          address3 = null;\n          var slice3 = null;\n          if (this._input.length > this._offset) {\n            slice3 = this._input.substring(this._offset, this._offset + 1);\n          } else {\n            slice3 = null;\n          }\n          if (!this.error || this.error.offset <= this._offset) {\n            this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[bBdDfnrsStvwW1-9]\"};\n          }\n        }\n        if (address3) {\n          elements1.push(address3);\n          text1 += address3.textValue;\n          labelled1.code = address3;\n          var address4 = null;\n          var index4 = this._offset;\n          var slice4 = null;\n          if (this._input.length > this._offset) {\n            slice4 = this._input.substring(this._offset, this._offset + 0);\n          } else {\n            slice4 = null;\n          }\n          if (slice4 === \"\") {\n            var klass2 = this.constructor.SyntaxNode;\n            var type2 = null;\n            address4 = new klass2(\"\", this._offset, []);\n            if (typeof type2 === \"object\") {\n              extend(address4, type2);\n            }\n            this._offset += 0;\n          } else {\n            address4 = null;\n            var slice5 = null;\n            if (this._input.length > this._offset) {\n              slice5 = this._input.substring(this._offset, this._offset + 1);\n            } else {\n              slice5 = null;\n            }\n            if (!this.error || this.error.offset <= this._offset) {\n              this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"\\\"\"};\n            }\n          }\n          if (address4) {\n          } else {\n            this._offset = index4;\n            var klass3 = this.constructor.SyntaxNode;\n            var type3 = null;\n            address4 = new klass3(\"\", this._offset, []);\n            if (typeof type3 === \"object\") {\n              extend(address4, type3);\n            }\n            this._offset += 0;\n          }\n          if (address4) {\n            elements1.push(address4);\n            text1 += address4.textValue;\n            labelled1.arg = address4;\n          } else {\n            elements1 = null;\n            this._offset = index3;\n          }\n        } else {\n          elements1 = null;\n          this._offset = index3;\n        }\n        if (elements1) {\n          this._offset = index3;\n          var klass4 = this.constructor.SyntaxNode;\n          var type4 = null;\n          address2 = new klass4(text1, this._offset, elements1, labelled1);\n          if (typeof type4 === \"object\") {\n            extend(address2, type4);\n          }\n          this._offset += text1.length;\n        } else {\n          address2 = null;\n        }\n        if (address2) {\n        } else {\n          this._offset = index2;\n          address2 = this.__consume__control_escape();\n          if (address2) {\n          } else {\n            this._offset = index2;\n            address2 = this.__consume__octal_escape();\n            if (address2) {\n            } else {\n              this._offset = index2;\n              address2 = this.__consume__hex_escape();\n              if (address2) {\n              } else {\n                this._offset = index2;\n                address2 = this.__consume__unicode_escape();\n                if (address2) {\n                } else {\n                  this._offset = index2;\n                  address2 = this.__consume__null_escape();\n                  if (address2) {\n                  } else {\n                    this._offset = index2;\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (address2) {\n          elements0.push(address2);\n          text0 += address2.textValue;\n          labelled0.esc = address2;\n        } else {\n          elements0 = null;\n          this._offset = index1;\n        }\n      } else {\n        elements0 = null;\n        this._offset = index1;\n      }\n      if (elements0) {\n        this._offset = index1;\n        var klass5 = this.constructor.SyntaxNode;\n        var type5 = null;\n        address0 = new klass5(text0, this._offset, elements0, labelled0);\n        if (typeof type5 === \"object\") {\n          extend(address0, type5);\n        }\n        this._offset += text0.length;\n      } else {\n        address0 = null;\n      }\n      return this._nodeCache[\"escape\"][index0] = address0;\n    },\n    __consume__literal: function(input) {\n      var address0 = null, index0 = this._offset;\n      this._nodeCache[\"literal\"] = this._nodeCache[\"literal\"] || {};\n      var cached = this._nodeCache[\"literal\"][index0];\n      if (cached) {\n        this._offset += cached.textValue.length;\n        return cached;\n      }\n      var index1 = this._offset;\n      var index2 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n      var address1 = null;\n      var index3 = this._offset;\n      var slice0 = null;\n      if (this._input.length > this._offset) {\n        slice0 = this._input.substring(this._offset, this._offset + 0);\n      } else {\n        slice0 = null;\n      }\n      if (slice0 === \"\") {\n        var klass0 = this.constructor.SyntaxNode;\n        var type0 = null;\n        address1 = new klass0(\"\", this._offset, []);\n        if (typeof type0 === \"object\") {\n          extend(address1, type0);\n        }\n        this._offset += 0;\n      } else {\n        address1 = null;\n        var slice1 = null;\n        if (this._input.length > this._offset) {\n          slice1 = this._input.substring(this._offset, this._offset + 1);\n        } else {\n          slice1 = null;\n        }\n        if (!this.error || this.error.offset <= this._offset) {\n          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"\\\"\"};\n        }\n      }\n      if (address1) {\n      } else {\n        this._offset = index3;\n        var klass1 = this.constructor.SyntaxNode;\n        var type1 = null;\n        address1 = new klass1(\"\", this._offset, []);\n        if (typeof type1 === \"object\") {\n          extend(address1, type1);\n        }\n        this._offset += 0;\n      }\n      if (address1) {\n        elements0.push(address1);\n        text0 += address1.textValue;\n        var address2 = null;\n        var slice2 = null;\n        if (this._input.length > this._offset) {\n          slice2 = this._input.substring(this._offset, this._offset + 1);\n        } else {\n          slice2 = null;\n        }\n        if (slice2 && /^[^|\\\\/.\\[\\(\\)?+*$^]/.test(slice2)) {\n          var klass2 = this.constructor.SyntaxNode;\n          var type2 = null;\n          address2 = new klass2(slice2, this._offset, []);\n          if (typeof type2 === \"object\") {\n            extend(address2, type2);\n          }\n          this._offset += 1;\n        } else {\n          address2 = null;\n          var slice3 = null;\n          if (this._input.length > this._offset) {\n            slice3 = this._input.substring(this._offset, this._offset + 1);\n          } else {\n            slice3 = null;\n          }\n          if (!this.error || this.error.offset <= this._offset) {\n            this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[^|\\\\\\\\/.\\\\[\\\\(\\\\)?+*$^]\"};\n          }\n        }\n        if (address2) {\n          elements0.push(address2);\n          text0 += address2.textValue;\n          labelled0.literal = address2;\n        } else {\n          elements0 = null;\n          this._offset = index2;\n        }\n      } else {\n        elements0 = null;\n        this._offset = index2;\n      }\n      if (elements0) {\n        this._offset = index2;\n        var klass3 = this.constructor.SyntaxNode;\n        var type3 = null;\n        address0 = new klass3(text0, this._offset, elements0, labelled0);\n        if (typeof type3 === \"object\") {\n          extend(address0, type3);\n        }\n        this._offset += text0.length;\n      } else {\n        address0 = null;\n      }\n      if (address0) {\n      } else {\n        this._offset = index1;\n        var index4 = this._offset, elements1 = [], labelled1 = {}, text1 = \"\";\n        var address3 = null;\n        var slice4 = null;\n        if (this._input.length > this._offset) {\n          slice4 = this._input.substring(this._offset, this._offset + 1);\n        } else {\n          slice4 = null;\n        }\n        if (slice4 === \"\\\\\") {\n          var klass4 = this.constructor.SyntaxNode;\n          var type4 = null;\n          address3 = new klass4(\"\\\\\", this._offset, []);\n          if (typeof type4 === \"object\") {\n            extend(address3, type4);\n          }\n          this._offset += 1;\n        } else {\n          address3 = null;\n          var slice5 = null;\n          if (this._input.length > this._offset) {\n            slice5 = this._input.substring(this._offset, this._offset + 1);\n          } else {\n            slice5 = null;\n          }\n          if (!this.error || this.error.offset <= this._offset) {\n            this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"\\\\\\\\\\\"\"};\n          }\n        }\n        if (address3) {\n          elements1.push(address3);\n          text1 += address3.textValue;\n          labelled1.literal = address3;\n          var address4 = null;\n          var index5 = this._offset;\n          var slice6 = null;\n          if (this._input.length > this._offset) {\n            slice6 = this._input.substring(this._offset, this._offset + 1);\n          } else {\n            slice6 = null;\n          }\n          if (slice6 === \"c\") {\n            var klass5 = this.constructor.SyntaxNode;\n            var type5 = null;\n            address4 = new klass5(\"c\", this._offset, []);\n            if (typeof type5 === \"object\") {\n              extend(address4, type5);\n            }\n            this._offset += 1;\n          } else {\n            address4 = null;\n            var slice7 = null;\n            if (this._input.length > this._offset) {\n              slice7 = this._input.substring(this._offset, this._offset + 1);\n            } else {\n              slice7 = null;\n            }\n            if (!this.error || this.error.offset <= this._offset) {\n              this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"c\\\"\"};\n            }\n          }\n          this._offset = index5;\n          if (address4) {\n            var klass6 = this.constructor.SyntaxNode;\n            var type6 = null;\n            address4 = new klass6(\"\", this._offset, []);\n            if (typeof type6 === \"object\") {\n              extend(address4, type6);\n            }\n            this._offset += 0;\n          } else {\n            address4 = null;\n          }\n          if (address4) {\n            elements1.push(address4);\n            text1 += address4.textValue;\n          } else {\n            elements1 = null;\n            this._offset = index4;\n          }\n        } else {\n          elements1 = null;\n          this._offset = index4;\n        }\n        if (elements1) {\n          this._offset = index4;\n          var klass7 = this.constructor.SyntaxNode;\n          var type7 = null;\n          address0 = new klass7(text1, this._offset, elements1, labelled1);\n          if (typeof type7 === \"object\") {\n            extend(address0, type7);\n          }\n          this._offset += text1.length;\n        } else {\n          address0 = null;\n        }\n        if (address0) {\n        } else {\n          this._offset = index1;\n          var index6 = this._offset, elements2 = [], labelled2 = {}, text2 = \"\";\n          var address5 = null;\n          var slice8 = null;\n          if (this._input.length > this._offset) {\n            slice8 = this._input.substring(this._offset, this._offset + 1);\n          } else {\n            slice8 = null;\n          }\n          if (slice8 === \"\\\\\") {\n            var klass8 = this.constructor.SyntaxNode;\n            var type8 = null;\n            address5 = new klass8(\"\\\\\", this._offset, []);\n            if (typeof type8 === \"object\") {\n              extend(address5, type8);\n            }\n            this._offset += 1;\n          } else {\n            address5 = null;\n            var slice9 = null;\n            if (this._input.length > this._offset) {\n              slice9 = this._input.substring(this._offset, this._offset + 1);\n            } else {\n              slice9 = null;\n            }\n            if (!this.error || this.error.offset <= this._offset) {\n              this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"\\\\\\\\\\\"\"};\n            }\n          }\n          if (address5) {\n            elements2.push(address5);\n            text2 += address5.textValue;\n            var address6 = null;\n            var slice10 = null;\n            if (this._input.length > this._offset) {\n              slice10 = this._input.substring(this._offset, this._offset + 1);\n            } else {\n              slice10 = null;\n            }\n            var temp0 = slice10;\n            if (temp0 === null) {\n              address6 = null;\n              var slice11 = null;\n              if (this._input.length > this._offset) {\n                slice11 = this._input.substring(this._offset, this._offset + 1);\n              } else {\n                slice11 = null;\n              }\n              if (!this.error || this.error.offset <= this._offset) {\n                this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"<any char>\"};\n              }\n            } else {\n              var klass9 = this.constructor.SyntaxNode;\n              var type9 = null;\n              address6 = new klass9(temp0, this._offset, []);\n              if (typeof type9 === \"object\") {\n                extend(address6, type9);\n              }\n              this._offset += 1;\n            }\n            if (address6) {\n              elements2.push(address6);\n              text2 += address6.textValue;\n              labelled2.literal = address6;\n            } else {\n              elements2 = null;\n              this._offset = index6;\n            }\n          } else {\n            elements2 = null;\n            this._offset = index6;\n          }\n          if (elements2) {\n            this._offset = index6;\n            var klass10 = this.constructor.SyntaxNode;\n            var type10 = null;\n            address0 = new klass10(text2, this._offset, elements2, labelled2);\n            if (typeof type10 === \"object\") {\n              extend(address0, type10);\n            }\n            this._offset += text2.length;\n          } else {\n            address0 = null;\n          }\n          if (address0) {\n          } else {\n            this._offset = index1;\n          }\n        }\n      }\n      return this._nodeCache[\"literal\"][index0] = address0;\n    },\n    __consume__control_escape: function(input) {\n      var address0 = null, index0 = this._offset;\n      this._nodeCache[\"control_escape\"] = this._nodeCache[\"control_escape\"] || {};\n      var cached = this._nodeCache[\"control_escape\"][index0];\n      if (cached) {\n        this._offset += cached.textValue.length;\n        return cached;\n      }\n      var index1 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n      var address1 = null;\n      var slice0 = null;\n      if (this._input.length > this._offset) {\n        slice0 = this._input.substring(this._offset, this._offset + 1);\n      } else {\n        slice0 = null;\n      }\n      if (slice0 === \"c\") {\n        var klass0 = this.constructor.SyntaxNode;\n        var type0 = null;\n        address1 = new klass0(\"c\", this._offset, []);\n        if (typeof type0 === \"object\") {\n          extend(address1, type0);\n        }\n        this._offset += 1;\n      } else {\n        address1 = null;\n        var slice1 = null;\n        if (this._input.length > this._offset) {\n          slice1 = this._input.substring(this._offset, this._offset + 1);\n        } else {\n          slice1 = null;\n        }\n        if (!this.error || this.error.offset <= this._offset) {\n          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"c\\\"\"};\n        }\n      }\n      if (address1) {\n        elements0.push(address1);\n        text0 += address1.textValue;\n        labelled0.code = address1;\n        var address2 = null;\n        var slice2 = null;\n        if (this._input.length > this._offset) {\n          slice2 = this._input.substring(this._offset, this._offset + 1);\n        } else {\n          slice2 = null;\n        }\n        if (slice2 && /^[a-zA-Z]/.test(slice2)) {\n          var klass1 = this.constructor.SyntaxNode;\n          var type1 = null;\n          address2 = new klass1(slice2, this._offset, []);\n          if (typeof type1 === \"object\") {\n            extend(address2, type1);\n          }\n          this._offset += 1;\n        } else {\n          address2 = null;\n          var slice3 = null;\n          if (this._input.length > this._offset) {\n            slice3 = this._input.substring(this._offset, this._offset + 1);\n          } else {\n            slice3 = null;\n          }\n          if (!this.error || this.error.offset <= this._offset) {\n            this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[a-zA-Z]\"};\n          }\n        }\n        if (address2) {\n          elements0.push(address2);\n          text0 += address2.textValue;\n          labelled0.arg = address2;\n        } else {\n          elements0 = null;\n          this._offset = index1;\n        }\n      } else {\n        elements0 = null;\n        this._offset = index1;\n      }\n      if (elements0) {\n        this._offset = index1;\n        var klass2 = this.constructor.SyntaxNode;\n        var type2 = null;\n        address0 = new klass2(text0, this._offset, elements0, labelled0);\n        if (typeof type2 === \"object\") {\n          extend(address0, type2);\n        }\n        this._offset += text0.length;\n      } else {\n        address0 = null;\n      }\n      return this._nodeCache[\"control_escape\"][index0] = address0;\n    },\n    __consume__octal_escape: function(input) {\n      var address0 = null, index0 = this._offset;\n      this._nodeCache[\"octal_escape\"] = this._nodeCache[\"octal_escape\"] || {};\n      var cached = this._nodeCache[\"octal_escape\"][index0];\n      if (cached) {\n        this._offset += cached.textValue.length;\n        return cached;\n      }\n      var index1 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n      var address1 = null;\n      var slice0 = null;\n      if (this._input.length > this._offset) {\n        slice0 = this._input.substring(this._offset, this._offset + 1);\n      } else {\n        slice0 = null;\n      }\n      if (slice0 === \"0\") {\n        var klass0 = this.constructor.SyntaxNode;\n        var type0 = null;\n        address1 = new klass0(\"0\", this._offset, []);\n        if (typeof type0 === \"object\") {\n          extend(address1, type0);\n        }\n        this._offset += 1;\n      } else {\n        address1 = null;\n        var slice1 = null;\n        if (this._input.length > this._offset) {\n          slice1 = this._input.substring(this._offset, this._offset + 1);\n        } else {\n          slice1 = null;\n        }\n        if (!this.error || this.error.offset <= this._offset) {\n          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"0\\\"\"};\n        }\n      }\n      if (address1) {\n        elements0.push(address1);\n        text0 += address1.textValue;\n        labelled0.code = address1;\n        var address2 = null;\n        var remaining0 = 1, index2 = this._offset, elements1 = [], text1 = \"\", address3 = true;\n        while (address3) {\n          var slice2 = null;\n          if (this._input.length > this._offset) {\n            slice2 = this._input.substring(this._offset, this._offset + 1);\n          } else {\n            slice2 = null;\n          }\n          if (slice2 && /^[0-7]/.test(slice2)) {\n            var klass1 = this.constructor.SyntaxNode;\n            var type1 = null;\n            address3 = new klass1(slice2, this._offset, []);\n            if (typeof type1 === \"object\") {\n              extend(address3, type1);\n            }\n            this._offset += 1;\n          } else {\n            address3 = null;\n            var slice3 = null;\n            if (this._input.length > this._offset) {\n              slice3 = this._input.substring(this._offset, this._offset + 1);\n            } else {\n              slice3 = null;\n            }\n            if (!this.error || this.error.offset <= this._offset) {\n              this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[0-7]\"};\n            }\n          }\n          if (address3) {\n            elements1.push(address3);\n            text1 += address3.textValue;\n            remaining0 -= 1;\n          }\n        }\n        if (remaining0 <= 0) {\n          this._offset = index2;\n          var klass2 = this.constructor.SyntaxNode;\n          var type2 = null;\n          address2 = new klass2(text1, this._offset, elements1);\n          if (typeof type2 === \"object\") {\n            extend(address2, type2);\n          }\n          this._offset += text1.length;\n        } else {\n          address2 = null;\n        }\n        if (address2) {\n          elements0.push(address2);\n          text0 += address2.textValue;\n          labelled0.arg = address2;\n        } else {\n          elements0 = null;\n          this._offset = index1;\n        }\n      } else {\n        elements0 = null;\n        this._offset = index1;\n      }\n      if (elements0) {\n        this._offset = index1;\n        var klass3 = this.constructor.SyntaxNode;\n        var type3 = null;\n        address0 = new klass3(text0, this._offset, elements0, labelled0);\n        if (typeof type3 === \"object\") {\n          extend(address0, type3);\n        }\n        this._offset += text0.length;\n      } else {\n        address0 = null;\n      }\n      return this._nodeCache[\"octal_escape\"][index0] = address0;\n    },\n    __consume__hex_escape: function(input) {\n      var address0 = null, index0 = this._offset;\n      this._nodeCache[\"hex_escape\"] = this._nodeCache[\"hex_escape\"] || {};\n      var cached = this._nodeCache[\"hex_escape\"][index0];\n      if (cached) {\n        this._offset += cached.textValue.length;\n        return cached;\n      }\n      var index1 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n      var address1 = null;\n      var slice0 = null;\n      if (this._input.length > this._offset) {\n        slice0 = this._input.substring(this._offset, this._offset + 1);\n      } else {\n        slice0 = null;\n      }\n      if (slice0 === \"x\") {\n        var klass0 = this.constructor.SyntaxNode;\n        var type0 = null;\n        address1 = new klass0(\"x\", this._offset, []);\n        if (typeof type0 === \"object\") {\n          extend(address1, type0);\n        }\n        this._offset += 1;\n      } else {\n        address1 = null;\n        var slice1 = null;\n        if (this._input.length > this._offset) {\n          slice1 = this._input.substring(this._offset, this._offset + 1);\n        } else {\n          slice1 = null;\n        }\n        if (!this.error || this.error.offset <= this._offset) {\n          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"x\\\"\"};\n        }\n      }\n      if (address1) {\n        elements0.push(address1);\n        text0 += address1.textValue;\n        labelled0.code = address1;\n        var address2 = null;\n        var index2 = this._offset, elements1 = [], labelled1 = {}, text1 = \"\";\n        var address3 = null;\n        var slice2 = null;\n        if (this._input.length > this._offset) {\n          slice2 = this._input.substring(this._offset, this._offset + 1);\n        } else {\n          slice2 = null;\n        }\n        if (slice2 && /^[0-9a-fA-F]/.test(slice2)) {\n          var klass1 = this.constructor.SyntaxNode;\n          var type1 = null;\n          address3 = new klass1(slice2, this._offset, []);\n          if (typeof type1 === \"object\") {\n            extend(address3, type1);\n          }\n          this._offset += 1;\n        } else {\n          address3 = null;\n          var slice3 = null;\n          if (this._input.length > this._offset) {\n            slice3 = this._input.substring(this._offset, this._offset + 1);\n          } else {\n            slice3 = null;\n          }\n          if (!this.error || this.error.offset <= this._offset) {\n            this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[0-9a-fA-F]\"};\n          }\n        }\n        if (address3) {\n          elements1.push(address3);\n          text1 += address3.textValue;\n          var address4 = null;\n          var slice4 = null;\n          if (this._input.length > this._offset) {\n            slice4 = this._input.substring(this._offset, this._offset + 1);\n          } else {\n            slice4 = null;\n          }\n          if (slice4 && /^[0-9a-fA-F]/.test(slice4)) {\n            var klass2 = this.constructor.SyntaxNode;\n            var type2 = null;\n            address4 = new klass2(slice4, this._offset, []);\n            if (typeof type2 === \"object\") {\n              extend(address4, type2);\n            }\n            this._offset += 1;\n          } else {\n            address4 = null;\n            var slice5 = null;\n            if (this._input.length > this._offset) {\n              slice5 = this._input.substring(this._offset, this._offset + 1);\n            } else {\n              slice5 = null;\n            }\n            if (!this.error || this.error.offset <= this._offset) {\n              this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[0-9a-fA-F]\"};\n            }\n          }\n          if (address4) {\n            elements1.push(address4);\n            text1 += address4.textValue;\n          } else {\n            elements1 = null;\n            this._offset = index2;\n          }\n        } else {\n          elements1 = null;\n          this._offset = index2;\n        }\n        if (elements1) {\n          this._offset = index2;\n          var klass3 = this.constructor.SyntaxNode;\n          var type3 = null;\n          address2 = new klass3(text1, this._offset, elements1, labelled1);\n          if (typeof type3 === \"object\") {\n            extend(address2, type3);\n          }\n          this._offset += text1.length;\n        } else {\n          address2 = null;\n        }\n        if (address2) {\n          elements0.push(address2);\n          text0 += address2.textValue;\n          labelled0.arg = address2;\n        } else {\n          elements0 = null;\n          this._offset = index1;\n        }\n      } else {\n        elements0 = null;\n        this._offset = index1;\n      }\n      if (elements0) {\n        this._offset = index1;\n        var klass4 = this.constructor.SyntaxNode;\n        var type4 = null;\n        address0 = new klass4(text0, this._offset, elements0, labelled0);\n        if (typeof type4 === \"object\") {\n          extend(address0, type4);\n        }\n        this._offset += text0.length;\n      } else {\n        address0 = null;\n      }\n      return this._nodeCache[\"hex_escape\"][index0] = address0;\n    },\n    __consume__unicode_escape: function(input) {\n      var address0 = null, index0 = this._offset;\n      this._nodeCache[\"unicode_escape\"] = this._nodeCache[\"unicode_escape\"] || {};\n      var cached = this._nodeCache[\"unicode_escape\"][index0];\n      if (cached) {\n        this._offset += cached.textValue.length;\n        return cached;\n      }\n      var index1 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n      var address1 = null;\n      var slice0 = null;\n      if (this._input.length > this._offset) {\n        slice0 = this._input.substring(this._offset, this._offset + 1);\n      } else {\n        slice0 = null;\n      }\n      if (slice0 === \"u\") {\n        var klass0 = this.constructor.SyntaxNode;\n        var type0 = null;\n        address1 = new klass0(\"u\", this._offset, []);\n        if (typeof type0 === \"object\") {\n          extend(address1, type0);\n        }\n        this._offset += 1;\n      } else {\n        address1 = null;\n        var slice1 = null;\n        if (this._input.length > this._offset) {\n          slice1 = this._input.substring(this._offset, this._offset + 1);\n        } else {\n          slice1 = null;\n        }\n        if (!this.error || this.error.offset <= this._offset) {\n          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"u\\\"\"};\n        }\n      }\n      if (address1) {\n        elements0.push(address1);\n        text0 += address1.textValue;\n        labelled0.code = address1;\n        var address2 = null;\n        var index2 = this._offset, elements1 = [], labelled1 = {}, text1 = \"\";\n        var address3 = null;\n        var slice2 = null;\n        if (this._input.length > this._offset) {\n          slice2 = this._input.substring(this._offset, this._offset + 1);\n        } else {\n          slice2 = null;\n        }\n        if (slice2 && /^[0-9a-fA-F]/.test(slice2)) {\n          var klass1 = this.constructor.SyntaxNode;\n          var type1 = null;\n          address3 = new klass1(slice2, this._offset, []);\n          if (typeof type1 === \"object\") {\n            extend(address3, type1);\n          }\n          this._offset += 1;\n        } else {\n          address3 = null;\n          var slice3 = null;\n          if (this._input.length > this._offset) {\n            slice3 = this._input.substring(this._offset, this._offset + 1);\n          } else {\n            slice3 = null;\n          }\n          if (!this.error || this.error.offset <= this._offset) {\n            this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[0-9a-fA-F]\"};\n          }\n        }\n        if (address3) {\n          elements1.push(address3);\n          text1 += address3.textValue;\n          var address4 = null;\n          var slice4 = null;\n          if (this._input.length > this._offset) {\n            slice4 = this._input.substring(this._offset, this._offset + 1);\n          } else {\n            slice4 = null;\n          }\n          if (slice4 && /^[0-9a-fA-F]/.test(slice4)) {\n            var klass2 = this.constructor.SyntaxNode;\n            var type2 = null;\n            address4 = new klass2(slice4, this._offset, []);\n            if (typeof type2 === \"object\") {\n              extend(address4, type2);\n            }\n            this._offset += 1;\n          } else {\n            address4 = null;\n            var slice5 = null;\n            if (this._input.length > this._offset) {\n              slice5 = this._input.substring(this._offset, this._offset + 1);\n            } else {\n              slice5 = null;\n            }\n            if (!this.error || this.error.offset <= this._offset) {\n              this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[0-9a-fA-F]\"};\n            }\n          }\n          if (address4) {\n            elements1.push(address4);\n            text1 += address4.textValue;\n            var address5 = null;\n            var slice6 = null;\n            if (this._input.length > this._offset) {\n              slice6 = this._input.substring(this._offset, this._offset + 1);\n            } else {\n              slice6 = null;\n            }\n            if (slice6 && /^[0-9a-fA-F]/.test(slice6)) {\n              var klass3 = this.constructor.SyntaxNode;\n              var type3 = null;\n              address5 = new klass3(slice6, this._offset, []);\n              if (typeof type3 === \"object\") {\n                extend(address5, type3);\n              }\n              this._offset += 1;\n            } else {\n              address5 = null;\n              var slice7 = null;\n              if (this._input.length > this._offset) {\n                slice7 = this._input.substring(this._offset, this._offset + 1);\n              } else {\n                slice7 = null;\n              }\n              if (!this.error || this.error.offset <= this._offset) {\n                this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[0-9a-fA-F]\"};\n              }\n            }\n            if (address5) {\n              elements1.push(address5);\n              text1 += address5.textValue;\n              var address6 = null;\n              var slice8 = null;\n              if (this._input.length > this._offset) {\n                slice8 = this._input.substring(this._offset, this._offset + 1);\n              } else {\n                slice8 = null;\n              }\n              if (slice8 && /^[0-9a-fA-F]/.test(slice8)) {\n                var klass4 = this.constructor.SyntaxNode;\n                var type4 = null;\n                address6 = new klass4(slice8, this._offset, []);\n                if (typeof type4 === \"object\") {\n                  extend(address6, type4);\n                }\n                this._offset += 1;\n              } else {\n                address6 = null;\n                var slice9 = null;\n                if (this._input.length > this._offset) {\n                  slice9 = this._input.substring(this._offset, this._offset + 1);\n                } else {\n                  slice9 = null;\n                }\n                if (!this.error || this.error.offset <= this._offset) {\n                  this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"[0-9a-fA-F]\"};\n                }\n              }\n              if (address6) {\n                elements1.push(address6);\n                text1 += address6.textValue;\n              } else {\n                elements1 = null;\n                this._offset = index2;\n              }\n            } else {\n              elements1 = null;\n              this._offset = index2;\n            }\n          } else {\n            elements1 = null;\n            this._offset = index2;\n          }\n        } else {\n          elements1 = null;\n          this._offset = index2;\n        }\n        if (elements1) {\n          this._offset = index2;\n          var klass5 = this.constructor.SyntaxNode;\n          var type5 = null;\n          address2 = new klass5(text1, this._offset, elements1, labelled1);\n          if (typeof type5 === \"object\") {\n            extend(address2, type5);\n          }\n          this._offset += text1.length;\n        } else {\n          address2 = null;\n        }\n        if (address2) {\n          elements0.push(address2);\n          text0 += address2.textValue;\n          labelled0.arg = address2;\n        } else {\n          elements0 = null;\n          this._offset = index1;\n        }\n      } else {\n        elements0 = null;\n        this._offset = index1;\n      }\n      if (elements0) {\n        this._offset = index1;\n        var klass6 = this.constructor.SyntaxNode;\n        var type6 = null;\n        address0 = new klass6(text0, this._offset, elements0, labelled0);\n        if (typeof type6 === \"object\") {\n          extend(address0, type6);\n        }\n        this._offset += text0.length;\n      } else {\n        address0 = null;\n      }\n      return this._nodeCache[\"unicode_escape\"][index0] = address0;\n    },\n    __consume__null_escape: function(input) {\n      var address0 = null, index0 = this._offset;\n      this._nodeCache[\"null_escape\"] = this._nodeCache[\"null_escape\"] || {};\n      var cached = this._nodeCache[\"null_escape\"][index0];\n      if (cached) {\n        this._offset += cached.textValue.length;\n        return cached;\n      }\n      var index1 = this._offset, elements0 = [], labelled0 = {}, text0 = \"\";\n      var address1 = null;\n      var slice0 = null;\n      if (this._input.length > this._offset) {\n        slice0 = this._input.substring(this._offset, this._offset + 1);\n      } else {\n        slice0 = null;\n      }\n      if (slice0 === \"0\") {\n        var klass0 = this.constructor.SyntaxNode;\n        var type0 = null;\n        address1 = new klass0(\"0\", this._offset, []);\n        if (typeof type0 === \"object\") {\n          extend(address1, type0);\n        }\n        this._offset += 1;\n      } else {\n        address1 = null;\n        var slice1 = null;\n        if (this._input.length > this._offset) {\n          slice1 = this._input.substring(this._offset, this._offset + 1);\n        } else {\n          slice1 = null;\n        }\n        if (!this.error || this.error.offset <= this._offset) {\n          this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"0\\\"\"};\n        }\n      }\n      if (address1) {\n        elements0.push(address1);\n        text0 += address1.textValue;\n        labelled0.code = address1;\n        var address2 = null;\n        var index2 = this._offset;\n        var slice2 = null;\n        if (this._input.length > this._offset) {\n          slice2 = this._input.substring(this._offset, this._offset + 0);\n        } else {\n          slice2 = null;\n        }\n        if (slice2 === \"\") {\n          var klass1 = this.constructor.SyntaxNode;\n          var type1 = null;\n          address2 = new klass1(\"\", this._offset, []);\n          if (typeof type1 === \"object\") {\n            extend(address2, type1);\n          }\n          this._offset += 0;\n        } else {\n          address2 = null;\n          var slice3 = null;\n          if (this._input.length > this._offset) {\n            slice3 = this._input.substring(this._offset, this._offset + 1);\n          } else {\n            slice3 = null;\n          }\n          if (!this.error || this.error.offset <= this._offset) {\n            this.error = this.constructor.lastError = {input: this._input, offset: this._offset, expected: \"\\\"\\\"\"};\n          }\n        }\n        if (address2) {\n        } else {\n          this._offset = index2;\n          var klass2 = this.constructor.SyntaxNode;\n          var type2 = null;\n          address2 = new klass2(\"\", this._offset, []);\n          if (typeof type2 === \"object\") {\n            extend(address2, type2);\n          }\n          this._offset += 0;\n        }\n        if (address2) {\n          elements0.push(address2);\n          text0 += address2.textValue;\n          labelled0.arg = address2;\n        } else {\n          elements0 = null;\n          this._offset = index1;\n        }\n      } else {\n        elements0 = null;\n        this._offset = index1;\n      }\n      if (elements0) {\n        this._offset = index1;\n        var klass3 = this.constructor.SyntaxNode;\n        var type3 = null;\n        address0 = new klass3(text0, this._offset, elements0, labelled0);\n        if (typeof type3 === \"object\") {\n          extend(address0, type3);\n        }\n        this._offset += text0.length;\n      } else {\n        address0 = null;\n      }\n      return this._nodeCache[\"null_escape\"][index0] = address0;\n    }\n  };\n  \n  var Parser = function(input) {\n    this._input = input;\n    this._offset = 0;\n    this._nodeCache = {};\n  };\n  \n  Parser.prototype.parse = function() {\n    var result = this.__consume__root();\n    if (result && this._offset === this._input.length) {\n      return result;\n    }\n    if (!(this.error)) {\n      this.error = {input: this._input, offset: this._offset, expected: \"<EOF>\"};\n    }\n    var message = formatError(this.error);\n    var error = new Error(message);\n    throw error;\n  };\n  \n  Parser.parse = function(input) {\n    var parser = new Parser(input);\n    return parser.parse();\n  };\n  \n  extend(Parser.prototype, Grammar);\n  \n  var SyntaxNode = function(textValue, offset, elements, properties) {\n    this.textValue = textValue;\n    this.offset    = offset;\n    this.elements  = elements || [];\n    if (!properties) return;\n    for (var key in properties) this[key] = properties[key];\n  };\n  \n  SyntaxNode.prototype.forEach = function(block, context) {\n    for (var i = 0, n = this.elements.length; i < n; i++) {\n      block.call(context, this.elements[i], i);\n    }\n  };\n  \n  Parser.SyntaxNode = SyntaxNode;\n  \n  if (typeof require === \"function\" && typeof exports === \"object\") {\n    exports.Grammar = Grammar;\n    exports.Parser  = Parser;\n    exports.parse   = Parser.parse;\n    \n  } else {\n    var namespace = this;\n    JavascriptRegexp = Grammar;\n    JavascriptRegexpParser = Parser;\n    JavascriptRegexpParser.formatError = formatError;\n  }\n})();\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/parser/javascript/grammar.peg\n// module id = 8\n// module chunks = 2","// Base class for all nodes in the parse tree. An instance of this class is\n// created for each parsed node, and then extended with one of the node-type\n// modules.\nimport util from '../../util.js';\nimport _ from 'lodash';\n\nexport default class Node {\n  // Arguments passed in are defined by the canopy tool.\n  constructor(textValue, offset, elements, properties) {\n    this.textValue = textValue;\n    this.offset = offset;\n    this.elements = elements || [];\n\n    this.properties = properties;\n\n    // This is the current parser state (an instance\n    // [ParserState](./parser_state.html).)\n    this.state = Node.state;\n  }\n\n  // Node-type module to extend the Node instance with. Setting of this is\n  // done by canopy during parsing and is setup in [parser.js](./parser.html).\n  set module(mod) {\n    _.extend(this, mod);\n\n    if (this.setup) {\n      this.setup();\n    }\n\n    _.forOwn(this.definedProperties || {}, (methods, name) => {\n      Object.defineProperty(this, name, methods);\n    });\n\n    delete this.definedProperties;\n  }\n\n  // The SVG element to render this node into. A node-type class is\n  // automatically added to the container. The class to set is defined on the\n  // module set during parsing.\n  set container(container) {\n    this._container = container;\n    this._container.addClass(this.type);\n  }\n\n  get container() {\n    return this._container;\n  }\n\n  // The anchor defined the points on the left and right of the rendered node\n  // that the centerline of the rendered expression connects to. For most\n  // nodes, this element will be defined by the normalizeBBox method in\n  // [Util](../../util.html).\n  get anchor() {\n    if (this.proxy) {\n      return this.proxy.anchor;\n    } else {\n      return this._anchor || {};\n    }\n  }\n\n  // Returns the bounding box of the container with the anchor included.\n  getBBox() {\n    return _.extend(util.normalizeBBox(this.container.getBBox()), this.anchor);\n  }\n\n  // Transforms the container.\n  //\n  // - __matrix__ - A matrix transform to be applied. Created using Snap.svg.\n  transform(matrix) {\n    return this.container.transform(matrix);\n  }\n\n  // Returns a Promise that will be resolved with the provided value. If the\n  // render is cancelled before the Promise is resolved, then an exception will\n  // be thrown to halt any rendering.\n  //\n  // - __value__ - Value to resolve the returned promise with.\n  deferredStep(value) {\n    return util.tick().then(() => {\n      if (this.state.cancelRender) {\n        throw 'Render cancelled';\n      }\n\n      return value;\n    });\n  }\n\n  // Render this node.\n  //\n  // - __container__ - Optional element to render this node into. A container\n  //    must be specified, but if it has already been set, then it does not\n  //    need to be provided to render.\n  render(container) {\n    if (container) {\n      this.container = container;\n    }\n\n    if (this.proxy) {\n      // For nodes that proxy to a child node, just render the child.\n      return this.proxy.render(this.container);\n    } else {\n      // Non-proxied nodes call their _render method (defined by the node-type\n      // module).\n      this.state.renderCounter++;\n      return this._render()\n        .then(() => {\n          this.state.renderCounter--;\n          return this;\n        });\n    }\n  }\n\n  // Renders a label centered within a rectangle which can be styled. Returns\n  // a Promise which will be resolved with the SVG group the rect and text are\n  // rendered in.\n  //\n  // - __text__ - String or array of strings to render as a label.\n  renderLabel(text) {\n    let group = this.container.group()\n          .addClass('label'),\n        rect = group.rect(),\n        label = group.text(0, 0, _.flatten([text]));\n\n    return this.deferredStep()\n      .then(() => {\n        let box = label.getBBox(),\n            margin = 5;\n\n        label.transform(Snap.matrix()\n          .translate(margin, box.height / 2 + 2 * margin));\n\n        rect.attr({\n          width: box.width + 2 * margin,\n          height: box.height + 2 * margin\n        });\n\n        return group;\n      });\n  }\n\n  // Renders a labeled box around another SVG element. Returns a Promise.\n  //\n  // - __text__ - String or array of strings to label the box with.\n  // - __content__ - SVG element to wrap in the box.\n  // - __options.padding__ - Pixels of padding to place between the content and\n  //    the box.\n  renderLabeledBox(text, content, options) {\n    let label = this.container.text(0, 0, _.flatten([text]))\n          .addClass(`${this.type}-label`),\n        box = this.container.rect()\n          .addClass(`${this.type}-box`)\n          .attr({\n            rx: 3,\n            ry: 3\n          });\n\n    options = _.defaults(options || {}, {\n      padding: 0\n    });\n\n    this.container.prepend(label);\n    this.container.prepend(box);\n\n    return this.deferredStep()\n      .then(() => {\n        let labelBox = label.getBBox(),\n            contentBox = content.getBBox();\n\n        label.transform(Snap.matrix()\n          .translate(0, labelBox.height));\n\n        box\n          .transform(Snap.matrix()\n            .translate(0, labelBox.height))\n          .attr({\n            width: Math.max(contentBox.width + options.padding * 2, labelBox.width),\n            height: contentBox.height + options.padding * 2\n          });\n\n        content.transform(Snap.matrix()\n          .translate(box.getBBox().cx - contentBox.cx, labelBox.height + options.padding));\n      });\n  }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/parser/javascript/node.js","// Root nodes contain the top-level [Regexp](./regexp.html) node. Any flags\n// and a few decorative elements are rendered by the root node.\n\nimport _ from 'lodash';\n\nexport default {\n  type: 'root',\n\n  flagLabels: {\n    i: 'Ignore Case',\n    g: 'Global',\n    m: 'Multiline'\n  },\n\n  // Renders the root into the currently set container.\n  _render() {\n    let flagText;\n\n    // Render a label for any flags that have been set of the expression.\n    if (this.flags.length > 0) {\n      flagText = this.container.text(0, 0, `Flags: ${this.flags.join(', ')}`);\n    }\n\n    // Render the content of the regular expression.\n    return this.regexp.render(this.container.group())\n      .then(() => {\n        // Move rendered regexp to account for flag label and to allow for\n        // decorative elements.\n        if (flagText) {\n          this.regexp.transform(Snap.matrix()\n            .translate(10, flagText.getBBox().height));\n        } else {\n          this.regexp.transform(Snap.matrix()\n            .translate(10, 0));\n        }\n\n        let box = this.regexp.getBBox();\n\n        // Render decorative elements.\n        this.container.path(`M${box.ax},${box.ay}H0M${box.ax2},${box.ay}H${box.x2 + 10}`);\n        this.container.circle(0, box.ay, 5);\n        this.container.circle(box.x2 + 10, box.ay, 5);\n      });\n  },\n\n  setup() {\n    // Convert list of flags into text describing each flag.\n    this.flags = _(this.properties.flags.textValue)\n      .uniq().sort()\n      .map(flag => this.flagLabels[flag]).value();\n\n    this.regexp = this.properties.regexp\n  }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/parser/javascript/root.js","// Regexp nodes are the entire regular expression. They consist of a collection\n// of [Match](./match.html) nodes separated by `|`.\n\nimport util from '../../util.js';\nimport _ from 'lodash';\n\nexport default {\n  type: 'regexp',\n\n  // Renders the regexp into the currently set container.\n  _render() {\n    let matchContainer = this.container.group()\n      .addClass('regexp-matches')\n      .transform(Snap.matrix()\n        .translate(20, 0));\n\n    // Renders each match into the match container.\n    return Promise.all(_.map(this.matches,\n      match => match.render(matchContainer.group())\n    ))\n      .then(() => {\n        let containerBox,\n            paths;\n\n        // Space matches vertically in the match container.\n        util.spaceVertically(this.matches, {\n          padding: 5\n        });\n\n        containerBox = this.getBBox();\n\n        // Creates the curves from the side lines for each match.\n        paths = _.map(this.matches, match => this.makeCurve(containerBox, match));\n\n        // Add side lines to the list of paths.\n        paths.push(this.makeSide(containerBox, _.first(this.matches)));\n        paths.push(this.makeSide(containerBox, _.last(this.matches)));\n\n        // Render connector paths.\n        this.container.prepend(\n          this.container.path(_(paths).flatten().compact().values().join('')));\n\n        containerBox = matchContainer.getBBox();\n\n        // Create connections from side lines to each match and render into\n        // the match container.\n        paths = _.map(this.matches, match => this.makeConnector(containerBox, match));\n        matchContainer.prepend(\n          matchContainer.path(paths.join('')));\n      });\n  },\n\n  // Returns an array of SVG path strings to draw the vertical lines on the\n  // left and right of the node.\n  //\n  // - __containerBox__ - Bounding box of the container.\n  // - __match__ - Match node that the line will be drawn to.\n  makeSide(containerBox, match) {\n    let box = match.getBBox(),\n        distance = Math.abs(box.ay - containerBox.cy);\n\n    // Only need to draw side lines if the match is more than 15 pixels from\n    // the vertical center of the rendered regexp. Less that 15 pixels will be\n    // handled by the curve directly.\n    if (distance >= 15) {\n      let shift = (box.ay > containerBox.cy) ? 10 : -10,\n          edge = box.ay - shift;\n\n      return [\n        `M0,${containerBox.cy}q10,0 10,${shift}V${edge}`,\n        `M${containerBox.width + 40},${containerBox.cy}q-10,0 -10,${shift}V${edge}`\n      ];\n    }\n  },\n\n  // Returns an array of SVG path strings to draw the curves from the\n  // sidelines up to the anchor of the match node.\n  //\n  // - __containerBox__ - Bounding box of the container.\n  // - __match__ - Match node that the line will be drawn to.\n  makeCurve(containerBox, match) {\n    let box = match.getBBox(),\n        distance = Math.abs(box.ay - containerBox.cy);\n\n    if (distance >= 15) {\n      // For match nodes more than 15 pixels from the center of the regexp, a\n      // quarter-circle curve is used to connect to the sideline.\n      let curve = (box.ay > containerBox.cy) ? 10 : -10;\n\n      return [\n        `M10,${box.ay - curve}q0,${curve} 10,${curve}`,\n        `M${containerBox.width + 30},${box.ay - curve}q0,${curve} -10,${curve}`\n      ];\n    } else {\n      // For match nodes less than 15 pixels from the center of the regexp, a\n      // slightly curved line is used to connect to the sideline.\n      let anchor = box.ay - containerBox.cy;\n\n      return [\n        `M0,${containerBox.cy}c10,0 10,${anchor} 20,${anchor}`,\n        `M${containerBox.width + 40},${containerBox.cy}c-10,0 -10,${anchor} -20,${anchor}`\n      ];\n    }\n  },\n\n  // Returns an array of SVG path strings to draw the connection from the\n  // curve to match node.\n  //\n  // - __containerBox__ - Bounding box of the container.\n  // - __match__ - Match node that the line will be drawn to.\n  makeConnector(containerBox, match) {\n    let box = match.getBBox();\n\n    return `M0,${box.ay}h${box.ax}M${box.ax2},${box.ay}H${containerBox.width}`;\n  },\n\n  setup() {\n    if (this.properties.alternates.elements.length === 0) {\n      // When there is only one match node to render, proxy to it.\n      this.proxy = this.properties.match;\n    } else {\n      // Merge all the match nodes into one array.\n      this.matches = [this.properties.match].concat(\n        _.map(this.properties.alternates.elements,\n          element => element.properties.match)\n      );\n    }\n  }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/parser/javascript/regexp.js","// Match nodes are used for the parts of a regular expression between `|`\n// symbols. They consist of a series of [MatchFragment](./match_fragment.html)\n// nodes. Optional `^` and `$` symbols are also allowed at the beginning and\n// end of the Match.\n\nimport util from '../../util.js';\nimport _ from 'lodash';\n\nexport default {\n  type: 'match',\n\n  definedProperties: {\n    // Default anchor is overridden to attach the left point of the anchor to\n    // the first element, and the right point to the last element.\n    _anchor: {\n      get: function() {\n        var start = util.normalizeBBox(this.start.getBBox()),\n            end = util.normalizeBBox(this.end.getBBox()),\n            matrix = this.transform().localMatrix;\n\n        return {\n          ax: matrix.x(start.ax, start.ay),\n          ax2: matrix.x(end.ax2, end.ay),\n          ay: matrix.y(start.ax, start.ay)\n        };\n      }\n    }\n  },\n\n  // Renders the match into the currently set container.\n  _render() {\n    // Render each of the match fragments.\n    let partPromises = _.map(this.parts, part => part.render(this.container.group())),\n        items = _(partPromises).compact().value();\n\n    // Handle the situation where a regular expression of `()` is rendered.\n    // This leads to a Match node with no fragments. Something must be rendered\n    // so that the anchor can be calculated based on it.\n    //\n    // Furthermore, the content rendered must have height and width or else the\n    // anchor calculations fail.\n    if (items.length === 0) {\n      items = [this.container.group().path('M0,0h10')];\n    }\n\n    return Promise.all(items)\n      .then(items => {\n        // Find SVG elements to be used when calculating the anchor.\n        this.start = _.first(items);\n        this.end = _.last(items);\n\n        util.spaceHorizontally(items, {\n          padding: 10\n        });\n\n        // Add lines between each item.\n        this.container.prepend(\n          this.container.path(this.connectorPaths(items).join('')));\n      });\n  },\n\n  // Returns an array of SVG path strings between each item.\n  // - __items__ - Array of SVG elements or nodes.\n  connectorPaths(items) {\n    let prev, next;\n\n    prev = util.normalizeBBox(_.first(items).getBBox());\n    return _.map(items.slice(1), item => {\n      try {\n        next = util.normalizeBBox(item.getBBox());\n        return `M${prev.ax2},${prev.ay}H${next.ax}`;\n      }\n      finally {\n        prev = next;\n      }\n    });\n  },\n\n  setup() {\n    // Merged list of MatchFragments to be rendered.\n    this.parts = _.reduce(this.properties.parts.elements, function(result, node) {\n      var last = _.last(result);\n\n      if (last && node.canMerge && last.canMerge) {\n        // Merged the content of `node` into `last` when possible. This also\n        // discards `node` in the process since `result` has not been changed.\n        last.content.merge(node.content);\n      } else {\n        // `node` cannot be merged with the previous node, so it is added to\n        // the list of parts.\n        result.push(node);\n      }\n\n      return result;\n    }, []);\n\n    // When there is only one part, then proxy to the part.\n    if (this.parts.length === 1) {\n      this.proxy = this.parts[0];\n    }\n  }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/parser/javascript/match.js","// MatchFragment nodes are part of a [Match](./match.html) followed by an\n// optional [Repeat](./repeat.html) node. If no repeat is applied, then\n// rendering is proxied to the content node.\n\nimport _ from 'lodash';\n\nexport default {\n  type: 'match-fragment',\n\n  definedProperties: {\n    // Default anchor is overridden to apply an transforms from the fragment\n    // to its content's anchor. Essentially, the fragment inherits the anchor\n    // of its content.\n    _anchor: {\n      get: function() {\n        var anchor = this.content.getBBox(),\n            matrix = this.transform().localMatrix;\n\n        return {\n          ax: matrix.x(anchor.ax, anchor.ay),\n          ax2: matrix.x(anchor.ax2, anchor.ay),\n          ay: matrix.y(anchor.ax, anchor.ay)\n        };\n      }\n    }\n  },\n\n  // Renders the fragment into the currently set container.\n  _render() {\n    return this.content.render(this.container.group())\n      .then(() => {\n        let box, paths;\n\n        // Contents must be transformed based on the repeat that is applied.\n        this.content.transform(this.repeat.contentPosition);\n\n        box = this.content.getBBox();\n\n        // Add skip or repeat paths to the container.\n        paths = _.flatten([\n          this.repeat.skipPath(box),\n          this.repeat.loopPath(box)\n        ]);\n\n        this.container.prepend(\n          this.container.path(paths.join('')));\n\n        this.loopLabel();\n      });\n  },\n\n  // Renders label for the loop path indicating how many times the content may\n  // be matched.\n  loopLabel() {\n    let labelStr = this.repeat.label,\n        tooltipStr = this.repeat.tooltip;\n\n    if (labelStr) {\n      let label = this.container.text(0, 0, [labelStr])\n            .addClass('repeat-label'),\n          labelBox = label.getBBox(),\n          box = this.getBBox();\n\n      if (tooltipStr) {\n        let tooltip = this.container.el('title')\n          .append(this.container.text(0, 0, tooltipStr));\n        label.append(tooltip);\n      }\n\n      label.transform(Snap.matrix().translate(\n        box.x2 - labelBox.width - (this.repeat.hasSkip ? 5 : 0),\n        box.y2 + labelBox.height));\n    }\n  },\n\n  setup() {\n    // Then content of the fragment.\n    this.content = this.properties.content;\n    // The repetition rule for the fragment.\n    this.repeat = this.properties.repeat;\n\n    if (!this.repeat.hasLoop && !this.repeat.hasSkip) {\n      // For fragments without a skip or loop, rendering is proxied to the\n      // content. Also set flag indicating that contents can be merged if the\n      // content is a literal node.\n      this.canMerge = (this.content.type === 'literal');\n      this.proxy = this.content;\n    } else {\n      // Fragments that have skip or loop lines cannot be merged with others.\n      this.canMerge = false;\n    }\n  }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/parser/javascript/match_fragment.js","export default {\n  _render() {\n    return this.renderLabel(this.label).then(label => label.addClass('anchor'));\n  },\n\n  setup() {\n    if (this.textValue === '^') {\n      this.label = 'Start of line';\n    } else {\n      this.label = 'End of line';\n    }\n  }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/parser/javascript/anchor.js","// Subexp nodes are for expressions inside of parenthesis. It is rendered as a\n// labeled box around the contained expression if a label is required.\n\nimport _ from 'lodash';\n\nexport default {\n  type: 'subexp',\n\n  definedProperties: {\n    // Default anchor is overridden to move it down to account for the group\n    // label and outline box.\n    _anchor: {\n      get: function() {\n        var anchor = this.regexp.getBBox(),\n            matrix = this.transform().localMatrix;\n\n        return {\n          ax: matrix.x(anchor.ax, anchor.ay),\n          ax2: matrix.x(anchor.ax2, anchor.ay),\n          ay: matrix.y(anchor.ax, anchor.ay)\n        };\n      }\n    }\n  },\n\n  labelMap: {\n    '?:': '',\n    '?=': 'positive lookahead',\n    '?!': 'negative lookahead'\n  },\n\n  // Renders the subexp into the currently set container.\n  _render() {\n    // **NOTE:** `this.label()` **MUST** be called here, in _render, and before\n    // any child nodes are rendered. This is to keep the group numbers in the\n    // correct order.\n    let label = this.label();\n\n    // Render the contained regexp.\n    return this.regexp.render(this.container.group())\n      // Create the labeled box around the regexp.\n      .then(() => this.renderLabeledBox(label, this.regexp, {\n        padding: 10\n      }));\n  },\n\n  // Returns the label for the subexpression.\n  label() {\n    if (_.has(this.labelMap, this.properties.capture.textValue)) {\n      return this.labelMap[this.properties.capture.textValue];\n    } else {\n      return `group #${this.state.groupCounter++}`;\n    }\n  },\n\n  setup() {\n    // **NOTE:** **DO NOT** call `this.label()` in setup. It will lead to\n    // groups being numbered in reverse order.\n    this.regexp = this.properties.regexp;\n\n    // If there is no need for a label, then proxy to the nested regexp.\n    if (this.properties.capture.textValue == '?:') {\n      this.proxy = this.regexp;\n    }\n  }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/parser/javascript/subexp.js","// Charset nodes are used for `[abc1-9]` regular expression syntax. It is\n// rendered as a labeled box with each literal, escape, and range rendering\n// handled by the nested node(s).\n\nimport util from '../../util.js';\nimport _ from 'lodash';\n\nexport default {\n  type: 'charset',\n\n  definedProperties: {\n    // Default anchor is overridden to move it down so that it connects at the\n    // middle of the box that wraps all of the charset parts, instead of the\n    // middle of the container, which would take the label into account.\n    _anchor: {\n      get: function() {\n        var matrix = this.transform().localMatrix;\n\n        return {\n          ay: matrix.y(0, this.partContainer.getBBox().cy)\n        };\n      }\n    }\n  },\n\n  // Renders the charset into the currently set container.\n  _render() {\n    this.partContainer = this.container.group();\n\n    // Renders each part of the charset into the part container.\n    return Promise.all(_.map(this.elements,\n      part => part.render(this.partContainer.group())\n    ))\n      .then(() => {\n        // Space the parts of the charset vertically in the part container.\n        util.spaceVertically(this.elements, {\n          padding: 5\n        });\n\n        // Label the part container.\n        return this.renderLabeledBox(this.label, this.partContainer, {\n          padding: 5\n        });\n      });\n  },\n\n  setup() {\n    // The label for the charset will be:\n    // - \"One of:\" for charsets of the form: `[abc]`.\n    // - \"None of:\" for charsets of the form: `[^abc]`.\n    this.label = (this.properties.invert.textValue === '^') ? 'None of:' : 'One of:';\n\n    // Removes any duplicate parts from the charset. This is based on the type\n    // and text value of the part, so `[aa]` will have only one item, but\n    // `[a\\x61]` will contain two since the first matches \"a\" and the second\n    // matches 0x61 (even though both are an \"a\").\n    this.elements = _.uniqBy(this.properties.parts.elements,\n      part => `${part.type}:${part.textValue}`);\n\n    // Include a warning for charsets that attempt to match `\\c` followed by\n    // any character other than A-Z (case insensitive). Charsets like `[\\c@]`\n    // behave differently in different browsers. Some match the character\n    // reference by the control charater escape, others match \"\\\", \"c\", or \"@\",\n    // and some do not appear to match anything.\n    if (this.textValue.match(/\\\\c[^a-zA-Z]/)) {\n      this.state.warnings.push(`The character set \"${this.textValue}\" contains the \\\\c escape followed by a character other than A-Z. This can lead to different behavior depending on browser. The representation here is the most common interpretation.`);\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/parser/javascript/charset.js","// CharsetEscape nodes are for escape sequences inside of character sets. They\n// differ from other [Escape](./escape.html) nodes in that `\\b` matches a\n// backspace character instead of a word boundary.\n\nimport _ from 'lodash';\nimport Escape from './escape.js';\n\nexport default _.extend({}, Escape, {\n  type: 'charset-escape',\n\n  b: ['backspace', 0x08, true]\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/parser/javascript/charset_escape.js","// Escape nodes are used for escape sequences. It is rendered as a label with\n// the description of the escape and the numeric code it matches when\n// appropriate.\n\nimport _ from 'lodash';\n\nfunction hex(value) {\n  var str = value.toString(16).toUpperCase();\n\n  if (str.length < 2) {\n    str = '0' + str;\n  }\n\n  return `(0x${str})`;\n}\n\nexport default {\n  type: 'escape',\n\n  // Renders the escape into the currently set container.\n  _render() {\n    return this.renderLabel(this.label)\n      .then(label => {\n        label.select('rect').attr({\n          rx: 3,\n          ry: 3\n        });\n        return label;\n      });\n  },\n\n  setup() {\n    let addHex;\n\n    // The escape code. For an escape such as `\\b` it would be \"b\".\n    this.code = this.properties.esc.properties.code.textValue;\n    // The argument. For an escape such as `\\xab` it would be \"ab\".\n    this.arg = this.properties.esc.properties.arg.textValue;\n    // Retrieves the label, ordinal value, an flag to control adding hex value\n    // from the escape code mappings\n    [this.label, this.ordinal, addHex] = _.result(this, this.code);\n\n    // When requested, add hex code to the label.\n    if (addHex) {\n      this.label = `${this.label} ${hex(this.ordinal)}`;\n    }\n  },\n\n  // Escape code mappings\n  b: ['word boundary', -1, false],\n  B: ['non-word boundary', -1, false],\n  d: ['digit', -1, false],\n  D: ['non-digit', -1, false],\n  f: ['form feed', 0x0c, true],\n  n: ['line feed', 0x0a, true],\n  r: ['carriage return', 0x0d, true],\n  s: ['white space', -1, false],\n  S: ['non-white space', -1, false],\n  t: ['tab', 0x09, true],\n  v: ['vertical tab', 0x0b, true],\n  w: ['word', -1, false],\n  W: ['non-word', -1, false],\n  1: ['Back reference (group = 1)', -1, false],\n  2: ['Back reference (group = 2)', -1, false],\n  3: ['Back reference (group = 3)', -1, false],\n  4: ['Back reference (group = 4)', -1, false],\n  5: ['Back reference (group = 5)', -1, false],\n  6: ['Back reference (group = 6)', -1, false],\n  7: ['Back reference (group = 7)', -1, false],\n  8: ['Back reference (group = 8)', -1, false],\n  9: ['Back reference (group = 9)', -1, false],\n  0: function() {\n    if (this.arg) {\n      return [`octal: ${this.arg}`, parseInt(this.arg, 8), true];\n    } else {\n      return ['null', 0, true];\n    }\n  },\n  c() {\n    return [`ctrl-${this.arg.toUpperCase()}`, this.arg.toUpperCase().charCodeAt(0) - 64, true];\n  },\n  x() {\n    return [`0x${this.arg.toUpperCase()}`, parseInt(this.arg, 16), false];\n  },\n  u() {\n    return [`U+${this.arg.toUpperCase()}`, parseInt(this.arg, 16), false];\n  }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/parser/javascript/escape.js","// CharsetRange nodes are used for `[a-z]` regular expression syntax. The two\n// literal or escape nodes are rendered with a hyphen between them.\n\nimport util from '../../util.js';\nimport _ from 'lodash';\n\nexport default {\n  type: 'charset-range',\n\n  // Renders the charset range into the currently set container\n  _render() {\n    let contents = [\n      this.first,\n      this.container.text(0, 0, '-'),\n      this.last\n    ];\n\n    // Render the nodes of the range.\n    return Promise.all([\n      this.first.render(this.container.group()),\n      this.last.render(this.container.group())\n    ])\n      .then(() => {\n        // Space the nodes and hyphen horizontally.\n        util.spaceHorizontally(contents, {\n          padding: 5\n        });\n      });\n  },\n\n  setup() {\n    // The two nodes for the range. In `[a-z]` these would be\n    // [Literal](./literal.html) nodes for \"a\" and \"z\".\n    this.first = this.properties.first;\n    this.last = this.properties.last;\n\n    // Report invalid expression when extents of the range are out of order.\n    if (this.first.ordinal > this.last.ordinal) {\n      throw `Range out of order in character class: ${this.textValue}`;\n    }\n  }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/parser/javascript/charset_range.js","// Literal nodes are for plain strings in the regular expression. They are\n// rendered as labels with the value of the literal quoted.\n\nimport _ from 'lodash';\n\nexport default {\n  type: 'literal',\n\n  // Renders the literal into the currently set container.\n  _render() {\n    return this.renderLabel(['\\u201c', this.literal, '\\u201d'])\n      .then(label => {\n        let spans = label.selectAll('tspan');\n\n        // The quote marks get some styling to lighten their color so they are\n        // distinct from the actual literal value.\n        spans[0].addClass('quote');\n        spans[2].addClass('quote');\n\n        label.select('rect').attr({\n          rx: 3,\n          ry: 3\n        });\n\n        return label;\n      });\n  },\n\n  // Merges this literal with another. Literals come back as single characters\n  // during parsing, and must be post-processed into multi-character literals\n  // for rendering. This processing is done in [Match](./match.html).\n  merge(other) {\n    this.literal += other.literal;\n  },\n\n  setup() {\n    // Value of the literal.\n    this.literal = this.properties.literal.textValue;\n    // Ordinal value of the literal for use in\n    // [CharsetRange](./charset_range.html).\n    this.ordinal = this.literal.charCodeAt(0);\n  }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/parser/javascript/literal.js","// AnyCharacter nodes are for `*` regular expression syntax. They are rendered\n// as just an \"any character\" label.\n\nimport _ from 'lodash';\n\nexport default {\n  type: 'any-character',\n\n  _render() {\n    return this.renderLabel('any character');\n  }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/parser/javascript/any_character.js","// Repeat nodes are for the various repetition syntaxes (`a*`, `a+`, `a?`, and\n// `a{1,3}`). It is not rendered directly, but contains data used for the\n// rendering of [MatchFragment](./match_fragment.html) nodes.\n\nfunction formatTimes(times) {\n  if (times === 1) {\n    return 'once';\n  } else {\n    return `${times} times`;\n  }\n}\n\nexport default {\n  definedProperties: {\n    // Translation to apply to content to be repeated to account for the loop\n    // and skip lines.\n    contentPosition: {\n      get: function() {\n        var matrix = Snap.matrix();\n\n        if (this.hasSkip) {\n          return matrix.translate(15, 10);\n        } else if (this.hasLoop) {\n          return matrix.translate(10, 0);\n        } else {\n          return matrix.translate(0, 0);\n        }\n      }\n    },\n\n    // Label to place of loop path to indicate the number of times that path\n    // may be followed.\n    label: {\n      get: function() {\n        if (this.minimum === this.maximum) {\n          if (this.minimum === 0) {\n            return undefined;\n          }\n          return formatTimes(this.minimum - 1);\n        } else if (this.minimum <= 1 && this.maximum >= 2) {\n          return `at most ${formatTimes(this.maximum - 1)}`;\n        } else if (this.minimum >= 2) {\n          if (this.maximum === -1) {\n            return `${this.minimum - 1}+ times`;\n          } else {\n            return `${this.minimum - 1}\\u2026${formatTimes(this.maximum - 1)}`;\n          }\n        }\n      }\n    },\n\n    // Tooltip to place of loop path label to provide further details.\n    tooltip: {\n      get: function() {\n        let repeatCount;\n        if (this.minimum === this.maximum) {\n          if (this.minimum === 0) {\n            repeatCount = undefined;\n          } else {\n            repeatCount = formatTimes(this.minimum);\n          }\n        } else if (this.minimum <= 1 && this.maximum >= 2) {\n          repeatCount = `at most ${formatTimes(this.maximum)}`;\n        } else if (this.minimum >= 2) {\n          if (this.maximum === -1) {\n            repeatCount = `${this.minimum}+ times`;\n          } else {\n            repeatCount = `${this.minimum}\\u2026${formatTimes(this.maximum)}`;\n          }\n        }\n        return repeatCount ? `repeats ${repeatCount} in total` : repeatCount;\n      }\n    }\n  },\n\n  // Returns the path spec to render the line that skips over the content for\n  // fragments that are optionally matched.\n  skipPath(box) {\n    let paths = [];\n\n    if (this.hasSkip) {\n      let vert = Math.max(0, box.ay - box.y - 10),\n          horiz = box.width - 10;\n\n      paths.push(`M0,${box.ay}q10,0 10,-10v${-vert}q0,-10 10,-10h${horiz}q10,0 10,10v${vert}q0,10 10,10`);\n\n      // When the repeat is not greedy, the skip path gets a preference arrow.\n      if (!this.greedy) {\n        paths.push(`M10,${box.ay - 15}l5,5m-5,-5l-5,5`);\n      }\n    }\n\n    return paths;\n  },\n\n  // Returns the path spec to render the line that repeats the content for\n  // fragments that are matched more than once.\n  loopPath(box) {\n    let paths = [];\n\n    if (this.hasLoop) {\n      let vert = box.y2 - box.ay - 10;\n\n      paths.push(`M${box.x},${box.ay}q-10,0 -10,10v${vert}q0,10 10,10h${box.width}q10,0 10,-10v${-vert}q0,-10 -10,-10`);\n\n      // When the repeat is greedy, the loop path gets the preference arrow.\n      if (this.greedy) {\n        paths.push(`M${box.x2 + 10},${box.ay + 15}l5,-5m-5,5l-5,-5`);\n      }\n    }\n\n    return paths;\n  },\n\n  setup() {\n    this.minimum = this.properties.spec.minimum;\n    this.maximum = this.properties.spec.maximum;\n    this.greedy = (this.properties.greedy.textValue === '');\n    this.hasSkip = (this.minimum === 0);\n    this.hasLoop = (this.maximum === -1 || this.maximum > 1);\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/parser/javascript/repeat.js","// RepeatAny nodes are used for `a*` regular expression syntax. It is not\n// rendered directly; it just indicates that the [Repeat](./repeat.html) node\n// loops zero or more times.\n\nexport default {\n  minimum: 0,\n  maximum: -1\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/parser/javascript/repeat_any.js","// RepeatOptional nodes are used for `a?` regular expression syntax. It is not\n// rendered directly; it just indicates that the [Repeat](./repeat.html) node\n// loops zero or one times.\n\nexport default {\n  minimum: 0,\n  maximum: 1\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/parser/javascript/repeat_optional.js","// RepeatRequired nodes are used for `a+` regular expression syntax. It is not\n// rendered directly; it just indicates that the [Repeat](./repeat.html) node\n// loops one or more times.\n\nexport default {\n  minimum: 1,\n  maximum: -1\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/parser/javascript/repeat_required.js","// RepeatSpec nodes are used for `a{m,n}` regular expression syntax. It is not\n// rendered directly; it just indicates how many times the\n// [Repeat](./repeat.html) node loops.\n\nexport default {\n  setup() {\n    if (this.properties.min) {\n      this.minimum = Number(this.properties.min.textValue);\n    } else if (this.properties.exact) {\n      this.minimum = Number(this.properties.exact.textValue);\n    } else {\n      this.minimum = 0;\n    }\n\n    if (this.properties.max) {\n      this.maximum = Number(this.properties.max.textValue);\n    } else if (this.properties.exact) {\n      this.maximum = Number(this.properties.exact.textValue);\n    } else {\n      this.maximum = -1;\n    }\n\n    // Report invalid repeat when the minimum is larger than the maximum.\n    if (this.minimum > this.maximum && this.maximum !== -1) {\n      throw `Numbers out of order: ${this.textValue}`;\n    }\n  }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/parser/javascript/repeat_spec.js","// State tracking for an in-progress parse and render.\nexport default class ParserState {\n  // - __progress__ - DOM node to update to indicate completion progress.\n  constructor(progress) {\n    // Tracks the number of capture groups in the expression.\n    this.groupCounter = 1;\n    // Cancels the in-progress render when set to true.\n    this.cancelRender = false;\n    // Warnings that have been generated while rendering.\n    this.warnings = [];\n\n    // Used to display the progress indicator\n    this._renderCounter = 0;\n    this._maxCounter = 0;\n    this._progress = progress;\n  }\n\n  // Counts the number of in-progress rendering steps. As the counter goes up,\n  // a maximum value is also tracked. The maximum value and current render\n  // counter are used to calculate the completion process.\n  get renderCounter() {\n    return this._renderCounter;\n  }\n\n  set renderCounter(value) {\n    if (value > this.renderCounter) {\n      this._maxCounter = value;\n    }\n\n    this._renderCounter = value;\n\n    if (this._maxCounter && !this.cancelRender) {\n      this._progress.style.width = ((1 - this.renderCounter / this._maxCounter) * 100).toFixed(2) + '%';\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/parser/javascript/parser_state.js"],"sourceRoot":""}